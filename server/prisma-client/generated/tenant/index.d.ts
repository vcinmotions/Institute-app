
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model ClientAdmin
 * 
 */
export type ClientAdmin = $Result.DefaultSelection<Prisma.$ClientAdminPayload>
/**
 * Model RoleUser
 * 
 */
export type RoleUser = $Result.DefaultSelection<Prisma.$RoleUserPayload>
/**
 * Model ActivityLog
 * 
 */
export type ActivityLog = $Result.DefaultSelection<Prisma.$ActivityLogPayload>
/**
 * Model Enquiry
 * 
 */
export type Enquiry = $Result.DefaultSelection<Prisma.$EnquiryPayload>
/**
 * Model EnquiryCourse
 * 
 */
export type EnquiryCourse = $Result.DefaultSelection<Prisma.$EnquiryCoursePayload>
/**
 * Model FollowUp
 * 
 */
export type FollowUp = $Result.DefaultSelection<Prisma.$FollowUpPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model Student
 * 
 */
export type Student = $Result.DefaultSelection<Prisma.$StudentPayload>
/**
 * Model Course
 * 
 */
export type Course = $Result.DefaultSelection<Prisma.$CoursePayload>
/**
 * Model CourseFeeStructure
 * 
 */
export type CourseFeeStructure = $Result.DefaultSelection<Prisma.$CourseFeeStructurePayload>
/**
 * Model Batch
 * 
 */
export type Batch = $Result.DefaultSelection<Prisma.$BatchPayload>
/**
 * Model BatchCourse
 * 
 */
export type BatchCourse = $Result.DefaultSelection<Prisma.$BatchCoursePayload>
/**
 * Model Faculty
 * 
 */
export type Faculty = $Result.DefaultSelection<Prisma.$FacultyPayload>
/**
 * Model Lab
 * 
 */
export type Lab = $Result.DefaultSelection<Prisma.$LabPayload>
/**
 * Model LabTimeSlot
 * 
 */
export type LabTimeSlot = $Result.DefaultSelection<Prisma.$LabTimeSlotPayload>
/**
 * Model PaymentStructureType
 * 
 */
export type PaymentStructureType = $Result.DefaultSelection<Prisma.$PaymentStructureTypePayload>
/**
 * Model InstallmentDetail
 * 
 */
export type InstallmentDetail = $Result.DefaultSelection<Prisma.$InstallmentDetailPayload>
/**
 * Model LabAllocation
 * 
 */
export type LabAllocation = $Result.DefaultSelection<Prisma.$LabAllocationPayload>
/**
 * Model StudentCourse
 * 
 */
export type StudentCourse = $Result.DefaultSelection<Prisma.$StudentCoursePayload>
/**
 * Model FeeStructure
 * 
 */
export type FeeStructure = $Result.DefaultSelection<Prisma.$FeeStructurePayload>
/**
 * Model StudentFeeLog
 * 
 */
export type StudentFeeLog = $Result.DefaultSelection<Prisma.$StudentFeeLogPayload>
/**
 * Model StudentFee
 * 
 */
export type StudentFee = $Result.DefaultSelection<Prisma.$StudentFeePayload>
/**
 * Model StationeryItem
 * 
 */
export type StationeryItem = $Result.DefaultSelection<Prisma.$StationeryItemPayload>
/**
 * Model StationeryIssue
 * 
 */
export type StationeryIssue = $Result.DefaultSelection<Prisma.$StationeryIssuePayload>
/**
 * Model AttendanceRecord
 * 
 */
export type AttendanceRecord = $Result.DefaultSelection<Prisma.$AttendanceRecordPayload>
/**
 * Model StudentTask
 * 
 */
export type StudentTask = $Result.DefaultSelection<Prisma.$StudentTaskPayload>
/**
 * Model StudentTest
 * 
 */
export type StudentTest = $Result.DefaultSelection<Prisma.$StudentTestPayload>
/**
 * Model CourseCompletion
 * 
 */
export type CourseCompletion = $Result.DefaultSelection<Prisma.$CourseCompletionPayload>
/**
 * Model Certificate
 * 
 */
export type Certificate = $Result.DefaultSelection<Prisma.$CertificatePayload>
/**
 * Model FinancialRecord
 * 
 */
export type FinancialRecord = $Result.DefaultSelection<Prisma.$FinancialRecordPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const RecordType: {
  INCOME: 'INCOME',
  EXPENSE: 'EXPENSE'
};

export type RecordType = (typeof RecordType)[keyof typeof RecordType]


export const LeadStatus: {
  COLD: 'COLD',
  WARM: 'WARM',
  HOT: 'HOT',
  WON: 'WON',
  LOST: 'LOST',
  HOLD: 'HOLD'
};

export type LeadStatus = (typeof LeadStatus)[keyof typeof LeadStatus]


export const FollowUpStatus: {
  PENDING: 'PENDING',
  COMPLETED: 'COMPLETED',
  MISSED: 'MISSED'
};

export type FollowUpStatus = (typeof FollowUpStatus)[keyof typeof FollowUpStatus]


export const PaymentStatus: {
  PENDING: 'PENDING',
  SUCCESS: 'SUCCESS',
  FAILED: 'FAILED',
  CANCELLED: 'CANCELLED'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]


export const PaymentType: {
  ONE_TIME: 'ONE_TIME',
  INSTALLMENT: 'INSTALLMENT'
};

export type PaymentType = (typeof PaymentType)[keyof typeof PaymentType]


export const PaymentMode: {
  CASH: 'CASH',
  UPI: 'UPI',
  CARD: 'CARD',
  BANK_TRANSFER: 'BANK_TRANSFER',
  CHEQUE: 'CHEQUE'
};

export type PaymentMode = (typeof PaymentMode)[keyof typeof PaymentMode]


export const UserRole: {
  ADMIN: 'ADMIN',
  FRONT_DESK: 'FRONT_DESK',
  FACULTY: 'FACULTY',
  ACCOUNTANT: 'ACCOUNTANT',
  VIEW_ONLY: 'VIEW_ONLY'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]

}

export type RecordType = $Enums.RecordType

export const RecordType: typeof $Enums.RecordType

export type LeadStatus = $Enums.LeadStatus

export const LeadStatus: typeof $Enums.LeadStatus

export type FollowUpStatus = $Enums.FollowUpStatus

export const FollowUpStatus: typeof $Enums.FollowUpStatus

export type PaymentStatus = $Enums.PaymentStatus

export const PaymentStatus: typeof $Enums.PaymentStatus

export type PaymentType = $Enums.PaymentType

export const PaymentType: typeof $Enums.PaymentType

export type PaymentMode = $Enums.PaymentMode

export const PaymentMode: typeof $Enums.PaymentMode

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more ClientAdmins
 * const clientAdmins = await prisma.clientAdmin.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more ClientAdmins
   * const clientAdmins = await prisma.clientAdmin.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.clientAdmin`: Exposes CRUD operations for the **ClientAdmin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClientAdmins
    * const clientAdmins = await prisma.clientAdmin.findMany()
    * ```
    */
  get clientAdmin(): Prisma.ClientAdminDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.roleUser`: Exposes CRUD operations for the **RoleUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RoleUsers
    * const roleUsers = await prisma.roleUser.findMany()
    * ```
    */
  get roleUser(): Prisma.RoleUserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.activityLog`: Exposes CRUD operations for the **ActivityLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ActivityLogs
    * const activityLogs = await prisma.activityLog.findMany()
    * ```
    */
  get activityLog(): Prisma.ActivityLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.enquiry`: Exposes CRUD operations for the **Enquiry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Enquiries
    * const enquiries = await prisma.enquiry.findMany()
    * ```
    */
  get enquiry(): Prisma.EnquiryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.enquiryCourse`: Exposes CRUD operations for the **EnquiryCourse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EnquiryCourses
    * const enquiryCourses = await prisma.enquiryCourse.findMany()
    * ```
    */
  get enquiryCourse(): Prisma.EnquiryCourseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.followUp`: Exposes CRUD operations for the **FollowUp** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FollowUps
    * const followUps = await prisma.followUp.findMany()
    * ```
    */
  get followUp(): Prisma.FollowUpDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.student`: Exposes CRUD operations for the **Student** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Students
    * const students = await prisma.student.findMany()
    * ```
    */
  get student(): Prisma.StudentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.course`: Exposes CRUD operations for the **Course** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Courses
    * const courses = await prisma.course.findMany()
    * ```
    */
  get course(): Prisma.CourseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.courseFeeStructure`: Exposes CRUD operations for the **CourseFeeStructure** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CourseFeeStructures
    * const courseFeeStructures = await prisma.courseFeeStructure.findMany()
    * ```
    */
  get courseFeeStructure(): Prisma.CourseFeeStructureDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.batch`: Exposes CRUD operations for the **Batch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Batches
    * const batches = await prisma.batch.findMany()
    * ```
    */
  get batch(): Prisma.BatchDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.batchCourse`: Exposes CRUD operations for the **BatchCourse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BatchCourses
    * const batchCourses = await prisma.batchCourse.findMany()
    * ```
    */
  get batchCourse(): Prisma.BatchCourseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.faculty`: Exposes CRUD operations for the **Faculty** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Faculties
    * const faculties = await prisma.faculty.findMany()
    * ```
    */
  get faculty(): Prisma.FacultyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lab`: Exposes CRUD operations for the **Lab** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Labs
    * const labs = await prisma.lab.findMany()
    * ```
    */
  get lab(): Prisma.LabDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.labTimeSlot`: Exposes CRUD operations for the **LabTimeSlot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LabTimeSlots
    * const labTimeSlots = await prisma.labTimeSlot.findMany()
    * ```
    */
  get labTimeSlot(): Prisma.LabTimeSlotDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.paymentStructureType`: Exposes CRUD operations for the **PaymentStructureType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentStructureTypes
    * const paymentStructureTypes = await prisma.paymentStructureType.findMany()
    * ```
    */
  get paymentStructureType(): Prisma.PaymentStructureTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.installmentDetail`: Exposes CRUD operations for the **InstallmentDetail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InstallmentDetails
    * const installmentDetails = await prisma.installmentDetail.findMany()
    * ```
    */
  get installmentDetail(): Prisma.InstallmentDetailDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.labAllocation`: Exposes CRUD operations for the **LabAllocation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LabAllocations
    * const labAllocations = await prisma.labAllocation.findMany()
    * ```
    */
  get labAllocation(): Prisma.LabAllocationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.studentCourse`: Exposes CRUD operations for the **StudentCourse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentCourses
    * const studentCourses = await prisma.studentCourse.findMany()
    * ```
    */
  get studentCourse(): Prisma.StudentCourseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.feeStructure`: Exposes CRUD operations for the **FeeStructure** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FeeStructures
    * const feeStructures = await prisma.feeStructure.findMany()
    * ```
    */
  get feeStructure(): Prisma.FeeStructureDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.studentFeeLog`: Exposes CRUD operations for the **StudentFeeLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentFeeLogs
    * const studentFeeLogs = await prisma.studentFeeLog.findMany()
    * ```
    */
  get studentFeeLog(): Prisma.StudentFeeLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.studentFee`: Exposes CRUD operations for the **StudentFee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentFees
    * const studentFees = await prisma.studentFee.findMany()
    * ```
    */
  get studentFee(): Prisma.StudentFeeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stationeryItem`: Exposes CRUD operations for the **StationeryItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StationeryItems
    * const stationeryItems = await prisma.stationeryItem.findMany()
    * ```
    */
  get stationeryItem(): Prisma.StationeryItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stationeryIssue`: Exposes CRUD operations for the **StationeryIssue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StationeryIssues
    * const stationeryIssues = await prisma.stationeryIssue.findMany()
    * ```
    */
  get stationeryIssue(): Prisma.StationeryIssueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.attendanceRecord`: Exposes CRUD operations for the **AttendanceRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AttendanceRecords
    * const attendanceRecords = await prisma.attendanceRecord.findMany()
    * ```
    */
  get attendanceRecord(): Prisma.AttendanceRecordDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.studentTask`: Exposes CRUD operations for the **StudentTask** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentTasks
    * const studentTasks = await prisma.studentTask.findMany()
    * ```
    */
  get studentTask(): Prisma.StudentTaskDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.studentTest`: Exposes CRUD operations for the **StudentTest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentTests
    * const studentTests = await prisma.studentTest.findMany()
    * ```
    */
  get studentTest(): Prisma.StudentTestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.courseCompletion`: Exposes CRUD operations for the **CourseCompletion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CourseCompletions
    * const courseCompletions = await prisma.courseCompletion.findMany()
    * ```
    */
  get courseCompletion(): Prisma.CourseCompletionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.certificate`: Exposes CRUD operations for the **Certificate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Certificates
    * const certificates = await prisma.certificate.findMany()
    * ```
    */
  get certificate(): Prisma.CertificateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.financialRecord`: Exposes CRUD operations for the **FinancialRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FinancialRecords
    * const financialRecords = await prisma.financialRecord.findMany()
    * ```
    */
  get financialRecord(): Prisma.FinancialRecordDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.1
   * Query Engine version: c2990dca591cba766e3b7ef5d9e8a84796e47ab7
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    ClientAdmin: 'ClientAdmin',
    RoleUser: 'RoleUser',
    ActivityLog: 'ActivityLog',
    Enquiry: 'Enquiry',
    EnquiryCourse: 'EnquiryCourse',
    FollowUp: 'FollowUp',
    Notification: 'Notification',
    Student: 'Student',
    Course: 'Course',
    CourseFeeStructure: 'CourseFeeStructure',
    Batch: 'Batch',
    BatchCourse: 'BatchCourse',
    Faculty: 'Faculty',
    Lab: 'Lab',
    LabTimeSlot: 'LabTimeSlot',
    PaymentStructureType: 'PaymentStructureType',
    InstallmentDetail: 'InstallmentDetail',
    LabAllocation: 'LabAllocation',
    StudentCourse: 'StudentCourse',
    FeeStructure: 'FeeStructure',
    StudentFeeLog: 'StudentFeeLog',
    StudentFee: 'StudentFee',
    StationeryItem: 'StationeryItem',
    StationeryIssue: 'StationeryIssue',
    AttendanceRecord: 'AttendanceRecord',
    StudentTask: 'StudentTask',
    StudentTest: 'StudentTest',
    CourseCompletion: 'CourseCompletion',
    Certificate: 'Certificate',
    FinancialRecord: 'FinancialRecord'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "clientAdmin" | "roleUser" | "activityLog" | "enquiry" | "enquiryCourse" | "followUp" | "notification" | "student" | "course" | "courseFeeStructure" | "batch" | "batchCourse" | "faculty" | "lab" | "labTimeSlot" | "paymentStructureType" | "installmentDetail" | "labAllocation" | "studentCourse" | "feeStructure" | "studentFeeLog" | "studentFee" | "stationeryItem" | "stationeryIssue" | "attendanceRecord" | "studentTask" | "studentTest" | "courseCompletion" | "certificate" | "financialRecord"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      ClientAdmin: {
        payload: Prisma.$ClientAdminPayload<ExtArgs>
        fields: Prisma.ClientAdminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientAdminFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientAdminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientAdminFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientAdminPayload>
          }
          findFirst: {
            args: Prisma.ClientAdminFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientAdminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientAdminFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientAdminPayload>
          }
          findMany: {
            args: Prisma.ClientAdminFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientAdminPayload>[]
          }
          create: {
            args: Prisma.ClientAdminCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientAdminPayload>
          }
          createMany: {
            args: Prisma.ClientAdminCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClientAdminCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientAdminPayload>[]
          }
          delete: {
            args: Prisma.ClientAdminDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientAdminPayload>
          }
          update: {
            args: Prisma.ClientAdminUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientAdminPayload>
          }
          deleteMany: {
            args: Prisma.ClientAdminDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClientAdminUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClientAdminUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientAdminPayload>[]
          }
          upsert: {
            args: Prisma.ClientAdminUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientAdminPayload>
          }
          aggregate: {
            args: Prisma.ClientAdminAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClientAdmin>
          }
          groupBy: {
            args: Prisma.ClientAdminGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientAdminGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientAdminCountArgs<ExtArgs>
            result: $Utils.Optional<ClientAdminCountAggregateOutputType> | number
          }
        }
      }
      RoleUser: {
        payload: Prisma.$RoleUserPayload<ExtArgs>
        fields: Prisma.RoleUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleUserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleUserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleUserPayload>
          }
          findFirst: {
            args: Prisma.RoleUserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleUserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleUserPayload>
          }
          findMany: {
            args: Prisma.RoleUserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleUserPayload>[]
          }
          create: {
            args: Prisma.RoleUserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleUserPayload>
          }
          createMany: {
            args: Prisma.RoleUserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoleUserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleUserPayload>[]
          }
          delete: {
            args: Prisma.RoleUserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleUserPayload>
          }
          update: {
            args: Prisma.RoleUserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleUserPayload>
          }
          deleteMany: {
            args: Prisma.RoleUserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleUserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RoleUserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleUserPayload>[]
          }
          upsert: {
            args: Prisma.RoleUserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoleUserPayload>
          }
          aggregate: {
            args: Prisma.RoleUserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoleUser>
          }
          groupBy: {
            args: Prisma.RoleUserGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleUserCountArgs<ExtArgs>
            result: $Utils.Optional<RoleUserCountAggregateOutputType> | number
          }
        }
      }
      ActivityLog: {
        payload: Prisma.$ActivityLogPayload<ExtArgs>
        fields: Prisma.ActivityLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActivityLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActivityLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          findFirst: {
            args: Prisma.ActivityLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActivityLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          findMany: {
            args: Prisma.ActivityLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>[]
          }
          create: {
            args: Prisma.ActivityLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          createMany: {
            args: Prisma.ActivityLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActivityLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>[]
          }
          delete: {
            args: Prisma.ActivityLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          update: {
            args: Prisma.ActivityLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          deleteMany: {
            args: Prisma.ActivityLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActivityLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ActivityLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>[]
          }
          upsert: {
            args: Prisma.ActivityLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          aggregate: {
            args: Prisma.ActivityLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivityLog>
          }
          groupBy: {
            args: Prisma.ActivityLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivityLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActivityLogCountArgs<ExtArgs>
            result: $Utils.Optional<ActivityLogCountAggregateOutputType> | number
          }
        }
      }
      Enquiry: {
        payload: Prisma.$EnquiryPayload<ExtArgs>
        fields: Prisma.EnquiryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EnquiryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnquiryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EnquiryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnquiryPayload>
          }
          findFirst: {
            args: Prisma.EnquiryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnquiryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EnquiryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnquiryPayload>
          }
          findMany: {
            args: Prisma.EnquiryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnquiryPayload>[]
          }
          create: {
            args: Prisma.EnquiryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnquiryPayload>
          }
          createMany: {
            args: Prisma.EnquiryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EnquiryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnquiryPayload>[]
          }
          delete: {
            args: Prisma.EnquiryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnquiryPayload>
          }
          update: {
            args: Prisma.EnquiryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnquiryPayload>
          }
          deleteMany: {
            args: Prisma.EnquiryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EnquiryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EnquiryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnquiryPayload>[]
          }
          upsert: {
            args: Prisma.EnquiryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnquiryPayload>
          }
          aggregate: {
            args: Prisma.EnquiryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEnquiry>
          }
          groupBy: {
            args: Prisma.EnquiryGroupByArgs<ExtArgs>
            result: $Utils.Optional<EnquiryGroupByOutputType>[]
          }
          count: {
            args: Prisma.EnquiryCountArgs<ExtArgs>
            result: $Utils.Optional<EnquiryCountAggregateOutputType> | number
          }
        }
      }
      EnquiryCourse: {
        payload: Prisma.$EnquiryCoursePayload<ExtArgs>
        fields: Prisma.EnquiryCourseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EnquiryCourseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnquiryCoursePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EnquiryCourseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnquiryCoursePayload>
          }
          findFirst: {
            args: Prisma.EnquiryCourseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnquiryCoursePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EnquiryCourseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnquiryCoursePayload>
          }
          findMany: {
            args: Prisma.EnquiryCourseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnquiryCoursePayload>[]
          }
          create: {
            args: Prisma.EnquiryCourseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnquiryCoursePayload>
          }
          createMany: {
            args: Prisma.EnquiryCourseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EnquiryCourseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnquiryCoursePayload>[]
          }
          delete: {
            args: Prisma.EnquiryCourseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnquiryCoursePayload>
          }
          update: {
            args: Prisma.EnquiryCourseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnquiryCoursePayload>
          }
          deleteMany: {
            args: Prisma.EnquiryCourseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EnquiryCourseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EnquiryCourseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnquiryCoursePayload>[]
          }
          upsert: {
            args: Prisma.EnquiryCourseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnquiryCoursePayload>
          }
          aggregate: {
            args: Prisma.EnquiryCourseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEnquiryCourse>
          }
          groupBy: {
            args: Prisma.EnquiryCourseGroupByArgs<ExtArgs>
            result: $Utils.Optional<EnquiryCourseGroupByOutputType>[]
          }
          count: {
            args: Prisma.EnquiryCourseCountArgs<ExtArgs>
            result: $Utils.Optional<EnquiryCourseCountAggregateOutputType> | number
          }
        }
      }
      FollowUp: {
        payload: Prisma.$FollowUpPayload<ExtArgs>
        fields: Prisma.FollowUpFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FollowUpFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowUpPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FollowUpFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowUpPayload>
          }
          findFirst: {
            args: Prisma.FollowUpFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowUpPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FollowUpFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowUpPayload>
          }
          findMany: {
            args: Prisma.FollowUpFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowUpPayload>[]
          }
          create: {
            args: Prisma.FollowUpCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowUpPayload>
          }
          createMany: {
            args: Prisma.FollowUpCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FollowUpCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowUpPayload>[]
          }
          delete: {
            args: Prisma.FollowUpDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowUpPayload>
          }
          update: {
            args: Prisma.FollowUpUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowUpPayload>
          }
          deleteMany: {
            args: Prisma.FollowUpDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FollowUpUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FollowUpUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowUpPayload>[]
          }
          upsert: {
            args: Prisma.FollowUpUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowUpPayload>
          }
          aggregate: {
            args: Prisma.FollowUpAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFollowUp>
          }
          groupBy: {
            args: Prisma.FollowUpGroupByArgs<ExtArgs>
            result: $Utils.Optional<FollowUpGroupByOutputType>[]
          }
          count: {
            args: Prisma.FollowUpCountArgs<ExtArgs>
            result: $Utils.Optional<FollowUpCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      Student: {
        payload: Prisma.$StudentPayload<ExtArgs>
        fields: Prisma.StudentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          findFirst: {
            args: Prisma.StudentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          findMany: {
            args: Prisma.StudentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>[]
          }
          create: {
            args: Prisma.StudentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          createMany: {
            args: Prisma.StudentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>[]
          }
          delete: {
            args: Prisma.StudentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          update: {
            args: Prisma.StudentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          deleteMany: {
            args: Prisma.StudentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StudentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>[]
          }
          upsert: {
            args: Prisma.StudentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          aggregate: {
            args: Prisma.StudentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudent>
          }
          groupBy: {
            args: Prisma.StudentGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentCountArgs<ExtArgs>
            result: $Utils.Optional<StudentCountAggregateOutputType> | number
          }
        }
      }
      Course: {
        payload: Prisma.$CoursePayload<ExtArgs>
        fields: Prisma.CourseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          findFirst: {
            args: Prisma.CourseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          findMany: {
            args: Prisma.CourseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>[]
          }
          create: {
            args: Prisma.CourseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          createMany: {
            args: Prisma.CourseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CourseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>[]
          }
          delete: {
            args: Prisma.CourseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          update: {
            args: Prisma.CourseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          deleteMany: {
            args: Prisma.CourseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CourseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>[]
          }
          upsert: {
            args: Prisma.CourseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          aggregate: {
            args: Prisma.CourseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourse>
          }
          groupBy: {
            args: Prisma.CourseGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseCountArgs<ExtArgs>
            result: $Utils.Optional<CourseCountAggregateOutputType> | number
          }
        }
      }
      CourseFeeStructure: {
        payload: Prisma.$CourseFeeStructurePayload<ExtArgs>
        fields: Prisma.CourseFeeStructureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseFeeStructureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseFeeStructurePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseFeeStructureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseFeeStructurePayload>
          }
          findFirst: {
            args: Prisma.CourseFeeStructureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseFeeStructurePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseFeeStructureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseFeeStructurePayload>
          }
          findMany: {
            args: Prisma.CourseFeeStructureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseFeeStructurePayload>[]
          }
          create: {
            args: Prisma.CourseFeeStructureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseFeeStructurePayload>
          }
          createMany: {
            args: Prisma.CourseFeeStructureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CourseFeeStructureCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseFeeStructurePayload>[]
          }
          delete: {
            args: Prisma.CourseFeeStructureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseFeeStructurePayload>
          }
          update: {
            args: Prisma.CourseFeeStructureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseFeeStructurePayload>
          }
          deleteMany: {
            args: Prisma.CourseFeeStructureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseFeeStructureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CourseFeeStructureUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseFeeStructurePayload>[]
          }
          upsert: {
            args: Prisma.CourseFeeStructureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseFeeStructurePayload>
          }
          aggregate: {
            args: Prisma.CourseFeeStructureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourseFeeStructure>
          }
          groupBy: {
            args: Prisma.CourseFeeStructureGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseFeeStructureGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseFeeStructureCountArgs<ExtArgs>
            result: $Utils.Optional<CourseFeeStructureCountAggregateOutputType> | number
          }
        }
      }
      Batch: {
        payload: Prisma.$BatchPayload<ExtArgs>
        fields: Prisma.BatchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BatchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BatchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload>
          }
          findFirst: {
            args: Prisma.BatchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BatchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload>
          }
          findMany: {
            args: Prisma.BatchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload>[]
          }
          create: {
            args: Prisma.BatchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload>
          }
          createMany: {
            args: Prisma.BatchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BatchCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload>[]
          }
          delete: {
            args: Prisma.BatchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload>
          }
          update: {
            args: Prisma.BatchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload>
          }
          deleteMany: {
            args: Prisma.BatchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BatchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BatchUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload>[]
          }
          upsert: {
            args: Prisma.BatchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchPayload>
          }
          aggregate: {
            args: Prisma.BatchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBatch>
          }
          groupBy: {
            args: Prisma.BatchGroupByArgs<ExtArgs>
            result: $Utils.Optional<BatchGroupByOutputType>[]
          }
          count: {
            args: Prisma.BatchCountArgs<ExtArgs>
            result: $Utils.Optional<BatchCountAggregateOutputType> | number
          }
        }
      }
      BatchCourse: {
        payload: Prisma.$BatchCoursePayload<ExtArgs>
        fields: Prisma.BatchCourseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BatchCourseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchCoursePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BatchCourseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchCoursePayload>
          }
          findFirst: {
            args: Prisma.BatchCourseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchCoursePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BatchCourseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchCoursePayload>
          }
          findMany: {
            args: Prisma.BatchCourseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchCoursePayload>[]
          }
          create: {
            args: Prisma.BatchCourseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchCoursePayload>
          }
          createMany: {
            args: Prisma.BatchCourseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BatchCourseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchCoursePayload>[]
          }
          delete: {
            args: Prisma.BatchCourseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchCoursePayload>
          }
          update: {
            args: Prisma.BatchCourseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchCoursePayload>
          }
          deleteMany: {
            args: Prisma.BatchCourseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BatchCourseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BatchCourseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchCoursePayload>[]
          }
          upsert: {
            args: Prisma.BatchCourseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchCoursePayload>
          }
          aggregate: {
            args: Prisma.BatchCourseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBatchCourse>
          }
          groupBy: {
            args: Prisma.BatchCourseGroupByArgs<ExtArgs>
            result: $Utils.Optional<BatchCourseGroupByOutputType>[]
          }
          count: {
            args: Prisma.BatchCourseCountArgs<ExtArgs>
            result: $Utils.Optional<BatchCourseCountAggregateOutputType> | number
          }
        }
      }
      Faculty: {
        payload: Prisma.$FacultyPayload<ExtArgs>
        fields: Prisma.FacultyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FacultyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FacultyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyPayload>
          }
          findFirst: {
            args: Prisma.FacultyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FacultyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyPayload>
          }
          findMany: {
            args: Prisma.FacultyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyPayload>[]
          }
          create: {
            args: Prisma.FacultyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyPayload>
          }
          createMany: {
            args: Prisma.FacultyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FacultyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyPayload>[]
          }
          delete: {
            args: Prisma.FacultyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyPayload>
          }
          update: {
            args: Prisma.FacultyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyPayload>
          }
          deleteMany: {
            args: Prisma.FacultyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FacultyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FacultyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyPayload>[]
          }
          upsert: {
            args: Prisma.FacultyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacultyPayload>
          }
          aggregate: {
            args: Prisma.FacultyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFaculty>
          }
          groupBy: {
            args: Prisma.FacultyGroupByArgs<ExtArgs>
            result: $Utils.Optional<FacultyGroupByOutputType>[]
          }
          count: {
            args: Prisma.FacultyCountArgs<ExtArgs>
            result: $Utils.Optional<FacultyCountAggregateOutputType> | number
          }
        }
      }
      Lab: {
        payload: Prisma.$LabPayload<ExtArgs>
        fields: Prisma.LabFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LabFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LabFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabPayload>
          }
          findFirst: {
            args: Prisma.LabFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LabFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabPayload>
          }
          findMany: {
            args: Prisma.LabFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabPayload>[]
          }
          create: {
            args: Prisma.LabCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabPayload>
          }
          createMany: {
            args: Prisma.LabCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LabCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabPayload>[]
          }
          delete: {
            args: Prisma.LabDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabPayload>
          }
          update: {
            args: Prisma.LabUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabPayload>
          }
          deleteMany: {
            args: Prisma.LabDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LabUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LabUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabPayload>[]
          }
          upsert: {
            args: Prisma.LabUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabPayload>
          }
          aggregate: {
            args: Prisma.LabAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLab>
          }
          groupBy: {
            args: Prisma.LabGroupByArgs<ExtArgs>
            result: $Utils.Optional<LabGroupByOutputType>[]
          }
          count: {
            args: Prisma.LabCountArgs<ExtArgs>
            result: $Utils.Optional<LabCountAggregateOutputType> | number
          }
        }
      }
      LabTimeSlot: {
        payload: Prisma.$LabTimeSlotPayload<ExtArgs>
        fields: Prisma.LabTimeSlotFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LabTimeSlotFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabTimeSlotPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LabTimeSlotFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabTimeSlotPayload>
          }
          findFirst: {
            args: Prisma.LabTimeSlotFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabTimeSlotPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LabTimeSlotFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabTimeSlotPayload>
          }
          findMany: {
            args: Prisma.LabTimeSlotFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabTimeSlotPayload>[]
          }
          create: {
            args: Prisma.LabTimeSlotCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabTimeSlotPayload>
          }
          createMany: {
            args: Prisma.LabTimeSlotCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LabTimeSlotCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabTimeSlotPayload>[]
          }
          delete: {
            args: Prisma.LabTimeSlotDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabTimeSlotPayload>
          }
          update: {
            args: Prisma.LabTimeSlotUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabTimeSlotPayload>
          }
          deleteMany: {
            args: Prisma.LabTimeSlotDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LabTimeSlotUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LabTimeSlotUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabTimeSlotPayload>[]
          }
          upsert: {
            args: Prisma.LabTimeSlotUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabTimeSlotPayload>
          }
          aggregate: {
            args: Prisma.LabTimeSlotAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLabTimeSlot>
          }
          groupBy: {
            args: Prisma.LabTimeSlotGroupByArgs<ExtArgs>
            result: $Utils.Optional<LabTimeSlotGroupByOutputType>[]
          }
          count: {
            args: Prisma.LabTimeSlotCountArgs<ExtArgs>
            result: $Utils.Optional<LabTimeSlotCountAggregateOutputType> | number
          }
        }
      }
      PaymentStructureType: {
        payload: Prisma.$PaymentStructureTypePayload<ExtArgs>
        fields: Prisma.PaymentStructureTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentStructureTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentStructureTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentStructureTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentStructureTypePayload>
          }
          findFirst: {
            args: Prisma.PaymentStructureTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentStructureTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentStructureTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentStructureTypePayload>
          }
          findMany: {
            args: Prisma.PaymentStructureTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentStructureTypePayload>[]
          }
          create: {
            args: Prisma.PaymentStructureTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentStructureTypePayload>
          }
          createMany: {
            args: Prisma.PaymentStructureTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentStructureTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentStructureTypePayload>[]
          }
          delete: {
            args: Prisma.PaymentStructureTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentStructureTypePayload>
          }
          update: {
            args: Prisma.PaymentStructureTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentStructureTypePayload>
          }
          deleteMany: {
            args: Prisma.PaymentStructureTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentStructureTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentStructureTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentStructureTypePayload>[]
          }
          upsert: {
            args: Prisma.PaymentStructureTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentStructureTypePayload>
          }
          aggregate: {
            args: Prisma.PaymentStructureTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaymentStructureType>
          }
          groupBy: {
            args: Prisma.PaymentStructureTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentStructureTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentStructureTypeCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentStructureTypeCountAggregateOutputType> | number
          }
        }
      }
      InstallmentDetail: {
        payload: Prisma.$InstallmentDetailPayload<ExtArgs>
        fields: Prisma.InstallmentDetailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InstallmentDetailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstallmentDetailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InstallmentDetailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstallmentDetailPayload>
          }
          findFirst: {
            args: Prisma.InstallmentDetailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstallmentDetailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InstallmentDetailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstallmentDetailPayload>
          }
          findMany: {
            args: Prisma.InstallmentDetailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstallmentDetailPayload>[]
          }
          create: {
            args: Prisma.InstallmentDetailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstallmentDetailPayload>
          }
          createMany: {
            args: Prisma.InstallmentDetailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InstallmentDetailCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstallmentDetailPayload>[]
          }
          delete: {
            args: Prisma.InstallmentDetailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstallmentDetailPayload>
          }
          update: {
            args: Prisma.InstallmentDetailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstallmentDetailPayload>
          }
          deleteMany: {
            args: Prisma.InstallmentDetailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InstallmentDetailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InstallmentDetailUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstallmentDetailPayload>[]
          }
          upsert: {
            args: Prisma.InstallmentDetailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstallmentDetailPayload>
          }
          aggregate: {
            args: Prisma.InstallmentDetailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInstallmentDetail>
          }
          groupBy: {
            args: Prisma.InstallmentDetailGroupByArgs<ExtArgs>
            result: $Utils.Optional<InstallmentDetailGroupByOutputType>[]
          }
          count: {
            args: Prisma.InstallmentDetailCountArgs<ExtArgs>
            result: $Utils.Optional<InstallmentDetailCountAggregateOutputType> | number
          }
        }
      }
      LabAllocation: {
        payload: Prisma.$LabAllocationPayload<ExtArgs>
        fields: Prisma.LabAllocationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LabAllocationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabAllocationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LabAllocationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabAllocationPayload>
          }
          findFirst: {
            args: Prisma.LabAllocationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabAllocationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LabAllocationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabAllocationPayload>
          }
          findMany: {
            args: Prisma.LabAllocationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabAllocationPayload>[]
          }
          create: {
            args: Prisma.LabAllocationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabAllocationPayload>
          }
          createMany: {
            args: Prisma.LabAllocationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LabAllocationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabAllocationPayload>[]
          }
          delete: {
            args: Prisma.LabAllocationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabAllocationPayload>
          }
          update: {
            args: Prisma.LabAllocationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabAllocationPayload>
          }
          deleteMany: {
            args: Prisma.LabAllocationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LabAllocationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LabAllocationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabAllocationPayload>[]
          }
          upsert: {
            args: Prisma.LabAllocationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabAllocationPayload>
          }
          aggregate: {
            args: Prisma.LabAllocationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLabAllocation>
          }
          groupBy: {
            args: Prisma.LabAllocationGroupByArgs<ExtArgs>
            result: $Utils.Optional<LabAllocationGroupByOutputType>[]
          }
          count: {
            args: Prisma.LabAllocationCountArgs<ExtArgs>
            result: $Utils.Optional<LabAllocationCountAggregateOutputType> | number
          }
        }
      }
      StudentCourse: {
        payload: Prisma.$StudentCoursePayload<ExtArgs>
        fields: Prisma.StudentCourseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentCourseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentCoursePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentCourseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentCoursePayload>
          }
          findFirst: {
            args: Prisma.StudentCourseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentCoursePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentCourseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentCoursePayload>
          }
          findMany: {
            args: Prisma.StudentCourseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentCoursePayload>[]
          }
          create: {
            args: Prisma.StudentCourseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentCoursePayload>
          }
          createMany: {
            args: Prisma.StudentCourseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentCourseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentCoursePayload>[]
          }
          delete: {
            args: Prisma.StudentCourseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentCoursePayload>
          }
          update: {
            args: Prisma.StudentCourseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentCoursePayload>
          }
          deleteMany: {
            args: Prisma.StudentCourseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentCourseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StudentCourseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentCoursePayload>[]
          }
          upsert: {
            args: Prisma.StudentCourseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentCoursePayload>
          }
          aggregate: {
            args: Prisma.StudentCourseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudentCourse>
          }
          groupBy: {
            args: Prisma.StudentCourseGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentCourseGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentCourseCountArgs<ExtArgs>
            result: $Utils.Optional<StudentCourseCountAggregateOutputType> | number
          }
        }
      }
      FeeStructure: {
        payload: Prisma.$FeeStructurePayload<ExtArgs>
        fields: Prisma.FeeStructureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeeStructureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeStructurePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeeStructureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeStructurePayload>
          }
          findFirst: {
            args: Prisma.FeeStructureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeStructurePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeeStructureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeStructurePayload>
          }
          findMany: {
            args: Prisma.FeeStructureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeStructurePayload>[]
          }
          create: {
            args: Prisma.FeeStructureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeStructurePayload>
          }
          createMany: {
            args: Prisma.FeeStructureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FeeStructureCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeStructurePayload>[]
          }
          delete: {
            args: Prisma.FeeStructureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeStructurePayload>
          }
          update: {
            args: Prisma.FeeStructureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeStructurePayload>
          }
          deleteMany: {
            args: Prisma.FeeStructureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeeStructureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FeeStructureUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeStructurePayload>[]
          }
          upsert: {
            args: Prisma.FeeStructureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeStructurePayload>
          }
          aggregate: {
            args: Prisma.FeeStructureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeeStructure>
          }
          groupBy: {
            args: Prisma.FeeStructureGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeeStructureGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeeStructureCountArgs<ExtArgs>
            result: $Utils.Optional<FeeStructureCountAggregateOutputType> | number
          }
        }
      }
      StudentFeeLog: {
        payload: Prisma.$StudentFeeLogPayload<ExtArgs>
        fields: Prisma.StudentFeeLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentFeeLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentFeeLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentFeeLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentFeeLogPayload>
          }
          findFirst: {
            args: Prisma.StudentFeeLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentFeeLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentFeeLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentFeeLogPayload>
          }
          findMany: {
            args: Prisma.StudentFeeLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentFeeLogPayload>[]
          }
          create: {
            args: Prisma.StudentFeeLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentFeeLogPayload>
          }
          createMany: {
            args: Prisma.StudentFeeLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentFeeLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentFeeLogPayload>[]
          }
          delete: {
            args: Prisma.StudentFeeLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentFeeLogPayload>
          }
          update: {
            args: Prisma.StudentFeeLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentFeeLogPayload>
          }
          deleteMany: {
            args: Prisma.StudentFeeLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentFeeLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StudentFeeLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentFeeLogPayload>[]
          }
          upsert: {
            args: Prisma.StudentFeeLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentFeeLogPayload>
          }
          aggregate: {
            args: Prisma.StudentFeeLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudentFeeLog>
          }
          groupBy: {
            args: Prisma.StudentFeeLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentFeeLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentFeeLogCountArgs<ExtArgs>
            result: $Utils.Optional<StudentFeeLogCountAggregateOutputType> | number
          }
        }
      }
      StudentFee: {
        payload: Prisma.$StudentFeePayload<ExtArgs>
        fields: Prisma.StudentFeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentFeeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentFeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentFeeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentFeePayload>
          }
          findFirst: {
            args: Prisma.StudentFeeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentFeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentFeeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentFeePayload>
          }
          findMany: {
            args: Prisma.StudentFeeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentFeePayload>[]
          }
          create: {
            args: Prisma.StudentFeeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentFeePayload>
          }
          createMany: {
            args: Prisma.StudentFeeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentFeeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentFeePayload>[]
          }
          delete: {
            args: Prisma.StudentFeeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentFeePayload>
          }
          update: {
            args: Prisma.StudentFeeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentFeePayload>
          }
          deleteMany: {
            args: Prisma.StudentFeeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentFeeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StudentFeeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentFeePayload>[]
          }
          upsert: {
            args: Prisma.StudentFeeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentFeePayload>
          }
          aggregate: {
            args: Prisma.StudentFeeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudentFee>
          }
          groupBy: {
            args: Prisma.StudentFeeGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentFeeGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentFeeCountArgs<ExtArgs>
            result: $Utils.Optional<StudentFeeCountAggregateOutputType> | number
          }
        }
      }
      StationeryItem: {
        payload: Prisma.$StationeryItemPayload<ExtArgs>
        fields: Prisma.StationeryItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StationeryItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StationeryItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StationeryItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StationeryItemPayload>
          }
          findFirst: {
            args: Prisma.StationeryItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StationeryItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StationeryItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StationeryItemPayload>
          }
          findMany: {
            args: Prisma.StationeryItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StationeryItemPayload>[]
          }
          create: {
            args: Prisma.StationeryItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StationeryItemPayload>
          }
          createMany: {
            args: Prisma.StationeryItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StationeryItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StationeryItemPayload>[]
          }
          delete: {
            args: Prisma.StationeryItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StationeryItemPayload>
          }
          update: {
            args: Prisma.StationeryItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StationeryItemPayload>
          }
          deleteMany: {
            args: Prisma.StationeryItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StationeryItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StationeryItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StationeryItemPayload>[]
          }
          upsert: {
            args: Prisma.StationeryItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StationeryItemPayload>
          }
          aggregate: {
            args: Prisma.StationeryItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStationeryItem>
          }
          groupBy: {
            args: Prisma.StationeryItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<StationeryItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.StationeryItemCountArgs<ExtArgs>
            result: $Utils.Optional<StationeryItemCountAggregateOutputType> | number
          }
        }
      }
      StationeryIssue: {
        payload: Prisma.$StationeryIssuePayload<ExtArgs>
        fields: Prisma.StationeryIssueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StationeryIssueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StationeryIssuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StationeryIssueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StationeryIssuePayload>
          }
          findFirst: {
            args: Prisma.StationeryIssueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StationeryIssuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StationeryIssueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StationeryIssuePayload>
          }
          findMany: {
            args: Prisma.StationeryIssueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StationeryIssuePayload>[]
          }
          create: {
            args: Prisma.StationeryIssueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StationeryIssuePayload>
          }
          createMany: {
            args: Prisma.StationeryIssueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StationeryIssueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StationeryIssuePayload>[]
          }
          delete: {
            args: Prisma.StationeryIssueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StationeryIssuePayload>
          }
          update: {
            args: Prisma.StationeryIssueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StationeryIssuePayload>
          }
          deleteMany: {
            args: Prisma.StationeryIssueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StationeryIssueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StationeryIssueUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StationeryIssuePayload>[]
          }
          upsert: {
            args: Prisma.StationeryIssueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StationeryIssuePayload>
          }
          aggregate: {
            args: Prisma.StationeryIssueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStationeryIssue>
          }
          groupBy: {
            args: Prisma.StationeryIssueGroupByArgs<ExtArgs>
            result: $Utils.Optional<StationeryIssueGroupByOutputType>[]
          }
          count: {
            args: Prisma.StationeryIssueCountArgs<ExtArgs>
            result: $Utils.Optional<StationeryIssueCountAggregateOutputType> | number
          }
        }
      }
      AttendanceRecord: {
        payload: Prisma.$AttendanceRecordPayload<ExtArgs>
        fields: Prisma.AttendanceRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttendanceRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttendanceRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceRecordPayload>
          }
          findFirst: {
            args: Prisma.AttendanceRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttendanceRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceRecordPayload>
          }
          findMany: {
            args: Prisma.AttendanceRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceRecordPayload>[]
          }
          create: {
            args: Prisma.AttendanceRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceRecordPayload>
          }
          createMany: {
            args: Prisma.AttendanceRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AttendanceRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceRecordPayload>[]
          }
          delete: {
            args: Prisma.AttendanceRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceRecordPayload>
          }
          update: {
            args: Prisma.AttendanceRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceRecordPayload>
          }
          deleteMany: {
            args: Prisma.AttendanceRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttendanceRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AttendanceRecordUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceRecordPayload>[]
          }
          upsert: {
            args: Prisma.AttendanceRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceRecordPayload>
          }
          aggregate: {
            args: Prisma.AttendanceRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttendanceRecord>
          }
          groupBy: {
            args: Prisma.AttendanceRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttendanceRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.AttendanceRecordCountArgs<ExtArgs>
            result: $Utils.Optional<AttendanceRecordCountAggregateOutputType> | number
          }
        }
      }
      StudentTask: {
        payload: Prisma.$StudentTaskPayload<ExtArgs>
        fields: Prisma.StudentTaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentTaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentTaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTaskPayload>
          }
          findFirst: {
            args: Prisma.StudentTaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentTaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTaskPayload>
          }
          findMany: {
            args: Prisma.StudentTaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTaskPayload>[]
          }
          create: {
            args: Prisma.StudentTaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTaskPayload>
          }
          createMany: {
            args: Prisma.StudentTaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentTaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTaskPayload>[]
          }
          delete: {
            args: Prisma.StudentTaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTaskPayload>
          }
          update: {
            args: Prisma.StudentTaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTaskPayload>
          }
          deleteMany: {
            args: Prisma.StudentTaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentTaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StudentTaskUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTaskPayload>[]
          }
          upsert: {
            args: Prisma.StudentTaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTaskPayload>
          }
          aggregate: {
            args: Prisma.StudentTaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudentTask>
          }
          groupBy: {
            args: Prisma.StudentTaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentTaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentTaskCountArgs<ExtArgs>
            result: $Utils.Optional<StudentTaskCountAggregateOutputType> | number
          }
        }
      }
      StudentTest: {
        payload: Prisma.$StudentTestPayload<ExtArgs>
        fields: Prisma.StudentTestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentTestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentTestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTestPayload>
          }
          findFirst: {
            args: Prisma.StudentTestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentTestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTestPayload>
          }
          findMany: {
            args: Prisma.StudentTestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTestPayload>[]
          }
          create: {
            args: Prisma.StudentTestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTestPayload>
          }
          createMany: {
            args: Prisma.StudentTestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentTestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTestPayload>[]
          }
          delete: {
            args: Prisma.StudentTestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTestPayload>
          }
          update: {
            args: Prisma.StudentTestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTestPayload>
          }
          deleteMany: {
            args: Prisma.StudentTestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentTestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StudentTestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTestPayload>[]
          }
          upsert: {
            args: Prisma.StudentTestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTestPayload>
          }
          aggregate: {
            args: Prisma.StudentTestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudentTest>
          }
          groupBy: {
            args: Prisma.StudentTestGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentTestGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentTestCountArgs<ExtArgs>
            result: $Utils.Optional<StudentTestCountAggregateOutputType> | number
          }
        }
      }
      CourseCompletion: {
        payload: Prisma.$CourseCompletionPayload<ExtArgs>
        fields: Prisma.CourseCompletionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseCompletionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseCompletionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseCompletionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseCompletionPayload>
          }
          findFirst: {
            args: Prisma.CourseCompletionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseCompletionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseCompletionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseCompletionPayload>
          }
          findMany: {
            args: Prisma.CourseCompletionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseCompletionPayload>[]
          }
          create: {
            args: Prisma.CourseCompletionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseCompletionPayload>
          }
          createMany: {
            args: Prisma.CourseCompletionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CourseCompletionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseCompletionPayload>[]
          }
          delete: {
            args: Prisma.CourseCompletionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseCompletionPayload>
          }
          update: {
            args: Prisma.CourseCompletionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseCompletionPayload>
          }
          deleteMany: {
            args: Prisma.CourseCompletionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseCompletionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CourseCompletionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseCompletionPayload>[]
          }
          upsert: {
            args: Prisma.CourseCompletionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseCompletionPayload>
          }
          aggregate: {
            args: Prisma.CourseCompletionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourseCompletion>
          }
          groupBy: {
            args: Prisma.CourseCompletionGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseCompletionGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseCompletionCountArgs<ExtArgs>
            result: $Utils.Optional<CourseCompletionCountAggregateOutputType> | number
          }
        }
      }
      Certificate: {
        payload: Prisma.$CertificatePayload<ExtArgs>
        fields: Prisma.CertificateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CertificateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CertificateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          findFirst: {
            args: Prisma.CertificateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CertificateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          findMany: {
            args: Prisma.CertificateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>[]
          }
          create: {
            args: Prisma.CertificateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          createMany: {
            args: Prisma.CertificateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CertificateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>[]
          }
          delete: {
            args: Prisma.CertificateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          update: {
            args: Prisma.CertificateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          deleteMany: {
            args: Prisma.CertificateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CertificateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CertificateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>[]
          }
          upsert: {
            args: Prisma.CertificateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          aggregate: {
            args: Prisma.CertificateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCertificate>
          }
          groupBy: {
            args: Prisma.CertificateGroupByArgs<ExtArgs>
            result: $Utils.Optional<CertificateGroupByOutputType>[]
          }
          count: {
            args: Prisma.CertificateCountArgs<ExtArgs>
            result: $Utils.Optional<CertificateCountAggregateOutputType> | number
          }
        }
      }
      FinancialRecord: {
        payload: Prisma.$FinancialRecordPayload<ExtArgs>
        fields: Prisma.FinancialRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FinancialRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FinancialRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialRecordPayload>
          }
          findFirst: {
            args: Prisma.FinancialRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FinancialRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialRecordPayload>
          }
          findMany: {
            args: Prisma.FinancialRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialRecordPayload>[]
          }
          create: {
            args: Prisma.FinancialRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialRecordPayload>
          }
          createMany: {
            args: Prisma.FinancialRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FinancialRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialRecordPayload>[]
          }
          delete: {
            args: Prisma.FinancialRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialRecordPayload>
          }
          update: {
            args: Prisma.FinancialRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialRecordPayload>
          }
          deleteMany: {
            args: Prisma.FinancialRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FinancialRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FinancialRecordUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialRecordPayload>[]
          }
          upsert: {
            args: Prisma.FinancialRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialRecordPayload>
          }
          aggregate: {
            args: Prisma.FinancialRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFinancialRecord>
          }
          groupBy: {
            args: Prisma.FinancialRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<FinancialRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.FinancialRecordCountArgs<ExtArgs>
            result: $Utils.Optional<FinancialRecordCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    clientAdmin?: ClientAdminOmit
    roleUser?: RoleUserOmit
    activityLog?: ActivityLogOmit
    enquiry?: EnquiryOmit
    enquiryCourse?: EnquiryCourseOmit
    followUp?: FollowUpOmit
    notification?: NotificationOmit
    student?: StudentOmit
    course?: CourseOmit
    courseFeeStructure?: CourseFeeStructureOmit
    batch?: BatchOmit
    batchCourse?: BatchCourseOmit
    faculty?: FacultyOmit
    lab?: LabOmit
    labTimeSlot?: LabTimeSlotOmit
    paymentStructureType?: PaymentStructureTypeOmit
    installmentDetail?: InstallmentDetailOmit
    labAllocation?: LabAllocationOmit
    studentCourse?: StudentCourseOmit
    feeStructure?: FeeStructureOmit
    studentFeeLog?: StudentFeeLogOmit
    studentFee?: StudentFeeOmit
    stationeryItem?: StationeryItemOmit
    stationeryIssue?: StationeryIssueOmit
    attendanceRecord?: AttendanceRecordOmit
    studentTask?: StudentTaskOmit
    studentTest?: StudentTestOmit
    courseCompletion?: CourseCompletionOmit
    certificate?: CertificateOmit
    financialRecord?: FinancialRecordOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ClientAdminCountOutputType
   */

  export type ClientAdminCountOutputType = {
    roleUsers: number
    faculties: number
    batches: number
    courses: number
    enquiryCourse: number
    labs: number
    labTimeSlots: number
    labAllocations: number
    students: number
    activities: number
    studentCourses: number
    feeStructures: number
    studentFees: number
    stationeryIssues: number
    attendanceRecords: number
    studentTasks: number
    studentTests: number
    courseCompletions: number
    certificates: number
    financialRecords: number
    enquiries: number
    notifications: number
    courseFeeStructures: number
  }

  export type ClientAdminCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roleUsers?: boolean | ClientAdminCountOutputTypeCountRoleUsersArgs
    faculties?: boolean | ClientAdminCountOutputTypeCountFacultiesArgs
    batches?: boolean | ClientAdminCountOutputTypeCountBatchesArgs
    courses?: boolean | ClientAdminCountOutputTypeCountCoursesArgs
    enquiryCourse?: boolean | ClientAdminCountOutputTypeCountEnquiryCourseArgs
    labs?: boolean | ClientAdminCountOutputTypeCountLabsArgs
    labTimeSlots?: boolean | ClientAdminCountOutputTypeCountLabTimeSlotsArgs
    labAllocations?: boolean | ClientAdminCountOutputTypeCountLabAllocationsArgs
    students?: boolean | ClientAdminCountOutputTypeCountStudentsArgs
    activities?: boolean | ClientAdminCountOutputTypeCountActivitiesArgs
    studentCourses?: boolean | ClientAdminCountOutputTypeCountStudentCoursesArgs
    feeStructures?: boolean | ClientAdminCountOutputTypeCountFeeStructuresArgs
    studentFees?: boolean | ClientAdminCountOutputTypeCountStudentFeesArgs
    stationeryIssues?: boolean | ClientAdminCountOutputTypeCountStationeryIssuesArgs
    attendanceRecords?: boolean | ClientAdminCountOutputTypeCountAttendanceRecordsArgs
    studentTasks?: boolean | ClientAdminCountOutputTypeCountStudentTasksArgs
    studentTests?: boolean | ClientAdminCountOutputTypeCountStudentTestsArgs
    courseCompletions?: boolean | ClientAdminCountOutputTypeCountCourseCompletionsArgs
    certificates?: boolean | ClientAdminCountOutputTypeCountCertificatesArgs
    financialRecords?: boolean | ClientAdminCountOutputTypeCountFinancialRecordsArgs
    enquiries?: boolean | ClientAdminCountOutputTypeCountEnquiriesArgs
    notifications?: boolean | ClientAdminCountOutputTypeCountNotificationsArgs
    courseFeeStructures?: boolean | ClientAdminCountOutputTypeCountCourseFeeStructuresArgs
  }

  // Custom InputTypes
  /**
   * ClientAdminCountOutputType without action
   */
  export type ClientAdminCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientAdminCountOutputType
     */
    select?: ClientAdminCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClientAdminCountOutputType without action
   */
  export type ClientAdminCountOutputTypeCountRoleUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleUserWhereInput
  }

  /**
   * ClientAdminCountOutputType without action
   */
  export type ClientAdminCountOutputTypeCountFacultiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FacultyWhereInput
  }

  /**
   * ClientAdminCountOutputType without action
   */
  export type ClientAdminCountOutputTypeCountBatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BatchWhereInput
  }

  /**
   * ClientAdminCountOutputType without action
   */
  export type ClientAdminCountOutputTypeCountCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseWhereInput
  }

  /**
   * ClientAdminCountOutputType without action
   */
  export type ClientAdminCountOutputTypeCountEnquiryCourseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnquiryCourseWhereInput
  }

  /**
   * ClientAdminCountOutputType without action
   */
  export type ClientAdminCountOutputTypeCountLabsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabWhereInput
  }

  /**
   * ClientAdminCountOutputType without action
   */
  export type ClientAdminCountOutputTypeCountLabTimeSlotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabTimeSlotWhereInput
  }

  /**
   * ClientAdminCountOutputType without action
   */
  export type ClientAdminCountOutputTypeCountLabAllocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabAllocationWhereInput
  }

  /**
   * ClientAdminCountOutputType without action
   */
  export type ClientAdminCountOutputTypeCountStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
  }

  /**
   * ClientAdminCountOutputType without action
   */
  export type ClientAdminCountOutputTypeCountActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityLogWhereInput
  }

  /**
   * ClientAdminCountOutputType without action
   */
  export type ClientAdminCountOutputTypeCountStudentCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentCourseWhereInput
  }

  /**
   * ClientAdminCountOutputType without action
   */
  export type ClientAdminCountOutputTypeCountFeeStructuresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeeStructureWhereInput
  }

  /**
   * ClientAdminCountOutputType without action
   */
  export type ClientAdminCountOutputTypeCountStudentFeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentFeeWhereInput
  }

  /**
   * ClientAdminCountOutputType without action
   */
  export type ClientAdminCountOutputTypeCountStationeryIssuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StationeryIssueWhereInput
  }

  /**
   * ClientAdminCountOutputType without action
   */
  export type ClientAdminCountOutputTypeCountAttendanceRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceRecordWhereInput
  }

  /**
   * ClientAdminCountOutputType without action
   */
  export type ClientAdminCountOutputTypeCountStudentTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentTaskWhereInput
  }

  /**
   * ClientAdminCountOutputType without action
   */
  export type ClientAdminCountOutputTypeCountStudentTestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentTestWhereInput
  }

  /**
   * ClientAdminCountOutputType without action
   */
  export type ClientAdminCountOutputTypeCountCourseCompletionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseCompletionWhereInput
  }

  /**
   * ClientAdminCountOutputType without action
   */
  export type ClientAdminCountOutputTypeCountCertificatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CertificateWhereInput
  }

  /**
   * ClientAdminCountOutputType without action
   */
  export type ClientAdminCountOutputTypeCountFinancialRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FinancialRecordWhereInput
  }

  /**
   * ClientAdminCountOutputType without action
   */
  export type ClientAdminCountOutputTypeCountEnquiriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnquiryWhereInput
  }

  /**
   * ClientAdminCountOutputType without action
   */
  export type ClientAdminCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * ClientAdminCountOutputType without action
   */
  export type ClientAdminCountOutputTypeCountCourseFeeStructuresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseFeeStructureWhereInput
  }


  /**
   * Count Type EnquiryCountOutputType
   */

  export type EnquiryCountOutputType = {
    followUps: number
    enquiryCourse: number
  }

  export type EnquiryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    followUps?: boolean | EnquiryCountOutputTypeCountFollowUpsArgs
    enquiryCourse?: boolean | EnquiryCountOutputTypeCountEnquiryCourseArgs
  }

  // Custom InputTypes
  /**
   * EnquiryCountOutputType without action
   */
  export type EnquiryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnquiryCountOutputType
     */
    select?: EnquiryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EnquiryCountOutputType without action
   */
  export type EnquiryCountOutputTypeCountFollowUpsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FollowUpWhereInput
  }

  /**
   * EnquiryCountOutputType without action
   */
  export type EnquiryCountOutputTypeCountEnquiryCourseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnquiryCourseWhereInput
  }


  /**
   * Count Type StudentCountOutputType
   */

  export type StudentCountOutputType = {
    labAllocations: number
    studentCourses: number
    feeStructures: number
    feeRecords: number
    attendance: number
    tasks: number
    tests: number
    completions: number
    stationery: number
    certificates: number
    financialRecords: number
  }

  export type StudentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    labAllocations?: boolean | StudentCountOutputTypeCountLabAllocationsArgs
    studentCourses?: boolean | StudentCountOutputTypeCountStudentCoursesArgs
    feeStructures?: boolean | StudentCountOutputTypeCountFeeStructuresArgs
    feeRecords?: boolean | StudentCountOutputTypeCountFeeRecordsArgs
    attendance?: boolean | StudentCountOutputTypeCountAttendanceArgs
    tasks?: boolean | StudentCountOutputTypeCountTasksArgs
    tests?: boolean | StudentCountOutputTypeCountTestsArgs
    completions?: boolean | StudentCountOutputTypeCountCompletionsArgs
    stationery?: boolean | StudentCountOutputTypeCountStationeryArgs
    certificates?: boolean | StudentCountOutputTypeCountCertificatesArgs
    financialRecords?: boolean | StudentCountOutputTypeCountFinancialRecordsArgs
  }

  // Custom InputTypes
  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentCountOutputType
     */
    select?: StudentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountLabAllocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabAllocationWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountStudentCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentCourseWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountFeeStructuresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeeStructureWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountFeeRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentFeeWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountAttendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceRecordWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentTaskWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountTestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentTestWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountCompletionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseCompletionWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountStationeryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StationeryIssueWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountCertificatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CertificateWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountFinancialRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FinancialRecordWhereInput
  }


  /**
   * Count Type CourseCountOutputType
   */

  export type CourseCountOutputType = {
    studentCourses: number
    enquiryCourse: number
    feeStructures: number
    stationery: number
    studentFees: number
    attendanceRecords: number
    studentTasks: number
    studentTests: number
    certificates: number
    financialRecords: number
    batchCourses: number
  }

  export type CourseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    studentCourses?: boolean | CourseCountOutputTypeCountStudentCoursesArgs
    enquiryCourse?: boolean | CourseCountOutputTypeCountEnquiryCourseArgs
    feeStructures?: boolean | CourseCountOutputTypeCountFeeStructuresArgs
    stationery?: boolean | CourseCountOutputTypeCountStationeryArgs
    studentFees?: boolean | CourseCountOutputTypeCountStudentFeesArgs
    attendanceRecords?: boolean | CourseCountOutputTypeCountAttendanceRecordsArgs
    studentTasks?: boolean | CourseCountOutputTypeCountStudentTasksArgs
    studentTests?: boolean | CourseCountOutputTypeCountStudentTestsArgs
    certificates?: boolean | CourseCountOutputTypeCountCertificatesArgs
    financialRecords?: boolean | CourseCountOutputTypeCountFinancialRecordsArgs
    batchCourses?: boolean | CourseCountOutputTypeCountBatchCoursesArgs
  }

  // Custom InputTypes
  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseCountOutputType
     */
    select?: CourseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountStudentCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentCourseWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountEnquiryCourseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnquiryCourseWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountFeeStructuresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeeStructureWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountStationeryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StationeryIssueWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountStudentFeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentFeeWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountAttendanceRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceRecordWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountStudentTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentTaskWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountStudentTestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentTestWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountCertificatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CertificateWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountFinancialRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FinancialRecordWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountBatchCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BatchCourseWhereInput
  }


  /**
   * Count Type CourseFeeStructureCountOutputType
   */

  export type CourseFeeStructureCountOutputType = {
    installments: number
  }

  export type CourseFeeStructureCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    installments?: boolean | CourseFeeStructureCountOutputTypeCountInstallmentsArgs
  }

  // Custom InputTypes
  /**
   * CourseFeeStructureCountOutputType without action
   */
  export type CourseFeeStructureCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseFeeStructureCountOutputType
     */
    select?: CourseFeeStructureCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CourseFeeStructureCountOutputType without action
   */
  export type CourseFeeStructureCountOutputTypeCountInstallmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstallmentDetailWhereInput
  }


  /**
   * Count Type BatchCountOutputType
   */

  export type BatchCountOutputType = {
    studentCourses: number
    batchCourses: number
  }

  export type BatchCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    studentCourses?: boolean | BatchCountOutputTypeCountStudentCoursesArgs
    batchCourses?: boolean | BatchCountOutputTypeCountBatchCoursesArgs
  }

  // Custom InputTypes
  /**
   * BatchCountOutputType without action
   */
  export type BatchCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchCountOutputType
     */
    select?: BatchCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BatchCountOutputType without action
   */
  export type BatchCountOutputTypeCountStudentCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentCourseWhereInput
  }

  /**
   * BatchCountOutputType without action
   */
  export type BatchCountOutputTypeCountBatchCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BatchCourseWhereInput
  }


  /**
   * Count Type FacultyCountOutputType
   */

  export type FacultyCountOutputType = {
    batches: number
    attendance: number
    tasks: number
    financialRecords: number
  }

  export type FacultyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    batches?: boolean | FacultyCountOutputTypeCountBatchesArgs
    attendance?: boolean | FacultyCountOutputTypeCountAttendanceArgs
    tasks?: boolean | FacultyCountOutputTypeCountTasksArgs
    financialRecords?: boolean | FacultyCountOutputTypeCountFinancialRecordsArgs
  }

  // Custom InputTypes
  /**
   * FacultyCountOutputType without action
   */
  export type FacultyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacultyCountOutputType
     */
    select?: FacultyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FacultyCountOutputType without action
   */
  export type FacultyCountOutputTypeCountBatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BatchWhereInput
  }

  /**
   * FacultyCountOutputType without action
   */
  export type FacultyCountOutputTypeCountAttendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceRecordWhereInput
  }

  /**
   * FacultyCountOutputType without action
   */
  export type FacultyCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentTaskWhereInput
  }

  /**
   * FacultyCountOutputType without action
   */
  export type FacultyCountOutputTypeCountFinancialRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FinancialRecordWhereInput
  }


  /**
   * Count Type LabCountOutputType
   */

  export type LabCountOutputType = {
    timeSlots: number
    financialRecords: number
  }

  export type LabCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    timeSlots?: boolean | LabCountOutputTypeCountTimeSlotsArgs
    financialRecords?: boolean | LabCountOutputTypeCountFinancialRecordsArgs
  }

  // Custom InputTypes
  /**
   * LabCountOutputType without action
   */
  export type LabCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabCountOutputType
     */
    select?: LabCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LabCountOutputType without action
   */
  export type LabCountOutputTypeCountTimeSlotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabTimeSlotWhereInput
  }

  /**
   * LabCountOutputType without action
   */
  export type LabCountOutputTypeCountFinancialRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FinancialRecordWhereInput
  }


  /**
   * Count Type LabTimeSlotCountOutputType
   */

  export type LabTimeSlotCountOutputType = {
    batches: number
    allocations: number
  }

  export type LabTimeSlotCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    batches?: boolean | LabTimeSlotCountOutputTypeCountBatchesArgs
    allocations?: boolean | LabTimeSlotCountOutputTypeCountAllocationsArgs
  }

  // Custom InputTypes
  /**
   * LabTimeSlotCountOutputType without action
   */
  export type LabTimeSlotCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabTimeSlotCountOutputType
     */
    select?: LabTimeSlotCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LabTimeSlotCountOutputType without action
   */
  export type LabTimeSlotCountOutputTypeCountBatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BatchWhereInput
  }

  /**
   * LabTimeSlotCountOutputType without action
   */
  export type LabTimeSlotCountOutputTypeCountAllocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabAllocationWhereInput
  }


  /**
   * Count Type InstallmentDetailCountOutputType
   */

  export type InstallmentDetailCountOutputType = {
    feeStructures: number
  }

  export type InstallmentDetailCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feeStructures?: boolean | InstallmentDetailCountOutputTypeCountFeeStructuresArgs
  }

  // Custom InputTypes
  /**
   * InstallmentDetailCountOutputType without action
   */
  export type InstallmentDetailCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstallmentDetailCountOutputType
     */
    select?: InstallmentDetailCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InstallmentDetailCountOutputType without action
   */
  export type InstallmentDetailCountOutputTypeCountFeeStructuresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeeStructureWhereInput
  }


  /**
   * Count Type StudentCourseCountOutputType
   */

  export type StudentCourseCountOutputType = {
    completions: number
  }

  export type StudentCourseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    completions?: boolean | StudentCourseCountOutputTypeCountCompletionsArgs
  }

  // Custom InputTypes
  /**
   * StudentCourseCountOutputType without action
   */
  export type StudentCourseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentCourseCountOutputType
     */
    select?: StudentCourseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StudentCourseCountOutputType without action
   */
  export type StudentCourseCountOutputTypeCountCompletionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseCompletionWhereInput
  }


  /**
   * Count Type FeeStructureCountOutputType
   */

  export type FeeStructureCountOutputType = {
    studentFees: number
  }

  export type FeeStructureCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    studentFees?: boolean | FeeStructureCountOutputTypeCountStudentFeesArgs
  }

  // Custom InputTypes
  /**
   * FeeStructureCountOutputType without action
   */
  export type FeeStructureCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeStructureCountOutputType
     */
    select?: FeeStructureCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FeeStructureCountOutputType without action
   */
  export type FeeStructureCountOutputTypeCountStudentFeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentFeeWhereInput
  }


  /**
   * Count Type StudentFeeCountOutputType
   */

  export type StudentFeeCountOutputType = {
    feeLogs: number
  }

  export type StudentFeeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feeLogs?: boolean | StudentFeeCountOutputTypeCountFeeLogsArgs
  }

  // Custom InputTypes
  /**
   * StudentFeeCountOutputType without action
   */
  export type StudentFeeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentFeeCountOutputType
     */
    select?: StudentFeeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StudentFeeCountOutputType without action
   */
  export type StudentFeeCountOutputTypeCountFeeLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentFeeLogWhereInput
  }


  /**
   * Count Type StationeryItemCountOutputType
   */

  export type StationeryItemCountOutputType = {
    stationeryIssues: number
  }

  export type StationeryItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stationeryIssues?: boolean | StationeryItemCountOutputTypeCountStationeryIssuesArgs
  }

  // Custom InputTypes
  /**
   * StationeryItemCountOutputType without action
   */
  export type StationeryItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StationeryItemCountOutputType
     */
    select?: StationeryItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StationeryItemCountOutputType without action
   */
  export type StationeryItemCountOutputTypeCountStationeryIssuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StationeryIssueWhereInput
  }


  /**
   * Models
   */

  /**
   * Model ClientAdmin
   */

  export type AggregateClientAdmin = {
    _count: ClientAdminCountAggregateOutputType | null
    _min: ClientAdminMinAggregateOutputType | null
    _max: ClientAdminMaxAggregateOutputType | null
  }

  export type ClientAdminMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    password: string | null
    instituteName: string | null
    slug: string | null
    fullAddress: string | null
    logo: string | null
    certificateName: string | null
    stamp: string | null
    sign: string | null
    contact: string | null
    position: string | null
    country: string | null
    state: string | null
    city: string | null
    zipCode: string | null
    createdAt: Date | null
    role: $Enums.UserRole | null
    currentSessionToken: string | null
    lastLoginAt: Date | null
  }

  export type ClientAdminMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    password: string | null
    instituteName: string | null
    slug: string | null
    fullAddress: string | null
    logo: string | null
    certificateName: string | null
    stamp: string | null
    sign: string | null
    contact: string | null
    position: string | null
    country: string | null
    state: string | null
    city: string | null
    zipCode: string | null
    createdAt: Date | null
    role: $Enums.UserRole | null
    currentSessionToken: string | null
    lastLoginAt: Date | null
  }

  export type ClientAdminCountAggregateOutputType = {
    id: number
    name: number
    email: number
    password: number
    instituteName: number
    slug: number
    fullAddress: number
    logo: number
    certificateName: number
    stamp: number
    sign: number
    contact: number
    position: number
    country: number
    state: number
    city: number
    zipCode: number
    createdAt: number
    role: number
    currentSessionToken: number
    lastLoginAt: number
    _all: number
  }


  export type ClientAdminMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    instituteName?: true
    slug?: true
    fullAddress?: true
    logo?: true
    certificateName?: true
    stamp?: true
    sign?: true
    contact?: true
    position?: true
    country?: true
    state?: true
    city?: true
    zipCode?: true
    createdAt?: true
    role?: true
    currentSessionToken?: true
    lastLoginAt?: true
  }

  export type ClientAdminMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    instituteName?: true
    slug?: true
    fullAddress?: true
    logo?: true
    certificateName?: true
    stamp?: true
    sign?: true
    contact?: true
    position?: true
    country?: true
    state?: true
    city?: true
    zipCode?: true
    createdAt?: true
    role?: true
    currentSessionToken?: true
    lastLoginAt?: true
  }

  export type ClientAdminCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    instituteName?: true
    slug?: true
    fullAddress?: true
    logo?: true
    certificateName?: true
    stamp?: true
    sign?: true
    contact?: true
    position?: true
    country?: true
    state?: true
    city?: true
    zipCode?: true
    createdAt?: true
    role?: true
    currentSessionToken?: true
    lastLoginAt?: true
    _all?: true
  }

  export type ClientAdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientAdmin to aggregate.
     */
    where?: ClientAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientAdmins to fetch.
     */
    orderBy?: ClientAdminOrderByWithRelationInput | ClientAdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientAdmins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClientAdmins
    **/
    _count?: true | ClientAdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientAdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientAdminMaxAggregateInputType
  }

  export type GetClientAdminAggregateType<T extends ClientAdminAggregateArgs> = {
        [P in keyof T & keyof AggregateClientAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClientAdmin[P]>
      : GetScalarType<T[P], AggregateClientAdmin[P]>
  }




  export type ClientAdminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientAdminWhereInput
    orderBy?: ClientAdminOrderByWithAggregationInput | ClientAdminOrderByWithAggregationInput[]
    by: ClientAdminScalarFieldEnum[] | ClientAdminScalarFieldEnum
    having?: ClientAdminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientAdminCountAggregateInputType | true
    _min?: ClientAdminMinAggregateInputType
    _max?: ClientAdminMaxAggregateInputType
  }

  export type ClientAdminGroupByOutputType = {
    id: string
    name: string
    email: string
    password: string
    instituteName: string
    slug: string
    fullAddress: string
    logo: string | null
    certificateName: string | null
    stamp: string | null
    sign: string | null
    contact: string
    position: string
    country: string
    state: string
    city: string
    zipCode: string
    createdAt: Date
    role: $Enums.UserRole
    currentSessionToken: string | null
    lastLoginAt: Date | null
    _count: ClientAdminCountAggregateOutputType | null
    _min: ClientAdminMinAggregateOutputType | null
    _max: ClientAdminMaxAggregateOutputType | null
  }

  type GetClientAdminGroupByPayload<T extends ClientAdminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientAdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientAdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientAdminGroupByOutputType[P]>
            : GetScalarType<T[P], ClientAdminGroupByOutputType[P]>
        }
      >
    >


  export type ClientAdminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    instituteName?: boolean
    slug?: boolean
    fullAddress?: boolean
    logo?: boolean
    certificateName?: boolean
    stamp?: boolean
    sign?: boolean
    contact?: boolean
    position?: boolean
    country?: boolean
    state?: boolean
    city?: boolean
    zipCode?: boolean
    createdAt?: boolean
    role?: boolean
    currentSessionToken?: boolean
    lastLoginAt?: boolean
    roleUsers?: boolean | ClientAdmin$roleUsersArgs<ExtArgs>
    faculties?: boolean | ClientAdmin$facultiesArgs<ExtArgs>
    batches?: boolean | ClientAdmin$batchesArgs<ExtArgs>
    courses?: boolean | ClientAdmin$coursesArgs<ExtArgs>
    enquiryCourse?: boolean | ClientAdmin$enquiryCourseArgs<ExtArgs>
    labs?: boolean | ClientAdmin$labsArgs<ExtArgs>
    labTimeSlots?: boolean | ClientAdmin$labTimeSlotsArgs<ExtArgs>
    labAllocations?: boolean | ClientAdmin$labAllocationsArgs<ExtArgs>
    students?: boolean | ClientAdmin$studentsArgs<ExtArgs>
    activities?: boolean | ClientAdmin$activitiesArgs<ExtArgs>
    studentCourses?: boolean | ClientAdmin$studentCoursesArgs<ExtArgs>
    feeStructures?: boolean | ClientAdmin$feeStructuresArgs<ExtArgs>
    studentFees?: boolean | ClientAdmin$studentFeesArgs<ExtArgs>
    stationeryIssues?: boolean | ClientAdmin$stationeryIssuesArgs<ExtArgs>
    attendanceRecords?: boolean | ClientAdmin$attendanceRecordsArgs<ExtArgs>
    studentTasks?: boolean | ClientAdmin$studentTasksArgs<ExtArgs>
    studentTests?: boolean | ClientAdmin$studentTestsArgs<ExtArgs>
    courseCompletions?: boolean | ClientAdmin$courseCompletionsArgs<ExtArgs>
    certificates?: boolean | ClientAdmin$certificatesArgs<ExtArgs>
    financialRecords?: boolean | ClientAdmin$financialRecordsArgs<ExtArgs>
    enquiries?: boolean | ClientAdmin$enquiriesArgs<ExtArgs>
    notifications?: boolean | ClientAdmin$notificationsArgs<ExtArgs>
    courseFeeStructures?: boolean | ClientAdmin$courseFeeStructuresArgs<ExtArgs>
    _count?: boolean | ClientAdminCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientAdmin"]>

  export type ClientAdminSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    instituteName?: boolean
    slug?: boolean
    fullAddress?: boolean
    logo?: boolean
    certificateName?: boolean
    stamp?: boolean
    sign?: boolean
    contact?: boolean
    position?: boolean
    country?: boolean
    state?: boolean
    city?: boolean
    zipCode?: boolean
    createdAt?: boolean
    role?: boolean
    currentSessionToken?: boolean
    lastLoginAt?: boolean
  }, ExtArgs["result"]["clientAdmin"]>

  export type ClientAdminSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    instituteName?: boolean
    slug?: boolean
    fullAddress?: boolean
    logo?: boolean
    certificateName?: boolean
    stamp?: boolean
    sign?: boolean
    contact?: boolean
    position?: boolean
    country?: boolean
    state?: boolean
    city?: boolean
    zipCode?: boolean
    createdAt?: boolean
    role?: boolean
    currentSessionToken?: boolean
    lastLoginAt?: boolean
  }, ExtArgs["result"]["clientAdmin"]>

  export type ClientAdminSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    instituteName?: boolean
    slug?: boolean
    fullAddress?: boolean
    logo?: boolean
    certificateName?: boolean
    stamp?: boolean
    sign?: boolean
    contact?: boolean
    position?: boolean
    country?: boolean
    state?: boolean
    city?: boolean
    zipCode?: boolean
    createdAt?: boolean
    role?: boolean
    currentSessionToken?: boolean
    lastLoginAt?: boolean
  }

  export type ClientAdminOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "password" | "instituteName" | "slug" | "fullAddress" | "logo" | "certificateName" | "stamp" | "sign" | "contact" | "position" | "country" | "state" | "city" | "zipCode" | "createdAt" | "role" | "currentSessionToken" | "lastLoginAt", ExtArgs["result"]["clientAdmin"]>
  export type ClientAdminInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roleUsers?: boolean | ClientAdmin$roleUsersArgs<ExtArgs>
    faculties?: boolean | ClientAdmin$facultiesArgs<ExtArgs>
    batches?: boolean | ClientAdmin$batchesArgs<ExtArgs>
    courses?: boolean | ClientAdmin$coursesArgs<ExtArgs>
    enquiryCourse?: boolean | ClientAdmin$enquiryCourseArgs<ExtArgs>
    labs?: boolean | ClientAdmin$labsArgs<ExtArgs>
    labTimeSlots?: boolean | ClientAdmin$labTimeSlotsArgs<ExtArgs>
    labAllocations?: boolean | ClientAdmin$labAllocationsArgs<ExtArgs>
    students?: boolean | ClientAdmin$studentsArgs<ExtArgs>
    activities?: boolean | ClientAdmin$activitiesArgs<ExtArgs>
    studentCourses?: boolean | ClientAdmin$studentCoursesArgs<ExtArgs>
    feeStructures?: boolean | ClientAdmin$feeStructuresArgs<ExtArgs>
    studentFees?: boolean | ClientAdmin$studentFeesArgs<ExtArgs>
    stationeryIssues?: boolean | ClientAdmin$stationeryIssuesArgs<ExtArgs>
    attendanceRecords?: boolean | ClientAdmin$attendanceRecordsArgs<ExtArgs>
    studentTasks?: boolean | ClientAdmin$studentTasksArgs<ExtArgs>
    studentTests?: boolean | ClientAdmin$studentTestsArgs<ExtArgs>
    courseCompletions?: boolean | ClientAdmin$courseCompletionsArgs<ExtArgs>
    certificates?: boolean | ClientAdmin$certificatesArgs<ExtArgs>
    financialRecords?: boolean | ClientAdmin$financialRecordsArgs<ExtArgs>
    enquiries?: boolean | ClientAdmin$enquiriesArgs<ExtArgs>
    notifications?: boolean | ClientAdmin$notificationsArgs<ExtArgs>
    courseFeeStructures?: boolean | ClientAdmin$courseFeeStructuresArgs<ExtArgs>
    _count?: boolean | ClientAdminCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClientAdminIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ClientAdminIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ClientAdminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClientAdmin"
    objects: {
      roleUsers: Prisma.$RoleUserPayload<ExtArgs>[]
      faculties: Prisma.$FacultyPayload<ExtArgs>[]
      batches: Prisma.$BatchPayload<ExtArgs>[]
      courses: Prisma.$CoursePayload<ExtArgs>[]
      enquiryCourse: Prisma.$EnquiryCoursePayload<ExtArgs>[]
      labs: Prisma.$LabPayload<ExtArgs>[]
      labTimeSlots: Prisma.$LabTimeSlotPayload<ExtArgs>[]
      labAllocations: Prisma.$LabAllocationPayload<ExtArgs>[]
      students: Prisma.$StudentPayload<ExtArgs>[]
      activities: Prisma.$ActivityLogPayload<ExtArgs>[]
      studentCourses: Prisma.$StudentCoursePayload<ExtArgs>[]
      feeStructures: Prisma.$FeeStructurePayload<ExtArgs>[]
      studentFees: Prisma.$StudentFeePayload<ExtArgs>[]
      stationeryIssues: Prisma.$StationeryIssuePayload<ExtArgs>[]
      attendanceRecords: Prisma.$AttendanceRecordPayload<ExtArgs>[]
      studentTasks: Prisma.$StudentTaskPayload<ExtArgs>[]
      studentTests: Prisma.$StudentTestPayload<ExtArgs>[]
      courseCompletions: Prisma.$CourseCompletionPayload<ExtArgs>[]
      certificates: Prisma.$CertificatePayload<ExtArgs>[]
      financialRecords: Prisma.$FinancialRecordPayload<ExtArgs>[]
      enquiries: Prisma.$EnquiryPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      courseFeeStructures: Prisma.$CourseFeeStructurePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      password: string
      instituteName: string
      slug: string
      fullAddress: string
      logo: string | null
      certificateName: string | null
      stamp: string | null
      sign: string | null
      contact: string
      position: string
      country: string
      state: string
      city: string
      zipCode: string
      createdAt: Date
      role: $Enums.UserRole
      currentSessionToken: string | null
      lastLoginAt: Date | null
    }, ExtArgs["result"]["clientAdmin"]>
    composites: {}
  }

  type ClientAdminGetPayload<S extends boolean | null | undefined | ClientAdminDefaultArgs> = $Result.GetResult<Prisma.$ClientAdminPayload, S>

  type ClientAdminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClientAdminFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClientAdminCountAggregateInputType | true
    }

  export interface ClientAdminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClientAdmin'], meta: { name: 'ClientAdmin' } }
    /**
     * Find zero or one ClientAdmin that matches the filter.
     * @param {ClientAdminFindUniqueArgs} args - Arguments to find a ClientAdmin
     * @example
     * // Get one ClientAdmin
     * const clientAdmin = await prisma.clientAdmin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientAdminFindUniqueArgs>(args: SelectSubset<T, ClientAdminFindUniqueArgs<ExtArgs>>): Prisma__ClientAdminClient<$Result.GetResult<Prisma.$ClientAdminPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClientAdmin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClientAdminFindUniqueOrThrowArgs} args - Arguments to find a ClientAdmin
     * @example
     * // Get one ClientAdmin
     * const clientAdmin = await prisma.clientAdmin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientAdminFindUniqueOrThrowArgs>(args: SelectSubset<T, ClientAdminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClientAdminClient<$Result.GetResult<Prisma.$ClientAdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClientAdmin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAdminFindFirstArgs} args - Arguments to find a ClientAdmin
     * @example
     * // Get one ClientAdmin
     * const clientAdmin = await prisma.clientAdmin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientAdminFindFirstArgs>(args?: SelectSubset<T, ClientAdminFindFirstArgs<ExtArgs>>): Prisma__ClientAdminClient<$Result.GetResult<Prisma.$ClientAdminPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClientAdmin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAdminFindFirstOrThrowArgs} args - Arguments to find a ClientAdmin
     * @example
     * // Get one ClientAdmin
     * const clientAdmin = await prisma.clientAdmin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientAdminFindFirstOrThrowArgs>(args?: SelectSubset<T, ClientAdminFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClientAdminClient<$Result.GetResult<Prisma.$ClientAdminPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClientAdmins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAdminFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClientAdmins
     * const clientAdmins = await prisma.clientAdmin.findMany()
     * 
     * // Get first 10 ClientAdmins
     * const clientAdmins = await prisma.clientAdmin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientAdminWithIdOnly = await prisma.clientAdmin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClientAdminFindManyArgs>(args?: SelectSubset<T, ClientAdminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientAdminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClientAdmin.
     * @param {ClientAdminCreateArgs} args - Arguments to create a ClientAdmin.
     * @example
     * // Create one ClientAdmin
     * const ClientAdmin = await prisma.clientAdmin.create({
     *   data: {
     *     // ... data to create a ClientAdmin
     *   }
     * })
     * 
     */
    create<T extends ClientAdminCreateArgs>(args: SelectSubset<T, ClientAdminCreateArgs<ExtArgs>>): Prisma__ClientAdminClient<$Result.GetResult<Prisma.$ClientAdminPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClientAdmins.
     * @param {ClientAdminCreateManyArgs} args - Arguments to create many ClientAdmins.
     * @example
     * // Create many ClientAdmins
     * const clientAdmin = await prisma.clientAdmin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClientAdminCreateManyArgs>(args?: SelectSubset<T, ClientAdminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClientAdmins and returns the data saved in the database.
     * @param {ClientAdminCreateManyAndReturnArgs} args - Arguments to create many ClientAdmins.
     * @example
     * // Create many ClientAdmins
     * const clientAdmin = await prisma.clientAdmin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClientAdmins and only return the `id`
     * const clientAdminWithIdOnly = await prisma.clientAdmin.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClientAdminCreateManyAndReturnArgs>(args?: SelectSubset<T, ClientAdminCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientAdminPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ClientAdmin.
     * @param {ClientAdminDeleteArgs} args - Arguments to delete one ClientAdmin.
     * @example
     * // Delete one ClientAdmin
     * const ClientAdmin = await prisma.clientAdmin.delete({
     *   where: {
     *     // ... filter to delete one ClientAdmin
     *   }
     * })
     * 
     */
    delete<T extends ClientAdminDeleteArgs>(args: SelectSubset<T, ClientAdminDeleteArgs<ExtArgs>>): Prisma__ClientAdminClient<$Result.GetResult<Prisma.$ClientAdminPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClientAdmin.
     * @param {ClientAdminUpdateArgs} args - Arguments to update one ClientAdmin.
     * @example
     * // Update one ClientAdmin
     * const clientAdmin = await prisma.clientAdmin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClientAdminUpdateArgs>(args: SelectSubset<T, ClientAdminUpdateArgs<ExtArgs>>): Prisma__ClientAdminClient<$Result.GetResult<Prisma.$ClientAdminPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClientAdmins.
     * @param {ClientAdminDeleteManyArgs} args - Arguments to filter ClientAdmins to delete.
     * @example
     * // Delete a few ClientAdmins
     * const { count } = await prisma.clientAdmin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClientAdminDeleteManyArgs>(args?: SelectSubset<T, ClientAdminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientAdmins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClientAdmins
     * const clientAdmin = await prisma.clientAdmin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClientAdminUpdateManyArgs>(args: SelectSubset<T, ClientAdminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientAdmins and returns the data updated in the database.
     * @param {ClientAdminUpdateManyAndReturnArgs} args - Arguments to update many ClientAdmins.
     * @example
     * // Update many ClientAdmins
     * const clientAdmin = await prisma.clientAdmin.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ClientAdmins and only return the `id`
     * const clientAdminWithIdOnly = await prisma.clientAdmin.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClientAdminUpdateManyAndReturnArgs>(args: SelectSubset<T, ClientAdminUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientAdminPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ClientAdmin.
     * @param {ClientAdminUpsertArgs} args - Arguments to update or create a ClientAdmin.
     * @example
     * // Update or create a ClientAdmin
     * const clientAdmin = await prisma.clientAdmin.upsert({
     *   create: {
     *     // ... data to create a ClientAdmin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClientAdmin we want to update
     *   }
     * })
     */
    upsert<T extends ClientAdminUpsertArgs>(args: SelectSubset<T, ClientAdminUpsertArgs<ExtArgs>>): Prisma__ClientAdminClient<$Result.GetResult<Prisma.$ClientAdminPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClientAdmins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAdminCountArgs} args - Arguments to filter ClientAdmins to count.
     * @example
     * // Count the number of ClientAdmins
     * const count = await prisma.clientAdmin.count({
     *   where: {
     *     // ... the filter for the ClientAdmins we want to count
     *   }
     * })
    **/
    count<T extends ClientAdminCountArgs>(
      args?: Subset<T, ClientAdminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientAdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClientAdmin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientAdminAggregateArgs>(args: Subset<T, ClientAdminAggregateArgs>): Prisma.PrismaPromise<GetClientAdminAggregateType<T>>

    /**
     * Group by ClientAdmin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientAdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientAdminGroupByArgs['orderBy'] }
        : { orderBy?: ClientAdminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientAdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClientAdmin model
   */
  readonly fields: ClientAdminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClientAdmin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientAdminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    roleUsers<T extends ClientAdmin$roleUsersArgs<ExtArgs> = {}>(args?: Subset<T, ClientAdmin$roleUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoleUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    faculties<T extends ClientAdmin$facultiesArgs<ExtArgs> = {}>(args?: Subset<T, ClientAdmin$facultiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    batches<T extends ClientAdmin$batchesArgs<ExtArgs> = {}>(args?: Subset<T, ClientAdmin$batchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    courses<T extends ClientAdmin$coursesArgs<ExtArgs> = {}>(args?: Subset<T, ClientAdmin$coursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    enquiryCourse<T extends ClientAdmin$enquiryCourseArgs<ExtArgs> = {}>(args?: Subset<T, ClientAdmin$enquiryCourseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnquiryCoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    labs<T extends ClientAdmin$labsArgs<ExtArgs> = {}>(args?: Subset<T, ClientAdmin$labsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    labTimeSlots<T extends ClientAdmin$labTimeSlotsArgs<ExtArgs> = {}>(args?: Subset<T, ClientAdmin$labTimeSlotsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabTimeSlotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    labAllocations<T extends ClientAdmin$labAllocationsArgs<ExtArgs> = {}>(args?: Subset<T, ClientAdmin$labAllocationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabAllocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    students<T extends ClientAdmin$studentsArgs<ExtArgs> = {}>(args?: Subset<T, ClientAdmin$studentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    activities<T extends ClientAdmin$activitiesArgs<ExtArgs> = {}>(args?: Subset<T, ClientAdmin$activitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    studentCourses<T extends ClientAdmin$studentCoursesArgs<ExtArgs> = {}>(args?: Subset<T, ClientAdmin$studentCoursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentCoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    feeStructures<T extends ClientAdmin$feeStructuresArgs<ExtArgs> = {}>(args?: Subset<T, ClientAdmin$feeStructuresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeeStructurePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    studentFees<T extends ClientAdmin$studentFeesArgs<ExtArgs> = {}>(args?: Subset<T, ClientAdmin$studentFeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentFeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    stationeryIssues<T extends ClientAdmin$stationeryIssuesArgs<ExtArgs> = {}>(args?: Subset<T, ClientAdmin$stationeryIssuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StationeryIssuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attendanceRecords<T extends ClientAdmin$attendanceRecordsArgs<ExtArgs> = {}>(args?: Subset<T, ClientAdmin$attendanceRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    studentTasks<T extends ClientAdmin$studentTasksArgs<ExtArgs> = {}>(args?: Subset<T, ClientAdmin$studentTasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    studentTests<T extends ClientAdmin$studentTestsArgs<ExtArgs> = {}>(args?: Subset<T, ClientAdmin$studentTestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentTestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    courseCompletions<T extends ClientAdmin$courseCompletionsArgs<ExtArgs> = {}>(args?: Subset<T, ClientAdmin$courseCompletionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseCompletionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    certificates<T extends ClientAdmin$certificatesArgs<ExtArgs> = {}>(args?: Subset<T, ClientAdmin$certificatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    financialRecords<T extends ClientAdmin$financialRecordsArgs<ExtArgs> = {}>(args?: Subset<T, ClientAdmin$financialRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinancialRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    enquiries<T extends ClientAdmin$enquiriesArgs<ExtArgs> = {}>(args?: Subset<T, ClientAdmin$enquiriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnquiryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends ClientAdmin$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, ClientAdmin$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    courseFeeStructures<T extends ClientAdmin$courseFeeStructuresArgs<ExtArgs> = {}>(args?: Subset<T, ClientAdmin$courseFeeStructuresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseFeeStructurePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClientAdmin model
   */
  interface ClientAdminFieldRefs {
    readonly id: FieldRef<"ClientAdmin", 'String'>
    readonly name: FieldRef<"ClientAdmin", 'String'>
    readonly email: FieldRef<"ClientAdmin", 'String'>
    readonly password: FieldRef<"ClientAdmin", 'String'>
    readonly instituteName: FieldRef<"ClientAdmin", 'String'>
    readonly slug: FieldRef<"ClientAdmin", 'String'>
    readonly fullAddress: FieldRef<"ClientAdmin", 'String'>
    readonly logo: FieldRef<"ClientAdmin", 'String'>
    readonly certificateName: FieldRef<"ClientAdmin", 'String'>
    readonly stamp: FieldRef<"ClientAdmin", 'String'>
    readonly sign: FieldRef<"ClientAdmin", 'String'>
    readonly contact: FieldRef<"ClientAdmin", 'String'>
    readonly position: FieldRef<"ClientAdmin", 'String'>
    readonly country: FieldRef<"ClientAdmin", 'String'>
    readonly state: FieldRef<"ClientAdmin", 'String'>
    readonly city: FieldRef<"ClientAdmin", 'String'>
    readonly zipCode: FieldRef<"ClientAdmin", 'String'>
    readonly createdAt: FieldRef<"ClientAdmin", 'DateTime'>
    readonly role: FieldRef<"ClientAdmin", 'UserRole'>
    readonly currentSessionToken: FieldRef<"ClientAdmin", 'String'>
    readonly lastLoginAt: FieldRef<"ClientAdmin", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ClientAdmin findUnique
   */
  export type ClientAdminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientAdmin
     */
    select?: ClientAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientAdmin
     */
    omit?: ClientAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientAdminInclude<ExtArgs> | null
    /**
     * Filter, which ClientAdmin to fetch.
     */
    where: ClientAdminWhereUniqueInput
  }

  /**
   * ClientAdmin findUniqueOrThrow
   */
  export type ClientAdminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientAdmin
     */
    select?: ClientAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientAdmin
     */
    omit?: ClientAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientAdminInclude<ExtArgs> | null
    /**
     * Filter, which ClientAdmin to fetch.
     */
    where: ClientAdminWhereUniqueInput
  }

  /**
   * ClientAdmin findFirst
   */
  export type ClientAdminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientAdmin
     */
    select?: ClientAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientAdmin
     */
    omit?: ClientAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientAdminInclude<ExtArgs> | null
    /**
     * Filter, which ClientAdmin to fetch.
     */
    where?: ClientAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientAdmins to fetch.
     */
    orderBy?: ClientAdminOrderByWithRelationInput | ClientAdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientAdmins.
     */
    cursor?: ClientAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientAdmins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientAdmins.
     */
    distinct?: ClientAdminScalarFieldEnum | ClientAdminScalarFieldEnum[]
  }

  /**
   * ClientAdmin findFirstOrThrow
   */
  export type ClientAdminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientAdmin
     */
    select?: ClientAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientAdmin
     */
    omit?: ClientAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientAdminInclude<ExtArgs> | null
    /**
     * Filter, which ClientAdmin to fetch.
     */
    where?: ClientAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientAdmins to fetch.
     */
    orderBy?: ClientAdminOrderByWithRelationInput | ClientAdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientAdmins.
     */
    cursor?: ClientAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientAdmins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientAdmins.
     */
    distinct?: ClientAdminScalarFieldEnum | ClientAdminScalarFieldEnum[]
  }

  /**
   * ClientAdmin findMany
   */
  export type ClientAdminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientAdmin
     */
    select?: ClientAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientAdmin
     */
    omit?: ClientAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientAdminInclude<ExtArgs> | null
    /**
     * Filter, which ClientAdmins to fetch.
     */
    where?: ClientAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientAdmins to fetch.
     */
    orderBy?: ClientAdminOrderByWithRelationInput | ClientAdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClientAdmins.
     */
    cursor?: ClientAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientAdmins.
     */
    skip?: number
    distinct?: ClientAdminScalarFieldEnum | ClientAdminScalarFieldEnum[]
  }

  /**
   * ClientAdmin create
   */
  export type ClientAdminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientAdmin
     */
    select?: ClientAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientAdmin
     */
    omit?: ClientAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientAdminInclude<ExtArgs> | null
    /**
     * The data needed to create a ClientAdmin.
     */
    data: XOR<ClientAdminCreateInput, ClientAdminUncheckedCreateInput>
  }

  /**
   * ClientAdmin createMany
   */
  export type ClientAdminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClientAdmins.
     */
    data: ClientAdminCreateManyInput | ClientAdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClientAdmin createManyAndReturn
   */
  export type ClientAdminCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientAdmin
     */
    select?: ClientAdminSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClientAdmin
     */
    omit?: ClientAdminOmit<ExtArgs> | null
    /**
     * The data used to create many ClientAdmins.
     */
    data: ClientAdminCreateManyInput | ClientAdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClientAdmin update
   */
  export type ClientAdminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientAdmin
     */
    select?: ClientAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientAdmin
     */
    omit?: ClientAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientAdminInclude<ExtArgs> | null
    /**
     * The data needed to update a ClientAdmin.
     */
    data: XOR<ClientAdminUpdateInput, ClientAdminUncheckedUpdateInput>
    /**
     * Choose, which ClientAdmin to update.
     */
    where: ClientAdminWhereUniqueInput
  }

  /**
   * ClientAdmin updateMany
   */
  export type ClientAdminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClientAdmins.
     */
    data: XOR<ClientAdminUpdateManyMutationInput, ClientAdminUncheckedUpdateManyInput>
    /**
     * Filter which ClientAdmins to update
     */
    where?: ClientAdminWhereInput
    /**
     * Limit how many ClientAdmins to update.
     */
    limit?: number
  }

  /**
   * ClientAdmin updateManyAndReturn
   */
  export type ClientAdminUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientAdmin
     */
    select?: ClientAdminSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClientAdmin
     */
    omit?: ClientAdminOmit<ExtArgs> | null
    /**
     * The data used to update ClientAdmins.
     */
    data: XOR<ClientAdminUpdateManyMutationInput, ClientAdminUncheckedUpdateManyInput>
    /**
     * Filter which ClientAdmins to update
     */
    where?: ClientAdminWhereInput
    /**
     * Limit how many ClientAdmins to update.
     */
    limit?: number
  }

  /**
   * ClientAdmin upsert
   */
  export type ClientAdminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientAdmin
     */
    select?: ClientAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientAdmin
     */
    omit?: ClientAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientAdminInclude<ExtArgs> | null
    /**
     * The filter to search for the ClientAdmin to update in case it exists.
     */
    where: ClientAdminWhereUniqueInput
    /**
     * In case the ClientAdmin found by the `where` argument doesn't exist, create a new ClientAdmin with this data.
     */
    create: XOR<ClientAdminCreateInput, ClientAdminUncheckedCreateInput>
    /**
     * In case the ClientAdmin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientAdminUpdateInput, ClientAdminUncheckedUpdateInput>
  }

  /**
   * ClientAdmin delete
   */
  export type ClientAdminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientAdmin
     */
    select?: ClientAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientAdmin
     */
    omit?: ClientAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientAdminInclude<ExtArgs> | null
    /**
     * Filter which ClientAdmin to delete.
     */
    where: ClientAdminWhereUniqueInput
  }

  /**
   * ClientAdmin deleteMany
   */
  export type ClientAdminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientAdmins to delete
     */
    where?: ClientAdminWhereInput
    /**
     * Limit how many ClientAdmins to delete.
     */
    limit?: number
  }

  /**
   * ClientAdmin.roleUsers
   */
  export type ClientAdmin$roleUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleUser
     */
    select?: RoleUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleUser
     */
    omit?: RoleUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleUserInclude<ExtArgs> | null
    where?: RoleUserWhereInput
    orderBy?: RoleUserOrderByWithRelationInput | RoleUserOrderByWithRelationInput[]
    cursor?: RoleUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoleUserScalarFieldEnum | RoleUserScalarFieldEnum[]
  }

  /**
   * ClientAdmin.faculties
   */
  export type ClientAdmin$facultiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faculty
     */
    omit?: FacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyInclude<ExtArgs> | null
    where?: FacultyWhereInput
    orderBy?: FacultyOrderByWithRelationInput | FacultyOrderByWithRelationInput[]
    cursor?: FacultyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FacultyScalarFieldEnum | FacultyScalarFieldEnum[]
  }

  /**
   * ClientAdmin.batches
   */
  export type ClientAdmin$batchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    where?: BatchWhereInput
    orderBy?: BatchOrderByWithRelationInput | BatchOrderByWithRelationInput[]
    cursor?: BatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BatchScalarFieldEnum | BatchScalarFieldEnum[]
  }

  /**
   * ClientAdmin.courses
   */
  export type ClientAdmin$coursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    where?: CourseWhereInput
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    cursor?: CourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * ClientAdmin.enquiryCourse
   */
  export type ClientAdmin$enquiryCourseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnquiryCourse
     */
    select?: EnquiryCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnquiryCourse
     */
    omit?: EnquiryCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnquiryCourseInclude<ExtArgs> | null
    where?: EnquiryCourseWhereInput
    orderBy?: EnquiryCourseOrderByWithRelationInput | EnquiryCourseOrderByWithRelationInput[]
    cursor?: EnquiryCourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EnquiryCourseScalarFieldEnum | EnquiryCourseScalarFieldEnum[]
  }

  /**
   * ClientAdmin.labs
   */
  export type ClientAdmin$labsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lab
     */
    select?: LabSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lab
     */
    omit?: LabOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabInclude<ExtArgs> | null
    where?: LabWhereInput
    orderBy?: LabOrderByWithRelationInput | LabOrderByWithRelationInput[]
    cursor?: LabWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LabScalarFieldEnum | LabScalarFieldEnum[]
  }

  /**
   * ClientAdmin.labTimeSlots
   */
  export type ClientAdmin$labTimeSlotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabTimeSlot
     */
    select?: LabTimeSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabTimeSlot
     */
    omit?: LabTimeSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabTimeSlotInclude<ExtArgs> | null
    where?: LabTimeSlotWhereInput
    orderBy?: LabTimeSlotOrderByWithRelationInput | LabTimeSlotOrderByWithRelationInput[]
    cursor?: LabTimeSlotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LabTimeSlotScalarFieldEnum | LabTimeSlotScalarFieldEnum[]
  }

  /**
   * ClientAdmin.labAllocations
   */
  export type ClientAdmin$labAllocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabAllocation
     */
    select?: LabAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabAllocation
     */
    omit?: LabAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabAllocationInclude<ExtArgs> | null
    where?: LabAllocationWhereInput
    orderBy?: LabAllocationOrderByWithRelationInput | LabAllocationOrderByWithRelationInput[]
    cursor?: LabAllocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LabAllocationScalarFieldEnum | LabAllocationScalarFieldEnum[]
  }

  /**
   * ClientAdmin.students
   */
  export type ClientAdmin$studentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    cursor?: StudentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * ClientAdmin.activities
   */
  export type ClientAdmin$activitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    where?: ActivityLogWhereInput
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    cursor?: ActivityLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ClientAdmin.studentCourses
   */
  export type ClientAdmin$studentCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentCourse
     */
    select?: StudentCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentCourse
     */
    omit?: StudentCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentCourseInclude<ExtArgs> | null
    where?: StudentCourseWhereInput
    orderBy?: StudentCourseOrderByWithRelationInput | StudentCourseOrderByWithRelationInput[]
    cursor?: StudentCourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentCourseScalarFieldEnum | StudentCourseScalarFieldEnum[]
  }

  /**
   * ClientAdmin.feeStructures
   */
  export type ClientAdmin$feeStructuresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeStructure
     */
    select?: FeeStructureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeStructure
     */
    omit?: FeeStructureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeStructureInclude<ExtArgs> | null
    where?: FeeStructureWhereInput
    orderBy?: FeeStructureOrderByWithRelationInput | FeeStructureOrderByWithRelationInput[]
    cursor?: FeeStructureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeeStructureScalarFieldEnum | FeeStructureScalarFieldEnum[]
  }

  /**
   * ClientAdmin.studentFees
   */
  export type ClientAdmin$studentFeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentFee
     */
    select?: StudentFeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentFee
     */
    omit?: StudentFeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentFeeInclude<ExtArgs> | null
    where?: StudentFeeWhereInput
    orderBy?: StudentFeeOrderByWithRelationInput | StudentFeeOrderByWithRelationInput[]
    cursor?: StudentFeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentFeeScalarFieldEnum | StudentFeeScalarFieldEnum[]
  }

  /**
   * ClientAdmin.stationeryIssues
   */
  export type ClientAdmin$stationeryIssuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StationeryIssue
     */
    select?: StationeryIssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StationeryIssue
     */
    omit?: StationeryIssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StationeryIssueInclude<ExtArgs> | null
    where?: StationeryIssueWhereInput
    orderBy?: StationeryIssueOrderByWithRelationInput | StationeryIssueOrderByWithRelationInput[]
    cursor?: StationeryIssueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StationeryIssueScalarFieldEnum | StationeryIssueScalarFieldEnum[]
  }

  /**
   * ClientAdmin.attendanceRecords
   */
  export type ClientAdmin$attendanceRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceRecord
     */
    omit?: AttendanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    where?: AttendanceRecordWhereInput
    orderBy?: AttendanceRecordOrderByWithRelationInput | AttendanceRecordOrderByWithRelationInput[]
    cursor?: AttendanceRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceRecordScalarFieldEnum | AttendanceRecordScalarFieldEnum[]
  }

  /**
   * ClientAdmin.studentTasks
   */
  export type ClientAdmin$studentTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTask
     */
    select?: StudentTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentTask
     */
    omit?: StudentTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTaskInclude<ExtArgs> | null
    where?: StudentTaskWhereInput
    orderBy?: StudentTaskOrderByWithRelationInput | StudentTaskOrderByWithRelationInput[]
    cursor?: StudentTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentTaskScalarFieldEnum | StudentTaskScalarFieldEnum[]
  }

  /**
   * ClientAdmin.studentTests
   */
  export type ClientAdmin$studentTestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTest
     */
    select?: StudentTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentTest
     */
    omit?: StudentTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTestInclude<ExtArgs> | null
    where?: StudentTestWhereInput
    orderBy?: StudentTestOrderByWithRelationInput | StudentTestOrderByWithRelationInput[]
    cursor?: StudentTestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentTestScalarFieldEnum | StudentTestScalarFieldEnum[]
  }

  /**
   * ClientAdmin.courseCompletions
   */
  export type ClientAdmin$courseCompletionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseCompletion
     */
    select?: CourseCompletionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseCompletion
     */
    omit?: CourseCompletionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseCompletionInclude<ExtArgs> | null
    where?: CourseCompletionWhereInput
    orderBy?: CourseCompletionOrderByWithRelationInput | CourseCompletionOrderByWithRelationInput[]
    cursor?: CourseCompletionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseCompletionScalarFieldEnum | CourseCompletionScalarFieldEnum[]
  }

  /**
   * ClientAdmin.certificates
   */
  export type ClientAdmin$certificatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    where?: CertificateWhereInput
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    cursor?: CertificateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CertificateScalarFieldEnum | CertificateScalarFieldEnum[]
  }

  /**
   * ClientAdmin.financialRecords
   */
  export type ClientAdmin$financialRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialRecord
     */
    select?: FinancialRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialRecord
     */
    omit?: FinancialRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialRecordInclude<ExtArgs> | null
    where?: FinancialRecordWhereInput
    orderBy?: FinancialRecordOrderByWithRelationInput | FinancialRecordOrderByWithRelationInput[]
    cursor?: FinancialRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FinancialRecordScalarFieldEnum | FinancialRecordScalarFieldEnum[]
  }

  /**
   * ClientAdmin.enquiries
   */
  export type ClientAdmin$enquiriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enquiry
     */
    select?: EnquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enquiry
     */
    omit?: EnquiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnquiryInclude<ExtArgs> | null
    where?: EnquiryWhereInput
    orderBy?: EnquiryOrderByWithRelationInput | EnquiryOrderByWithRelationInput[]
    cursor?: EnquiryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EnquiryScalarFieldEnum | EnquiryScalarFieldEnum[]
  }

  /**
   * ClientAdmin.notifications
   */
  export type ClientAdmin$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * ClientAdmin.courseFeeStructures
   */
  export type ClientAdmin$courseFeeStructuresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseFeeStructure
     */
    select?: CourseFeeStructureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseFeeStructure
     */
    omit?: CourseFeeStructureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseFeeStructureInclude<ExtArgs> | null
    where?: CourseFeeStructureWhereInput
    orderBy?: CourseFeeStructureOrderByWithRelationInput | CourseFeeStructureOrderByWithRelationInput[]
    cursor?: CourseFeeStructureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseFeeStructureScalarFieldEnum | CourseFeeStructureScalarFieldEnum[]
  }

  /**
   * ClientAdmin without action
   */
  export type ClientAdminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientAdmin
     */
    select?: ClientAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientAdmin
     */
    omit?: ClientAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientAdminInclude<ExtArgs> | null
  }


  /**
   * Model RoleUser
   */

  export type AggregateRoleUser = {
    _count: RoleUserCountAggregateOutputType | null
    _min: RoleUserMinAggregateOutputType | null
    _max: RoleUserMaxAggregateOutputType | null
  }

  export type RoleUserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    password: string | null
    role: $Enums.UserRole | null
    createdAt: Date | null
    country: string | null
    state: string | null
    city: string | null
    zipCode: string | null
    currentSessionToken: string | null
    lastLoginAt: Date | null
    clientAdminId: string | null
  }

  export type RoleUserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    password: string | null
    role: $Enums.UserRole | null
    createdAt: Date | null
    country: string | null
    state: string | null
    city: string | null
    zipCode: string | null
    currentSessionToken: string | null
    lastLoginAt: Date | null
    clientAdminId: string | null
  }

  export type RoleUserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    password: number
    role: number
    createdAt: number
    country: number
    state: number
    city: number
    zipCode: number
    currentSessionToken: number
    lastLoginAt: number
    clientAdminId: number
    _all: number
  }


  export type RoleUserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    role?: true
    createdAt?: true
    country?: true
    state?: true
    city?: true
    zipCode?: true
    currentSessionToken?: true
    lastLoginAt?: true
    clientAdminId?: true
  }

  export type RoleUserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    role?: true
    createdAt?: true
    country?: true
    state?: true
    city?: true
    zipCode?: true
    currentSessionToken?: true
    lastLoginAt?: true
    clientAdminId?: true
  }

  export type RoleUserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    role?: true
    createdAt?: true
    country?: true
    state?: true
    city?: true
    zipCode?: true
    currentSessionToken?: true
    lastLoginAt?: true
    clientAdminId?: true
    _all?: true
  }

  export type RoleUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoleUser to aggregate.
     */
    where?: RoleUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoleUsers to fetch.
     */
    orderBy?: RoleUserOrderByWithRelationInput | RoleUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoleUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoleUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RoleUsers
    **/
    _count?: true | RoleUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleUserMaxAggregateInputType
  }

  export type GetRoleUserAggregateType<T extends RoleUserAggregateArgs> = {
        [P in keyof T & keyof AggregateRoleUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoleUser[P]>
      : GetScalarType<T[P], AggregateRoleUser[P]>
  }




  export type RoleUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleUserWhereInput
    orderBy?: RoleUserOrderByWithAggregationInput | RoleUserOrderByWithAggregationInput[]
    by: RoleUserScalarFieldEnum[] | RoleUserScalarFieldEnum
    having?: RoleUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleUserCountAggregateInputType | true
    _min?: RoleUserMinAggregateInputType
    _max?: RoleUserMaxAggregateInputType
  }

  export type RoleUserGroupByOutputType = {
    id: string
    name: string
    email: string
    password: string
    role: $Enums.UserRole
    createdAt: Date
    country: string
    state: string
    city: string
    zipCode: string
    currentSessionToken: string | null
    lastLoginAt: Date | null
    clientAdminId: string
    _count: RoleUserCountAggregateOutputType | null
    _min: RoleUserMinAggregateOutputType | null
    _max: RoleUserMaxAggregateOutputType | null
  }

  type GetRoleUserGroupByPayload<T extends RoleUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleUserGroupByOutputType[P]>
            : GetScalarType<T[P], RoleUserGroupByOutputType[P]>
        }
      >
    >


  export type RoleUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    createdAt?: boolean
    country?: boolean
    state?: boolean
    city?: boolean
    zipCode?: boolean
    currentSessionToken?: boolean
    lastLoginAt?: boolean
    clientAdminId?: boolean
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roleUser"]>

  export type RoleUserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    createdAt?: boolean
    country?: boolean
    state?: boolean
    city?: boolean
    zipCode?: boolean
    currentSessionToken?: boolean
    lastLoginAt?: boolean
    clientAdminId?: boolean
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roleUser"]>

  export type RoleUserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    createdAt?: boolean
    country?: boolean
    state?: boolean
    city?: boolean
    zipCode?: boolean
    currentSessionToken?: boolean
    lastLoginAt?: boolean
    clientAdminId?: boolean
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roleUser"]>

  export type RoleUserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    createdAt?: boolean
    country?: boolean
    state?: boolean
    city?: boolean
    zipCode?: boolean
    currentSessionToken?: boolean
    lastLoginAt?: boolean
    clientAdminId?: boolean
  }

  export type RoleUserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "password" | "role" | "createdAt" | "country" | "state" | "city" | "zipCode" | "currentSessionToken" | "lastLoginAt" | "clientAdminId", ExtArgs["result"]["roleUser"]>
  export type RoleUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }
  export type RoleUserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }
  export type RoleUserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }

  export type $RoleUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RoleUser"
    objects: {
      clientAdmin: Prisma.$ClientAdminPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      password: string
      role: $Enums.UserRole
      createdAt: Date
      country: string
      state: string
      city: string
      zipCode: string
      currentSessionToken: string | null
      lastLoginAt: Date | null
      clientAdminId: string
    }, ExtArgs["result"]["roleUser"]>
    composites: {}
  }

  type RoleUserGetPayload<S extends boolean | null | undefined | RoleUserDefaultArgs> = $Result.GetResult<Prisma.$RoleUserPayload, S>

  type RoleUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoleUserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoleUserCountAggregateInputType | true
    }

  export interface RoleUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RoleUser'], meta: { name: 'RoleUser' } }
    /**
     * Find zero or one RoleUser that matches the filter.
     * @param {RoleUserFindUniqueArgs} args - Arguments to find a RoleUser
     * @example
     * // Get one RoleUser
     * const roleUser = await prisma.roleUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleUserFindUniqueArgs>(args: SelectSubset<T, RoleUserFindUniqueArgs<ExtArgs>>): Prisma__RoleUserClient<$Result.GetResult<Prisma.$RoleUserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RoleUser that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoleUserFindUniqueOrThrowArgs} args - Arguments to find a RoleUser
     * @example
     * // Get one RoleUser
     * const roleUser = await prisma.roleUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleUserFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleUserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleUserClient<$Result.GetResult<Prisma.$RoleUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RoleUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUserFindFirstArgs} args - Arguments to find a RoleUser
     * @example
     * // Get one RoleUser
     * const roleUser = await prisma.roleUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleUserFindFirstArgs>(args?: SelectSubset<T, RoleUserFindFirstArgs<ExtArgs>>): Prisma__RoleUserClient<$Result.GetResult<Prisma.$RoleUserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RoleUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUserFindFirstOrThrowArgs} args - Arguments to find a RoleUser
     * @example
     * // Get one RoleUser
     * const roleUser = await prisma.roleUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleUserFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleUserFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleUserClient<$Result.GetResult<Prisma.$RoleUserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RoleUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RoleUsers
     * const roleUsers = await prisma.roleUser.findMany()
     * 
     * // Get first 10 RoleUsers
     * const roleUsers = await prisma.roleUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleUserWithIdOnly = await prisma.roleUser.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoleUserFindManyArgs>(args?: SelectSubset<T, RoleUserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoleUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RoleUser.
     * @param {RoleUserCreateArgs} args - Arguments to create a RoleUser.
     * @example
     * // Create one RoleUser
     * const RoleUser = await prisma.roleUser.create({
     *   data: {
     *     // ... data to create a RoleUser
     *   }
     * })
     * 
     */
    create<T extends RoleUserCreateArgs>(args: SelectSubset<T, RoleUserCreateArgs<ExtArgs>>): Prisma__RoleUserClient<$Result.GetResult<Prisma.$RoleUserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RoleUsers.
     * @param {RoleUserCreateManyArgs} args - Arguments to create many RoleUsers.
     * @example
     * // Create many RoleUsers
     * const roleUser = await prisma.roleUser.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleUserCreateManyArgs>(args?: SelectSubset<T, RoleUserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RoleUsers and returns the data saved in the database.
     * @param {RoleUserCreateManyAndReturnArgs} args - Arguments to create many RoleUsers.
     * @example
     * // Create many RoleUsers
     * const roleUser = await prisma.roleUser.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RoleUsers and only return the `id`
     * const roleUserWithIdOnly = await prisma.roleUser.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoleUserCreateManyAndReturnArgs>(args?: SelectSubset<T, RoleUserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoleUserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RoleUser.
     * @param {RoleUserDeleteArgs} args - Arguments to delete one RoleUser.
     * @example
     * // Delete one RoleUser
     * const RoleUser = await prisma.roleUser.delete({
     *   where: {
     *     // ... filter to delete one RoleUser
     *   }
     * })
     * 
     */
    delete<T extends RoleUserDeleteArgs>(args: SelectSubset<T, RoleUserDeleteArgs<ExtArgs>>): Prisma__RoleUserClient<$Result.GetResult<Prisma.$RoleUserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RoleUser.
     * @param {RoleUserUpdateArgs} args - Arguments to update one RoleUser.
     * @example
     * // Update one RoleUser
     * const roleUser = await prisma.roleUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleUserUpdateArgs>(args: SelectSubset<T, RoleUserUpdateArgs<ExtArgs>>): Prisma__RoleUserClient<$Result.GetResult<Prisma.$RoleUserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RoleUsers.
     * @param {RoleUserDeleteManyArgs} args - Arguments to filter RoleUsers to delete.
     * @example
     * // Delete a few RoleUsers
     * const { count } = await prisma.roleUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleUserDeleteManyArgs>(args?: SelectSubset<T, RoleUserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoleUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RoleUsers
     * const roleUser = await prisma.roleUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleUserUpdateManyArgs>(args: SelectSubset<T, RoleUserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoleUsers and returns the data updated in the database.
     * @param {RoleUserUpdateManyAndReturnArgs} args - Arguments to update many RoleUsers.
     * @example
     * // Update many RoleUsers
     * const roleUser = await prisma.roleUser.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RoleUsers and only return the `id`
     * const roleUserWithIdOnly = await prisma.roleUser.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RoleUserUpdateManyAndReturnArgs>(args: SelectSubset<T, RoleUserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoleUserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RoleUser.
     * @param {RoleUserUpsertArgs} args - Arguments to update or create a RoleUser.
     * @example
     * // Update or create a RoleUser
     * const roleUser = await prisma.roleUser.upsert({
     *   create: {
     *     // ... data to create a RoleUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RoleUser we want to update
     *   }
     * })
     */
    upsert<T extends RoleUserUpsertArgs>(args: SelectSubset<T, RoleUserUpsertArgs<ExtArgs>>): Prisma__RoleUserClient<$Result.GetResult<Prisma.$RoleUserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RoleUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUserCountArgs} args - Arguments to filter RoleUsers to count.
     * @example
     * // Count the number of RoleUsers
     * const count = await prisma.roleUser.count({
     *   where: {
     *     // ... the filter for the RoleUsers we want to count
     *   }
     * })
    **/
    count<T extends RoleUserCountArgs>(
      args?: Subset<T, RoleUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RoleUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleUserAggregateArgs>(args: Subset<T, RoleUserAggregateArgs>): Prisma.PrismaPromise<GetRoleUserAggregateType<T>>

    /**
     * Group by RoleUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleUserGroupByArgs['orderBy'] }
        : { orderBy?: RoleUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RoleUser model
   */
  readonly fields: RoleUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RoleUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clientAdmin<T extends ClientAdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientAdminDefaultArgs<ExtArgs>>): Prisma__ClientAdminClient<$Result.GetResult<Prisma.$ClientAdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RoleUser model
   */
  interface RoleUserFieldRefs {
    readonly id: FieldRef<"RoleUser", 'String'>
    readonly name: FieldRef<"RoleUser", 'String'>
    readonly email: FieldRef<"RoleUser", 'String'>
    readonly password: FieldRef<"RoleUser", 'String'>
    readonly role: FieldRef<"RoleUser", 'UserRole'>
    readonly createdAt: FieldRef<"RoleUser", 'DateTime'>
    readonly country: FieldRef<"RoleUser", 'String'>
    readonly state: FieldRef<"RoleUser", 'String'>
    readonly city: FieldRef<"RoleUser", 'String'>
    readonly zipCode: FieldRef<"RoleUser", 'String'>
    readonly currentSessionToken: FieldRef<"RoleUser", 'String'>
    readonly lastLoginAt: FieldRef<"RoleUser", 'DateTime'>
    readonly clientAdminId: FieldRef<"RoleUser", 'String'>
  }
    

  // Custom InputTypes
  /**
   * RoleUser findUnique
   */
  export type RoleUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleUser
     */
    select?: RoleUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleUser
     */
    omit?: RoleUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleUserInclude<ExtArgs> | null
    /**
     * Filter, which RoleUser to fetch.
     */
    where: RoleUserWhereUniqueInput
  }

  /**
   * RoleUser findUniqueOrThrow
   */
  export type RoleUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleUser
     */
    select?: RoleUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleUser
     */
    omit?: RoleUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleUserInclude<ExtArgs> | null
    /**
     * Filter, which RoleUser to fetch.
     */
    where: RoleUserWhereUniqueInput
  }

  /**
   * RoleUser findFirst
   */
  export type RoleUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleUser
     */
    select?: RoleUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleUser
     */
    omit?: RoleUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleUserInclude<ExtArgs> | null
    /**
     * Filter, which RoleUser to fetch.
     */
    where?: RoleUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoleUsers to fetch.
     */
    orderBy?: RoleUserOrderByWithRelationInput | RoleUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoleUsers.
     */
    cursor?: RoleUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoleUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoleUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoleUsers.
     */
    distinct?: RoleUserScalarFieldEnum | RoleUserScalarFieldEnum[]
  }

  /**
   * RoleUser findFirstOrThrow
   */
  export type RoleUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleUser
     */
    select?: RoleUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleUser
     */
    omit?: RoleUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleUserInclude<ExtArgs> | null
    /**
     * Filter, which RoleUser to fetch.
     */
    where?: RoleUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoleUsers to fetch.
     */
    orderBy?: RoleUserOrderByWithRelationInput | RoleUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoleUsers.
     */
    cursor?: RoleUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoleUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoleUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoleUsers.
     */
    distinct?: RoleUserScalarFieldEnum | RoleUserScalarFieldEnum[]
  }

  /**
   * RoleUser findMany
   */
  export type RoleUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleUser
     */
    select?: RoleUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleUser
     */
    omit?: RoleUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleUserInclude<ExtArgs> | null
    /**
     * Filter, which RoleUsers to fetch.
     */
    where?: RoleUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoleUsers to fetch.
     */
    orderBy?: RoleUserOrderByWithRelationInput | RoleUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RoleUsers.
     */
    cursor?: RoleUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoleUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoleUsers.
     */
    skip?: number
    distinct?: RoleUserScalarFieldEnum | RoleUserScalarFieldEnum[]
  }

  /**
   * RoleUser create
   */
  export type RoleUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleUser
     */
    select?: RoleUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleUser
     */
    omit?: RoleUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleUserInclude<ExtArgs> | null
    /**
     * The data needed to create a RoleUser.
     */
    data: XOR<RoleUserCreateInput, RoleUserUncheckedCreateInput>
  }

  /**
   * RoleUser createMany
   */
  export type RoleUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RoleUsers.
     */
    data: RoleUserCreateManyInput | RoleUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RoleUser createManyAndReturn
   */
  export type RoleUserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleUser
     */
    select?: RoleUserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RoleUser
     */
    omit?: RoleUserOmit<ExtArgs> | null
    /**
     * The data used to create many RoleUsers.
     */
    data: RoleUserCreateManyInput | RoleUserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleUserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RoleUser update
   */
  export type RoleUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleUser
     */
    select?: RoleUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleUser
     */
    omit?: RoleUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleUserInclude<ExtArgs> | null
    /**
     * The data needed to update a RoleUser.
     */
    data: XOR<RoleUserUpdateInput, RoleUserUncheckedUpdateInput>
    /**
     * Choose, which RoleUser to update.
     */
    where: RoleUserWhereUniqueInput
  }

  /**
   * RoleUser updateMany
   */
  export type RoleUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RoleUsers.
     */
    data: XOR<RoleUserUpdateManyMutationInput, RoleUserUncheckedUpdateManyInput>
    /**
     * Filter which RoleUsers to update
     */
    where?: RoleUserWhereInput
    /**
     * Limit how many RoleUsers to update.
     */
    limit?: number
  }

  /**
   * RoleUser updateManyAndReturn
   */
  export type RoleUserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleUser
     */
    select?: RoleUserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RoleUser
     */
    omit?: RoleUserOmit<ExtArgs> | null
    /**
     * The data used to update RoleUsers.
     */
    data: XOR<RoleUserUpdateManyMutationInput, RoleUserUncheckedUpdateManyInput>
    /**
     * Filter which RoleUsers to update
     */
    where?: RoleUserWhereInput
    /**
     * Limit how many RoleUsers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleUserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RoleUser upsert
   */
  export type RoleUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleUser
     */
    select?: RoleUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleUser
     */
    omit?: RoleUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleUserInclude<ExtArgs> | null
    /**
     * The filter to search for the RoleUser to update in case it exists.
     */
    where: RoleUserWhereUniqueInput
    /**
     * In case the RoleUser found by the `where` argument doesn't exist, create a new RoleUser with this data.
     */
    create: XOR<RoleUserCreateInput, RoleUserUncheckedCreateInput>
    /**
     * In case the RoleUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUserUpdateInput, RoleUserUncheckedUpdateInput>
  }

  /**
   * RoleUser delete
   */
  export type RoleUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleUser
     */
    select?: RoleUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleUser
     */
    omit?: RoleUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleUserInclude<ExtArgs> | null
    /**
     * Filter which RoleUser to delete.
     */
    where: RoleUserWhereUniqueInput
  }

  /**
   * RoleUser deleteMany
   */
  export type RoleUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoleUsers to delete
     */
    where?: RoleUserWhereInput
    /**
     * Limit how many RoleUsers to delete.
     */
    limit?: number
  }

  /**
   * RoleUser without action
   */
  export type RoleUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleUser
     */
    select?: RoleUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoleUser
     */
    omit?: RoleUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleUserInclude<ExtArgs> | null
  }


  /**
   * Model ActivityLog
   */

  export type AggregateActivityLog = {
    _count: ActivityLogCountAggregateOutputType | null
    _min: ActivityLogMinAggregateOutputType | null
    _max: ActivityLogMaxAggregateOutputType | null
  }

  export type ActivityLogMinAggregateOutputType = {
    id: string | null
    entity: string | null
    entityId: string | null
    action: string | null
    message: string | null
    createdAt: Date | null
    clientAdminId: string | null
  }

  export type ActivityLogMaxAggregateOutputType = {
    id: string | null
    entity: string | null
    entityId: string | null
    action: string | null
    message: string | null
    createdAt: Date | null
    clientAdminId: string | null
  }

  export type ActivityLogCountAggregateOutputType = {
    id: number
    entity: number
    entityId: number
    action: number
    message: number
    createdAt: number
    clientAdminId: number
    _all: number
  }


  export type ActivityLogMinAggregateInputType = {
    id?: true
    entity?: true
    entityId?: true
    action?: true
    message?: true
    createdAt?: true
    clientAdminId?: true
  }

  export type ActivityLogMaxAggregateInputType = {
    id?: true
    entity?: true
    entityId?: true
    action?: true
    message?: true
    createdAt?: true
    clientAdminId?: true
  }

  export type ActivityLogCountAggregateInputType = {
    id?: true
    entity?: true
    entityId?: true
    action?: true
    message?: true
    createdAt?: true
    clientAdminId?: true
    _all?: true
  }

  export type ActivityLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityLog to aggregate.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ActivityLogs
    **/
    _count?: true | ActivityLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityLogMaxAggregateInputType
  }

  export type GetActivityLogAggregateType<T extends ActivityLogAggregateArgs> = {
        [P in keyof T & keyof AggregateActivityLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivityLog[P]>
      : GetScalarType<T[P], AggregateActivityLog[P]>
  }




  export type ActivityLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityLogWhereInput
    orderBy?: ActivityLogOrderByWithAggregationInput | ActivityLogOrderByWithAggregationInput[]
    by: ActivityLogScalarFieldEnum[] | ActivityLogScalarFieldEnum
    having?: ActivityLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityLogCountAggregateInputType | true
    _min?: ActivityLogMinAggregateInputType
    _max?: ActivityLogMaxAggregateInputType
  }

  export type ActivityLogGroupByOutputType = {
    id: string
    entity: string
    entityId: string
    action: string
    message: string | null
    createdAt: Date
    clientAdminId: string
    _count: ActivityLogCountAggregateOutputType | null
    _min: ActivityLogMinAggregateOutputType | null
    _max: ActivityLogMaxAggregateOutputType | null
  }

  type GetActivityLogGroupByPayload<T extends ActivityLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivityLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityLogGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityLogGroupByOutputType[P]>
        }
      >
    >


  export type ActivityLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entity?: boolean
    entityId?: boolean
    action?: boolean
    message?: boolean
    createdAt?: boolean
    clientAdminId?: boolean
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activityLog"]>

  export type ActivityLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entity?: boolean
    entityId?: boolean
    action?: boolean
    message?: boolean
    createdAt?: boolean
    clientAdminId?: boolean
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activityLog"]>

  export type ActivityLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entity?: boolean
    entityId?: boolean
    action?: boolean
    message?: boolean
    createdAt?: boolean
    clientAdminId?: boolean
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activityLog"]>

  export type ActivityLogSelectScalar = {
    id?: boolean
    entity?: boolean
    entityId?: boolean
    action?: boolean
    message?: boolean
    createdAt?: boolean
    clientAdminId?: boolean
  }

  export type ActivityLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "entity" | "entityId" | "action" | "message" | "createdAt" | "clientAdminId", ExtArgs["result"]["activityLog"]>
  export type ActivityLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }
  export type ActivityLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }
  export type ActivityLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }

  export type $ActivityLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ActivityLog"
    objects: {
      clientAdmin: Prisma.$ClientAdminPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      entity: string
      entityId: string
      action: string
      message: string | null
      createdAt: Date
      clientAdminId: string
    }, ExtArgs["result"]["activityLog"]>
    composites: {}
  }

  type ActivityLogGetPayload<S extends boolean | null | undefined | ActivityLogDefaultArgs> = $Result.GetResult<Prisma.$ActivityLogPayload, S>

  type ActivityLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ActivityLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ActivityLogCountAggregateInputType | true
    }

  export interface ActivityLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ActivityLog'], meta: { name: 'ActivityLog' } }
    /**
     * Find zero or one ActivityLog that matches the filter.
     * @param {ActivityLogFindUniqueArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActivityLogFindUniqueArgs>(args: SelectSubset<T, ActivityLogFindUniqueArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ActivityLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ActivityLogFindUniqueOrThrowArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActivityLogFindUniqueOrThrowArgs>(args: SelectSubset<T, ActivityLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ActivityLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindFirstArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActivityLogFindFirstArgs>(args?: SelectSubset<T, ActivityLogFindFirstArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ActivityLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindFirstOrThrowArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActivityLogFindFirstOrThrowArgs>(args?: SelectSubset<T, ActivityLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ActivityLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ActivityLogs
     * const activityLogs = await prisma.activityLog.findMany()
     * 
     * // Get first 10 ActivityLogs
     * const activityLogs = await prisma.activityLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activityLogWithIdOnly = await prisma.activityLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActivityLogFindManyArgs>(args?: SelectSubset<T, ActivityLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ActivityLog.
     * @param {ActivityLogCreateArgs} args - Arguments to create a ActivityLog.
     * @example
     * // Create one ActivityLog
     * const ActivityLog = await prisma.activityLog.create({
     *   data: {
     *     // ... data to create a ActivityLog
     *   }
     * })
     * 
     */
    create<T extends ActivityLogCreateArgs>(args: SelectSubset<T, ActivityLogCreateArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ActivityLogs.
     * @param {ActivityLogCreateManyArgs} args - Arguments to create many ActivityLogs.
     * @example
     * // Create many ActivityLogs
     * const activityLog = await prisma.activityLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActivityLogCreateManyArgs>(args?: SelectSubset<T, ActivityLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ActivityLogs and returns the data saved in the database.
     * @param {ActivityLogCreateManyAndReturnArgs} args - Arguments to create many ActivityLogs.
     * @example
     * // Create many ActivityLogs
     * const activityLog = await prisma.activityLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ActivityLogs and only return the `id`
     * const activityLogWithIdOnly = await prisma.activityLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActivityLogCreateManyAndReturnArgs>(args?: SelectSubset<T, ActivityLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ActivityLog.
     * @param {ActivityLogDeleteArgs} args - Arguments to delete one ActivityLog.
     * @example
     * // Delete one ActivityLog
     * const ActivityLog = await prisma.activityLog.delete({
     *   where: {
     *     // ... filter to delete one ActivityLog
     *   }
     * })
     * 
     */
    delete<T extends ActivityLogDeleteArgs>(args: SelectSubset<T, ActivityLogDeleteArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ActivityLog.
     * @param {ActivityLogUpdateArgs} args - Arguments to update one ActivityLog.
     * @example
     * // Update one ActivityLog
     * const activityLog = await prisma.activityLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActivityLogUpdateArgs>(args: SelectSubset<T, ActivityLogUpdateArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ActivityLogs.
     * @param {ActivityLogDeleteManyArgs} args - Arguments to filter ActivityLogs to delete.
     * @example
     * // Delete a few ActivityLogs
     * const { count } = await prisma.activityLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActivityLogDeleteManyArgs>(args?: SelectSubset<T, ActivityLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ActivityLogs
     * const activityLog = await prisma.activityLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActivityLogUpdateManyArgs>(args: SelectSubset<T, ActivityLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityLogs and returns the data updated in the database.
     * @param {ActivityLogUpdateManyAndReturnArgs} args - Arguments to update many ActivityLogs.
     * @example
     * // Update many ActivityLogs
     * const activityLog = await prisma.activityLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ActivityLogs and only return the `id`
     * const activityLogWithIdOnly = await prisma.activityLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ActivityLogUpdateManyAndReturnArgs>(args: SelectSubset<T, ActivityLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ActivityLog.
     * @param {ActivityLogUpsertArgs} args - Arguments to update or create a ActivityLog.
     * @example
     * // Update or create a ActivityLog
     * const activityLog = await prisma.activityLog.upsert({
     *   create: {
     *     // ... data to create a ActivityLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ActivityLog we want to update
     *   }
     * })
     */
    upsert<T extends ActivityLogUpsertArgs>(args: SelectSubset<T, ActivityLogUpsertArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogCountArgs} args - Arguments to filter ActivityLogs to count.
     * @example
     * // Count the number of ActivityLogs
     * const count = await prisma.activityLog.count({
     *   where: {
     *     // ... the filter for the ActivityLogs we want to count
     *   }
     * })
    **/
    count<T extends ActivityLogCountArgs>(
      args?: Subset<T, ActivityLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityLogAggregateArgs>(args: Subset<T, ActivityLogAggregateArgs>): Prisma.PrismaPromise<GetActivityLogAggregateType<T>>

    /**
     * Group by ActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivityLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityLogGroupByArgs['orderBy'] }
        : { orderBy?: ActivityLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivityLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ActivityLog model
   */
  readonly fields: ActivityLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ActivityLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActivityLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clientAdmin<T extends ClientAdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientAdminDefaultArgs<ExtArgs>>): Prisma__ClientAdminClient<$Result.GetResult<Prisma.$ClientAdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ActivityLog model
   */
  interface ActivityLogFieldRefs {
    readonly id: FieldRef<"ActivityLog", 'String'>
    readonly entity: FieldRef<"ActivityLog", 'String'>
    readonly entityId: FieldRef<"ActivityLog", 'String'>
    readonly action: FieldRef<"ActivityLog", 'String'>
    readonly message: FieldRef<"ActivityLog", 'String'>
    readonly createdAt: FieldRef<"ActivityLog", 'DateTime'>
    readonly clientAdminId: FieldRef<"ActivityLog", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ActivityLog findUnique
   */
  export type ActivityLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog findUniqueOrThrow
   */
  export type ActivityLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog findFirst
   */
  export type ActivityLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityLogs.
     */
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog findFirstOrThrow
   */
  export type ActivityLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityLogs.
     */
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog findMany
   */
  export type ActivityLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLogs to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog create
   */
  export type ActivityLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * The data needed to create a ActivityLog.
     */
    data: XOR<ActivityLogCreateInput, ActivityLogUncheckedCreateInput>
  }

  /**
   * ActivityLog createMany
   */
  export type ActivityLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ActivityLogs.
     */
    data: ActivityLogCreateManyInput | ActivityLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ActivityLog createManyAndReturn
   */
  export type ActivityLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * The data used to create many ActivityLogs.
     */
    data: ActivityLogCreateManyInput | ActivityLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActivityLog update
   */
  export type ActivityLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * The data needed to update a ActivityLog.
     */
    data: XOR<ActivityLogUpdateInput, ActivityLogUncheckedUpdateInput>
    /**
     * Choose, which ActivityLog to update.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog updateMany
   */
  export type ActivityLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ActivityLogs.
     */
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyInput>
    /**
     * Filter which ActivityLogs to update
     */
    where?: ActivityLogWhereInput
    /**
     * Limit how many ActivityLogs to update.
     */
    limit?: number
  }

  /**
   * ActivityLog updateManyAndReturn
   */
  export type ActivityLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * The data used to update ActivityLogs.
     */
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyInput>
    /**
     * Filter which ActivityLogs to update
     */
    where?: ActivityLogWhereInput
    /**
     * Limit how many ActivityLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActivityLog upsert
   */
  export type ActivityLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * The filter to search for the ActivityLog to update in case it exists.
     */
    where: ActivityLogWhereUniqueInput
    /**
     * In case the ActivityLog found by the `where` argument doesn't exist, create a new ActivityLog with this data.
     */
    create: XOR<ActivityLogCreateInput, ActivityLogUncheckedCreateInput>
    /**
     * In case the ActivityLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActivityLogUpdateInput, ActivityLogUncheckedUpdateInput>
  }

  /**
   * ActivityLog delete
   */
  export type ActivityLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter which ActivityLog to delete.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog deleteMany
   */
  export type ActivityLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityLogs to delete
     */
    where?: ActivityLogWhereInput
    /**
     * Limit how many ActivityLogs to delete.
     */
    limit?: number
  }

  /**
   * ActivityLog without action
   */
  export type ActivityLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
  }


  /**
   * Model Enquiry
   */

  export type AggregateEnquiry = {
    _count: EnquiryCountAggregateOutputType | null
    _avg: EnquiryAvgAggregateOutputType | null
    _sum: EnquirySumAggregateOutputType | null
    _min: EnquiryMinAggregateOutputType | null
    _max: EnquiryMaxAggregateOutputType | null
  }

  export type EnquiryAvgAggregateOutputType = {
    studentId: number | null
  }

  export type EnquirySumAggregateOutputType = {
    studentId: number | null
  }

  export type EnquiryMinAggregateOutputType = {
    id: string | null
    name: string | null
    contact: string | null
    email: string | null
    course: string | null
    source: string | null
    leadStatus: $Enums.LeadStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    isConverted: boolean | null
    studentId: number | null
    clientAdminId: string | null
  }

  export type EnquiryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    contact: string | null
    email: string | null
    course: string | null
    source: string | null
    leadStatus: $Enums.LeadStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    isConverted: boolean | null
    studentId: number | null
    clientAdminId: string | null
  }

  export type EnquiryCountAggregateOutputType = {
    id: number
    name: number
    contact: number
    email: number
    course: number
    source: number
    leadStatus: number
    createdAt: number
    updatedAt: number
    isConverted: number
    studentId: number
    clientAdminId: number
    _all: number
  }


  export type EnquiryAvgAggregateInputType = {
    studentId?: true
  }

  export type EnquirySumAggregateInputType = {
    studentId?: true
  }

  export type EnquiryMinAggregateInputType = {
    id?: true
    name?: true
    contact?: true
    email?: true
    course?: true
    source?: true
    leadStatus?: true
    createdAt?: true
    updatedAt?: true
    isConverted?: true
    studentId?: true
    clientAdminId?: true
  }

  export type EnquiryMaxAggregateInputType = {
    id?: true
    name?: true
    contact?: true
    email?: true
    course?: true
    source?: true
    leadStatus?: true
    createdAt?: true
    updatedAt?: true
    isConverted?: true
    studentId?: true
    clientAdminId?: true
  }

  export type EnquiryCountAggregateInputType = {
    id?: true
    name?: true
    contact?: true
    email?: true
    course?: true
    source?: true
    leadStatus?: true
    createdAt?: true
    updatedAt?: true
    isConverted?: true
    studentId?: true
    clientAdminId?: true
    _all?: true
  }

  export type EnquiryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Enquiry to aggregate.
     */
    where?: EnquiryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enquiries to fetch.
     */
    orderBy?: EnquiryOrderByWithRelationInput | EnquiryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EnquiryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enquiries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enquiries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Enquiries
    **/
    _count?: true | EnquiryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EnquiryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EnquirySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EnquiryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EnquiryMaxAggregateInputType
  }

  export type GetEnquiryAggregateType<T extends EnquiryAggregateArgs> = {
        [P in keyof T & keyof AggregateEnquiry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEnquiry[P]>
      : GetScalarType<T[P], AggregateEnquiry[P]>
  }




  export type EnquiryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnquiryWhereInput
    orderBy?: EnquiryOrderByWithAggregationInput | EnquiryOrderByWithAggregationInput[]
    by: EnquiryScalarFieldEnum[] | EnquiryScalarFieldEnum
    having?: EnquiryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EnquiryCountAggregateInputType | true
    _avg?: EnquiryAvgAggregateInputType
    _sum?: EnquirySumAggregateInputType
    _min?: EnquiryMinAggregateInputType
    _max?: EnquiryMaxAggregateInputType
  }

  export type EnquiryGroupByOutputType = {
    id: string
    name: string
    contact: string
    email: string | null
    course: string | null
    source: string | null
    leadStatus: $Enums.LeadStatus
    createdAt: Date
    updatedAt: Date
    isConverted: boolean
    studentId: number | null
    clientAdminId: string
    _count: EnquiryCountAggregateOutputType | null
    _avg: EnquiryAvgAggregateOutputType | null
    _sum: EnquirySumAggregateOutputType | null
    _min: EnquiryMinAggregateOutputType | null
    _max: EnquiryMaxAggregateOutputType | null
  }

  type GetEnquiryGroupByPayload<T extends EnquiryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EnquiryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EnquiryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EnquiryGroupByOutputType[P]>
            : GetScalarType<T[P], EnquiryGroupByOutputType[P]>
        }
      >
    >


  export type EnquirySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    contact?: boolean
    email?: boolean
    course?: boolean
    source?: boolean
    leadStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isConverted?: boolean
    studentId?: boolean
    clientAdminId?: boolean
    followUps?: boolean | Enquiry$followUpsArgs<ExtArgs>
    student?: boolean | Enquiry$studentArgs<ExtArgs>
    enquiryCourse?: boolean | Enquiry$enquiryCourseArgs<ExtArgs>
    notification?: boolean | Enquiry$notificationArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
    _count?: boolean | EnquiryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["enquiry"]>

  export type EnquirySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    contact?: boolean
    email?: boolean
    course?: boolean
    source?: boolean
    leadStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isConverted?: boolean
    studentId?: boolean
    clientAdminId?: boolean
    student?: boolean | Enquiry$studentArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["enquiry"]>

  export type EnquirySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    contact?: boolean
    email?: boolean
    course?: boolean
    source?: boolean
    leadStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isConverted?: boolean
    studentId?: boolean
    clientAdminId?: boolean
    student?: boolean | Enquiry$studentArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["enquiry"]>

  export type EnquirySelectScalar = {
    id?: boolean
    name?: boolean
    contact?: boolean
    email?: boolean
    course?: boolean
    source?: boolean
    leadStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isConverted?: boolean
    studentId?: boolean
    clientAdminId?: boolean
  }

  export type EnquiryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "contact" | "email" | "course" | "source" | "leadStatus" | "createdAt" | "updatedAt" | "isConverted" | "studentId" | "clientAdminId", ExtArgs["result"]["enquiry"]>
  export type EnquiryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    followUps?: boolean | Enquiry$followUpsArgs<ExtArgs>
    student?: boolean | Enquiry$studentArgs<ExtArgs>
    enquiryCourse?: boolean | Enquiry$enquiryCourseArgs<ExtArgs>
    notification?: boolean | Enquiry$notificationArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
    _count?: boolean | EnquiryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EnquiryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | Enquiry$studentArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }
  export type EnquiryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | Enquiry$studentArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }

  export type $EnquiryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Enquiry"
    objects: {
      followUps: Prisma.$FollowUpPayload<ExtArgs>[]
      student: Prisma.$StudentPayload<ExtArgs> | null
      enquiryCourse: Prisma.$EnquiryCoursePayload<ExtArgs>[]
      notification: Prisma.$NotificationPayload<ExtArgs> | null
      clientAdmin: Prisma.$ClientAdminPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      contact: string
      email: string | null
      course: string | null
      source: string | null
      leadStatus: $Enums.LeadStatus
      createdAt: Date
      updatedAt: Date
      isConverted: boolean
      studentId: number | null
      clientAdminId: string
    }, ExtArgs["result"]["enquiry"]>
    composites: {}
  }

  type EnquiryGetPayload<S extends boolean | null | undefined | EnquiryDefaultArgs> = $Result.GetResult<Prisma.$EnquiryPayload, S>

  type EnquiryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EnquiryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EnquiryCountAggregateInputType | true
    }

  export interface EnquiryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Enquiry'], meta: { name: 'Enquiry' } }
    /**
     * Find zero or one Enquiry that matches the filter.
     * @param {EnquiryFindUniqueArgs} args - Arguments to find a Enquiry
     * @example
     * // Get one Enquiry
     * const enquiry = await prisma.enquiry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EnquiryFindUniqueArgs>(args: SelectSubset<T, EnquiryFindUniqueArgs<ExtArgs>>): Prisma__EnquiryClient<$Result.GetResult<Prisma.$EnquiryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Enquiry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EnquiryFindUniqueOrThrowArgs} args - Arguments to find a Enquiry
     * @example
     * // Get one Enquiry
     * const enquiry = await prisma.enquiry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EnquiryFindUniqueOrThrowArgs>(args: SelectSubset<T, EnquiryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EnquiryClient<$Result.GetResult<Prisma.$EnquiryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Enquiry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnquiryFindFirstArgs} args - Arguments to find a Enquiry
     * @example
     * // Get one Enquiry
     * const enquiry = await prisma.enquiry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EnquiryFindFirstArgs>(args?: SelectSubset<T, EnquiryFindFirstArgs<ExtArgs>>): Prisma__EnquiryClient<$Result.GetResult<Prisma.$EnquiryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Enquiry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnquiryFindFirstOrThrowArgs} args - Arguments to find a Enquiry
     * @example
     * // Get one Enquiry
     * const enquiry = await prisma.enquiry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EnquiryFindFirstOrThrowArgs>(args?: SelectSubset<T, EnquiryFindFirstOrThrowArgs<ExtArgs>>): Prisma__EnquiryClient<$Result.GetResult<Prisma.$EnquiryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Enquiries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnquiryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Enquiries
     * const enquiries = await prisma.enquiry.findMany()
     * 
     * // Get first 10 Enquiries
     * const enquiries = await prisma.enquiry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const enquiryWithIdOnly = await prisma.enquiry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EnquiryFindManyArgs>(args?: SelectSubset<T, EnquiryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnquiryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Enquiry.
     * @param {EnquiryCreateArgs} args - Arguments to create a Enquiry.
     * @example
     * // Create one Enquiry
     * const Enquiry = await prisma.enquiry.create({
     *   data: {
     *     // ... data to create a Enquiry
     *   }
     * })
     * 
     */
    create<T extends EnquiryCreateArgs>(args: SelectSubset<T, EnquiryCreateArgs<ExtArgs>>): Prisma__EnquiryClient<$Result.GetResult<Prisma.$EnquiryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Enquiries.
     * @param {EnquiryCreateManyArgs} args - Arguments to create many Enquiries.
     * @example
     * // Create many Enquiries
     * const enquiry = await prisma.enquiry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EnquiryCreateManyArgs>(args?: SelectSubset<T, EnquiryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Enquiries and returns the data saved in the database.
     * @param {EnquiryCreateManyAndReturnArgs} args - Arguments to create many Enquiries.
     * @example
     * // Create many Enquiries
     * const enquiry = await prisma.enquiry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Enquiries and only return the `id`
     * const enquiryWithIdOnly = await prisma.enquiry.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EnquiryCreateManyAndReturnArgs>(args?: SelectSubset<T, EnquiryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnquiryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Enquiry.
     * @param {EnquiryDeleteArgs} args - Arguments to delete one Enquiry.
     * @example
     * // Delete one Enquiry
     * const Enquiry = await prisma.enquiry.delete({
     *   where: {
     *     // ... filter to delete one Enquiry
     *   }
     * })
     * 
     */
    delete<T extends EnquiryDeleteArgs>(args: SelectSubset<T, EnquiryDeleteArgs<ExtArgs>>): Prisma__EnquiryClient<$Result.GetResult<Prisma.$EnquiryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Enquiry.
     * @param {EnquiryUpdateArgs} args - Arguments to update one Enquiry.
     * @example
     * // Update one Enquiry
     * const enquiry = await prisma.enquiry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EnquiryUpdateArgs>(args: SelectSubset<T, EnquiryUpdateArgs<ExtArgs>>): Prisma__EnquiryClient<$Result.GetResult<Prisma.$EnquiryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Enquiries.
     * @param {EnquiryDeleteManyArgs} args - Arguments to filter Enquiries to delete.
     * @example
     * // Delete a few Enquiries
     * const { count } = await prisma.enquiry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EnquiryDeleteManyArgs>(args?: SelectSubset<T, EnquiryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Enquiries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnquiryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Enquiries
     * const enquiry = await prisma.enquiry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EnquiryUpdateManyArgs>(args: SelectSubset<T, EnquiryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Enquiries and returns the data updated in the database.
     * @param {EnquiryUpdateManyAndReturnArgs} args - Arguments to update many Enquiries.
     * @example
     * // Update many Enquiries
     * const enquiry = await prisma.enquiry.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Enquiries and only return the `id`
     * const enquiryWithIdOnly = await prisma.enquiry.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EnquiryUpdateManyAndReturnArgs>(args: SelectSubset<T, EnquiryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnquiryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Enquiry.
     * @param {EnquiryUpsertArgs} args - Arguments to update or create a Enquiry.
     * @example
     * // Update or create a Enquiry
     * const enquiry = await prisma.enquiry.upsert({
     *   create: {
     *     // ... data to create a Enquiry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Enquiry we want to update
     *   }
     * })
     */
    upsert<T extends EnquiryUpsertArgs>(args: SelectSubset<T, EnquiryUpsertArgs<ExtArgs>>): Prisma__EnquiryClient<$Result.GetResult<Prisma.$EnquiryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Enquiries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnquiryCountArgs} args - Arguments to filter Enquiries to count.
     * @example
     * // Count the number of Enquiries
     * const count = await prisma.enquiry.count({
     *   where: {
     *     // ... the filter for the Enquiries we want to count
     *   }
     * })
    **/
    count<T extends EnquiryCountArgs>(
      args?: Subset<T, EnquiryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EnquiryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Enquiry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnquiryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EnquiryAggregateArgs>(args: Subset<T, EnquiryAggregateArgs>): Prisma.PrismaPromise<GetEnquiryAggregateType<T>>

    /**
     * Group by Enquiry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnquiryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EnquiryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EnquiryGroupByArgs['orderBy'] }
        : { orderBy?: EnquiryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EnquiryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEnquiryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Enquiry model
   */
  readonly fields: EnquiryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Enquiry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EnquiryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    followUps<T extends Enquiry$followUpsArgs<ExtArgs> = {}>(args?: Subset<T, Enquiry$followUpsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowUpPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    student<T extends Enquiry$studentArgs<ExtArgs> = {}>(args?: Subset<T, Enquiry$studentArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    enquiryCourse<T extends Enquiry$enquiryCourseArgs<ExtArgs> = {}>(args?: Subset<T, Enquiry$enquiryCourseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnquiryCoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notification<T extends Enquiry$notificationArgs<ExtArgs> = {}>(args?: Subset<T, Enquiry$notificationArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    clientAdmin<T extends ClientAdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientAdminDefaultArgs<ExtArgs>>): Prisma__ClientAdminClient<$Result.GetResult<Prisma.$ClientAdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Enquiry model
   */
  interface EnquiryFieldRefs {
    readonly id: FieldRef<"Enquiry", 'String'>
    readonly name: FieldRef<"Enquiry", 'String'>
    readonly contact: FieldRef<"Enquiry", 'String'>
    readonly email: FieldRef<"Enquiry", 'String'>
    readonly course: FieldRef<"Enquiry", 'String'>
    readonly source: FieldRef<"Enquiry", 'String'>
    readonly leadStatus: FieldRef<"Enquiry", 'LeadStatus'>
    readonly createdAt: FieldRef<"Enquiry", 'DateTime'>
    readonly updatedAt: FieldRef<"Enquiry", 'DateTime'>
    readonly isConverted: FieldRef<"Enquiry", 'Boolean'>
    readonly studentId: FieldRef<"Enquiry", 'Int'>
    readonly clientAdminId: FieldRef<"Enquiry", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Enquiry findUnique
   */
  export type EnquiryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enquiry
     */
    select?: EnquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enquiry
     */
    omit?: EnquiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnquiryInclude<ExtArgs> | null
    /**
     * Filter, which Enquiry to fetch.
     */
    where: EnquiryWhereUniqueInput
  }

  /**
   * Enquiry findUniqueOrThrow
   */
  export type EnquiryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enquiry
     */
    select?: EnquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enquiry
     */
    omit?: EnquiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnquiryInclude<ExtArgs> | null
    /**
     * Filter, which Enquiry to fetch.
     */
    where: EnquiryWhereUniqueInput
  }

  /**
   * Enquiry findFirst
   */
  export type EnquiryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enquiry
     */
    select?: EnquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enquiry
     */
    omit?: EnquiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnquiryInclude<ExtArgs> | null
    /**
     * Filter, which Enquiry to fetch.
     */
    where?: EnquiryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enquiries to fetch.
     */
    orderBy?: EnquiryOrderByWithRelationInput | EnquiryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Enquiries.
     */
    cursor?: EnquiryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enquiries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enquiries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Enquiries.
     */
    distinct?: EnquiryScalarFieldEnum | EnquiryScalarFieldEnum[]
  }

  /**
   * Enquiry findFirstOrThrow
   */
  export type EnquiryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enquiry
     */
    select?: EnquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enquiry
     */
    omit?: EnquiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnquiryInclude<ExtArgs> | null
    /**
     * Filter, which Enquiry to fetch.
     */
    where?: EnquiryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enquiries to fetch.
     */
    orderBy?: EnquiryOrderByWithRelationInput | EnquiryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Enquiries.
     */
    cursor?: EnquiryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enquiries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enquiries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Enquiries.
     */
    distinct?: EnquiryScalarFieldEnum | EnquiryScalarFieldEnum[]
  }

  /**
   * Enquiry findMany
   */
  export type EnquiryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enquiry
     */
    select?: EnquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enquiry
     */
    omit?: EnquiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnquiryInclude<ExtArgs> | null
    /**
     * Filter, which Enquiries to fetch.
     */
    where?: EnquiryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enquiries to fetch.
     */
    orderBy?: EnquiryOrderByWithRelationInput | EnquiryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Enquiries.
     */
    cursor?: EnquiryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enquiries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enquiries.
     */
    skip?: number
    distinct?: EnquiryScalarFieldEnum | EnquiryScalarFieldEnum[]
  }

  /**
   * Enquiry create
   */
  export type EnquiryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enquiry
     */
    select?: EnquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enquiry
     */
    omit?: EnquiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnquiryInclude<ExtArgs> | null
    /**
     * The data needed to create a Enquiry.
     */
    data: XOR<EnquiryCreateInput, EnquiryUncheckedCreateInput>
  }

  /**
   * Enquiry createMany
   */
  export type EnquiryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Enquiries.
     */
    data: EnquiryCreateManyInput | EnquiryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Enquiry createManyAndReturn
   */
  export type EnquiryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enquiry
     */
    select?: EnquirySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Enquiry
     */
    omit?: EnquiryOmit<ExtArgs> | null
    /**
     * The data used to create many Enquiries.
     */
    data: EnquiryCreateManyInput | EnquiryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnquiryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Enquiry update
   */
  export type EnquiryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enquiry
     */
    select?: EnquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enquiry
     */
    omit?: EnquiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnquiryInclude<ExtArgs> | null
    /**
     * The data needed to update a Enquiry.
     */
    data: XOR<EnquiryUpdateInput, EnquiryUncheckedUpdateInput>
    /**
     * Choose, which Enquiry to update.
     */
    where: EnquiryWhereUniqueInput
  }

  /**
   * Enquiry updateMany
   */
  export type EnquiryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Enquiries.
     */
    data: XOR<EnquiryUpdateManyMutationInput, EnquiryUncheckedUpdateManyInput>
    /**
     * Filter which Enquiries to update
     */
    where?: EnquiryWhereInput
    /**
     * Limit how many Enquiries to update.
     */
    limit?: number
  }

  /**
   * Enquiry updateManyAndReturn
   */
  export type EnquiryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enquiry
     */
    select?: EnquirySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Enquiry
     */
    omit?: EnquiryOmit<ExtArgs> | null
    /**
     * The data used to update Enquiries.
     */
    data: XOR<EnquiryUpdateManyMutationInput, EnquiryUncheckedUpdateManyInput>
    /**
     * Filter which Enquiries to update
     */
    where?: EnquiryWhereInput
    /**
     * Limit how many Enquiries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnquiryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Enquiry upsert
   */
  export type EnquiryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enquiry
     */
    select?: EnquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enquiry
     */
    omit?: EnquiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnquiryInclude<ExtArgs> | null
    /**
     * The filter to search for the Enquiry to update in case it exists.
     */
    where: EnquiryWhereUniqueInput
    /**
     * In case the Enquiry found by the `where` argument doesn't exist, create a new Enquiry with this data.
     */
    create: XOR<EnquiryCreateInput, EnquiryUncheckedCreateInput>
    /**
     * In case the Enquiry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EnquiryUpdateInput, EnquiryUncheckedUpdateInput>
  }

  /**
   * Enquiry delete
   */
  export type EnquiryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enquiry
     */
    select?: EnquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enquiry
     */
    omit?: EnquiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnquiryInclude<ExtArgs> | null
    /**
     * Filter which Enquiry to delete.
     */
    where: EnquiryWhereUniqueInput
  }

  /**
   * Enquiry deleteMany
   */
  export type EnquiryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Enquiries to delete
     */
    where?: EnquiryWhereInput
    /**
     * Limit how many Enquiries to delete.
     */
    limit?: number
  }

  /**
   * Enquiry.followUps
   */
  export type Enquiry$followUpsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowUp
     */
    select?: FollowUpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FollowUp
     */
    omit?: FollowUpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowUpInclude<ExtArgs> | null
    where?: FollowUpWhereInput
    orderBy?: FollowUpOrderByWithRelationInput | FollowUpOrderByWithRelationInput[]
    cursor?: FollowUpWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FollowUpScalarFieldEnum | FollowUpScalarFieldEnum[]
  }

  /**
   * Enquiry.student
   */
  export type Enquiry$studentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
  }

  /**
   * Enquiry.enquiryCourse
   */
  export type Enquiry$enquiryCourseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnquiryCourse
     */
    select?: EnquiryCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnquiryCourse
     */
    omit?: EnquiryCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnquiryCourseInclude<ExtArgs> | null
    where?: EnquiryCourseWhereInput
    orderBy?: EnquiryCourseOrderByWithRelationInput | EnquiryCourseOrderByWithRelationInput[]
    cursor?: EnquiryCourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EnquiryCourseScalarFieldEnum | EnquiryCourseScalarFieldEnum[]
  }

  /**
   * Enquiry.notification
   */
  export type Enquiry$notificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
  }

  /**
   * Enquiry without action
   */
  export type EnquiryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enquiry
     */
    select?: EnquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enquiry
     */
    omit?: EnquiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnquiryInclude<ExtArgs> | null
  }


  /**
   * Model EnquiryCourse
   */

  export type AggregateEnquiryCourse = {
    _count: EnquiryCourseCountAggregateOutputType | null
    _avg: EnquiryCourseAvgAggregateOutputType | null
    _sum: EnquiryCourseSumAggregateOutputType | null
    _min: EnquiryCourseMinAggregateOutputType | null
    _max: EnquiryCourseMaxAggregateOutputType | null
  }

  export type EnquiryCourseAvgAggregateOutputType = {
    id: number | null
    courseId: number | null
  }

  export type EnquiryCourseSumAggregateOutputType = {
    id: number | null
    courseId: number | null
  }

  export type EnquiryCourseMinAggregateOutputType = {
    id: number | null
    enquiryId: string | null
    courseId: number | null
    clientAdminId: string | null
  }

  export type EnquiryCourseMaxAggregateOutputType = {
    id: number | null
    enquiryId: string | null
    courseId: number | null
    clientAdminId: string | null
  }

  export type EnquiryCourseCountAggregateOutputType = {
    id: number
    enquiryId: number
    courseId: number
    clientAdminId: number
    _all: number
  }


  export type EnquiryCourseAvgAggregateInputType = {
    id?: true
    courseId?: true
  }

  export type EnquiryCourseSumAggregateInputType = {
    id?: true
    courseId?: true
  }

  export type EnquiryCourseMinAggregateInputType = {
    id?: true
    enquiryId?: true
    courseId?: true
    clientAdminId?: true
  }

  export type EnquiryCourseMaxAggregateInputType = {
    id?: true
    enquiryId?: true
    courseId?: true
    clientAdminId?: true
  }

  export type EnquiryCourseCountAggregateInputType = {
    id?: true
    enquiryId?: true
    courseId?: true
    clientAdminId?: true
    _all?: true
  }

  export type EnquiryCourseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EnquiryCourse to aggregate.
     */
    where?: EnquiryCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EnquiryCourses to fetch.
     */
    orderBy?: EnquiryCourseOrderByWithRelationInput | EnquiryCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EnquiryCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EnquiryCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EnquiryCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EnquiryCourses
    **/
    _count?: true | EnquiryCourseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EnquiryCourseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EnquiryCourseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EnquiryCourseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EnquiryCourseMaxAggregateInputType
  }

  export type GetEnquiryCourseAggregateType<T extends EnquiryCourseAggregateArgs> = {
        [P in keyof T & keyof AggregateEnquiryCourse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEnquiryCourse[P]>
      : GetScalarType<T[P], AggregateEnquiryCourse[P]>
  }




  export type EnquiryCourseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnquiryCourseWhereInput
    orderBy?: EnquiryCourseOrderByWithAggregationInput | EnquiryCourseOrderByWithAggregationInput[]
    by: EnquiryCourseScalarFieldEnum[] | EnquiryCourseScalarFieldEnum
    having?: EnquiryCourseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EnquiryCourseCountAggregateInputType | true
    _avg?: EnquiryCourseAvgAggregateInputType
    _sum?: EnquiryCourseSumAggregateInputType
    _min?: EnquiryCourseMinAggregateInputType
    _max?: EnquiryCourseMaxAggregateInputType
  }

  export type EnquiryCourseGroupByOutputType = {
    id: number
    enquiryId: string
    courseId: number
    clientAdminId: string
    _count: EnquiryCourseCountAggregateOutputType | null
    _avg: EnquiryCourseAvgAggregateOutputType | null
    _sum: EnquiryCourseSumAggregateOutputType | null
    _min: EnquiryCourseMinAggregateOutputType | null
    _max: EnquiryCourseMaxAggregateOutputType | null
  }

  type GetEnquiryCourseGroupByPayload<T extends EnquiryCourseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EnquiryCourseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EnquiryCourseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EnquiryCourseGroupByOutputType[P]>
            : GetScalarType<T[P], EnquiryCourseGroupByOutputType[P]>
        }
      >
    >


  export type EnquiryCourseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    enquiryId?: boolean
    courseId?: boolean
    clientAdminId?: boolean
    enquiry?: boolean | EnquiryDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["enquiryCourse"]>

  export type EnquiryCourseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    enquiryId?: boolean
    courseId?: boolean
    clientAdminId?: boolean
    enquiry?: boolean | EnquiryDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["enquiryCourse"]>

  export type EnquiryCourseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    enquiryId?: boolean
    courseId?: boolean
    clientAdminId?: boolean
    enquiry?: boolean | EnquiryDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["enquiryCourse"]>

  export type EnquiryCourseSelectScalar = {
    id?: boolean
    enquiryId?: boolean
    courseId?: boolean
    clientAdminId?: boolean
  }

  export type EnquiryCourseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "enquiryId" | "courseId" | "clientAdminId", ExtArgs["result"]["enquiryCourse"]>
  export type EnquiryCourseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    enquiry?: boolean | EnquiryDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }
  export type EnquiryCourseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    enquiry?: boolean | EnquiryDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }
  export type EnquiryCourseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    enquiry?: boolean | EnquiryDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }

  export type $EnquiryCoursePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EnquiryCourse"
    objects: {
      enquiry: Prisma.$EnquiryPayload<ExtArgs>
      course: Prisma.$CoursePayload<ExtArgs>
      clientAdmin: Prisma.$ClientAdminPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      enquiryId: string
      courseId: number
      clientAdminId: string
    }, ExtArgs["result"]["enquiryCourse"]>
    composites: {}
  }

  type EnquiryCourseGetPayload<S extends boolean | null | undefined | EnquiryCourseDefaultArgs> = $Result.GetResult<Prisma.$EnquiryCoursePayload, S>

  type EnquiryCourseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EnquiryCourseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EnquiryCourseCountAggregateInputType | true
    }

  export interface EnquiryCourseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EnquiryCourse'], meta: { name: 'EnquiryCourse' } }
    /**
     * Find zero or one EnquiryCourse that matches the filter.
     * @param {EnquiryCourseFindUniqueArgs} args - Arguments to find a EnquiryCourse
     * @example
     * // Get one EnquiryCourse
     * const enquiryCourse = await prisma.enquiryCourse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EnquiryCourseFindUniqueArgs>(args: SelectSubset<T, EnquiryCourseFindUniqueArgs<ExtArgs>>): Prisma__EnquiryCourseClient<$Result.GetResult<Prisma.$EnquiryCoursePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EnquiryCourse that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EnquiryCourseFindUniqueOrThrowArgs} args - Arguments to find a EnquiryCourse
     * @example
     * // Get one EnquiryCourse
     * const enquiryCourse = await prisma.enquiryCourse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EnquiryCourseFindUniqueOrThrowArgs>(args: SelectSubset<T, EnquiryCourseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EnquiryCourseClient<$Result.GetResult<Prisma.$EnquiryCoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EnquiryCourse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnquiryCourseFindFirstArgs} args - Arguments to find a EnquiryCourse
     * @example
     * // Get one EnquiryCourse
     * const enquiryCourse = await prisma.enquiryCourse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EnquiryCourseFindFirstArgs>(args?: SelectSubset<T, EnquiryCourseFindFirstArgs<ExtArgs>>): Prisma__EnquiryCourseClient<$Result.GetResult<Prisma.$EnquiryCoursePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EnquiryCourse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnquiryCourseFindFirstOrThrowArgs} args - Arguments to find a EnquiryCourse
     * @example
     * // Get one EnquiryCourse
     * const enquiryCourse = await prisma.enquiryCourse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EnquiryCourseFindFirstOrThrowArgs>(args?: SelectSubset<T, EnquiryCourseFindFirstOrThrowArgs<ExtArgs>>): Prisma__EnquiryCourseClient<$Result.GetResult<Prisma.$EnquiryCoursePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EnquiryCourses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnquiryCourseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EnquiryCourses
     * const enquiryCourses = await prisma.enquiryCourse.findMany()
     * 
     * // Get first 10 EnquiryCourses
     * const enquiryCourses = await prisma.enquiryCourse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const enquiryCourseWithIdOnly = await prisma.enquiryCourse.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EnquiryCourseFindManyArgs>(args?: SelectSubset<T, EnquiryCourseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnquiryCoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EnquiryCourse.
     * @param {EnquiryCourseCreateArgs} args - Arguments to create a EnquiryCourse.
     * @example
     * // Create one EnquiryCourse
     * const EnquiryCourse = await prisma.enquiryCourse.create({
     *   data: {
     *     // ... data to create a EnquiryCourse
     *   }
     * })
     * 
     */
    create<T extends EnquiryCourseCreateArgs>(args: SelectSubset<T, EnquiryCourseCreateArgs<ExtArgs>>): Prisma__EnquiryCourseClient<$Result.GetResult<Prisma.$EnquiryCoursePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EnquiryCourses.
     * @param {EnquiryCourseCreateManyArgs} args - Arguments to create many EnquiryCourses.
     * @example
     * // Create many EnquiryCourses
     * const enquiryCourse = await prisma.enquiryCourse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EnquiryCourseCreateManyArgs>(args?: SelectSubset<T, EnquiryCourseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EnquiryCourses and returns the data saved in the database.
     * @param {EnquiryCourseCreateManyAndReturnArgs} args - Arguments to create many EnquiryCourses.
     * @example
     * // Create many EnquiryCourses
     * const enquiryCourse = await prisma.enquiryCourse.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EnquiryCourses and only return the `id`
     * const enquiryCourseWithIdOnly = await prisma.enquiryCourse.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EnquiryCourseCreateManyAndReturnArgs>(args?: SelectSubset<T, EnquiryCourseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnquiryCoursePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EnquiryCourse.
     * @param {EnquiryCourseDeleteArgs} args - Arguments to delete one EnquiryCourse.
     * @example
     * // Delete one EnquiryCourse
     * const EnquiryCourse = await prisma.enquiryCourse.delete({
     *   where: {
     *     // ... filter to delete one EnquiryCourse
     *   }
     * })
     * 
     */
    delete<T extends EnquiryCourseDeleteArgs>(args: SelectSubset<T, EnquiryCourseDeleteArgs<ExtArgs>>): Prisma__EnquiryCourseClient<$Result.GetResult<Prisma.$EnquiryCoursePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EnquiryCourse.
     * @param {EnquiryCourseUpdateArgs} args - Arguments to update one EnquiryCourse.
     * @example
     * // Update one EnquiryCourse
     * const enquiryCourse = await prisma.enquiryCourse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EnquiryCourseUpdateArgs>(args: SelectSubset<T, EnquiryCourseUpdateArgs<ExtArgs>>): Prisma__EnquiryCourseClient<$Result.GetResult<Prisma.$EnquiryCoursePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EnquiryCourses.
     * @param {EnquiryCourseDeleteManyArgs} args - Arguments to filter EnquiryCourses to delete.
     * @example
     * // Delete a few EnquiryCourses
     * const { count } = await prisma.enquiryCourse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EnquiryCourseDeleteManyArgs>(args?: SelectSubset<T, EnquiryCourseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EnquiryCourses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnquiryCourseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EnquiryCourses
     * const enquiryCourse = await prisma.enquiryCourse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EnquiryCourseUpdateManyArgs>(args: SelectSubset<T, EnquiryCourseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EnquiryCourses and returns the data updated in the database.
     * @param {EnquiryCourseUpdateManyAndReturnArgs} args - Arguments to update many EnquiryCourses.
     * @example
     * // Update many EnquiryCourses
     * const enquiryCourse = await prisma.enquiryCourse.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EnquiryCourses and only return the `id`
     * const enquiryCourseWithIdOnly = await prisma.enquiryCourse.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EnquiryCourseUpdateManyAndReturnArgs>(args: SelectSubset<T, EnquiryCourseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnquiryCoursePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EnquiryCourse.
     * @param {EnquiryCourseUpsertArgs} args - Arguments to update or create a EnquiryCourse.
     * @example
     * // Update or create a EnquiryCourse
     * const enquiryCourse = await prisma.enquiryCourse.upsert({
     *   create: {
     *     // ... data to create a EnquiryCourse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EnquiryCourse we want to update
     *   }
     * })
     */
    upsert<T extends EnquiryCourseUpsertArgs>(args: SelectSubset<T, EnquiryCourseUpsertArgs<ExtArgs>>): Prisma__EnquiryCourseClient<$Result.GetResult<Prisma.$EnquiryCoursePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EnquiryCourses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnquiryCourseCountArgs} args - Arguments to filter EnquiryCourses to count.
     * @example
     * // Count the number of EnquiryCourses
     * const count = await prisma.enquiryCourse.count({
     *   where: {
     *     // ... the filter for the EnquiryCourses we want to count
     *   }
     * })
    **/
    count<T extends EnquiryCourseCountArgs>(
      args?: Subset<T, EnquiryCourseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EnquiryCourseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EnquiryCourse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnquiryCourseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EnquiryCourseAggregateArgs>(args: Subset<T, EnquiryCourseAggregateArgs>): Prisma.PrismaPromise<GetEnquiryCourseAggregateType<T>>

    /**
     * Group by EnquiryCourse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnquiryCourseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EnquiryCourseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EnquiryCourseGroupByArgs['orderBy'] }
        : { orderBy?: EnquiryCourseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EnquiryCourseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEnquiryCourseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EnquiryCourse model
   */
  readonly fields: EnquiryCourseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EnquiryCourse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EnquiryCourseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    enquiry<T extends EnquiryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EnquiryDefaultArgs<ExtArgs>>): Prisma__EnquiryClient<$Result.GetResult<Prisma.$EnquiryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    clientAdmin<T extends ClientAdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientAdminDefaultArgs<ExtArgs>>): Prisma__ClientAdminClient<$Result.GetResult<Prisma.$ClientAdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EnquiryCourse model
   */
  interface EnquiryCourseFieldRefs {
    readonly id: FieldRef<"EnquiryCourse", 'Int'>
    readonly enquiryId: FieldRef<"EnquiryCourse", 'String'>
    readonly courseId: FieldRef<"EnquiryCourse", 'Int'>
    readonly clientAdminId: FieldRef<"EnquiryCourse", 'String'>
  }
    

  // Custom InputTypes
  /**
   * EnquiryCourse findUnique
   */
  export type EnquiryCourseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnquiryCourse
     */
    select?: EnquiryCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnquiryCourse
     */
    omit?: EnquiryCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnquiryCourseInclude<ExtArgs> | null
    /**
     * Filter, which EnquiryCourse to fetch.
     */
    where: EnquiryCourseWhereUniqueInput
  }

  /**
   * EnquiryCourse findUniqueOrThrow
   */
  export type EnquiryCourseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnquiryCourse
     */
    select?: EnquiryCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnquiryCourse
     */
    omit?: EnquiryCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnquiryCourseInclude<ExtArgs> | null
    /**
     * Filter, which EnquiryCourse to fetch.
     */
    where: EnquiryCourseWhereUniqueInput
  }

  /**
   * EnquiryCourse findFirst
   */
  export type EnquiryCourseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnquiryCourse
     */
    select?: EnquiryCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnquiryCourse
     */
    omit?: EnquiryCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnquiryCourseInclude<ExtArgs> | null
    /**
     * Filter, which EnquiryCourse to fetch.
     */
    where?: EnquiryCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EnquiryCourses to fetch.
     */
    orderBy?: EnquiryCourseOrderByWithRelationInput | EnquiryCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EnquiryCourses.
     */
    cursor?: EnquiryCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EnquiryCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EnquiryCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EnquiryCourses.
     */
    distinct?: EnquiryCourseScalarFieldEnum | EnquiryCourseScalarFieldEnum[]
  }

  /**
   * EnquiryCourse findFirstOrThrow
   */
  export type EnquiryCourseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnquiryCourse
     */
    select?: EnquiryCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnquiryCourse
     */
    omit?: EnquiryCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnquiryCourseInclude<ExtArgs> | null
    /**
     * Filter, which EnquiryCourse to fetch.
     */
    where?: EnquiryCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EnquiryCourses to fetch.
     */
    orderBy?: EnquiryCourseOrderByWithRelationInput | EnquiryCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EnquiryCourses.
     */
    cursor?: EnquiryCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EnquiryCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EnquiryCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EnquiryCourses.
     */
    distinct?: EnquiryCourseScalarFieldEnum | EnquiryCourseScalarFieldEnum[]
  }

  /**
   * EnquiryCourse findMany
   */
  export type EnquiryCourseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnquiryCourse
     */
    select?: EnquiryCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnquiryCourse
     */
    omit?: EnquiryCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnquiryCourseInclude<ExtArgs> | null
    /**
     * Filter, which EnquiryCourses to fetch.
     */
    where?: EnquiryCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EnquiryCourses to fetch.
     */
    orderBy?: EnquiryCourseOrderByWithRelationInput | EnquiryCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EnquiryCourses.
     */
    cursor?: EnquiryCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EnquiryCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EnquiryCourses.
     */
    skip?: number
    distinct?: EnquiryCourseScalarFieldEnum | EnquiryCourseScalarFieldEnum[]
  }

  /**
   * EnquiryCourse create
   */
  export type EnquiryCourseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnquiryCourse
     */
    select?: EnquiryCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnquiryCourse
     */
    omit?: EnquiryCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnquiryCourseInclude<ExtArgs> | null
    /**
     * The data needed to create a EnquiryCourse.
     */
    data: XOR<EnquiryCourseCreateInput, EnquiryCourseUncheckedCreateInput>
  }

  /**
   * EnquiryCourse createMany
   */
  export type EnquiryCourseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EnquiryCourses.
     */
    data: EnquiryCourseCreateManyInput | EnquiryCourseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EnquiryCourse createManyAndReturn
   */
  export type EnquiryCourseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnquiryCourse
     */
    select?: EnquiryCourseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EnquiryCourse
     */
    omit?: EnquiryCourseOmit<ExtArgs> | null
    /**
     * The data used to create many EnquiryCourses.
     */
    data: EnquiryCourseCreateManyInput | EnquiryCourseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnquiryCourseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EnquiryCourse update
   */
  export type EnquiryCourseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnquiryCourse
     */
    select?: EnquiryCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnquiryCourse
     */
    omit?: EnquiryCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnquiryCourseInclude<ExtArgs> | null
    /**
     * The data needed to update a EnquiryCourse.
     */
    data: XOR<EnquiryCourseUpdateInput, EnquiryCourseUncheckedUpdateInput>
    /**
     * Choose, which EnquiryCourse to update.
     */
    where: EnquiryCourseWhereUniqueInput
  }

  /**
   * EnquiryCourse updateMany
   */
  export type EnquiryCourseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EnquiryCourses.
     */
    data: XOR<EnquiryCourseUpdateManyMutationInput, EnquiryCourseUncheckedUpdateManyInput>
    /**
     * Filter which EnquiryCourses to update
     */
    where?: EnquiryCourseWhereInput
    /**
     * Limit how many EnquiryCourses to update.
     */
    limit?: number
  }

  /**
   * EnquiryCourse updateManyAndReturn
   */
  export type EnquiryCourseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnquiryCourse
     */
    select?: EnquiryCourseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EnquiryCourse
     */
    omit?: EnquiryCourseOmit<ExtArgs> | null
    /**
     * The data used to update EnquiryCourses.
     */
    data: XOR<EnquiryCourseUpdateManyMutationInput, EnquiryCourseUncheckedUpdateManyInput>
    /**
     * Filter which EnquiryCourses to update
     */
    where?: EnquiryCourseWhereInput
    /**
     * Limit how many EnquiryCourses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnquiryCourseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EnquiryCourse upsert
   */
  export type EnquiryCourseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnquiryCourse
     */
    select?: EnquiryCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnquiryCourse
     */
    omit?: EnquiryCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnquiryCourseInclude<ExtArgs> | null
    /**
     * The filter to search for the EnquiryCourse to update in case it exists.
     */
    where: EnquiryCourseWhereUniqueInput
    /**
     * In case the EnquiryCourse found by the `where` argument doesn't exist, create a new EnquiryCourse with this data.
     */
    create: XOR<EnquiryCourseCreateInput, EnquiryCourseUncheckedCreateInput>
    /**
     * In case the EnquiryCourse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EnquiryCourseUpdateInput, EnquiryCourseUncheckedUpdateInput>
  }

  /**
   * EnquiryCourse delete
   */
  export type EnquiryCourseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnquiryCourse
     */
    select?: EnquiryCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnquiryCourse
     */
    omit?: EnquiryCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnquiryCourseInclude<ExtArgs> | null
    /**
     * Filter which EnquiryCourse to delete.
     */
    where: EnquiryCourseWhereUniqueInput
  }

  /**
   * EnquiryCourse deleteMany
   */
  export type EnquiryCourseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EnquiryCourses to delete
     */
    where?: EnquiryCourseWhereInput
    /**
     * Limit how many EnquiryCourses to delete.
     */
    limit?: number
  }

  /**
   * EnquiryCourse without action
   */
  export type EnquiryCourseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnquiryCourse
     */
    select?: EnquiryCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnquiryCourse
     */
    omit?: EnquiryCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnquiryCourseInclude<ExtArgs> | null
  }


  /**
   * Model FollowUp
   */

  export type AggregateFollowUp = {
    _count: FollowUpCountAggregateOutputType | null
    _min: FollowUpMinAggregateOutputType | null
    _max: FollowUpMaxAggregateOutputType | null
  }

  export type FollowUpMinAggregateOutputType = {
    id: string | null
    enquiryId: string | null
    scheduledAt: Date | null
    doneAt: Date | null
    remark: string | null
    createdAt: Date | null
    followUpStatus: $Enums.FollowUpStatus | null
  }

  export type FollowUpMaxAggregateOutputType = {
    id: string | null
    enquiryId: string | null
    scheduledAt: Date | null
    doneAt: Date | null
    remark: string | null
    createdAt: Date | null
    followUpStatus: $Enums.FollowUpStatus | null
  }

  export type FollowUpCountAggregateOutputType = {
    id: number
    enquiryId: number
    scheduledAt: number
    doneAt: number
    remark: number
    createdAt: number
    followUpStatus: number
    _all: number
  }


  export type FollowUpMinAggregateInputType = {
    id?: true
    enquiryId?: true
    scheduledAt?: true
    doneAt?: true
    remark?: true
    createdAt?: true
    followUpStatus?: true
  }

  export type FollowUpMaxAggregateInputType = {
    id?: true
    enquiryId?: true
    scheduledAt?: true
    doneAt?: true
    remark?: true
    createdAt?: true
    followUpStatus?: true
  }

  export type FollowUpCountAggregateInputType = {
    id?: true
    enquiryId?: true
    scheduledAt?: true
    doneAt?: true
    remark?: true
    createdAt?: true
    followUpStatus?: true
    _all?: true
  }

  export type FollowUpAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FollowUp to aggregate.
     */
    where?: FollowUpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FollowUps to fetch.
     */
    orderBy?: FollowUpOrderByWithRelationInput | FollowUpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FollowUpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FollowUps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FollowUps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FollowUps
    **/
    _count?: true | FollowUpCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FollowUpMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FollowUpMaxAggregateInputType
  }

  export type GetFollowUpAggregateType<T extends FollowUpAggregateArgs> = {
        [P in keyof T & keyof AggregateFollowUp]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFollowUp[P]>
      : GetScalarType<T[P], AggregateFollowUp[P]>
  }




  export type FollowUpGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FollowUpWhereInput
    orderBy?: FollowUpOrderByWithAggregationInput | FollowUpOrderByWithAggregationInput[]
    by: FollowUpScalarFieldEnum[] | FollowUpScalarFieldEnum
    having?: FollowUpScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FollowUpCountAggregateInputType | true
    _min?: FollowUpMinAggregateInputType
    _max?: FollowUpMaxAggregateInputType
  }

  export type FollowUpGroupByOutputType = {
    id: string
    enquiryId: string
    scheduledAt: Date | null
    doneAt: Date | null
    remark: string
    createdAt: Date
    followUpStatus: $Enums.FollowUpStatus
    _count: FollowUpCountAggregateOutputType | null
    _min: FollowUpMinAggregateOutputType | null
    _max: FollowUpMaxAggregateOutputType | null
  }

  type GetFollowUpGroupByPayload<T extends FollowUpGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FollowUpGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FollowUpGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FollowUpGroupByOutputType[P]>
            : GetScalarType<T[P], FollowUpGroupByOutputType[P]>
        }
      >
    >


  export type FollowUpSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    enquiryId?: boolean
    scheduledAt?: boolean
    doneAt?: boolean
    remark?: boolean
    createdAt?: boolean
    followUpStatus?: boolean
    enquiry?: boolean | EnquiryDefaultArgs<ExtArgs>
    notification?: boolean | FollowUp$notificationArgs<ExtArgs>
  }, ExtArgs["result"]["followUp"]>

  export type FollowUpSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    enquiryId?: boolean
    scheduledAt?: boolean
    doneAt?: boolean
    remark?: boolean
    createdAt?: boolean
    followUpStatus?: boolean
    enquiry?: boolean | EnquiryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["followUp"]>

  export type FollowUpSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    enquiryId?: boolean
    scheduledAt?: boolean
    doneAt?: boolean
    remark?: boolean
    createdAt?: boolean
    followUpStatus?: boolean
    enquiry?: boolean | EnquiryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["followUp"]>

  export type FollowUpSelectScalar = {
    id?: boolean
    enquiryId?: boolean
    scheduledAt?: boolean
    doneAt?: boolean
    remark?: boolean
    createdAt?: boolean
    followUpStatus?: boolean
  }

  export type FollowUpOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "enquiryId" | "scheduledAt" | "doneAt" | "remark" | "createdAt" | "followUpStatus", ExtArgs["result"]["followUp"]>
  export type FollowUpInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    enquiry?: boolean | EnquiryDefaultArgs<ExtArgs>
    notification?: boolean | FollowUp$notificationArgs<ExtArgs>
  }
  export type FollowUpIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    enquiry?: boolean | EnquiryDefaultArgs<ExtArgs>
  }
  export type FollowUpIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    enquiry?: boolean | EnquiryDefaultArgs<ExtArgs>
  }

  export type $FollowUpPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FollowUp"
    objects: {
      enquiry: Prisma.$EnquiryPayload<ExtArgs>
      notification: Prisma.$NotificationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      enquiryId: string
      scheduledAt: Date | null
      doneAt: Date | null
      remark: string
      createdAt: Date
      followUpStatus: $Enums.FollowUpStatus
    }, ExtArgs["result"]["followUp"]>
    composites: {}
  }

  type FollowUpGetPayload<S extends boolean | null | undefined | FollowUpDefaultArgs> = $Result.GetResult<Prisma.$FollowUpPayload, S>

  type FollowUpCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FollowUpFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FollowUpCountAggregateInputType | true
    }

  export interface FollowUpDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FollowUp'], meta: { name: 'FollowUp' } }
    /**
     * Find zero or one FollowUp that matches the filter.
     * @param {FollowUpFindUniqueArgs} args - Arguments to find a FollowUp
     * @example
     * // Get one FollowUp
     * const followUp = await prisma.followUp.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FollowUpFindUniqueArgs>(args: SelectSubset<T, FollowUpFindUniqueArgs<ExtArgs>>): Prisma__FollowUpClient<$Result.GetResult<Prisma.$FollowUpPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FollowUp that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FollowUpFindUniqueOrThrowArgs} args - Arguments to find a FollowUp
     * @example
     * // Get one FollowUp
     * const followUp = await prisma.followUp.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FollowUpFindUniqueOrThrowArgs>(args: SelectSubset<T, FollowUpFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FollowUpClient<$Result.GetResult<Prisma.$FollowUpPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FollowUp that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowUpFindFirstArgs} args - Arguments to find a FollowUp
     * @example
     * // Get one FollowUp
     * const followUp = await prisma.followUp.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FollowUpFindFirstArgs>(args?: SelectSubset<T, FollowUpFindFirstArgs<ExtArgs>>): Prisma__FollowUpClient<$Result.GetResult<Prisma.$FollowUpPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FollowUp that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowUpFindFirstOrThrowArgs} args - Arguments to find a FollowUp
     * @example
     * // Get one FollowUp
     * const followUp = await prisma.followUp.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FollowUpFindFirstOrThrowArgs>(args?: SelectSubset<T, FollowUpFindFirstOrThrowArgs<ExtArgs>>): Prisma__FollowUpClient<$Result.GetResult<Prisma.$FollowUpPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FollowUps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowUpFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FollowUps
     * const followUps = await prisma.followUp.findMany()
     * 
     * // Get first 10 FollowUps
     * const followUps = await prisma.followUp.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const followUpWithIdOnly = await prisma.followUp.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FollowUpFindManyArgs>(args?: SelectSubset<T, FollowUpFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowUpPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FollowUp.
     * @param {FollowUpCreateArgs} args - Arguments to create a FollowUp.
     * @example
     * // Create one FollowUp
     * const FollowUp = await prisma.followUp.create({
     *   data: {
     *     // ... data to create a FollowUp
     *   }
     * })
     * 
     */
    create<T extends FollowUpCreateArgs>(args: SelectSubset<T, FollowUpCreateArgs<ExtArgs>>): Prisma__FollowUpClient<$Result.GetResult<Prisma.$FollowUpPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FollowUps.
     * @param {FollowUpCreateManyArgs} args - Arguments to create many FollowUps.
     * @example
     * // Create many FollowUps
     * const followUp = await prisma.followUp.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FollowUpCreateManyArgs>(args?: SelectSubset<T, FollowUpCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FollowUps and returns the data saved in the database.
     * @param {FollowUpCreateManyAndReturnArgs} args - Arguments to create many FollowUps.
     * @example
     * // Create many FollowUps
     * const followUp = await prisma.followUp.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FollowUps and only return the `id`
     * const followUpWithIdOnly = await prisma.followUp.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FollowUpCreateManyAndReturnArgs>(args?: SelectSubset<T, FollowUpCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowUpPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FollowUp.
     * @param {FollowUpDeleteArgs} args - Arguments to delete one FollowUp.
     * @example
     * // Delete one FollowUp
     * const FollowUp = await prisma.followUp.delete({
     *   where: {
     *     // ... filter to delete one FollowUp
     *   }
     * })
     * 
     */
    delete<T extends FollowUpDeleteArgs>(args: SelectSubset<T, FollowUpDeleteArgs<ExtArgs>>): Prisma__FollowUpClient<$Result.GetResult<Prisma.$FollowUpPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FollowUp.
     * @param {FollowUpUpdateArgs} args - Arguments to update one FollowUp.
     * @example
     * // Update one FollowUp
     * const followUp = await prisma.followUp.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FollowUpUpdateArgs>(args: SelectSubset<T, FollowUpUpdateArgs<ExtArgs>>): Prisma__FollowUpClient<$Result.GetResult<Prisma.$FollowUpPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FollowUps.
     * @param {FollowUpDeleteManyArgs} args - Arguments to filter FollowUps to delete.
     * @example
     * // Delete a few FollowUps
     * const { count } = await prisma.followUp.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FollowUpDeleteManyArgs>(args?: SelectSubset<T, FollowUpDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FollowUps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowUpUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FollowUps
     * const followUp = await prisma.followUp.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FollowUpUpdateManyArgs>(args: SelectSubset<T, FollowUpUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FollowUps and returns the data updated in the database.
     * @param {FollowUpUpdateManyAndReturnArgs} args - Arguments to update many FollowUps.
     * @example
     * // Update many FollowUps
     * const followUp = await prisma.followUp.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FollowUps and only return the `id`
     * const followUpWithIdOnly = await prisma.followUp.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FollowUpUpdateManyAndReturnArgs>(args: SelectSubset<T, FollowUpUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowUpPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FollowUp.
     * @param {FollowUpUpsertArgs} args - Arguments to update or create a FollowUp.
     * @example
     * // Update or create a FollowUp
     * const followUp = await prisma.followUp.upsert({
     *   create: {
     *     // ... data to create a FollowUp
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FollowUp we want to update
     *   }
     * })
     */
    upsert<T extends FollowUpUpsertArgs>(args: SelectSubset<T, FollowUpUpsertArgs<ExtArgs>>): Prisma__FollowUpClient<$Result.GetResult<Prisma.$FollowUpPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FollowUps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowUpCountArgs} args - Arguments to filter FollowUps to count.
     * @example
     * // Count the number of FollowUps
     * const count = await prisma.followUp.count({
     *   where: {
     *     // ... the filter for the FollowUps we want to count
     *   }
     * })
    **/
    count<T extends FollowUpCountArgs>(
      args?: Subset<T, FollowUpCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FollowUpCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FollowUp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowUpAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FollowUpAggregateArgs>(args: Subset<T, FollowUpAggregateArgs>): Prisma.PrismaPromise<GetFollowUpAggregateType<T>>

    /**
     * Group by FollowUp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowUpGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FollowUpGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FollowUpGroupByArgs['orderBy'] }
        : { orderBy?: FollowUpGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FollowUpGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFollowUpGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FollowUp model
   */
  readonly fields: FollowUpFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FollowUp.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FollowUpClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    enquiry<T extends EnquiryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EnquiryDefaultArgs<ExtArgs>>): Prisma__EnquiryClient<$Result.GetResult<Prisma.$EnquiryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    notification<T extends FollowUp$notificationArgs<ExtArgs> = {}>(args?: Subset<T, FollowUp$notificationArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FollowUp model
   */
  interface FollowUpFieldRefs {
    readonly id: FieldRef<"FollowUp", 'String'>
    readonly enquiryId: FieldRef<"FollowUp", 'String'>
    readonly scheduledAt: FieldRef<"FollowUp", 'DateTime'>
    readonly doneAt: FieldRef<"FollowUp", 'DateTime'>
    readonly remark: FieldRef<"FollowUp", 'String'>
    readonly createdAt: FieldRef<"FollowUp", 'DateTime'>
    readonly followUpStatus: FieldRef<"FollowUp", 'FollowUpStatus'>
  }
    

  // Custom InputTypes
  /**
   * FollowUp findUnique
   */
  export type FollowUpFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowUp
     */
    select?: FollowUpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FollowUp
     */
    omit?: FollowUpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowUpInclude<ExtArgs> | null
    /**
     * Filter, which FollowUp to fetch.
     */
    where: FollowUpWhereUniqueInput
  }

  /**
   * FollowUp findUniqueOrThrow
   */
  export type FollowUpFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowUp
     */
    select?: FollowUpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FollowUp
     */
    omit?: FollowUpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowUpInclude<ExtArgs> | null
    /**
     * Filter, which FollowUp to fetch.
     */
    where: FollowUpWhereUniqueInput
  }

  /**
   * FollowUp findFirst
   */
  export type FollowUpFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowUp
     */
    select?: FollowUpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FollowUp
     */
    omit?: FollowUpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowUpInclude<ExtArgs> | null
    /**
     * Filter, which FollowUp to fetch.
     */
    where?: FollowUpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FollowUps to fetch.
     */
    orderBy?: FollowUpOrderByWithRelationInput | FollowUpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FollowUps.
     */
    cursor?: FollowUpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FollowUps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FollowUps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FollowUps.
     */
    distinct?: FollowUpScalarFieldEnum | FollowUpScalarFieldEnum[]
  }

  /**
   * FollowUp findFirstOrThrow
   */
  export type FollowUpFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowUp
     */
    select?: FollowUpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FollowUp
     */
    omit?: FollowUpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowUpInclude<ExtArgs> | null
    /**
     * Filter, which FollowUp to fetch.
     */
    where?: FollowUpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FollowUps to fetch.
     */
    orderBy?: FollowUpOrderByWithRelationInput | FollowUpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FollowUps.
     */
    cursor?: FollowUpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FollowUps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FollowUps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FollowUps.
     */
    distinct?: FollowUpScalarFieldEnum | FollowUpScalarFieldEnum[]
  }

  /**
   * FollowUp findMany
   */
  export type FollowUpFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowUp
     */
    select?: FollowUpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FollowUp
     */
    omit?: FollowUpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowUpInclude<ExtArgs> | null
    /**
     * Filter, which FollowUps to fetch.
     */
    where?: FollowUpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FollowUps to fetch.
     */
    orderBy?: FollowUpOrderByWithRelationInput | FollowUpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FollowUps.
     */
    cursor?: FollowUpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FollowUps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FollowUps.
     */
    skip?: number
    distinct?: FollowUpScalarFieldEnum | FollowUpScalarFieldEnum[]
  }

  /**
   * FollowUp create
   */
  export type FollowUpCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowUp
     */
    select?: FollowUpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FollowUp
     */
    omit?: FollowUpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowUpInclude<ExtArgs> | null
    /**
     * The data needed to create a FollowUp.
     */
    data: XOR<FollowUpCreateInput, FollowUpUncheckedCreateInput>
  }

  /**
   * FollowUp createMany
   */
  export type FollowUpCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FollowUps.
     */
    data: FollowUpCreateManyInput | FollowUpCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FollowUp createManyAndReturn
   */
  export type FollowUpCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowUp
     */
    select?: FollowUpSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FollowUp
     */
    omit?: FollowUpOmit<ExtArgs> | null
    /**
     * The data used to create many FollowUps.
     */
    data: FollowUpCreateManyInput | FollowUpCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowUpIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FollowUp update
   */
  export type FollowUpUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowUp
     */
    select?: FollowUpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FollowUp
     */
    omit?: FollowUpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowUpInclude<ExtArgs> | null
    /**
     * The data needed to update a FollowUp.
     */
    data: XOR<FollowUpUpdateInput, FollowUpUncheckedUpdateInput>
    /**
     * Choose, which FollowUp to update.
     */
    where: FollowUpWhereUniqueInput
  }

  /**
   * FollowUp updateMany
   */
  export type FollowUpUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FollowUps.
     */
    data: XOR<FollowUpUpdateManyMutationInput, FollowUpUncheckedUpdateManyInput>
    /**
     * Filter which FollowUps to update
     */
    where?: FollowUpWhereInput
    /**
     * Limit how many FollowUps to update.
     */
    limit?: number
  }

  /**
   * FollowUp updateManyAndReturn
   */
  export type FollowUpUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowUp
     */
    select?: FollowUpSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FollowUp
     */
    omit?: FollowUpOmit<ExtArgs> | null
    /**
     * The data used to update FollowUps.
     */
    data: XOR<FollowUpUpdateManyMutationInput, FollowUpUncheckedUpdateManyInput>
    /**
     * Filter which FollowUps to update
     */
    where?: FollowUpWhereInput
    /**
     * Limit how many FollowUps to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowUpIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FollowUp upsert
   */
  export type FollowUpUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowUp
     */
    select?: FollowUpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FollowUp
     */
    omit?: FollowUpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowUpInclude<ExtArgs> | null
    /**
     * The filter to search for the FollowUp to update in case it exists.
     */
    where: FollowUpWhereUniqueInput
    /**
     * In case the FollowUp found by the `where` argument doesn't exist, create a new FollowUp with this data.
     */
    create: XOR<FollowUpCreateInput, FollowUpUncheckedCreateInput>
    /**
     * In case the FollowUp was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FollowUpUpdateInput, FollowUpUncheckedUpdateInput>
  }

  /**
   * FollowUp delete
   */
  export type FollowUpDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowUp
     */
    select?: FollowUpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FollowUp
     */
    omit?: FollowUpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowUpInclude<ExtArgs> | null
    /**
     * Filter which FollowUp to delete.
     */
    where: FollowUpWhereUniqueInput
  }

  /**
   * FollowUp deleteMany
   */
  export type FollowUpDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FollowUps to delete
     */
    where?: FollowUpWhereInput
    /**
     * Limit how many FollowUps to delete.
     */
    limit?: number
  }

  /**
   * FollowUp.notification
   */
  export type FollowUp$notificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
  }

  /**
   * FollowUp without action
   */
  export type FollowUpDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowUp
     */
    select?: FollowUpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FollowUp
     */
    omit?: FollowUpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowUpInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationAvgAggregateOutputType = {
    paymentId: number | null
  }

  export type NotificationSumAggregateOutputType = {
    paymentId: number | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    message: string | null
    seen: boolean | null
    createdAt: Date | null
    followUpId: string | null
    enquiryId: string | null
    paymentId: number | null
    clientAdminId: string | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    message: string | null
    seen: boolean | null
    createdAt: Date | null
    followUpId: string | null
    enquiryId: string | null
    paymentId: number | null
    clientAdminId: string | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    message: number
    seen: number
    createdAt: number
    followUpId: number
    enquiryId: number
    paymentId: number
    clientAdminId: number
    _all: number
  }


  export type NotificationAvgAggregateInputType = {
    paymentId?: true
  }

  export type NotificationSumAggregateInputType = {
    paymentId?: true
  }

  export type NotificationMinAggregateInputType = {
    id?: true
    message?: true
    seen?: true
    createdAt?: true
    followUpId?: true
    enquiryId?: true
    paymentId?: true
    clientAdminId?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    message?: true
    seen?: true
    createdAt?: true
    followUpId?: true
    enquiryId?: true
    paymentId?: true
    clientAdminId?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    message?: true
    seen?: true
    createdAt?: true
    followUpId?: true
    enquiryId?: true
    paymentId?: true
    clientAdminId?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _avg?: NotificationAvgAggregateInputType
    _sum?: NotificationSumAggregateInputType
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    message: string
    seen: boolean
    createdAt: Date
    followUpId: string | null
    enquiryId: string | null
    paymentId: number | null
    clientAdminId: string
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    message?: boolean
    seen?: boolean
    createdAt?: boolean
    followUpId?: boolean
    enquiryId?: boolean
    paymentId?: boolean
    clientAdminId?: boolean
    followUp?: boolean | Notification$followUpArgs<ExtArgs>
    enquiry?: boolean | Notification$enquiryArgs<ExtArgs>
    payment?: boolean | Notification$paymentArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    message?: boolean
    seen?: boolean
    createdAt?: boolean
    followUpId?: boolean
    enquiryId?: boolean
    paymentId?: boolean
    clientAdminId?: boolean
    followUp?: boolean | Notification$followUpArgs<ExtArgs>
    enquiry?: boolean | Notification$enquiryArgs<ExtArgs>
    payment?: boolean | Notification$paymentArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    message?: boolean
    seen?: boolean
    createdAt?: boolean
    followUpId?: boolean
    enquiryId?: boolean
    paymentId?: boolean
    clientAdminId?: boolean
    followUp?: boolean | Notification$followUpArgs<ExtArgs>
    enquiry?: boolean | Notification$enquiryArgs<ExtArgs>
    payment?: boolean | Notification$paymentArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    message?: boolean
    seen?: boolean
    createdAt?: boolean
    followUpId?: boolean
    enquiryId?: boolean
    paymentId?: boolean
    clientAdminId?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "message" | "seen" | "createdAt" | "followUpId" | "enquiryId" | "paymentId" | "clientAdminId", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    followUp?: boolean | Notification$followUpArgs<ExtArgs>
    enquiry?: boolean | Notification$enquiryArgs<ExtArgs>
    payment?: boolean | Notification$paymentArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    followUp?: boolean | Notification$followUpArgs<ExtArgs>
    enquiry?: boolean | Notification$enquiryArgs<ExtArgs>
    payment?: boolean | Notification$paymentArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    followUp?: boolean | Notification$followUpArgs<ExtArgs>
    enquiry?: boolean | Notification$enquiryArgs<ExtArgs>
    payment?: boolean | Notification$paymentArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      followUp: Prisma.$FollowUpPayload<ExtArgs> | null
      enquiry: Prisma.$EnquiryPayload<ExtArgs> | null
      payment: Prisma.$StudentFeePayload<ExtArgs> | null
      clientAdmin: Prisma.$ClientAdminPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      message: string
      seen: boolean
      createdAt: Date
      followUpId: string | null
      enquiryId: string | null
      paymentId: number | null
      clientAdminId: string
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    followUp<T extends Notification$followUpArgs<ExtArgs> = {}>(args?: Subset<T, Notification$followUpArgs<ExtArgs>>): Prisma__FollowUpClient<$Result.GetResult<Prisma.$FollowUpPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    enquiry<T extends Notification$enquiryArgs<ExtArgs> = {}>(args?: Subset<T, Notification$enquiryArgs<ExtArgs>>): Prisma__EnquiryClient<$Result.GetResult<Prisma.$EnquiryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    payment<T extends Notification$paymentArgs<ExtArgs> = {}>(args?: Subset<T, Notification$paymentArgs<ExtArgs>>): Prisma__StudentFeeClient<$Result.GetResult<Prisma.$StudentFeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    clientAdmin<T extends ClientAdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientAdminDefaultArgs<ExtArgs>>): Prisma__ClientAdminClient<$Result.GetResult<Prisma.$ClientAdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly seen: FieldRef<"Notification", 'Boolean'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly followUpId: FieldRef<"Notification", 'String'>
    readonly enquiryId: FieldRef<"Notification", 'String'>
    readonly paymentId: FieldRef<"Notification", 'Int'>
    readonly clientAdminId: FieldRef<"Notification", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification.followUp
   */
  export type Notification$followUpArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FollowUp
     */
    select?: FollowUpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FollowUp
     */
    omit?: FollowUpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowUpInclude<ExtArgs> | null
    where?: FollowUpWhereInput
  }

  /**
   * Notification.enquiry
   */
  export type Notification$enquiryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enquiry
     */
    select?: EnquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enquiry
     */
    omit?: EnquiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnquiryInclude<ExtArgs> | null
    where?: EnquiryWhereInput
  }

  /**
   * Notification.payment
   */
  export type Notification$paymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentFee
     */
    select?: StudentFeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentFee
     */
    omit?: StudentFeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentFeeInclude<ExtArgs> | null
    where?: StudentFeeWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model Student
   */

  export type AggregateStudent = {
    _count: StudentCountAggregateOutputType | null
    _avg: StudentAvgAggregateOutputType | null
    _sum: StudentSumAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  export type StudentAvgAggregateOutputType = {
    id: number | null
    serialNumber: number | null
  }

  export type StudentSumAggregateOutputType = {
    id: number | null
    serialNumber: number | null
  }

  export type StudentMinAggregateOutputType = {
    id: number | null
    serialNumber: number | null
    studentCode: string | null
    fullName: string | null
    fatherName: string | null
    motherName: string | null
    photoUrl: string | null
    contact: string | null
    parentsContact: string | null
    email: string | null
    residentialAddress: string | null
    permenantAddress: string | null
    dob: string | null
    gender: string | null
    religion: string | null
    idProofType: string | null
    idProofNumber: string | null
    admissionDate: Date | null
    clientAdminId: string | null
  }

  export type StudentMaxAggregateOutputType = {
    id: number | null
    serialNumber: number | null
    studentCode: string | null
    fullName: string | null
    fatherName: string | null
    motherName: string | null
    photoUrl: string | null
    contact: string | null
    parentsContact: string | null
    email: string | null
    residentialAddress: string | null
    permenantAddress: string | null
    dob: string | null
    gender: string | null
    religion: string | null
    idProofType: string | null
    idProofNumber: string | null
    admissionDate: Date | null
    clientAdminId: string | null
  }

  export type StudentCountAggregateOutputType = {
    id: number
    serialNumber: number
    studentCode: number
    fullName: number
    fatherName: number
    motherName: number
    photoUrl: number
    contact: number
    parentsContact: number
    email: number
    residentialAddress: number
    permenantAddress: number
    dob: number
    gender: number
    religion: number
    idProofType: number
    idProofNumber: number
    admissionDate: number
    clientAdminId: number
    _all: number
  }


  export type StudentAvgAggregateInputType = {
    id?: true
    serialNumber?: true
  }

  export type StudentSumAggregateInputType = {
    id?: true
    serialNumber?: true
  }

  export type StudentMinAggregateInputType = {
    id?: true
    serialNumber?: true
    studentCode?: true
    fullName?: true
    fatherName?: true
    motherName?: true
    photoUrl?: true
    contact?: true
    parentsContact?: true
    email?: true
    residentialAddress?: true
    permenantAddress?: true
    dob?: true
    gender?: true
    religion?: true
    idProofType?: true
    idProofNumber?: true
    admissionDate?: true
    clientAdminId?: true
  }

  export type StudentMaxAggregateInputType = {
    id?: true
    serialNumber?: true
    studentCode?: true
    fullName?: true
    fatherName?: true
    motherName?: true
    photoUrl?: true
    contact?: true
    parentsContact?: true
    email?: true
    residentialAddress?: true
    permenantAddress?: true
    dob?: true
    gender?: true
    religion?: true
    idProofType?: true
    idProofNumber?: true
    admissionDate?: true
    clientAdminId?: true
  }

  export type StudentCountAggregateInputType = {
    id?: true
    serialNumber?: true
    studentCode?: true
    fullName?: true
    fatherName?: true
    motherName?: true
    photoUrl?: true
    contact?: true
    parentsContact?: true
    email?: true
    residentialAddress?: true
    permenantAddress?: true
    dob?: true
    gender?: true
    religion?: true
    idProofType?: true
    idProofNumber?: true
    admissionDate?: true
    clientAdminId?: true
    _all?: true
  }

  export type StudentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Student to aggregate.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Students
    **/
    _count?: true | StudentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentMaxAggregateInputType
  }

  export type GetStudentAggregateType<T extends StudentAggregateArgs> = {
        [P in keyof T & keyof AggregateStudent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudent[P]>
      : GetScalarType<T[P], AggregateStudent[P]>
  }




  export type StudentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithAggregationInput | StudentOrderByWithAggregationInput[]
    by: StudentScalarFieldEnum[] | StudentScalarFieldEnum
    having?: StudentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentCountAggregateInputType | true
    _avg?: StudentAvgAggregateInputType
    _sum?: StudentSumAggregateInputType
    _min?: StudentMinAggregateInputType
    _max?: StudentMaxAggregateInputType
  }

  export type StudentGroupByOutputType = {
    id: number
    serialNumber: number
    studentCode: string
    fullName: string
    fatherName: string
    motherName: string
    photoUrl: string | null
    contact: string
    parentsContact: string
    email: string | null
    residentialAddress: string | null
    permenantAddress: string | null
    dob: string
    gender: string
    religion: string | null
    idProofType: string | null
    idProofNumber: string | null
    admissionDate: Date
    clientAdminId: string
    _count: StudentCountAggregateOutputType | null
    _avg: StudentAvgAggregateOutputType | null
    _sum: StudentSumAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  type GetStudentGroupByPayload<T extends StudentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentGroupByOutputType[P]>
            : GetScalarType<T[P], StudentGroupByOutputType[P]>
        }
      >
    >


  export type StudentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serialNumber?: boolean
    studentCode?: boolean
    fullName?: boolean
    fatherName?: boolean
    motherName?: boolean
    photoUrl?: boolean
    contact?: boolean
    parentsContact?: boolean
    email?: boolean
    residentialAddress?: boolean
    permenantAddress?: boolean
    dob?: boolean
    gender?: boolean
    religion?: boolean
    idProofType?: boolean
    idProofNumber?: boolean
    admissionDate?: boolean
    clientAdminId?: boolean
    enquiry?: boolean | Student$enquiryArgs<ExtArgs>
    labAllocations?: boolean | Student$labAllocationsArgs<ExtArgs>
    studentCourses?: boolean | Student$studentCoursesArgs<ExtArgs>
    feeStructures?: boolean | Student$feeStructuresArgs<ExtArgs>
    feeRecords?: boolean | Student$feeRecordsArgs<ExtArgs>
    attendance?: boolean | Student$attendanceArgs<ExtArgs>
    tasks?: boolean | Student$tasksArgs<ExtArgs>
    tests?: boolean | Student$testsArgs<ExtArgs>
    completions?: boolean | Student$completionsArgs<ExtArgs>
    stationery?: boolean | Student$stationeryArgs<ExtArgs>
    certificates?: boolean | Student$certificatesArgs<ExtArgs>
    financialRecords?: boolean | Student$financialRecordsArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
    _count?: boolean | StudentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["student"]>

  export type StudentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serialNumber?: boolean
    studentCode?: boolean
    fullName?: boolean
    fatherName?: boolean
    motherName?: boolean
    photoUrl?: boolean
    contact?: boolean
    parentsContact?: boolean
    email?: boolean
    residentialAddress?: boolean
    permenantAddress?: boolean
    dob?: boolean
    gender?: boolean
    religion?: boolean
    idProofType?: boolean
    idProofNumber?: boolean
    admissionDate?: boolean
    clientAdminId?: boolean
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["student"]>

  export type StudentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serialNumber?: boolean
    studentCode?: boolean
    fullName?: boolean
    fatherName?: boolean
    motherName?: boolean
    photoUrl?: boolean
    contact?: boolean
    parentsContact?: boolean
    email?: boolean
    residentialAddress?: boolean
    permenantAddress?: boolean
    dob?: boolean
    gender?: boolean
    religion?: boolean
    idProofType?: boolean
    idProofNumber?: boolean
    admissionDate?: boolean
    clientAdminId?: boolean
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["student"]>

  export type StudentSelectScalar = {
    id?: boolean
    serialNumber?: boolean
    studentCode?: boolean
    fullName?: boolean
    fatherName?: boolean
    motherName?: boolean
    photoUrl?: boolean
    contact?: boolean
    parentsContact?: boolean
    email?: boolean
    residentialAddress?: boolean
    permenantAddress?: boolean
    dob?: boolean
    gender?: boolean
    religion?: boolean
    idProofType?: boolean
    idProofNumber?: boolean
    admissionDate?: boolean
    clientAdminId?: boolean
  }

  export type StudentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "serialNumber" | "studentCode" | "fullName" | "fatherName" | "motherName" | "photoUrl" | "contact" | "parentsContact" | "email" | "residentialAddress" | "permenantAddress" | "dob" | "gender" | "religion" | "idProofType" | "idProofNumber" | "admissionDate" | "clientAdminId", ExtArgs["result"]["student"]>
  export type StudentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    enquiry?: boolean | Student$enquiryArgs<ExtArgs>
    labAllocations?: boolean | Student$labAllocationsArgs<ExtArgs>
    studentCourses?: boolean | Student$studentCoursesArgs<ExtArgs>
    feeStructures?: boolean | Student$feeStructuresArgs<ExtArgs>
    feeRecords?: boolean | Student$feeRecordsArgs<ExtArgs>
    attendance?: boolean | Student$attendanceArgs<ExtArgs>
    tasks?: boolean | Student$tasksArgs<ExtArgs>
    tests?: boolean | Student$testsArgs<ExtArgs>
    completions?: boolean | Student$completionsArgs<ExtArgs>
    stationery?: boolean | Student$stationeryArgs<ExtArgs>
    certificates?: boolean | Student$certificatesArgs<ExtArgs>
    financialRecords?: boolean | Student$financialRecordsArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
    _count?: boolean | StudentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StudentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }
  export type StudentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }

  export type $StudentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Student"
    objects: {
      enquiry: Prisma.$EnquiryPayload<ExtArgs> | null
      labAllocations: Prisma.$LabAllocationPayload<ExtArgs>[]
      studentCourses: Prisma.$StudentCoursePayload<ExtArgs>[]
      feeStructures: Prisma.$FeeStructurePayload<ExtArgs>[]
      feeRecords: Prisma.$StudentFeePayload<ExtArgs>[]
      attendance: Prisma.$AttendanceRecordPayload<ExtArgs>[]
      tasks: Prisma.$StudentTaskPayload<ExtArgs>[]
      tests: Prisma.$StudentTestPayload<ExtArgs>[]
      completions: Prisma.$CourseCompletionPayload<ExtArgs>[]
      stationery: Prisma.$StationeryIssuePayload<ExtArgs>[]
      certificates: Prisma.$CertificatePayload<ExtArgs>[]
      financialRecords: Prisma.$FinancialRecordPayload<ExtArgs>[]
      clientAdmin: Prisma.$ClientAdminPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      serialNumber: number
      studentCode: string
      fullName: string
      fatherName: string
      motherName: string
      photoUrl: string | null
      contact: string
      parentsContact: string
      email: string | null
      residentialAddress: string | null
      permenantAddress: string | null
      dob: string
      gender: string
      religion: string | null
      idProofType: string | null
      idProofNumber: string | null
      admissionDate: Date
      clientAdminId: string
    }, ExtArgs["result"]["student"]>
    composites: {}
  }

  type StudentGetPayload<S extends boolean | null | undefined | StudentDefaultArgs> = $Result.GetResult<Prisma.$StudentPayload, S>

  type StudentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentCountAggregateInputType | true
    }

  export interface StudentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Student'], meta: { name: 'Student' } }
    /**
     * Find zero or one Student that matches the filter.
     * @param {StudentFindUniqueArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentFindUniqueArgs>(args: SelectSubset<T, StudentFindUniqueArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Student that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudentFindUniqueOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Student that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindFirstArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentFindFirstArgs>(args?: SelectSubset<T, StudentFindFirstArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Student that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindFirstOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Students that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Students
     * const students = await prisma.student.findMany()
     * 
     * // Get first 10 Students
     * const students = await prisma.student.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentWithIdOnly = await prisma.student.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentFindManyArgs>(args?: SelectSubset<T, StudentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Student.
     * @param {StudentCreateArgs} args - Arguments to create a Student.
     * @example
     * // Create one Student
     * const Student = await prisma.student.create({
     *   data: {
     *     // ... data to create a Student
     *   }
     * })
     * 
     */
    create<T extends StudentCreateArgs>(args: SelectSubset<T, StudentCreateArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Students.
     * @param {StudentCreateManyArgs} args - Arguments to create many Students.
     * @example
     * // Create many Students
     * const student = await prisma.student.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentCreateManyArgs>(args?: SelectSubset<T, StudentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Students and returns the data saved in the database.
     * @param {StudentCreateManyAndReturnArgs} args - Arguments to create many Students.
     * @example
     * // Create many Students
     * const student = await prisma.student.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Students and only return the `id`
     * const studentWithIdOnly = await prisma.student.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Student.
     * @param {StudentDeleteArgs} args - Arguments to delete one Student.
     * @example
     * // Delete one Student
     * const Student = await prisma.student.delete({
     *   where: {
     *     // ... filter to delete one Student
     *   }
     * })
     * 
     */
    delete<T extends StudentDeleteArgs>(args: SelectSubset<T, StudentDeleteArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Student.
     * @param {StudentUpdateArgs} args - Arguments to update one Student.
     * @example
     * // Update one Student
     * const student = await prisma.student.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentUpdateArgs>(args: SelectSubset<T, StudentUpdateArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Students.
     * @param {StudentDeleteManyArgs} args - Arguments to filter Students to delete.
     * @example
     * // Delete a few Students
     * const { count } = await prisma.student.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentDeleteManyArgs>(args?: SelectSubset<T, StudentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Students
     * const student = await prisma.student.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentUpdateManyArgs>(args: SelectSubset<T, StudentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Students and returns the data updated in the database.
     * @param {StudentUpdateManyAndReturnArgs} args - Arguments to update many Students.
     * @example
     * // Update many Students
     * const student = await prisma.student.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Students and only return the `id`
     * const studentWithIdOnly = await prisma.student.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StudentUpdateManyAndReturnArgs>(args: SelectSubset<T, StudentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Student.
     * @param {StudentUpsertArgs} args - Arguments to update or create a Student.
     * @example
     * // Update or create a Student
     * const student = await prisma.student.upsert({
     *   create: {
     *     // ... data to create a Student
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Student we want to update
     *   }
     * })
     */
    upsert<T extends StudentUpsertArgs>(args: SelectSubset<T, StudentUpsertArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentCountArgs} args - Arguments to filter Students to count.
     * @example
     * // Count the number of Students
     * const count = await prisma.student.count({
     *   where: {
     *     // ... the filter for the Students we want to count
     *   }
     * })
    **/
    count<T extends StudentCountArgs>(
      args?: Subset<T, StudentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentAggregateArgs>(args: Subset<T, StudentAggregateArgs>): Prisma.PrismaPromise<GetStudentAggregateType<T>>

    /**
     * Group by Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentGroupByArgs['orderBy'] }
        : { orderBy?: StudentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Student model
   */
  readonly fields: StudentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Student.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    enquiry<T extends Student$enquiryArgs<ExtArgs> = {}>(args?: Subset<T, Student$enquiryArgs<ExtArgs>>): Prisma__EnquiryClient<$Result.GetResult<Prisma.$EnquiryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    labAllocations<T extends Student$labAllocationsArgs<ExtArgs> = {}>(args?: Subset<T, Student$labAllocationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabAllocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    studentCourses<T extends Student$studentCoursesArgs<ExtArgs> = {}>(args?: Subset<T, Student$studentCoursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentCoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    feeStructures<T extends Student$feeStructuresArgs<ExtArgs> = {}>(args?: Subset<T, Student$feeStructuresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeeStructurePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    feeRecords<T extends Student$feeRecordsArgs<ExtArgs> = {}>(args?: Subset<T, Student$feeRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentFeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attendance<T extends Student$attendanceArgs<ExtArgs> = {}>(args?: Subset<T, Student$attendanceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tasks<T extends Student$tasksArgs<ExtArgs> = {}>(args?: Subset<T, Student$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tests<T extends Student$testsArgs<ExtArgs> = {}>(args?: Subset<T, Student$testsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentTestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    completions<T extends Student$completionsArgs<ExtArgs> = {}>(args?: Subset<T, Student$completionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseCompletionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    stationery<T extends Student$stationeryArgs<ExtArgs> = {}>(args?: Subset<T, Student$stationeryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StationeryIssuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    certificates<T extends Student$certificatesArgs<ExtArgs> = {}>(args?: Subset<T, Student$certificatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    financialRecords<T extends Student$financialRecordsArgs<ExtArgs> = {}>(args?: Subset<T, Student$financialRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinancialRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    clientAdmin<T extends ClientAdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientAdminDefaultArgs<ExtArgs>>): Prisma__ClientAdminClient<$Result.GetResult<Prisma.$ClientAdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Student model
   */
  interface StudentFieldRefs {
    readonly id: FieldRef<"Student", 'Int'>
    readonly serialNumber: FieldRef<"Student", 'Int'>
    readonly studentCode: FieldRef<"Student", 'String'>
    readonly fullName: FieldRef<"Student", 'String'>
    readonly fatherName: FieldRef<"Student", 'String'>
    readonly motherName: FieldRef<"Student", 'String'>
    readonly photoUrl: FieldRef<"Student", 'String'>
    readonly contact: FieldRef<"Student", 'String'>
    readonly parentsContact: FieldRef<"Student", 'String'>
    readonly email: FieldRef<"Student", 'String'>
    readonly residentialAddress: FieldRef<"Student", 'String'>
    readonly permenantAddress: FieldRef<"Student", 'String'>
    readonly dob: FieldRef<"Student", 'String'>
    readonly gender: FieldRef<"Student", 'String'>
    readonly religion: FieldRef<"Student", 'String'>
    readonly idProofType: FieldRef<"Student", 'String'>
    readonly idProofNumber: FieldRef<"Student", 'String'>
    readonly admissionDate: FieldRef<"Student", 'DateTime'>
    readonly clientAdminId: FieldRef<"Student", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Student findUnique
   */
  export type StudentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student findUniqueOrThrow
   */
  export type StudentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student findFirst
   */
  export type StudentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Students.
     */
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student findFirstOrThrow
   */
  export type StudentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Students.
     */
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student findMany
   */
  export type StudentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Students to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student create
   */
  export type StudentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The data needed to create a Student.
     */
    data: XOR<StudentCreateInput, StudentUncheckedCreateInput>
  }

  /**
   * Student createMany
   */
  export type StudentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Students.
     */
    data: StudentCreateManyInput | StudentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Student createManyAndReturn
   */
  export type StudentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * The data used to create many Students.
     */
    data: StudentCreateManyInput | StudentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Student update
   */
  export type StudentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The data needed to update a Student.
     */
    data: XOR<StudentUpdateInput, StudentUncheckedUpdateInput>
    /**
     * Choose, which Student to update.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student updateMany
   */
  export type StudentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Students.
     */
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyInput>
    /**
     * Filter which Students to update
     */
    where?: StudentWhereInput
    /**
     * Limit how many Students to update.
     */
    limit?: number
  }

  /**
   * Student updateManyAndReturn
   */
  export type StudentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * The data used to update Students.
     */
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyInput>
    /**
     * Filter which Students to update
     */
    where?: StudentWhereInput
    /**
     * Limit how many Students to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Student upsert
   */
  export type StudentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The filter to search for the Student to update in case it exists.
     */
    where: StudentWhereUniqueInput
    /**
     * In case the Student found by the `where` argument doesn't exist, create a new Student with this data.
     */
    create: XOR<StudentCreateInput, StudentUncheckedCreateInput>
    /**
     * In case the Student was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentUpdateInput, StudentUncheckedUpdateInput>
  }

  /**
   * Student delete
   */
  export type StudentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter which Student to delete.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student deleteMany
   */
  export type StudentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Students to delete
     */
    where?: StudentWhereInput
    /**
     * Limit how many Students to delete.
     */
    limit?: number
  }

  /**
   * Student.enquiry
   */
  export type Student$enquiryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enquiry
     */
    select?: EnquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enquiry
     */
    omit?: EnquiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnquiryInclude<ExtArgs> | null
    where?: EnquiryWhereInput
  }

  /**
   * Student.labAllocations
   */
  export type Student$labAllocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabAllocation
     */
    select?: LabAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabAllocation
     */
    omit?: LabAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabAllocationInclude<ExtArgs> | null
    where?: LabAllocationWhereInput
    orderBy?: LabAllocationOrderByWithRelationInput | LabAllocationOrderByWithRelationInput[]
    cursor?: LabAllocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LabAllocationScalarFieldEnum | LabAllocationScalarFieldEnum[]
  }

  /**
   * Student.studentCourses
   */
  export type Student$studentCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentCourse
     */
    select?: StudentCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentCourse
     */
    omit?: StudentCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentCourseInclude<ExtArgs> | null
    where?: StudentCourseWhereInput
    orderBy?: StudentCourseOrderByWithRelationInput | StudentCourseOrderByWithRelationInput[]
    cursor?: StudentCourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentCourseScalarFieldEnum | StudentCourseScalarFieldEnum[]
  }

  /**
   * Student.feeStructures
   */
  export type Student$feeStructuresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeStructure
     */
    select?: FeeStructureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeStructure
     */
    omit?: FeeStructureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeStructureInclude<ExtArgs> | null
    where?: FeeStructureWhereInput
    orderBy?: FeeStructureOrderByWithRelationInput | FeeStructureOrderByWithRelationInput[]
    cursor?: FeeStructureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeeStructureScalarFieldEnum | FeeStructureScalarFieldEnum[]
  }

  /**
   * Student.feeRecords
   */
  export type Student$feeRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentFee
     */
    select?: StudentFeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentFee
     */
    omit?: StudentFeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentFeeInclude<ExtArgs> | null
    where?: StudentFeeWhereInput
    orderBy?: StudentFeeOrderByWithRelationInput | StudentFeeOrderByWithRelationInput[]
    cursor?: StudentFeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentFeeScalarFieldEnum | StudentFeeScalarFieldEnum[]
  }

  /**
   * Student.attendance
   */
  export type Student$attendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceRecord
     */
    omit?: AttendanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    where?: AttendanceRecordWhereInput
    orderBy?: AttendanceRecordOrderByWithRelationInput | AttendanceRecordOrderByWithRelationInput[]
    cursor?: AttendanceRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceRecordScalarFieldEnum | AttendanceRecordScalarFieldEnum[]
  }

  /**
   * Student.tasks
   */
  export type Student$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTask
     */
    select?: StudentTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentTask
     */
    omit?: StudentTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTaskInclude<ExtArgs> | null
    where?: StudentTaskWhereInput
    orderBy?: StudentTaskOrderByWithRelationInput | StudentTaskOrderByWithRelationInput[]
    cursor?: StudentTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentTaskScalarFieldEnum | StudentTaskScalarFieldEnum[]
  }

  /**
   * Student.tests
   */
  export type Student$testsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTest
     */
    select?: StudentTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentTest
     */
    omit?: StudentTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTestInclude<ExtArgs> | null
    where?: StudentTestWhereInput
    orderBy?: StudentTestOrderByWithRelationInput | StudentTestOrderByWithRelationInput[]
    cursor?: StudentTestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentTestScalarFieldEnum | StudentTestScalarFieldEnum[]
  }

  /**
   * Student.completions
   */
  export type Student$completionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseCompletion
     */
    select?: CourseCompletionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseCompletion
     */
    omit?: CourseCompletionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseCompletionInclude<ExtArgs> | null
    where?: CourseCompletionWhereInput
    orderBy?: CourseCompletionOrderByWithRelationInput | CourseCompletionOrderByWithRelationInput[]
    cursor?: CourseCompletionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseCompletionScalarFieldEnum | CourseCompletionScalarFieldEnum[]
  }

  /**
   * Student.stationery
   */
  export type Student$stationeryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StationeryIssue
     */
    select?: StationeryIssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StationeryIssue
     */
    omit?: StationeryIssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StationeryIssueInclude<ExtArgs> | null
    where?: StationeryIssueWhereInput
    orderBy?: StationeryIssueOrderByWithRelationInput | StationeryIssueOrderByWithRelationInput[]
    cursor?: StationeryIssueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StationeryIssueScalarFieldEnum | StationeryIssueScalarFieldEnum[]
  }

  /**
   * Student.certificates
   */
  export type Student$certificatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    where?: CertificateWhereInput
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    cursor?: CertificateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CertificateScalarFieldEnum | CertificateScalarFieldEnum[]
  }

  /**
   * Student.financialRecords
   */
  export type Student$financialRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialRecord
     */
    select?: FinancialRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialRecord
     */
    omit?: FinancialRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialRecordInclude<ExtArgs> | null
    where?: FinancialRecordWhereInput
    orderBy?: FinancialRecordOrderByWithRelationInput | FinancialRecordOrderByWithRelationInput[]
    cursor?: FinancialRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FinancialRecordScalarFieldEnum | FinancialRecordScalarFieldEnum[]
  }

  /**
   * Student without action
   */
  export type StudentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
  }


  /**
   * Model Course
   */

  export type AggregateCourse = {
    _count: CourseCountAggregateOutputType | null
    _avg: CourseAvgAggregateOutputType | null
    _sum: CourseSumAggregateOutputType | null
    _min: CourseMinAggregateOutputType | null
    _max: CourseMaxAggregateOutputType | null
  }

  export type CourseAvgAggregateOutputType = {
    id: number | null
    durationWeeks: number | null
  }

  export type CourseSumAggregateOutputType = {
    id: number | null
    durationWeeks: number | null
  }

  export type CourseMinAggregateOutputType = {
    id: number | null
    name: string | null
    durationWeeks: number | null
    description: string | null
    clientAdminId: string | null
  }

  export type CourseMaxAggregateOutputType = {
    id: number | null
    name: string | null
    durationWeeks: number | null
    description: string | null
    clientAdminId: string | null
  }

  export type CourseCountAggregateOutputType = {
    id: number
    name: number
    durationWeeks: number
    description: number
    clientAdminId: number
    _all: number
  }


  export type CourseAvgAggregateInputType = {
    id?: true
    durationWeeks?: true
  }

  export type CourseSumAggregateInputType = {
    id?: true
    durationWeeks?: true
  }

  export type CourseMinAggregateInputType = {
    id?: true
    name?: true
    durationWeeks?: true
    description?: true
    clientAdminId?: true
  }

  export type CourseMaxAggregateInputType = {
    id?: true
    name?: true
    durationWeeks?: true
    description?: true
    clientAdminId?: true
  }

  export type CourseCountAggregateInputType = {
    id?: true
    name?: true
    durationWeeks?: true
    description?: true
    clientAdminId?: true
    _all?: true
  }

  export type CourseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Course to aggregate.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Courses
    **/
    _count?: true | CourseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CourseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CourseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseMaxAggregateInputType
  }

  export type GetCourseAggregateType<T extends CourseAggregateArgs> = {
        [P in keyof T & keyof AggregateCourse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourse[P]>
      : GetScalarType<T[P], AggregateCourse[P]>
  }




  export type CourseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseWhereInput
    orderBy?: CourseOrderByWithAggregationInput | CourseOrderByWithAggregationInput[]
    by: CourseScalarFieldEnum[] | CourseScalarFieldEnum
    having?: CourseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseCountAggregateInputType | true
    _avg?: CourseAvgAggregateInputType
    _sum?: CourseSumAggregateInputType
    _min?: CourseMinAggregateInputType
    _max?: CourseMaxAggregateInputType
  }

  export type CourseGroupByOutputType = {
    id: number
    name: string
    durationWeeks: number
    description: string | null
    clientAdminId: string
    _count: CourseCountAggregateOutputType | null
    _avg: CourseAvgAggregateOutputType | null
    _sum: CourseSumAggregateOutputType | null
    _min: CourseMinAggregateOutputType | null
    _max: CourseMaxAggregateOutputType | null
  }

  type GetCourseGroupByPayload<T extends CourseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseGroupByOutputType[P]>
            : GetScalarType<T[P], CourseGroupByOutputType[P]>
        }
      >
    >


  export type CourseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    durationWeeks?: boolean
    description?: boolean
    clientAdminId?: boolean
    courseFeeStructure?: boolean | Course$courseFeeStructureArgs<ExtArgs>
    studentCourses?: boolean | Course$studentCoursesArgs<ExtArgs>
    enquiryCourse?: boolean | Course$enquiryCourseArgs<ExtArgs>
    feeStructures?: boolean | Course$feeStructuresArgs<ExtArgs>
    stationery?: boolean | Course$stationeryArgs<ExtArgs>
    studentFees?: boolean | Course$studentFeesArgs<ExtArgs>
    attendanceRecords?: boolean | Course$attendanceRecordsArgs<ExtArgs>
    studentTasks?: boolean | Course$studentTasksArgs<ExtArgs>
    studentTests?: boolean | Course$studentTestsArgs<ExtArgs>
    certificates?: boolean | Course$certificatesArgs<ExtArgs>
    financialRecords?: boolean | Course$financialRecordsArgs<ExtArgs>
    batchCourses?: boolean | Course$batchCoursesArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
    _count?: boolean | CourseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["course"]>

  export type CourseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    durationWeeks?: boolean
    description?: boolean
    clientAdminId?: boolean
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["course"]>

  export type CourseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    durationWeeks?: boolean
    description?: boolean
    clientAdminId?: boolean
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["course"]>

  export type CourseSelectScalar = {
    id?: boolean
    name?: boolean
    durationWeeks?: boolean
    description?: boolean
    clientAdminId?: boolean
  }

  export type CourseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "durationWeeks" | "description" | "clientAdminId", ExtArgs["result"]["course"]>
  export type CourseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courseFeeStructure?: boolean | Course$courseFeeStructureArgs<ExtArgs>
    studentCourses?: boolean | Course$studentCoursesArgs<ExtArgs>
    enquiryCourse?: boolean | Course$enquiryCourseArgs<ExtArgs>
    feeStructures?: boolean | Course$feeStructuresArgs<ExtArgs>
    stationery?: boolean | Course$stationeryArgs<ExtArgs>
    studentFees?: boolean | Course$studentFeesArgs<ExtArgs>
    attendanceRecords?: boolean | Course$attendanceRecordsArgs<ExtArgs>
    studentTasks?: boolean | Course$studentTasksArgs<ExtArgs>
    studentTests?: boolean | Course$studentTestsArgs<ExtArgs>
    certificates?: boolean | Course$certificatesArgs<ExtArgs>
    financialRecords?: boolean | Course$financialRecordsArgs<ExtArgs>
    batchCourses?: boolean | Course$batchCoursesArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
    _count?: boolean | CourseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CourseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }
  export type CourseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }

  export type $CoursePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Course"
    objects: {
      courseFeeStructure: Prisma.$CourseFeeStructurePayload<ExtArgs> | null
      studentCourses: Prisma.$StudentCoursePayload<ExtArgs>[]
      enquiryCourse: Prisma.$EnquiryCoursePayload<ExtArgs>[]
      feeStructures: Prisma.$FeeStructurePayload<ExtArgs>[]
      stationery: Prisma.$StationeryIssuePayload<ExtArgs>[]
      studentFees: Prisma.$StudentFeePayload<ExtArgs>[]
      attendanceRecords: Prisma.$AttendanceRecordPayload<ExtArgs>[]
      studentTasks: Prisma.$StudentTaskPayload<ExtArgs>[]
      studentTests: Prisma.$StudentTestPayload<ExtArgs>[]
      certificates: Prisma.$CertificatePayload<ExtArgs>[]
      financialRecords: Prisma.$FinancialRecordPayload<ExtArgs>[]
      batchCourses: Prisma.$BatchCoursePayload<ExtArgs>[]
      clientAdmin: Prisma.$ClientAdminPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      durationWeeks: number
      description: string | null
      clientAdminId: string
    }, ExtArgs["result"]["course"]>
    composites: {}
  }

  type CourseGetPayload<S extends boolean | null | undefined | CourseDefaultArgs> = $Result.GetResult<Prisma.$CoursePayload, S>

  type CourseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CourseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CourseCountAggregateInputType | true
    }

  export interface CourseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Course'], meta: { name: 'Course' } }
    /**
     * Find zero or one Course that matches the filter.
     * @param {CourseFindUniqueArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseFindUniqueArgs>(args: SelectSubset<T, CourseFindUniqueArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Course that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CourseFindUniqueOrThrowArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Course that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindFirstArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseFindFirstArgs>(args?: SelectSubset<T, CourseFindFirstArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Course that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindFirstOrThrowArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Courses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Courses
     * const courses = await prisma.course.findMany()
     * 
     * // Get first 10 Courses
     * const courses = await prisma.course.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courseWithIdOnly = await prisma.course.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CourseFindManyArgs>(args?: SelectSubset<T, CourseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Course.
     * @param {CourseCreateArgs} args - Arguments to create a Course.
     * @example
     * // Create one Course
     * const Course = await prisma.course.create({
     *   data: {
     *     // ... data to create a Course
     *   }
     * })
     * 
     */
    create<T extends CourseCreateArgs>(args: SelectSubset<T, CourseCreateArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Courses.
     * @param {CourseCreateManyArgs} args - Arguments to create many Courses.
     * @example
     * // Create many Courses
     * const course = await prisma.course.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseCreateManyArgs>(args?: SelectSubset<T, CourseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Courses and returns the data saved in the database.
     * @param {CourseCreateManyAndReturnArgs} args - Arguments to create many Courses.
     * @example
     * // Create many Courses
     * const course = await prisma.course.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Courses and only return the `id`
     * const courseWithIdOnly = await prisma.course.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CourseCreateManyAndReturnArgs>(args?: SelectSubset<T, CourseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Course.
     * @param {CourseDeleteArgs} args - Arguments to delete one Course.
     * @example
     * // Delete one Course
     * const Course = await prisma.course.delete({
     *   where: {
     *     // ... filter to delete one Course
     *   }
     * })
     * 
     */
    delete<T extends CourseDeleteArgs>(args: SelectSubset<T, CourseDeleteArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Course.
     * @param {CourseUpdateArgs} args - Arguments to update one Course.
     * @example
     * // Update one Course
     * const course = await prisma.course.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseUpdateArgs>(args: SelectSubset<T, CourseUpdateArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Courses.
     * @param {CourseDeleteManyArgs} args - Arguments to filter Courses to delete.
     * @example
     * // Delete a few Courses
     * const { count } = await prisma.course.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseDeleteManyArgs>(args?: SelectSubset<T, CourseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Courses
     * const course = await prisma.course.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseUpdateManyArgs>(args: SelectSubset<T, CourseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Courses and returns the data updated in the database.
     * @param {CourseUpdateManyAndReturnArgs} args - Arguments to update many Courses.
     * @example
     * // Update many Courses
     * const course = await prisma.course.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Courses and only return the `id`
     * const courseWithIdOnly = await prisma.course.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CourseUpdateManyAndReturnArgs>(args: SelectSubset<T, CourseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Course.
     * @param {CourseUpsertArgs} args - Arguments to update or create a Course.
     * @example
     * // Update or create a Course
     * const course = await prisma.course.upsert({
     *   create: {
     *     // ... data to create a Course
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Course we want to update
     *   }
     * })
     */
    upsert<T extends CourseUpsertArgs>(args: SelectSubset<T, CourseUpsertArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseCountArgs} args - Arguments to filter Courses to count.
     * @example
     * // Count the number of Courses
     * const count = await prisma.course.count({
     *   where: {
     *     // ... the filter for the Courses we want to count
     *   }
     * })
    **/
    count<T extends CourseCountArgs>(
      args?: Subset<T, CourseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Course.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseAggregateArgs>(args: Subset<T, CourseAggregateArgs>): Prisma.PrismaPromise<GetCourseAggregateType<T>>

    /**
     * Group by Course.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseGroupByArgs['orderBy'] }
        : { orderBy?: CourseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Course model
   */
  readonly fields: CourseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Course.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    courseFeeStructure<T extends Course$courseFeeStructureArgs<ExtArgs> = {}>(args?: Subset<T, Course$courseFeeStructureArgs<ExtArgs>>): Prisma__CourseFeeStructureClient<$Result.GetResult<Prisma.$CourseFeeStructurePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    studentCourses<T extends Course$studentCoursesArgs<ExtArgs> = {}>(args?: Subset<T, Course$studentCoursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentCoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    enquiryCourse<T extends Course$enquiryCourseArgs<ExtArgs> = {}>(args?: Subset<T, Course$enquiryCourseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnquiryCoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    feeStructures<T extends Course$feeStructuresArgs<ExtArgs> = {}>(args?: Subset<T, Course$feeStructuresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeeStructurePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    stationery<T extends Course$stationeryArgs<ExtArgs> = {}>(args?: Subset<T, Course$stationeryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StationeryIssuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    studentFees<T extends Course$studentFeesArgs<ExtArgs> = {}>(args?: Subset<T, Course$studentFeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentFeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attendanceRecords<T extends Course$attendanceRecordsArgs<ExtArgs> = {}>(args?: Subset<T, Course$attendanceRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    studentTasks<T extends Course$studentTasksArgs<ExtArgs> = {}>(args?: Subset<T, Course$studentTasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    studentTests<T extends Course$studentTestsArgs<ExtArgs> = {}>(args?: Subset<T, Course$studentTestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentTestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    certificates<T extends Course$certificatesArgs<ExtArgs> = {}>(args?: Subset<T, Course$certificatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    financialRecords<T extends Course$financialRecordsArgs<ExtArgs> = {}>(args?: Subset<T, Course$financialRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinancialRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    batchCourses<T extends Course$batchCoursesArgs<ExtArgs> = {}>(args?: Subset<T, Course$batchCoursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchCoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    clientAdmin<T extends ClientAdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientAdminDefaultArgs<ExtArgs>>): Prisma__ClientAdminClient<$Result.GetResult<Prisma.$ClientAdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Course model
   */
  interface CourseFieldRefs {
    readonly id: FieldRef<"Course", 'Int'>
    readonly name: FieldRef<"Course", 'String'>
    readonly durationWeeks: FieldRef<"Course", 'Int'>
    readonly description: FieldRef<"Course", 'String'>
    readonly clientAdminId: FieldRef<"Course", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Course findUnique
   */
  export type CourseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course findUniqueOrThrow
   */
  export type CourseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course findFirst
   */
  export type CourseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courses.
     */
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course findFirstOrThrow
   */
  export type CourseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courses.
     */
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course findMany
   */
  export type CourseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Courses to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course create
   */
  export type CourseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The data needed to create a Course.
     */
    data: XOR<CourseCreateInput, CourseUncheckedCreateInput>
  }

  /**
   * Course createMany
   */
  export type CourseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Courses.
     */
    data: CourseCreateManyInput | CourseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Course createManyAndReturn
   */
  export type CourseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * The data used to create many Courses.
     */
    data: CourseCreateManyInput | CourseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Course update
   */
  export type CourseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The data needed to update a Course.
     */
    data: XOR<CourseUpdateInput, CourseUncheckedUpdateInput>
    /**
     * Choose, which Course to update.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course updateMany
   */
  export type CourseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Courses.
     */
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyInput>
    /**
     * Filter which Courses to update
     */
    where?: CourseWhereInput
    /**
     * Limit how many Courses to update.
     */
    limit?: number
  }

  /**
   * Course updateManyAndReturn
   */
  export type CourseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * The data used to update Courses.
     */
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyInput>
    /**
     * Filter which Courses to update
     */
    where?: CourseWhereInput
    /**
     * Limit how many Courses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Course upsert
   */
  export type CourseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The filter to search for the Course to update in case it exists.
     */
    where: CourseWhereUniqueInput
    /**
     * In case the Course found by the `where` argument doesn't exist, create a new Course with this data.
     */
    create: XOR<CourseCreateInput, CourseUncheckedCreateInput>
    /**
     * In case the Course was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseUpdateInput, CourseUncheckedUpdateInput>
  }

  /**
   * Course delete
   */
  export type CourseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter which Course to delete.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course deleteMany
   */
  export type CourseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Courses to delete
     */
    where?: CourseWhereInput
    /**
     * Limit how many Courses to delete.
     */
    limit?: number
  }

  /**
   * Course.courseFeeStructure
   */
  export type Course$courseFeeStructureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseFeeStructure
     */
    select?: CourseFeeStructureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseFeeStructure
     */
    omit?: CourseFeeStructureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseFeeStructureInclude<ExtArgs> | null
    where?: CourseFeeStructureWhereInput
  }

  /**
   * Course.studentCourses
   */
  export type Course$studentCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentCourse
     */
    select?: StudentCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentCourse
     */
    omit?: StudentCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentCourseInclude<ExtArgs> | null
    where?: StudentCourseWhereInput
    orderBy?: StudentCourseOrderByWithRelationInput | StudentCourseOrderByWithRelationInput[]
    cursor?: StudentCourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentCourseScalarFieldEnum | StudentCourseScalarFieldEnum[]
  }

  /**
   * Course.enquiryCourse
   */
  export type Course$enquiryCourseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnquiryCourse
     */
    select?: EnquiryCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EnquiryCourse
     */
    omit?: EnquiryCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnquiryCourseInclude<ExtArgs> | null
    where?: EnquiryCourseWhereInput
    orderBy?: EnquiryCourseOrderByWithRelationInput | EnquiryCourseOrderByWithRelationInput[]
    cursor?: EnquiryCourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EnquiryCourseScalarFieldEnum | EnquiryCourseScalarFieldEnum[]
  }

  /**
   * Course.feeStructures
   */
  export type Course$feeStructuresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeStructure
     */
    select?: FeeStructureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeStructure
     */
    omit?: FeeStructureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeStructureInclude<ExtArgs> | null
    where?: FeeStructureWhereInput
    orderBy?: FeeStructureOrderByWithRelationInput | FeeStructureOrderByWithRelationInput[]
    cursor?: FeeStructureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeeStructureScalarFieldEnum | FeeStructureScalarFieldEnum[]
  }

  /**
   * Course.stationery
   */
  export type Course$stationeryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StationeryIssue
     */
    select?: StationeryIssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StationeryIssue
     */
    omit?: StationeryIssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StationeryIssueInclude<ExtArgs> | null
    where?: StationeryIssueWhereInput
    orderBy?: StationeryIssueOrderByWithRelationInput | StationeryIssueOrderByWithRelationInput[]
    cursor?: StationeryIssueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StationeryIssueScalarFieldEnum | StationeryIssueScalarFieldEnum[]
  }

  /**
   * Course.studentFees
   */
  export type Course$studentFeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentFee
     */
    select?: StudentFeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentFee
     */
    omit?: StudentFeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentFeeInclude<ExtArgs> | null
    where?: StudentFeeWhereInput
    orderBy?: StudentFeeOrderByWithRelationInput | StudentFeeOrderByWithRelationInput[]
    cursor?: StudentFeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentFeeScalarFieldEnum | StudentFeeScalarFieldEnum[]
  }

  /**
   * Course.attendanceRecords
   */
  export type Course$attendanceRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceRecord
     */
    omit?: AttendanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    where?: AttendanceRecordWhereInput
    orderBy?: AttendanceRecordOrderByWithRelationInput | AttendanceRecordOrderByWithRelationInput[]
    cursor?: AttendanceRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceRecordScalarFieldEnum | AttendanceRecordScalarFieldEnum[]
  }

  /**
   * Course.studentTasks
   */
  export type Course$studentTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTask
     */
    select?: StudentTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentTask
     */
    omit?: StudentTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTaskInclude<ExtArgs> | null
    where?: StudentTaskWhereInput
    orderBy?: StudentTaskOrderByWithRelationInput | StudentTaskOrderByWithRelationInput[]
    cursor?: StudentTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentTaskScalarFieldEnum | StudentTaskScalarFieldEnum[]
  }

  /**
   * Course.studentTests
   */
  export type Course$studentTestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTest
     */
    select?: StudentTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentTest
     */
    omit?: StudentTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTestInclude<ExtArgs> | null
    where?: StudentTestWhereInput
    orderBy?: StudentTestOrderByWithRelationInput | StudentTestOrderByWithRelationInput[]
    cursor?: StudentTestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentTestScalarFieldEnum | StudentTestScalarFieldEnum[]
  }

  /**
   * Course.certificates
   */
  export type Course$certificatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    where?: CertificateWhereInput
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    cursor?: CertificateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CertificateScalarFieldEnum | CertificateScalarFieldEnum[]
  }

  /**
   * Course.financialRecords
   */
  export type Course$financialRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialRecord
     */
    select?: FinancialRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialRecord
     */
    omit?: FinancialRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialRecordInclude<ExtArgs> | null
    where?: FinancialRecordWhereInput
    orderBy?: FinancialRecordOrderByWithRelationInput | FinancialRecordOrderByWithRelationInput[]
    cursor?: FinancialRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FinancialRecordScalarFieldEnum | FinancialRecordScalarFieldEnum[]
  }

  /**
   * Course.batchCourses
   */
  export type Course$batchCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchCourse
     */
    select?: BatchCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchCourse
     */
    omit?: BatchCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchCourseInclude<ExtArgs> | null
    where?: BatchCourseWhereInput
    orderBy?: BatchCourseOrderByWithRelationInput | BatchCourseOrderByWithRelationInput[]
    cursor?: BatchCourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BatchCourseScalarFieldEnum | BatchCourseScalarFieldEnum[]
  }

  /**
   * Course without action
   */
  export type CourseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
  }


  /**
   * Model CourseFeeStructure
   */

  export type AggregateCourseFeeStructure = {
    _count: CourseFeeStructureCountAggregateOutputType | null
    _avg: CourseFeeStructureAvgAggregateOutputType | null
    _sum: CourseFeeStructureSumAggregateOutputType | null
    _min: CourseFeeStructureMinAggregateOutputType | null
    _max: CourseFeeStructureMaxAggregateOutputType | null
  }

  export type CourseFeeStructureAvgAggregateOutputType = {
    id: number | null
    courseId: number | null
    totalAmount: number | null
  }

  export type CourseFeeStructureSumAggregateOutputType = {
    id: number | null
    courseId: number | null
    totalAmount: number | null
  }

  export type CourseFeeStructureMinAggregateOutputType = {
    id: number | null
    courseId: number | null
    totalAmount: number | null
    clientAdminId: string | null
  }

  export type CourseFeeStructureMaxAggregateOutputType = {
    id: number | null
    courseId: number | null
    totalAmount: number | null
    clientAdminId: string | null
  }

  export type CourseFeeStructureCountAggregateOutputType = {
    id: number
    courseId: number
    totalAmount: number
    paymentType: number
    clientAdminId: number
    _all: number
  }


  export type CourseFeeStructureAvgAggregateInputType = {
    id?: true
    courseId?: true
    totalAmount?: true
  }

  export type CourseFeeStructureSumAggregateInputType = {
    id?: true
    courseId?: true
    totalAmount?: true
  }

  export type CourseFeeStructureMinAggregateInputType = {
    id?: true
    courseId?: true
    totalAmount?: true
    clientAdminId?: true
  }

  export type CourseFeeStructureMaxAggregateInputType = {
    id?: true
    courseId?: true
    totalAmount?: true
    clientAdminId?: true
  }

  export type CourseFeeStructureCountAggregateInputType = {
    id?: true
    courseId?: true
    totalAmount?: true
    paymentType?: true
    clientAdminId?: true
    _all?: true
  }

  export type CourseFeeStructureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseFeeStructure to aggregate.
     */
    where?: CourseFeeStructureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseFeeStructures to fetch.
     */
    orderBy?: CourseFeeStructureOrderByWithRelationInput | CourseFeeStructureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseFeeStructureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseFeeStructures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseFeeStructures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CourseFeeStructures
    **/
    _count?: true | CourseFeeStructureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CourseFeeStructureAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CourseFeeStructureSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseFeeStructureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseFeeStructureMaxAggregateInputType
  }

  export type GetCourseFeeStructureAggregateType<T extends CourseFeeStructureAggregateArgs> = {
        [P in keyof T & keyof AggregateCourseFeeStructure]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourseFeeStructure[P]>
      : GetScalarType<T[P], AggregateCourseFeeStructure[P]>
  }




  export type CourseFeeStructureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseFeeStructureWhereInput
    orderBy?: CourseFeeStructureOrderByWithAggregationInput | CourseFeeStructureOrderByWithAggregationInput[]
    by: CourseFeeStructureScalarFieldEnum[] | CourseFeeStructureScalarFieldEnum
    having?: CourseFeeStructureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseFeeStructureCountAggregateInputType | true
    _avg?: CourseFeeStructureAvgAggregateInputType
    _sum?: CourseFeeStructureSumAggregateInputType
    _min?: CourseFeeStructureMinAggregateInputType
    _max?: CourseFeeStructureMaxAggregateInputType
  }

  export type CourseFeeStructureGroupByOutputType = {
    id: number
    courseId: number
    totalAmount: number
    paymentType: string[]
    clientAdminId: string
    _count: CourseFeeStructureCountAggregateOutputType | null
    _avg: CourseFeeStructureAvgAggregateOutputType | null
    _sum: CourseFeeStructureSumAggregateOutputType | null
    _min: CourseFeeStructureMinAggregateOutputType | null
    _max: CourseFeeStructureMaxAggregateOutputType | null
  }

  type GetCourseFeeStructureGroupByPayload<T extends CourseFeeStructureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseFeeStructureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseFeeStructureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseFeeStructureGroupByOutputType[P]>
            : GetScalarType<T[P], CourseFeeStructureGroupByOutputType[P]>
        }
      >
    >


  export type CourseFeeStructureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    totalAmount?: boolean
    paymentType?: boolean
    clientAdminId?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    installments?: boolean | CourseFeeStructure$installmentsArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
    _count?: boolean | CourseFeeStructureCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseFeeStructure"]>

  export type CourseFeeStructureSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    totalAmount?: boolean
    paymentType?: boolean
    clientAdminId?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseFeeStructure"]>

  export type CourseFeeStructureSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    totalAmount?: boolean
    paymentType?: boolean
    clientAdminId?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseFeeStructure"]>

  export type CourseFeeStructureSelectScalar = {
    id?: boolean
    courseId?: boolean
    totalAmount?: boolean
    paymentType?: boolean
    clientAdminId?: boolean
  }

  export type CourseFeeStructureOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "courseId" | "totalAmount" | "paymentType" | "clientAdminId", ExtArgs["result"]["courseFeeStructure"]>
  export type CourseFeeStructureInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    installments?: boolean | CourseFeeStructure$installmentsArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
    _count?: boolean | CourseFeeStructureCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CourseFeeStructureIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }
  export type CourseFeeStructureIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }

  export type $CourseFeeStructurePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CourseFeeStructure"
    objects: {
      course: Prisma.$CoursePayload<ExtArgs>
      installments: Prisma.$InstallmentDetailPayload<ExtArgs>[]
      clientAdmin: Prisma.$ClientAdminPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      courseId: number
      totalAmount: number
      paymentType: string[]
      clientAdminId: string
    }, ExtArgs["result"]["courseFeeStructure"]>
    composites: {}
  }

  type CourseFeeStructureGetPayload<S extends boolean | null | undefined | CourseFeeStructureDefaultArgs> = $Result.GetResult<Prisma.$CourseFeeStructurePayload, S>

  type CourseFeeStructureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CourseFeeStructureFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CourseFeeStructureCountAggregateInputType | true
    }

  export interface CourseFeeStructureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CourseFeeStructure'], meta: { name: 'CourseFeeStructure' } }
    /**
     * Find zero or one CourseFeeStructure that matches the filter.
     * @param {CourseFeeStructureFindUniqueArgs} args - Arguments to find a CourseFeeStructure
     * @example
     * // Get one CourseFeeStructure
     * const courseFeeStructure = await prisma.courseFeeStructure.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseFeeStructureFindUniqueArgs>(args: SelectSubset<T, CourseFeeStructureFindUniqueArgs<ExtArgs>>): Prisma__CourseFeeStructureClient<$Result.GetResult<Prisma.$CourseFeeStructurePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CourseFeeStructure that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CourseFeeStructureFindUniqueOrThrowArgs} args - Arguments to find a CourseFeeStructure
     * @example
     * // Get one CourseFeeStructure
     * const courseFeeStructure = await prisma.courseFeeStructure.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseFeeStructureFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseFeeStructureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseFeeStructureClient<$Result.GetResult<Prisma.$CourseFeeStructurePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CourseFeeStructure that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFeeStructureFindFirstArgs} args - Arguments to find a CourseFeeStructure
     * @example
     * // Get one CourseFeeStructure
     * const courseFeeStructure = await prisma.courseFeeStructure.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseFeeStructureFindFirstArgs>(args?: SelectSubset<T, CourseFeeStructureFindFirstArgs<ExtArgs>>): Prisma__CourseFeeStructureClient<$Result.GetResult<Prisma.$CourseFeeStructurePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CourseFeeStructure that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFeeStructureFindFirstOrThrowArgs} args - Arguments to find a CourseFeeStructure
     * @example
     * // Get one CourseFeeStructure
     * const courseFeeStructure = await prisma.courseFeeStructure.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseFeeStructureFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseFeeStructureFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseFeeStructureClient<$Result.GetResult<Prisma.$CourseFeeStructurePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CourseFeeStructures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFeeStructureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CourseFeeStructures
     * const courseFeeStructures = await prisma.courseFeeStructure.findMany()
     * 
     * // Get first 10 CourseFeeStructures
     * const courseFeeStructures = await prisma.courseFeeStructure.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courseFeeStructureWithIdOnly = await prisma.courseFeeStructure.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CourseFeeStructureFindManyArgs>(args?: SelectSubset<T, CourseFeeStructureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseFeeStructurePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CourseFeeStructure.
     * @param {CourseFeeStructureCreateArgs} args - Arguments to create a CourseFeeStructure.
     * @example
     * // Create one CourseFeeStructure
     * const CourseFeeStructure = await prisma.courseFeeStructure.create({
     *   data: {
     *     // ... data to create a CourseFeeStructure
     *   }
     * })
     * 
     */
    create<T extends CourseFeeStructureCreateArgs>(args: SelectSubset<T, CourseFeeStructureCreateArgs<ExtArgs>>): Prisma__CourseFeeStructureClient<$Result.GetResult<Prisma.$CourseFeeStructurePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CourseFeeStructures.
     * @param {CourseFeeStructureCreateManyArgs} args - Arguments to create many CourseFeeStructures.
     * @example
     * // Create many CourseFeeStructures
     * const courseFeeStructure = await prisma.courseFeeStructure.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseFeeStructureCreateManyArgs>(args?: SelectSubset<T, CourseFeeStructureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CourseFeeStructures and returns the data saved in the database.
     * @param {CourseFeeStructureCreateManyAndReturnArgs} args - Arguments to create many CourseFeeStructures.
     * @example
     * // Create many CourseFeeStructures
     * const courseFeeStructure = await prisma.courseFeeStructure.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CourseFeeStructures and only return the `id`
     * const courseFeeStructureWithIdOnly = await prisma.courseFeeStructure.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CourseFeeStructureCreateManyAndReturnArgs>(args?: SelectSubset<T, CourseFeeStructureCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseFeeStructurePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CourseFeeStructure.
     * @param {CourseFeeStructureDeleteArgs} args - Arguments to delete one CourseFeeStructure.
     * @example
     * // Delete one CourseFeeStructure
     * const CourseFeeStructure = await prisma.courseFeeStructure.delete({
     *   where: {
     *     // ... filter to delete one CourseFeeStructure
     *   }
     * })
     * 
     */
    delete<T extends CourseFeeStructureDeleteArgs>(args: SelectSubset<T, CourseFeeStructureDeleteArgs<ExtArgs>>): Prisma__CourseFeeStructureClient<$Result.GetResult<Prisma.$CourseFeeStructurePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CourseFeeStructure.
     * @param {CourseFeeStructureUpdateArgs} args - Arguments to update one CourseFeeStructure.
     * @example
     * // Update one CourseFeeStructure
     * const courseFeeStructure = await prisma.courseFeeStructure.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseFeeStructureUpdateArgs>(args: SelectSubset<T, CourseFeeStructureUpdateArgs<ExtArgs>>): Prisma__CourseFeeStructureClient<$Result.GetResult<Prisma.$CourseFeeStructurePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CourseFeeStructures.
     * @param {CourseFeeStructureDeleteManyArgs} args - Arguments to filter CourseFeeStructures to delete.
     * @example
     * // Delete a few CourseFeeStructures
     * const { count } = await prisma.courseFeeStructure.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseFeeStructureDeleteManyArgs>(args?: SelectSubset<T, CourseFeeStructureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseFeeStructures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFeeStructureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CourseFeeStructures
     * const courseFeeStructure = await prisma.courseFeeStructure.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseFeeStructureUpdateManyArgs>(args: SelectSubset<T, CourseFeeStructureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseFeeStructures and returns the data updated in the database.
     * @param {CourseFeeStructureUpdateManyAndReturnArgs} args - Arguments to update many CourseFeeStructures.
     * @example
     * // Update many CourseFeeStructures
     * const courseFeeStructure = await prisma.courseFeeStructure.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CourseFeeStructures and only return the `id`
     * const courseFeeStructureWithIdOnly = await prisma.courseFeeStructure.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CourseFeeStructureUpdateManyAndReturnArgs>(args: SelectSubset<T, CourseFeeStructureUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseFeeStructurePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CourseFeeStructure.
     * @param {CourseFeeStructureUpsertArgs} args - Arguments to update or create a CourseFeeStructure.
     * @example
     * // Update or create a CourseFeeStructure
     * const courseFeeStructure = await prisma.courseFeeStructure.upsert({
     *   create: {
     *     // ... data to create a CourseFeeStructure
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CourseFeeStructure we want to update
     *   }
     * })
     */
    upsert<T extends CourseFeeStructureUpsertArgs>(args: SelectSubset<T, CourseFeeStructureUpsertArgs<ExtArgs>>): Prisma__CourseFeeStructureClient<$Result.GetResult<Prisma.$CourseFeeStructurePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CourseFeeStructures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFeeStructureCountArgs} args - Arguments to filter CourseFeeStructures to count.
     * @example
     * // Count the number of CourseFeeStructures
     * const count = await prisma.courseFeeStructure.count({
     *   where: {
     *     // ... the filter for the CourseFeeStructures we want to count
     *   }
     * })
    **/
    count<T extends CourseFeeStructureCountArgs>(
      args?: Subset<T, CourseFeeStructureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseFeeStructureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CourseFeeStructure.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFeeStructureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseFeeStructureAggregateArgs>(args: Subset<T, CourseFeeStructureAggregateArgs>): Prisma.PrismaPromise<GetCourseFeeStructureAggregateType<T>>

    /**
     * Group by CourseFeeStructure.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFeeStructureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseFeeStructureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseFeeStructureGroupByArgs['orderBy'] }
        : { orderBy?: CourseFeeStructureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseFeeStructureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseFeeStructureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CourseFeeStructure model
   */
  readonly fields: CourseFeeStructureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CourseFeeStructure.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseFeeStructureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    installments<T extends CourseFeeStructure$installmentsArgs<ExtArgs> = {}>(args?: Subset<T, CourseFeeStructure$installmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstallmentDetailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    clientAdmin<T extends ClientAdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientAdminDefaultArgs<ExtArgs>>): Prisma__ClientAdminClient<$Result.GetResult<Prisma.$ClientAdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CourseFeeStructure model
   */
  interface CourseFeeStructureFieldRefs {
    readonly id: FieldRef<"CourseFeeStructure", 'Int'>
    readonly courseId: FieldRef<"CourseFeeStructure", 'Int'>
    readonly totalAmount: FieldRef<"CourseFeeStructure", 'Float'>
    readonly paymentType: FieldRef<"CourseFeeStructure", 'String[]'>
    readonly clientAdminId: FieldRef<"CourseFeeStructure", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CourseFeeStructure findUnique
   */
  export type CourseFeeStructureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseFeeStructure
     */
    select?: CourseFeeStructureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseFeeStructure
     */
    omit?: CourseFeeStructureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseFeeStructureInclude<ExtArgs> | null
    /**
     * Filter, which CourseFeeStructure to fetch.
     */
    where: CourseFeeStructureWhereUniqueInput
  }

  /**
   * CourseFeeStructure findUniqueOrThrow
   */
  export type CourseFeeStructureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseFeeStructure
     */
    select?: CourseFeeStructureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseFeeStructure
     */
    omit?: CourseFeeStructureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseFeeStructureInclude<ExtArgs> | null
    /**
     * Filter, which CourseFeeStructure to fetch.
     */
    where: CourseFeeStructureWhereUniqueInput
  }

  /**
   * CourseFeeStructure findFirst
   */
  export type CourseFeeStructureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseFeeStructure
     */
    select?: CourseFeeStructureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseFeeStructure
     */
    omit?: CourseFeeStructureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseFeeStructureInclude<ExtArgs> | null
    /**
     * Filter, which CourseFeeStructure to fetch.
     */
    where?: CourseFeeStructureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseFeeStructures to fetch.
     */
    orderBy?: CourseFeeStructureOrderByWithRelationInput | CourseFeeStructureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseFeeStructures.
     */
    cursor?: CourseFeeStructureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseFeeStructures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseFeeStructures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseFeeStructures.
     */
    distinct?: CourseFeeStructureScalarFieldEnum | CourseFeeStructureScalarFieldEnum[]
  }

  /**
   * CourseFeeStructure findFirstOrThrow
   */
  export type CourseFeeStructureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseFeeStructure
     */
    select?: CourseFeeStructureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseFeeStructure
     */
    omit?: CourseFeeStructureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseFeeStructureInclude<ExtArgs> | null
    /**
     * Filter, which CourseFeeStructure to fetch.
     */
    where?: CourseFeeStructureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseFeeStructures to fetch.
     */
    orderBy?: CourseFeeStructureOrderByWithRelationInput | CourseFeeStructureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseFeeStructures.
     */
    cursor?: CourseFeeStructureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseFeeStructures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseFeeStructures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseFeeStructures.
     */
    distinct?: CourseFeeStructureScalarFieldEnum | CourseFeeStructureScalarFieldEnum[]
  }

  /**
   * CourseFeeStructure findMany
   */
  export type CourseFeeStructureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseFeeStructure
     */
    select?: CourseFeeStructureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseFeeStructure
     */
    omit?: CourseFeeStructureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseFeeStructureInclude<ExtArgs> | null
    /**
     * Filter, which CourseFeeStructures to fetch.
     */
    where?: CourseFeeStructureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseFeeStructures to fetch.
     */
    orderBy?: CourseFeeStructureOrderByWithRelationInput | CourseFeeStructureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CourseFeeStructures.
     */
    cursor?: CourseFeeStructureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseFeeStructures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseFeeStructures.
     */
    skip?: number
    distinct?: CourseFeeStructureScalarFieldEnum | CourseFeeStructureScalarFieldEnum[]
  }

  /**
   * CourseFeeStructure create
   */
  export type CourseFeeStructureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseFeeStructure
     */
    select?: CourseFeeStructureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseFeeStructure
     */
    omit?: CourseFeeStructureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseFeeStructureInclude<ExtArgs> | null
    /**
     * The data needed to create a CourseFeeStructure.
     */
    data: XOR<CourseFeeStructureCreateInput, CourseFeeStructureUncheckedCreateInput>
  }

  /**
   * CourseFeeStructure createMany
   */
  export type CourseFeeStructureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CourseFeeStructures.
     */
    data: CourseFeeStructureCreateManyInput | CourseFeeStructureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CourseFeeStructure createManyAndReturn
   */
  export type CourseFeeStructureCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseFeeStructure
     */
    select?: CourseFeeStructureSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CourseFeeStructure
     */
    omit?: CourseFeeStructureOmit<ExtArgs> | null
    /**
     * The data used to create many CourseFeeStructures.
     */
    data: CourseFeeStructureCreateManyInput | CourseFeeStructureCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseFeeStructureIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CourseFeeStructure update
   */
  export type CourseFeeStructureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseFeeStructure
     */
    select?: CourseFeeStructureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseFeeStructure
     */
    omit?: CourseFeeStructureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseFeeStructureInclude<ExtArgs> | null
    /**
     * The data needed to update a CourseFeeStructure.
     */
    data: XOR<CourseFeeStructureUpdateInput, CourseFeeStructureUncheckedUpdateInput>
    /**
     * Choose, which CourseFeeStructure to update.
     */
    where: CourseFeeStructureWhereUniqueInput
  }

  /**
   * CourseFeeStructure updateMany
   */
  export type CourseFeeStructureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CourseFeeStructures.
     */
    data: XOR<CourseFeeStructureUpdateManyMutationInput, CourseFeeStructureUncheckedUpdateManyInput>
    /**
     * Filter which CourseFeeStructures to update
     */
    where?: CourseFeeStructureWhereInput
    /**
     * Limit how many CourseFeeStructures to update.
     */
    limit?: number
  }

  /**
   * CourseFeeStructure updateManyAndReturn
   */
  export type CourseFeeStructureUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseFeeStructure
     */
    select?: CourseFeeStructureSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CourseFeeStructure
     */
    omit?: CourseFeeStructureOmit<ExtArgs> | null
    /**
     * The data used to update CourseFeeStructures.
     */
    data: XOR<CourseFeeStructureUpdateManyMutationInput, CourseFeeStructureUncheckedUpdateManyInput>
    /**
     * Filter which CourseFeeStructures to update
     */
    where?: CourseFeeStructureWhereInput
    /**
     * Limit how many CourseFeeStructures to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseFeeStructureIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CourseFeeStructure upsert
   */
  export type CourseFeeStructureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseFeeStructure
     */
    select?: CourseFeeStructureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseFeeStructure
     */
    omit?: CourseFeeStructureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseFeeStructureInclude<ExtArgs> | null
    /**
     * The filter to search for the CourseFeeStructure to update in case it exists.
     */
    where: CourseFeeStructureWhereUniqueInput
    /**
     * In case the CourseFeeStructure found by the `where` argument doesn't exist, create a new CourseFeeStructure with this data.
     */
    create: XOR<CourseFeeStructureCreateInput, CourseFeeStructureUncheckedCreateInput>
    /**
     * In case the CourseFeeStructure was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseFeeStructureUpdateInput, CourseFeeStructureUncheckedUpdateInput>
  }

  /**
   * CourseFeeStructure delete
   */
  export type CourseFeeStructureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseFeeStructure
     */
    select?: CourseFeeStructureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseFeeStructure
     */
    omit?: CourseFeeStructureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseFeeStructureInclude<ExtArgs> | null
    /**
     * Filter which CourseFeeStructure to delete.
     */
    where: CourseFeeStructureWhereUniqueInput
  }

  /**
   * CourseFeeStructure deleteMany
   */
  export type CourseFeeStructureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseFeeStructures to delete
     */
    where?: CourseFeeStructureWhereInput
    /**
     * Limit how many CourseFeeStructures to delete.
     */
    limit?: number
  }

  /**
   * CourseFeeStructure.installments
   */
  export type CourseFeeStructure$installmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstallmentDetail
     */
    select?: InstallmentDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstallmentDetail
     */
    omit?: InstallmentDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallmentDetailInclude<ExtArgs> | null
    where?: InstallmentDetailWhereInput
    orderBy?: InstallmentDetailOrderByWithRelationInput | InstallmentDetailOrderByWithRelationInput[]
    cursor?: InstallmentDetailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InstallmentDetailScalarFieldEnum | InstallmentDetailScalarFieldEnum[]
  }

  /**
   * CourseFeeStructure without action
   */
  export type CourseFeeStructureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseFeeStructure
     */
    select?: CourseFeeStructureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseFeeStructure
     */
    omit?: CourseFeeStructureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseFeeStructureInclude<ExtArgs> | null
  }


  /**
   * Model Batch
   */

  export type AggregateBatch = {
    _count: BatchCountAggregateOutputType | null
    _avg: BatchAvgAggregateOutputType | null
    _sum: BatchSumAggregateOutputType | null
    _min: BatchMinAggregateOutputType | null
    _max: BatchMaxAggregateOutputType | null
  }

  export type BatchAvgAggregateOutputType = {
    id: number | null
    facultyId: number | null
    labTimeSlotId: number | null
  }

  export type BatchSumAggregateOutputType = {
    id: number | null
    facultyId: number | null
    labTimeSlotId: number | null
  }

  export type BatchMinAggregateOutputType = {
    id: number | null
    name: string | null
    facultyId: number | null
    labTimeSlotId: number | null
    clientAdminId: string | null
  }

  export type BatchMaxAggregateOutputType = {
    id: number | null
    name: string | null
    facultyId: number | null
    labTimeSlotId: number | null
    clientAdminId: string | null
  }

  export type BatchCountAggregateOutputType = {
    id: number
    name: number
    facultyId: number
    labTimeSlotId: number
    clientAdminId: number
    _all: number
  }


  export type BatchAvgAggregateInputType = {
    id?: true
    facultyId?: true
    labTimeSlotId?: true
  }

  export type BatchSumAggregateInputType = {
    id?: true
    facultyId?: true
    labTimeSlotId?: true
  }

  export type BatchMinAggregateInputType = {
    id?: true
    name?: true
    facultyId?: true
    labTimeSlotId?: true
    clientAdminId?: true
  }

  export type BatchMaxAggregateInputType = {
    id?: true
    name?: true
    facultyId?: true
    labTimeSlotId?: true
    clientAdminId?: true
  }

  export type BatchCountAggregateInputType = {
    id?: true
    name?: true
    facultyId?: true
    labTimeSlotId?: true
    clientAdminId?: true
    _all?: true
  }

  export type BatchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Batch to aggregate.
     */
    where?: BatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Batches to fetch.
     */
    orderBy?: BatchOrderByWithRelationInput | BatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Batches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Batches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Batches
    **/
    _count?: true | BatchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BatchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BatchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BatchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BatchMaxAggregateInputType
  }

  export type GetBatchAggregateType<T extends BatchAggregateArgs> = {
        [P in keyof T & keyof AggregateBatch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBatch[P]>
      : GetScalarType<T[P], AggregateBatch[P]>
  }




  export type BatchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BatchWhereInput
    orderBy?: BatchOrderByWithAggregationInput | BatchOrderByWithAggregationInput[]
    by: BatchScalarFieldEnum[] | BatchScalarFieldEnum
    having?: BatchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BatchCountAggregateInputType | true
    _avg?: BatchAvgAggregateInputType
    _sum?: BatchSumAggregateInputType
    _min?: BatchMinAggregateInputType
    _max?: BatchMaxAggregateInputType
  }

  export type BatchGroupByOutputType = {
    id: number
    name: string
    facultyId: number | null
    labTimeSlotId: number
    clientAdminId: string
    _count: BatchCountAggregateOutputType | null
    _avg: BatchAvgAggregateOutputType | null
    _sum: BatchSumAggregateOutputType | null
    _min: BatchMinAggregateOutputType | null
    _max: BatchMaxAggregateOutputType | null
  }

  type GetBatchGroupByPayload<T extends BatchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BatchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BatchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BatchGroupByOutputType[P]>
            : GetScalarType<T[P], BatchGroupByOutputType[P]>
        }
      >
    >


  export type BatchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    facultyId?: boolean
    labTimeSlotId?: boolean
    clientAdminId?: boolean
    faculty?: boolean | Batch$facultyArgs<ExtArgs>
    labTimeSlot?: boolean | LabTimeSlotDefaultArgs<ExtArgs>
    studentCourses?: boolean | Batch$studentCoursesArgs<ExtArgs>
    batchCourses?: boolean | Batch$batchCoursesArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
    _count?: boolean | BatchCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["batch"]>

  export type BatchSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    facultyId?: boolean
    labTimeSlotId?: boolean
    clientAdminId?: boolean
    faculty?: boolean | Batch$facultyArgs<ExtArgs>
    labTimeSlot?: boolean | LabTimeSlotDefaultArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["batch"]>

  export type BatchSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    facultyId?: boolean
    labTimeSlotId?: boolean
    clientAdminId?: boolean
    faculty?: boolean | Batch$facultyArgs<ExtArgs>
    labTimeSlot?: boolean | LabTimeSlotDefaultArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["batch"]>

  export type BatchSelectScalar = {
    id?: boolean
    name?: boolean
    facultyId?: boolean
    labTimeSlotId?: boolean
    clientAdminId?: boolean
  }

  export type BatchOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "facultyId" | "labTimeSlotId" | "clientAdminId", ExtArgs["result"]["batch"]>
  export type BatchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    faculty?: boolean | Batch$facultyArgs<ExtArgs>
    labTimeSlot?: boolean | LabTimeSlotDefaultArgs<ExtArgs>
    studentCourses?: boolean | Batch$studentCoursesArgs<ExtArgs>
    batchCourses?: boolean | Batch$batchCoursesArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
    _count?: boolean | BatchCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BatchIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    faculty?: boolean | Batch$facultyArgs<ExtArgs>
    labTimeSlot?: boolean | LabTimeSlotDefaultArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }
  export type BatchIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    faculty?: boolean | Batch$facultyArgs<ExtArgs>
    labTimeSlot?: boolean | LabTimeSlotDefaultArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }

  export type $BatchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Batch"
    objects: {
      faculty: Prisma.$FacultyPayload<ExtArgs> | null
      labTimeSlot: Prisma.$LabTimeSlotPayload<ExtArgs>
      studentCourses: Prisma.$StudentCoursePayload<ExtArgs>[]
      batchCourses: Prisma.$BatchCoursePayload<ExtArgs>[]
      clientAdmin: Prisma.$ClientAdminPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      facultyId: number | null
      labTimeSlotId: number
      clientAdminId: string
    }, ExtArgs["result"]["batch"]>
    composites: {}
  }

  type BatchGetPayload<S extends boolean | null | undefined | BatchDefaultArgs> = $Result.GetResult<Prisma.$BatchPayload, S>

  type BatchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BatchFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BatchCountAggregateInputType | true
    }

  export interface BatchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Batch'], meta: { name: 'Batch' } }
    /**
     * Find zero or one Batch that matches the filter.
     * @param {BatchFindUniqueArgs} args - Arguments to find a Batch
     * @example
     * // Get one Batch
     * const batch = await prisma.batch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BatchFindUniqueArgs>(args: SelectSubset<T, BatchFindUniqueArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Batch that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BatchFindUniqueOrThrowArgs} args - Arguments to find a Batch
     * @example
     * // Get one Batch
     * const batch = await prisma.batch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BatchFindUniqueOrThrowArgs>(args: SelectSubset<T, BatchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Batch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchFindFirstArgs} args - Arguments to find a Batch
     * @example
     * // Get one Batch
     * const batch = await prisma.batch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BatchFindFirstArgs>(args?: SelectSubset<T, BatchFindFirstArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Batch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchFindFirstOrThrowArgs} args - Arguments to find a Batch
     * @example
     * // Get one Batch
     * const batch = await prisma.batch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BatchFindFirstOrThrowArgs>(args?: SelectSubset<T, BatchFindFirstOrThrowArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Batches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Batches
     * const batches = await prisma.batch.findMany()
     * 
     * // Get first 10 Batches
     * const batches = await prisma.batch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const batchWithIdOnly = await prisma.batch.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BatchFindManyArgs>(args?: SelectSubset<T, BatchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Batch.
     * @param {BatchCreateArgs} args - Arguments to create a Batch.
     * @example
     * // Create one Batch
     * const Batch = await prisma.batch.create({
     *   data: {
     *     // ... data to create a Batch
     *   }
     * })
     * 
     */
    create<T extends BatchCreateArgs>(args: SelectSubset<T, BatchCreateArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Batches.
     * @param {BatchCreateManyArgs} args - Arguments to create many Batches.
     * @example
     * // Create many Batches
     * const batch = await prisma.batch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BatchCreateManyArgs>(args?: SelectSubset<T, BatchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Batches and returns the data saved in the database.
     * @param {BatchCreateManyAndReturnArgs} args - Arguments to create many Batches.
     * @example
     * // Create many Batches
     * const batch = await prisma.batch.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Batches and only return the `id`
     * const batchWithIdOnly = await prisma.batch.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BatchCreateManyAndReturnArgs>(args?: SelectSubset<T, BatchCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Batch.
     * @param {BatchDeleteArgs} args - Arguments to delete one Batch.
     * @example
     * // Delete one Batch
     * const Batch = await prisma.batch.delete({
     *   where: {
     *     // ... filter to delete one Batch
     *   }
     * })
     * 
     */
    delete<T extends BatchDeleteArgs>(args: SelectSubset<T, BatchDeleteArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Batch.
     * @param {BatchUpdateArgs} args - Arguments to update one Batch.
     * @example
     * // Update one Batch
     * const batch = await prisma.batch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BatchUpdateArgs>(args: SelectSubset<T, BatchUpdateArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Batches.
     * @param {BatchDeleteManyArgs} args - Arguments to filter Batches to delete.
     * @example
     * // Delete a few Batches
     * const { count } = await prisma.batch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BatchDeleteManyArgs>(args?: SelectSubset<T, BatchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Batches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Batches
     * const batch = await prisma.batch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BatchUpdateManyArgs>(args: SelectSubset<T, BatchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Batches and returns the data updated in the database.
     * @param {BatchUpdateManyAndReturnArgs} args - Arguments to update many Batches.
     * @example
     * // Update many Batches
     * const batch = await prisma.batch.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Batches and only return the `id`
     * const batchWithIdOnly = await prisma.batch.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BatchUpdateManyAndReturnArgs>(args: SelectSubset<T, BatchUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Batch.
     * @param {BatchUpsertArgs} args - Arguments to update or create a Batch.
     * @example
     * // Update or create a Batch
     * const batch = await prisma.batch.upsert({
     *   create: {
     *     // ... data to create a Batch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Batch we want to update
     *   }
     * })
     */
    upsert<T extends BatchUpsertArgs>(args: SelectSubset<T, BatchUpsertArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Batches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchCountArgs} args - Arguments to filter Batches to count.
     * @example
     * // Count the number of Batches
     * const count = await prisma.batch.count({
     *   where: {
     *     // ... the filter for the Batches we want to count
     *   }
     * })
    **/
    count<T extends BatchCountArgs>(
      args?: Subset<T, BatchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BatchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Batch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BatchAggregateArgs>(args: Subset<T, BatchAggregateArgs>): Prisma.PrismaPromise<GetBatchAggregateType<T>>

    /**
     * Group by Batch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BatchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BatchGroupByArgs['orderBy'] }
        : { orderBy?: BatchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BatchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBatchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Batch model
   */
  readonly fields: BatchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Batch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BatchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    faculty<T extends Batch$facultyArgs<ExtArgs> = {}>(args?: Subset<T, Batch$facultyArgs<ExtArgs>>): Prisma__FacultyClient<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    labTimeSlot<T extends LabTimeSlotDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LabTimeSlotDefaultArgs<ExtArgs>>): Prisma__LabTimeSlotClient<$Result.GetResult<Prisma.$LabTimeSlotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    studentCourses<T extends Batch$studentCoursesArgs<ExtArgs> = {}>(args?: Subset<T, Batch$studentCoursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentCoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    batchCourses<T extends Batch$batchCoursesArgs<ExtArgs> = {}>(args?: Subset<T, Batch$batchCoursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchCoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    clientAdmin<T extends ClientAdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientAdminDefaultArgs<ExtArgs>>): Prisma__ClientAdminClient<$Result.GetResult<Prisma.$ClientAdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Batch model
   */
  interface BatchFieldRefs {
    readonly id: FieldRef<"Batch", 'Int'>
    readonly name: FieldRef<"Batch", 'String'>
    readonly facultyId: FieldRef<"Batch", 'Int'>
    readonly labTimeSlotId: FieldRef<"Batch", 'Int'>
    readonly clientAdminId: FieldRef<"Batch", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Batch findUnique
   */
  export type BatchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    /**
     * Filter, which Batch to fetch.
     */
    where: BatchWhereUniqueInput
  }

  /**
   * Batch findUniqueOrThrow
   */
  export type BatchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    /**
     * Filter, which Batch to fetch.
     */
    where: BatchWhereUniqueInput
  }

  /**
   * Batch findFirst
   */
  export type BatchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    /**
     * Filter, which Batch to fetch.
     */
    where?: BatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Batches to fetch.
     */
    orderBy?: BatchOrderByWithRelationInput | BatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Batches.
     */
    cursor?: BatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Batches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Batches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Batches.
     */
    distinct?: BatchScalarFieldEnum | BatchScalarFieldEnum[]
  }

  /**
   * Batch findFirstOrThrow
   */
  export type BatchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    /**
     * Filter, which Batch to fetch.
     */
    where?: BatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Batches to fetch.
     */
    orderBy?: BatchOrderByWithRelationInput | BatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Batches.
     */
    cursor?: BatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Batches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Batches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Batches.
     */
    distinct?: BatchScalarFieldEnum | BatchScalarFieldEnum[]
  }

  /**
   * Batch findMany
   */
  export type BatchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    /**
     * Filter, which Batches to fetch.
     */
    where?: BatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Batches to fetch.
     */
    orderBy?: BatchOrderByWithRelationInput | BatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Batches.
     */
    cursor?: BatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Batches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Batches.
     */
    skip?: number
    distinct?: BatchScalarFieldEnum | BatchScalarFieldEnum[]
  }

  /**
   * Batch create
   */
  export type BatchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    /**
     * The data needed to create a Batch.
     */
    data: XOR<BatchCreateInput, BatchUncheckedCreateInput>
  }

  /**
   * Batch createMany
   */
  export type BatchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Batches.
     */
    data: BatchCreateManyInput | BatchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Batch createManyAndReturn
   */
  export type BatchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * The data used to create many Batches.
     */
    data: BatchCreateManyInput | BatchCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Batch update
   */
  export type BatchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    /**
     * The data needed to update a Batch.
     */
    data: XOR<BatchUpdateInput, BatchUncheckedUpdateInput>
    /**
     * Choose, which Batch to update.
     */
    where: BatchWhereUniqueInput
  }

  /**
   * Batch updateMany
   */
  export type BatchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Batches.
     */
    data: XOR<BatchUpdateManyMutationInput, BatchUncheckedUpdateManyInput>
    /**
     * Filter which Batches to update
     */
    where?: BatchWhereInput
    /**
     * Limit how many Batches to update.
     */
    limit?: number
  }

  /**
   * Batch updateManyAndReturn
   */
  export type BatchUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * The data used to update Batches.
     */
    data: XOR<BatchUpdateManyMutationInput, BatchUncheckedUpdateManyInput>
    /**
     * Filter which Batches to update
     */
    where?: BatchWhereInput
    /**
     * Limit how many Batches to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Batch upsert
   */
  export type BatchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    /**
     * The filter to search for the Batch to update in case it exists.
     */
    where: BatchWhereUniqueInput
    /**
     * In case the Batch found by the `where` argument doesn't exist, create a new Batch with this data.
     */
    create: XOR<BatchCreateInput, BatchUncheckedCreateInput>
    /**
     * In case the Batch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BatchUpdateInput, BatchUncheckedUpdateInput>
  }

  /**
   * Batch delete
   */
  export type BatchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    /**
     * Filter which Batch to delete.
     */
    where: BatchWhereUniqueInput
  }

  /**
   * Batch deleteMany
   */
  export type BatchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Batches to delete
     */
    where?: BatchWhereInput
    /**
     * Limit how many Batches to delete.
     */
    limit?: number
  }

  /**
   * Batch.faculty
   */
  export type Batch$facultyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faculty
     */
    omit?: FacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyInclude<ExtArgs> | null
    where?: FacultyWhereInput
  }

  /**
   * Batch.studentCourses
   */
  export type Batch$studentCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentCourse
     */
    select?: StudentCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentCourse
     */
    omit?: StudentCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentCourseInclude<ExtArgs> | null
    where?: StudentCourseWhereInput
    orderBy?: StudentCourseOrderByWithRelationInput | StudentCourseOrderByWithRelationInput[]
    cursor?: StudentCourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentCourseScalarFieldEnum | StudentCourseScalarFieldEnum[]
  }

  /**
   * Batch.batchCourses
   */
  export type Batch$batchCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchCourse
     */
    select?: BatchCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchCourse
     */
    omit?: BatchCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchCourseInclude<ExtArgs> | null
    where?: BatchCourseWhereInput
    orderBy?: BatchCourseOrderByWithRelationInput | BatchCourseOrderByWithRelationInput[]
    cursor?: BatchCourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BatchCourseScalarFieldEnum | BatchCourseScalarFieldEnum[]
  }

  /**
   * Batch without action
   */
  export type BatchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
  }


  /**
   * Model BatchCourse
   */

  export type AggregateBatchCourse = {
    _count: BatchCourseCountAggregateOutputType | null
    _avg: BatchCourseAvgAggregateOutputType | null
    _sum: BatchCourseSumAggregateOutputType | null
    _min: BatchCourseMinAggregateOutputType | null
    _max: BatchCourseMaxAggregateOutputType | null
  }

  export type BatchCourseAvgAggregateOutputType = {
    id: number | null
    batchId: number | null
    courseId: number | null
    pcsReserved: number | null
  }

  export type BatchCourseSumAggregateOutputType = {
    id: number | null
    batchId: number | null
    courseId: number | null
    pcsReserved: number | null
  }

  export type BatchCourseMinAggregateOutputType = {
    id: number | null
    batchId: number | null
    courseId: number | null
    pcsReserved: number | null
  }

  export type BatchCourseMaxAggregateOutputType = {
    id: number | null
    batchId: number | null
    courseId: number | null
    pcsReserved: number | null
  }

  export type BatchCourseCountAggregateOutputType = {
    id: number
    batchId: number
    courseId: number
    pcsReserved: number
    _all: number
  }


  export type BatchCourseAvgAggregateInputType = {
    id?: true
    batchId?: true
    courseId?: true
    pcsReserved?: true
  }

  export type BatchCourseSumAggregateInputType = {
    id?: true
    batchId?: true
    courseId?: true
    pcsReserved?: true
  }

  export type BatchCourseMinAggregateInputType = {
    id?: true
    batchId?: true
    courseId?: true
    pcsReserved?: true
  }

  export type BatchCourseMaxAggregateInputType = {
    id?: true
    batchId?: true
    courseId?: true
    pcsReserved?: true
  }

  export type BatchCourseCountAggregateInputType = {
    id?: true
    batchId?: true
    courseId?: true
    pcsReserved?: true
    _all?: true
  }

  export type BatchCourseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BatchCourse to aggregate.
     */
    where?: BatchCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BatchCourses to fetch.
     */
    orderBy?: BatchCourseOrderByWithRelationInput | BatchCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BatchCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BatchCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BatchCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BatchCourses
    **/
    _count?: true | BatchCourseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BatchCourseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BatchCourseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BatchCourseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BatchCourseMaxAggregateInputType
  }

  export type GetBatchCourseAggregateType<T extends BatchCourseAggregateArgs> = {
        [P in keyof T & keyof AggregateBatchCourse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBatchCourse[P]>
      : GetScalarType<T[P], AggregateBatchCourse[P]>
  }




  export type BatchCourseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BatchCourseWhereInput
    orderBy?: BatchCourseOrderByWithAggregationInput | BatchCourseOrderByWithAggregationInput[]
    by: BatchCourseScalarFieldEnum[] | BatchCourseScalarFieldEnum
    having?: BatchCourseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BatchCourseCountAggregateInputType | true
    _avg?: BatchCourseAvgAggregateInputType
    _sum?: BatchCourseSumAggregateInputType
    _min?: BatchCourseMinAggregateInputType
    _max?: BatchCourseMaxAggregateInputType
  }

  export type BatchCourseGroupByOutputType = {
    id: number
    batchId: number
    courseId: number
    pcsReserved: number | null
    _count: BatchCourseCountAggregateOutputType | null
    _avg: BatchCourseAvgAggregateOutputType | null
    _sum: BatchCourseSumAggregateOutputType | null
    _min: BatchCourseMinAggregateOutputType | null
    _max: BatchCourseMaxAggregateOutputType | null
  }

  type GetBatchCourseGroupByPayload<T extends BatchCourseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BatchCourseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BatchCourseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BatchCourseGroupByOutputType[P]>
            : GetScalarType<T[P], BatchCourseGroupByOutputType[P]>
        }
      >
    >


  export type BatchCourseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    batchId?: boolean
    courseId?: boolean
    pcsReserved?: boolean
    batch?: boolean | BatchDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["batchCourse"]>

  export type BatchCourseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    batchId?: boolean
    courseId?: boolean
    pcsReserved?: boolean
    batch?: boolean | BatchDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["batchCourse"]>

  export type BatchCourseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    batchId?: boolean
    courseId?: boolean
    pcsReserved?: boolean
    batch?: boolean | BatchDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["batchCourse"]>

  export type BatchCourseSelectScalar = {
    id?: boolean
    batchId?: boolean
    courseId?: boolean
    pcsReserved?: boolean
  }

  export type BatchCourseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "batchId" | "courseId" | "pcsReserved", ExtArgs["result"]["batchCourse"]>
  export type BatchCourseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    batch?: boolean | BatchDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }
  export type BatchCourseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    batch?: boolean | BatchDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }
  export type BatchCourseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    batch?: boolean | BatchDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }

  export type $BatchCoursePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BatchCourse"
    objects: {
      batch: Prisma.$BatchPayload<ExtArgs>
      course: Prisma.$CoursePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      batchId: number
      courseId: number
      pcsReserved: number | null
    }, ExtArgs["result"]["batchCourse"]>
    composites: {}
  }

  type BatchCourseGetPayload<S extends boolean | null | undefined | BatchCourseDefaultArgs> = $Result.GetResult<Prisma.$BatchCoursePayload, S>

  type BatchCourseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BatchCourseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BatchCourseCountAggregateInputType | true
    }

  export interface BatchCourseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BatchCourse'], meta: { name: 'BatchCourse' } }
    /**
     * Find zero or one BatchCourse that matches the filter.
     * @param {BatchCourseFindUniqueArgs} args - Arguments to find a BatchCourse
     * @example
     * // Get one BatchCourse
     * const batchCourse = await prisma.batchCourse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BatchCourseFindUniqueArgs>(args: SelectSubset<T, BatchCourseFindUniqueArgs<ExtArgs>>): Prisma__BatchCourseClient<$Result.GetResult<Prisma.$BatchCoursePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BatchCourse that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BatchCourseFindUniqueOrThrowArgs} args - Arguments to find a BatchCourse
     * @example
     * // Get one BatchCourse
     * const batchCourse = await prisma.batchCourse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BatchCourseFindUniqueOrThrowArgs>(args: SelectSubset<T, BatchCourseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BatchCourseClient<$Result.GetResult<Prisma.$BatchCoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BatchCourse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchCourseFindFirstArgs} args - Arguments to find a BatchCourse
     * @example
     * // Get one BatchCourse
     * const batchCourse = await prisma.batchCourse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BatchCourseFindFirstArgs>(args?: SelectSubset<T, BatchCourseFindFirstArgs<ExtArgs>>): Prisma__BatchCourseClient<$Result.GetResult<Prisma.$BatchCoursePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BatchCourse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchCourseFindFirstOrThrowArgs} args - Arguments to find a BatchCourse
     * @example
     * // Get one BatchCourse
     * const batchCourse = await prisma.batchCourse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BatchCourseFindFirstOrThrowArgs>(args?: SelectSubset<T, BatchCourseFindFirstOrThrowArgs<ExtArgs>>): Prisma__BatchCourseClient<$Result.GetResult<Prisma.$BatchCoursePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BatchCourses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchCourseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BatchCourses
     * const batchCourses = await prisma.batchCourse.findMany()
     * 
     * // Get first 10 BatchCourses
     * const batchCourses = await prisma.batchCourse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const batchCourseWithIdOnly = await prisma.batchCourse.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BatchCourseFindManyArgs>(args?: SelectSubset<T, BatchCourseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchCoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BatchCourse.
     * @param {BatchCourseCreateArgs} args - Arguments to create a BatchCourse.
     * @example
     * // Create one BatchCourse
     * const BatchCourse = await prisma.batchCourse.create({
     *   data: {
     *     // ... data to create a BatchCourse
     *   }
     * })
     * 
     */
    create<T extends BatchCourseCreateArgs>(args: SelectSubset<T, BatchCourseCreateArgs<ExtArgs>>): Prisma__BatchCourseClient<$Result.GetResult<Prisma.$BatchCoursePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BatchCourses.
     * @param {BatchCourseCreateManyArgs} args - Arguments to create many BatchCourses.
     * @example
     * // Create many BatchCourses
     * const batchCourse = await prisma.batchCourse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BatchCourseCreateManyArgs>(args?: SelectSubset<T, BatchCourseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BatchCourses and returns the data saved in the database.
     * @param {BatchCourseCreateManyAndReturnArgs} args - Arguments to create many BatchCourses.
     * @example
     * // Create many BatchCourses
     * const batchCourse = await prisma.batchCourse.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BatchCourses and only return the `id`
     * const batchCourseWithIdOnly = await prisma.batchCourse.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BatchCourseCreateManyAndReturnArgs>(args?: SelectSubset<T, BatchCourseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchCoursePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BatchCourse.
     * @param {BatchCourseDeleteArgs} args - Arguments to delete one BatchCourse.
     * @example
     * // Delete one BatchCourse
     * const BatchCourse = await prisma.batchCourse.delete({
     *   where: {
     *     // ... filter to delete one BatchCourse
     *   }
     * })
     * 
     */
    delete<T extends BatchCourseDeleteArgs>(args: SelectSubset<T, BatchCourseDeleteArgs<ExtArgs>>): Prisma__BatchCourseClient<$Result.GetResult<Prisma.$BatchCoursePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BatchCourse.
     * @param {BatchCourseUpdateArgs} args - Arguments to update one BatchCourse.
     * @example
     * // Update one BatchCourse
     * const batchCourse = await prisma.batchCourse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BatchCourseUpdateArgs>(args: SelectSubset<T, BatchCourseUpdateArgs<ExtArgs>>): Prisma__BatchCourseClient<$Result.GetResult<Prisma.$BatchCoursePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BatchCourses.
     * @param {BatchCourseDeleteManyArgs} args - Arguments to filter BatchCourses to delete.
     * @example
     * // Delete a few BatchCourses
     * const { count } = await prisma.batchCourse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BatchCourseDeleteManyArgs>(args?: SelectSubset<T, BatchCourseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BatchCourses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchCourseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BatchCourses
     * const batchCourse = await prisma.batchCourse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BatchCourseUpdateManyArgs>(args: SelectSubset<T, BatchCourseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BatchCourses and returns the data updated in the database.
     * @param {BatchCourseUpdateManyAndReturnArgs} args - Arguments to update many BatchCourses.
     * @example
     * // Update many BatchCourses
     * const batchCourse = await prisma.batchCourse.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BatchCourses and only return the `id`
     * const batchCourseWithIdOnly = await prisma.batchCourse.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BatchCourseUpdateManyAndReturnArgs>(args: SelectSubset<T, BatchCourseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchCoursePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BatchCourse.
     * @param {BatchCourseUpsertArgs} args - Arguments to update or create a BatchCourse.
     * @example
     * // Update or create a BatchCourse
     * const batchCourse = await prisma.batchCourse.upsert({
     *   create: {
     *     // ... data to create a BatchCourse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BatchCourse we want to update
     *   }
     * })
     */
    upsert<T extends BatchCourseUpsertArgs>(args: SelectSubset<T, BatchCourseUpsertArgs<ExtArgs>>): Prisma__BatchCourseClient<$Result.GetResult<Prisma.$BatchCoursePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BatchCourses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchCourseCountArgs} args - Arguments to filter BatchCourses to count.
     * @example
     * // Count the number of BatchCourses
     * const count = await prisma.batchCourse.count({
     *   where: {
     *     // ... the filter for the BatchCourses we want to count
     *   }
     * })
    **/
    count<T extends BatchCourseCountArgs>(
      args?: Subset<T, BatchCourseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BatchCourseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BatchCourse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchCourseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BatchCourseAggregateArgs>(args: Subset<T, BatchCourseAggregateArgs>): Prisma.PrismaPromise<GetBatchCourseAggregateType<T>>

    /**
     * Group by BatchCourse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchCourseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BatchCourseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BatchCourseGroupByArgs['orderBy'] }
        : { orderBy?: BatchCourseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BatchCourseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBatchCourseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BatchCourse model
   */
  readonly fields: BatchCourseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BatchCourse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BatchCourseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    batch<T extends BatchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BatchDefaultArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BatchCourse model
   */
  interface BatchCourseFieldRefs {
    readonly id: FieldRef<"BatchCourse", 'Int'>
    readonly batchId: FieldRef<"BatchCourse", 'Int'>
    readonly courseId: FieldRef<"BatchCourse", 'Int'>
    readonly pcsReserved: FieldRef<"BatchCourse", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * BatchCourse findUnique
   */
  export type BatchCourseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchCourse
     */
    select?: BatchCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchCourse
     */
    omit?: BatchCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchCourseInclude<ExtArgs> | null
    /**
     * Filter, which BatchCourse to fetch.
     */
    where: BatchCourseWhereUniqueInput
  }

  /**
   * BatchCourse findUniqueOrThrow
   */
  export type BatchCourseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchCourse
     */
    select?: BatchCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchCourse
     */
    omit?: BatchCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchCourseInclude<ExtArgs> | null
    /**
     * Filter, which BatchCourse to fetch.
     */
    where: BatchCourseWhereUniqueInput
  }

  /**
   * BatchCourse findFirst
   */
  export type BatchCourseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchCourse
     */
    select?: BatchCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchCourse
     */
    omit?: BatchCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchCourseInclude<ExtArgs> | null
    /**
     * Filter, which BatchCourse to fetch.
     */
    where?: BatchCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BatchCourses to fetch.
     */
    orderBy?: BatchCourseOrderByWithRelationInput | BatchCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BatchCourses.
     */
    cursor?: BatchCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BatchCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BatchCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BatchCourses.
     */
    distinct?: BatchCourseScalarFieldEnum | BatchCourseScalarFieldEnum[]
  }

  /**
   * BatchCourse findFirstOrThrow
   */
  export type BatchCourseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchCourse
     */
    select?: BatchCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchCourse
     */
    omit?: BatchCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchCourseInclude<ExtArgs> | null
    /**
     * Filter, which BatchCourse to fetch.
     */
    where?: BatchCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BatchCourses to fetch.
     */
    orderBy?: BatchCourseOrderByWithRelationInput | BatchCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BatchCourses.
     */
    cursor?: BatchCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BatchCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BatchCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BatchCourses.
     */
    distinct?: BatchCourseScalarFieldEnum | BatchCourseScalarFieldEnum[]
  }

  /**
   * BatchCourse findMany
   */
  export type BatchCourseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchCourse
     */
    select?: BatchCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchCourse
     */
    omit?: BatchCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchCourseInclude<ExtArgs> | null
    /**
     * Filter, which BatchCourses to fetch.
     */
    where?: BatchCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BatchCourses to fetch.
     */
    orderBy?: BatchCourseOrderByWithRelationInput | BatchCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BatchCourses.
     */
    cursor?: BatchCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BatchCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BatchCourses.
     */
    skip?: number
    distinct?: BatchCourseScalarFieldEnum | BatchCourseScalarFieldEnum[]
  }

  /**
   * BatchCourse create
   */
  export type BatchCourseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchCourse
     */
    select?: BatchCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchCourse
     */
    omit?: BatchCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchCourseInclude<ExtArgs> | null
    /**
     * The data needed to create a BatchCourse.
     */
    data: XOR<BatchCourseCreateInput, BatchCourseUncheckedCreateInput>
  }

  /**
   * BatchCourse createMany
   */
  export type BatchCourseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BatchCourses.
     */
    data: BatchCourseCreateManyInput | BatchCourseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BatchCourse createManyAndReturn
   */
  export type BatchCourseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchCourse
     */
    select?: BatchCourseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BatchCourse
     */
    omit?: BatchCourseOmit<ExtArgs> | null
    /**
     * The data used to create many BatchCourses.
     */
    data: BatchCourseCreateManyInput | BatchCourseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchCourseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BatchCourse update
   */
  export type BatchCourseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchCourse
     */
    select?: BatchCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchCourse
     */
    omit?: BatchCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchCourseInclude<ExtArgs> | null
    /**
     * The data needed to update a BatchCourse.
     */
    data: XOR<BatchCourseUpdateInput, BatchCourseUncheckedUpdateInput>
    /**
     * Choose, which BatchCourse to update.
     */
    where: BatchCourseWhereUniqueInput
  }

  /**
   * BatchCourse updateMany
   */
  export type BatchCourseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BatchCourses.
     */
    data: XOR<BatchCourseUpdateManyMutationInput, BatchCourseUncheckedUpdateManyInput>
    /**
     * Filter which BatchCourses to update
     */
    where?: BatchCourseWhereInput
    /**
     * Limit how many BatchCourses to update.
     */
    limit?: number
  }

  /**
   * BatchCourse updateManyAndReturn
   */
  export type BatchCourseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchCourse
     */
    select?: BatchCourseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BatchCourse
     */
    omit?: BatchCourseOmit<ExtArgs> | null
    /**
     * The data used to update BatchCourses.
     */
    data: XOR<BatchCourseUpdateManyMutationInput, BatchCourseUncheckedUpdateManyInput>
    /**
     * Filter which BatchCourses to update
     */
    where?: BatchCourseWhereInput
    /**
     * Limit how many BatchCourses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchCourseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BatchCourse upsert
   */
  export type BatchCourseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchCourse
     */
    select?: BatchCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchCourse
     */
    omit?: BatchCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchCourseInclude<ExtArgs> | null
    /**
     * The filter to search for the BatchCourse to update in case it exists.
     */
    where: BatchCourseWhereUniqueInput
    /**
     * In case the BatchCourse found by the `where` argument doesn't exist, create a new BatchCourse with this data.
     */
    create: XOR<BatchCourseCreateInput, BatchCourseUncheckedCreateInput>
    /**
     * In case the BatchCourse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BatchCourseUpdateInput, BatchCourseUncheckedUpdateInput>
  }

  /**
   * BatchCourse delete
   */
  export type BatchCourseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchCourse
     */
    select?: BatchCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchCourse
     */
    omit?: BatchCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchCourseInclude<ExtArgs> | null
    /**
     * Filter which BatchCourse to delete.
     */
    where: BatchCourseWhereUniqueInput
  }

  /**
   * BatchCourse deleteMany
   */
  export type BatchCourseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BatchCourses to delete
     */
    where?: BatchCourseWhereInput
    /**
     * Limit how many BatchCourses to delete.
     */
    limit?: number
  }

  /**
   * BatchCourse without action
   */
  export type BatchCourseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchCourse
     */
    select?: BatchCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchCourse
     */
    omit?: BatchCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchCourseInclude<ExtArgs> | null
  }


  /**
   * Model Faculty
   */

  export type AggregateFaculty = {
    _count: FacultyCountAggregateOutputType | null
    _avg: FacultyAvgAggregateOutputType | null
    _sum: FacultySumAggregateOutputType | null
    _min: FacultyMinAggregateOutputType | null
    _max: FacultyMaxAggregateOutputType | null
  }

  export type FacultyAvgAggregateOutputType = {
    id: number | null
  }

  export type FacultySumAggregateOutputType = {
    id: number | null
  }

  export type FacultyMinAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    password: string | null
    contact: string | null
    joiningDate: Date | null
    specialization: string | null
    role: $Enums.UserRole | null
    country: string | null
    state: string | null
    city: string | null
    zipCode: string | null
    currentSessionToken: string | null
    lastLoginAt: Date | null
    clientAdminId: string | null
  }

  export type FacultyMaxAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    password: string | null
    contact: string | null
    joiningDate: Date | null
    specialization: string | null
    role: $Enums.UserRole | null
    country: string | null
    state: string | null
    city: string | null
    zipCode: string | null
    currentSessionToken: string | null
    lastLoginAt: Date | null
    clientAdminId: string | null
  }

  export type FacultyCountAggregateOutputType = {
    id: number
    name: number
    email: number
    password: number
    contact: number
    joiningDate: number
    specialization: number
    role: number
    country: number
    state: number
    city: number
    zipCode: number
    currentSessionToken: number
    lastLoginAt: number
    clientAdminId: number
    _all: number
  }


  export type FacultyAvgAggregateInputType = {
    id?: true
  }

  export type FacultySumAggregateInputType = {
    id?: true
  }

  export type FacultyMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    contact?: true
    joiningDate?: true
    specialization?: true
    role?: true
    country?: true
    state?: true
    city?: true
    zipCode?: true
    currentSessionToken?: true
    lastLoginAt?: true
    clientAdminId?: true
  }

  export type FacultyMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    contact?: true
    joiningDate?: true
    specialization?: true
    role?: true
    country?: true
    state?: true
    city?: true
    zipCode?: true
    currentSessionToken?: true
    lastLoginAt?: true
    clientAdminId?: true
  }

  export type FacultyCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    contact?: true
    joiningDate?: true
    specialization?: true
    role?: true
    country?: true
    state?: true
    city?: true
    zipCode?: true
    currentSessionToken?: true
    lastLoginAt?: true
    clientAdminId?: true
    _all?: true
  }

  export type FacultyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Faculty to aggregate.
     */
    where?: FacultyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Faculties to fetch.
     */
    orderBy?: FacultyOrderByWithRelationInput | FacultyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FacultyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Faculties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Faculties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Faculties
    **/
    _count?: true | FacultyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FacultyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FacultySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FacultyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FacultyMaxAggregateInputType
  }

  export type GetFacultyAggregateType<T extends FacultyAggregateArgs> = {
        [P in keyof T & keyof AggregateFaculty]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFaculty[P]>
      : GetScalarType<T[P], AggregateFaculty[P]>
  }




  export type FacultyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FacultyWhereInput
    orderBy?: FacultyOrderByWithAggregationInput | FacultyOrderByWithAggregationInput[]
    by: FacultyScalarFieldEnum[] | FacultyScalarFieldEnum
    having?: FacultyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FacultyCountAggregateInputType | true
    _avg?: FacultyAvgAggregateInputType
    _sum?: FacultySumAggregateInputType
    _min?: FacultyMinAggregateInputType
    _max?: FacultyMaxAggregateInputType
  }

  export type FacultyGroupByOutputType = {
    id: number
    name: string
    email: string
    password: string
    contact: string
    joiningDate: Date
    specialization: string | null
    role: $Enums.UserRole
    country: string
    state: string
    city: string
    zipCode: string
    currentSessionToken: string | null
    lastLoginAt: Date | null
    clientAdminId: string
    _count: FacultyCountAggregateOutputType | null
    _avg: FacultyAvgAggregateOutputType | null
    _sum: FacultySumAggregateOutputType | null
    _min: FacultyMinAggregateOutputType | null
    _max: FacultyMaxAggregateOutputType | null
  }

  type GetFacultyGroupByPayload<T extends FacultyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FacultyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FacultyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FacultyGroupByOutputType[P]>
            : GetScalarType<T[P], FacultyGroupByOutputType[P]>
        }
      >
    >


  export type FacultySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    contact?: boolean
    joiningDate?: boolean
    specialization?: boolean
    role?: boolean
    country?: boolean
    state?: boolean
    city?: boolean
    zipCode?: boolean
    currentSessionToken?: boolean
    lastLoginAt?: boolean
    clientAdminId?: boolean
    batches?: boolean | Faculty$batchesArgs<ExtArgs>
    attendance?: boolean | Faculty$attendanceArgs<ExtArgs>
    tasks?: boolean | Faculty$tasksArgs<ExtArgs>
    financialRecords?: boolean | Faculty$financialRecordsArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
    _count?: boolean | FacultyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["faculty"]>

  export type FacultySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    contact?: boolean
    joiningDate?: boolean
    specialization?: boolean
    role?: boolean
    country?: boolean
    state?: boolean
    city?: boolean
    zipCode?: boolean
    currentSessionToken?: boolean
    lastLoginAt?: boolean
    clientAdminId?: boolean
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["faculty"]>

  export type FacultySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    contact?: boolean
    joiningDate?: boolean
    specialization?: boolean
    role?: boolean
    country?: boolean
    state?: boolean
    city?: boolean
    zipCode?: boolean
    currentSessionToken?: boolean
    lastLoginAt?: boolean
    clientAdminId?: boolean
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["faculty"]>

  export type FacultySelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    contact?: boolean
    joiningDate?: boolean
    specialization?: boolean
    role?: boolean
    country?: boolean
    state?: boolean
    city?: boolean
    zipCode?: boolean
    currentSessionToken?: boolean
    lastLoginAt?: boolean
    clientAdminId?: boolean
  }

  export type FacultyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "password" | "contact" | "joiningDate" | "specialization" | "role" | "country" | "state" | "city" | "zipCode" | "currentSessionToken" | "lastLoginAt" | "clientAdminId", ExtArgs["result"]["faculty"]>
  export type FacultyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    batches?: boolean | Faculty$batchesArgs<ExtArgs>
    attendance?: boolean | Faculty$attendanceArgs<ExtArgs>
    tasks?: boolean | Faculty$tasksArgs<ExtArgs>
    financialRecords?: boolean | Faculty$financialRecordsArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
    _count?: boolean | FacultyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FacultyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }
  export type FacultyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }

  export type $FacultyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Faculty"
    objects: {
      batches: Prisma.$BatchPayload<ExtArgs>[]
      attendance: Prisma.$AttendanceRecordPayload<ExtArgs>[]
      tasks: Prisma.$StudentTaskPayload<ExtArgs>[]
      financialRecords: Prisma.$FinancialRecordPayload<ExtArgs>[]
      clientAdmin: Prisma.$ClientAdminPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      email: string
      password: string
      contact: string
      joiningDate: Date
      specialization: string | null
      role: $Enums.UserRole
      country: string
      state: string
      city: string
      zipCode: string
      currentSessionToken: string | null
      lastLoginAt: Date | null
      clientAdminId: string
    }, ExtArgs["result"]["faculty"]>
    composites: {}
  }

  type FacultyGetPayload<S extends boolean | null | undefined | FacultyDefaultArgs> = $Result.GetResult<Prisma.$FacultyPayload, S>

  type FacultyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FacultyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FacultyCountAggregateInputType | true
    }

  export interface FacultyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Faculty'], meta: { name: 'Faculty' } }
    /**
     * Find zero or one Faculty that matches the filter.
     * @param {FacultyFindUniqueArgs} args - Arguments to find a Faculty
     * @example
     * // Get one Faculty
     * const faculty = await prisma.faculty.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FacultyFindUniqueArgs>(args: SelectSubset<T, FacultyFindUniqueArgs<ExtArgs>>): Prisma__FacultyClient<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Faculty that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FacultyFindUniqueOrThrowArgs} args - Arguments to find a Faculty
     * @example
     * // Get one Faculty
     * const faculty = await prisma.faculty.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FacultyFindUniqueOrThrowArgs>(args: SelectSubset<T, FacultyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FacultyClient<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Faculty that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultyFindFirstArgs} args - Arguments to find a Faculty
     * @example
     * // Get one Faculty
     * const faculty = await prisma.faculty.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FacultyFindFirstArgs>(args?: SelectSubset<T, FacultyFindFirstArgs<ExtArgs>>): Prisma__FacultyClient<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Faculty that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultyFindFirstOrThrowArgs} args - Arguments to find a Faculty
     * @example
     * // Get one Faculty
     * const faculty = await prisma.faculty.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FacultyFindFirstOrThrowArgs>(args?: SelectSubset<T, FacultyFindFirstOrThrowArgs<ExtArgs>>): Prisma__FacultyClient<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Faculties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Faculties
     * const faculties = await prisma.faculty.findMany()
     * 
     * // Get first 10 Faculties
     * const faculties = await prisma.faculty.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const facultyWithIdOnly = await prisma.faculty.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FacultyFindManyArgs>(args?: SelectSubset<T, FacultyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Faculty.
     * @param {FacultyCreateArgs} args - Arguments to create a Faculty.
     * @example
     * // Create one Faculty
     * const Faculty = await prisma.faculty.create({
     *   data: {
     *     // ... data to create a Faculty
     *   }
     * })
     * 
     */
    create<T extends FacultyCreateArgs>(args: SelectSubset<T, FacultyCreateArgs<ExtArgs>>): Prisma__FacultyClient<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Faculties.
     * @param {FacultyCreateManyArgs} args - Arguments to create many Faculties.
     * @example
     * // Create many Faculties
     * const faculty = await prisma.faculty.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FacultyCreateManyArgs>(args?: SelectSubset<T, FacultyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Faculties and returns the data saved in the database.
     * @param {FacultyCreateManyAndReturnArgs} args - Arguments to create many Faculties.
     * @example
     * // Create many Faculties
     * const faculty = await prisma.faculty.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Faculties and only return the `id`
     * const facultyWithIdOnly = await prisma.faculty.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FacultyCreateManyAndReturnArgs>(args?: SelectSubset<T, FacultyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Faculty.
     * @param {FacultyDeleteArgs} args - Arguments to delete one Faculty.
     * @example
     * // Delete one Faculty
     * const Faculty = await prisma.faculty.delete({
     *   where: {
     *     // ... filter to delete one Faculty
     *   }
     * })
     * 
     */
    delete<T extends FacultyDeleteArgs>(args: SelectSubset<T, FacultyDeleteArgs<ExtArgs>>): Prisma__FacultyClient<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Faculty.
     * @param {FacultyUpdateArgs} args - Arguments to update one Faculty.
     * @example
     * // Update one Faculty
     * const faculty = await prisma.faculty.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FacultyUpdateArgs>(args: SelectSubset<T, FacultyUpdateArgs<ExtArgs>>): Prisma__FacultyClient<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Faculties.
     * @param {FacultyDeleteManyArgs} args - Arguments to filter Faculties to delete.
     * @example
     * // Delete a few Faculties
     * const { count } = await prisma.faculty.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FacultyDeleteManyArgs>(args?: SelectSubset<T, FacultyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Faculties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Faculties
     * const faculty = await prisma.faculty.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FacultyUpdateManyArgs>(args: SelectSubset<T, FacultyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Faculties and returns the data updated in the database.
     * @param {FacultyUpdateManyAndReturnArgs} args - Arguments to update many Faculties.
     * @example
     * // Update many Faculties
     * const faculty = await prisma.faculty.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Faculties and only return the `id`
     * const facultyWithIdOnly = await prisma.faculty.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FacultyUpdateManyAndReturnArgs>(args: SelectSubset<T, FacultyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Faculty.
     * @param {FacultyUpsertArgs} args - Arguments to update or create a Faculty.
     * @example
     * // Update or create a Faculty
     * const faculty = await prisma.faculty.upsert({
     *   create: {
     *     // ... data to create a Faculty
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Faculty we want to update
     *   }
     * })
     */
    upsert<T extends FacultyUpsertArgs>(args: SelectSubset<T, FacultyUpsertArgs<ExtArgs>>): Prisma__FacultyClient<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Faculties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultyCountArgs} args - Arguments to filter Faculties to count.
     * @example
     * // Count the number of Faculties
     * const count = await prisma.faculty.count({
     *   where: {
     *     // ... the filter for the Faculties we want to count
     *   }
     * })
    **/
    count<T extends FacultyCountArgs>(
      args?: Subset<T, FacultyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FacultyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Faculty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FacultyAggregateArgs>(args: Subset<T, FacultyAggregateArgs>): Prisma.PrismaPromise<GetFacultyAggregateType<T>>

    /**
     * Group by Faculty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FacultyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FacultyGroupByArgs['orderBy'] }
        : { orderBy?: FacultyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FacultyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFacultyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Faculty model
   */
  readonly fields: FacultyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Faculty.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FacultyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    batches<T extends Faculty$batchesArgs<ExtArgs> = {}>(args?: Subset<T, Faculty$batchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attendance<T extends Faculty$attendanceArgs<ExtArgs> = {}>(args?: Subset<T, Faculty$attendanceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tasks<T extends Faculty$tasksArgs<ExtArgs> = {}>(args?: Subset<T, Faculty$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    financialRecords<T extends Faculty$financialRecordsArgs<ExtArgs> = {}>(args?: Subset<T, Faculty$financialRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinancialRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    clientAdmin<T extends ClientAdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientAdminDefaultArgs<ExtArgs>>): Prisma__ClientAdminClient<$Result.GetResult<Prisma.$ClientAdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Faculty model
   */
  interface FacultyFieldRefs {
    readonly id: FieldRef<"Faculty", 'Int'>
    readonly name: FieldRef<"Faculty", 'String'>
    readonly email: FieldRef<"Faculty", 'String'>
    readonly password: FieldRef<"Faculty", 'String'>
    readonly contact: FieldRef<"Faculty", 'String'>
    readonly joiningDate: FieldRef<"Faculty", 'DateTime'>
    readonly specialization: FieldRef<"Faculty", 'String'>
    readonly role: FieldRef<"Faculty", 'UserRole'>
    readonly country: FieldRef<"Faculty", 'String'>
    readonly state: FieldRef<"Faculty", 'String'>
    readonly city: FieldRef<"Faculty", 'String'>
    readonly zipCode: FieldRef<"Faculty", 'String'>
    readonly currentSessionToken: FieldRef<"Faculty", 'String'>
    readonly lastLoginAt: FieldRef<"Faculty", 'DateTime'>
    readonly clientAdminId: FieldRef<"Faculty", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Faculty findUnique
   */
  export type FacultyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faculty
     */
    omit?: FacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyInclude<ExtArgs> | null
    /**
     * Filter, which Faculty to fetch.
     */
    where: FacultyWhereUniqueInput
  }

  /**
   * Faculty findUniqueOrThrow
   */
  export type FacultyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faculty
     */
    omit?: FacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyInclude<ExtArgs> | null
    /**
     * Filter, which Faculty to fetch.
     */
    where: FacultyWhereUniqueInput
  }

  /**
   * Faculty findFirst
   */
  export type FacultyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faculty
     */
    omit?: FacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyInclude<ExtArgs> | null
    /**
     * Filter, which Faculty to fetch.
     */
    where?: FacultyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Faculties to fetch.
     */
    orderBy?: FacultyOrderByWithRelationInput | FacultyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Faculties.
     */
    cursor?: FacultyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Faculties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Faculties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Faculties.
     */
    distinct?: FacultyScalarFieldEnum | FacultyScalarFieldEnum[]
  }

  /**
   * Faculty findFirstOrThrow
   */
  export type FacultyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faculty
     */
    omit?: FacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyInclude<ExtArgs> | null
    /**
     * Filter, which Faculty to fetch.
     */
    where?: FacultyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Faculties to fetch.
     */
    orderBy?: FacultyOrderByWithRelationInput | FacultyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Faculties.
     */
    cursor?: FacultyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Faculties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Faculties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Faculties.
     */
    distinct?: FacultyScalarFieldEnum | FacultyScalarFieldEnum[]
  }

  /**
   * Faculty findMany
   */
  export type FacultyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faculty
     */
    omit?: FacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyInclude<ExtArgs> | null
    /**
     * Filter, which Faculties to fetch.
     */
    where?: FacultyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Faculties to fetch.
     */
    orderBy?: FacultyOrderByWithRelationInput | FacultyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Faculties.
     */
    cursor?: FacultyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Faculties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Faculties.
     */
    skip?: number
    distinct?: FacultyScalarFieldEnum | FacultyScalarFieldEnum[]
  }

  /**
   * Faculty create
   */
  export type FacultyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faculty
     */
    omit?: FacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyInclude<ExtArgs> | null
    /**
     * The data needed to create a Faculty.
     */
    data: XOR<FacultyCreateInput, FacultyUncheckedCreateInput>
  }

  /**
   * Faculty createMany
   */
  export type FacultyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Faculties.
     */
    data: FacultyCreateManyInput | FacultyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Faculty createManyAndReturn
   */
  export type FacultyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Faculty
     */
    omit?: FacultyOmit<ExtArgs> | null
    /**
     * The data used to create many Faculties.
     */
    data: FacultyCreateManyInput | FacultyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Faculty update
   */
  export type FacultyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faculty
     */
    omit?: FacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyInclude<ExtArgs> | null
    /**
     * The data needed to update a Faculty.
     */
    data: XOR<FacultyUpdateInput, FacultyUncheckedUpdateInput>
    /**
     * Choose, which Faculty to update.
     */
    where: FacultyWhereUniqueInput
  }

  /**
   * Faculty updateMany
   */
  export type FacultyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Faculties.
     */
    data: XOR<FacultyUpdateManyMutationInput, FacultyUncheckedUpdateManyInput>
    /**
     * Filter which Faculties to update
     */
    where?: FacultyWhereInput
    /**
     * Limit how many Faculties to update.
     */
    limit?: number
  }

  /**
   * Faculty updateManyAndReturn
   */
  export type FacultyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Faculty
     */
    omit?: FacultyOmit<ExtArgs> | null
    /**
     * The data used to update Faculties.
     */
    data: XOR<FacultyUpdateManyMutationInput, FacultyUncheckedUpdateManyInput>
    /**
     * Filter which Faculties to update
     */
    where?: FacultyWhereInput
    /**
     * Limit how many Faculties to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Faculty upsert
   */
  export type FacultyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faculty
     */
    omit?: FacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyInclude<ExtArgs> | null
    /**
     * The filter to search for the Faculty to update in case it exists.
     */
    where: FacultyWhereUniqueInput
    /**
     * In case the Faculty found by the `where` argument doesn't exist, create a new Faculty with this data.
     */
    create: XOR<FacultyCreateInput, FacultyUncheckedCreateInput>
    /**
     * In case the Faculty was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FacultyUpdateInput, FacultyUncheckedUpdateInput>
  }

  /**
   * Faculty delete
   */
  export type FacultyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faculty
     */
    omit?: FacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyInclude<ExtArgs> | null
    /**
     * Filter which Faculty to delete.
     */
    where: FacultyWhereUniqueInput
  }

  /**
   * Faculty deleteMany
   */
  export type FacultyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Faculties to delete
     */
    where?: FacultyWhereInput
    /**
     * Limit how many Faculties to delete.
     */
    limit?: number
  }

  /**
   * Faculty.batches
   */
  export type Faculty$batchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    where?: BatchWhereInput
    orderBy?: BatchOrderByWithRelationInput | BatchOrderByWithRelationInput[]
    cursor?: BatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BatchScalarFieldEnum | BatchScalarFieldEnum[]
  }

  /**
   * Faculty.attendance
   */
  export type Faculty$attendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceRecord
     */
    omit?: AttendanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    where?: AttendanceRecordWhereInput
    orderBy?: AttendanceRecordOrderByWithRelationInput | AttendanceRecordOrderByWithRelationInput[]
    cursor?: AttendanceRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceRecordScalarFieldEnum | AttendanceRecordScalarFieldEnum[]
  }

  /**
   * Faculty.tasks
   */
  export type Faculty$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTask
     */
    select?: StudentTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentTask
     */
    omit?: StudentTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTaskInclude<ExtArgs> | null
    where?: StudentTaskWhereInput
    orderBy?: StudentTaskOrderByWithRelationInput | StudentTaskOrderByWithRelationInput[]
    cursor?: StudentTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentTaskScalarFieldEnum | StudentTaskScalarFieldEnum[]
  }

  /**
   * Faculty.financialRecords
   */
  export type Faculty$financialRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialRecord
     */
    select?: FinancialRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialRecord
     */
    omit?: FinancialRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialRecordInclude<ExtArgs> | null
    where?: FinancialRecordWhereInput
    orderBy?: FinancialRecordOrderByWithRelationInput | FinancialRecordOrderByWithRelationInput[]
    cursor?: FinancialRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FinancialRecordScalarFieldEnum | FinancialRecordScalarFieldEnum[]
  }

  /**
   * Faculty without action
   */
  export type FacultyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faculty
     */
    omit?: FacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyInclude<ExtArgs> | null
  }


  /**
   * Model Lab
   */

  export type AggregateLab = {
    _count: LabCountAggregateOutputType | null
    _avg: LabAvgAggregateOutputType | null
    _sum: LabSumAggregateOutputType | null
    _min: LabMinAggregateOutputType | null
    _max: LabMaxAggregateOutputType | null
  }

  export type LabAvgAggregateOutputType = {
    id: number | null
    totalPCs: number | null
  }

  export type LabSumAggregateOutputType = {
    id: number | null
    totalPCs: number | null
  }

  export type LabMinAggregateOutputType = {
    id: number | null
    name: string | null
    location: string | null
    totalPCs: number | null
    isActive: boolean | null
    clientAdminId: string | null
  }

  export type LabMaxAggregateOutputType = {
    id: number | null
    name: string | null
    location: string | null
    totalPCs: number | null
    isActive: boolean | null
    clientAdminId: string | null
  }

  export type LabCountAggregateOutputType = {
    id: number
    name: number
    location: number
    totalPCs: number
    isActive: number
    clientAdminId: number
    _all: number
  }


  export type LabAvgAggregateInputType = {
    id?: true
    totalPCs?: true
  }

  export type LabSumAggregateInputType = {
    id?: true
    totalPCs?: true
  }

  export type LabMinAggregateInputType = {
    id?: true
    name?: true
    location?: true
    totalPCs?: true
    isActive?: true
    clientAdminId?: true
  }

  export type LabMaxAggregateInputType = {
    id?: true
    name?: true
    location?: true
    totalPCs?: true
    isActive?: true
    clientAdminId?: true
  }

  export type LabCountAggregateInputType = {
    id?: true
    name?: true
    location?: true
    totalPCs?: true
    isActive?: true
    clientAdminId?: true
    _all?: true
  }

  export type LabAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lab to aggregate.
     */
    where?: LabWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Labs to fetch.
     */
    orderBy?: LabOrderByWithRelationInput | LabOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LabWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Labs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Labs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Labs
    **/
    _count?: true | LabCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LabAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LabSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LabMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LabMaxAggregateInputType
  }

  export type GetLabAggregateType<T extends LabAggregateArgs> = {
        [P in keyof T & keyof AggregateLab]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLab[P]>
      : GetScalarType<T[P], AggregateLab[P]>
  }




  export type LabGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabWhereInput
    orderBy?: LabOrderByWithAggregationInput | LabOrderByWithAggregationInput[]
    by: LabScalarFieldEnum[] | LabScalarFieldEnum
    having?: LabScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LabCountAggregateInputType | true
    _avg?: LabAvgAggregateInputType
    _sum?: LabSumAggregateInputType
    _min?: LabMinAggregateInputType
    _max?: LabMaxAggregateInputType
  }

  export type LabGroupByOutputType = {
    id: number
    name: string
    location: string | null
    totalPCs: number
    isActive: boolean
    clientAdminId: string
    _count: LabCountAggregateOutputType | null
    _avg: LabAvgAggregateOutputType | null
    _sum: LabSumAggregateOutputType | null
    _min: LabMinAggregateOutputType | null
    _max: LabMaxAggregateOutputType | null
  }

  type GetLabGroupByPayload<T extends LabGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LabGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LabGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LabGroupByOutputType[P]>
            : GetScalarType<T[P], LabGroupByOutputType[P]>
        }
      >
    >


  export type LabSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    location?: boolean
    totalPCs?: boolean
    isActive?: boolean
    clientAdminId?: boolean
    timeSlots?: boolean | Lab$timeSlotsArgs<ExtArgs>
    financialRecords?: boolean | Lab$financialRecordsArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
    _count?: boolean | LabCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lab"]>

  export type LabSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    location?: boolean
    totalPCs?: boolean
    isActive?: boolean
    clientAdminId?: boolean
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lab"]>

  export type LabSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    location?: boolean
    totalPCs?: boolean
    isActive?: boolean
    clientAdminId?: boolean
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lab"]>

  export type LabSelectScalar = {
    id?: boolean
    name?: boolean
    location?: boolean
    totalPCs?: boolean
    isActive?: boolean
    clientAdminId?: boolean
  }

  export type LabOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "location" | "totalPCs" | "isActive" | "clientAdminId", ExtArgs["result"]["lab"]>
  export type LabInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    timeSlots?: boolean | Lab$timeSlotsArgs<ExtArgs>
    financialRecords?: boolean | Lab$financialRecordsArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
    _count?: boolean | LabCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LabIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }
  export type LabIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }

  export type $LabPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lab"
    objects: {
      timeSlots: Prisma.$LabTimeSlotPayload<ExtArgs>[]
      financialRecords: Prisma.$FinancialRecordPayload<ExtArgs>[]
      clientAdmin: Prisma.$ClientAdminPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      location: string | null
      totalPCs: number
      isActive: boolean
      clientAdminId: string
    }, ExtArgs["result"]["lab"]>
    composites: {}
  }

  type LabGetPayload<S extends boolean | null | undefined | LabDefaultArgs> = $Result.GetResult<Prisma.$LabPayload, S>

  type LabCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LabFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LabCountAggregateInputType | true
    }

  export interface LabDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lab'], meta: { name: 'Lab' } }
    /**
     * Find zero or one Lab that matches the filter.
     * @param {LabFindUniqueArgs} args - Arguments to find a Lab
     * @example
     * // Get one Lab
     * const lab = await prisma.lab.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LabFindUniqueArgs>(args: SelectSubset<T, LabFindUniqueArgs<ExtArgs>>): Prisma__LabClient<$Result.GetResult<Prisma.$LabPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Lab that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LabFindUniqueOrThrowArgs} args - Arguments to find a Lab
     * @example
     * // Get one Lab
     * const lab = await prisma.lab.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LabFindUniqueOrThrowArgs>(args: SelectSubset<T, LabFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LabClient<$Result.GetResult<Prisma.$LabPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lab that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabFindFirstArgs} args - Arguments to find a Lab
     * @example
     * // Get one Lab
     * const lab = await prisma.lab.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LabFindFirstArgs>(args?: SelectSubset<T, LabFindFirstArgs<ExtArgs>>): Prisma__LabClient<$Result.GetResult<Prisma.$LabPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lab that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabFindFirstOrThrowArgs} args - Arguments to find a Lab
     * @example
     * // Get one Lab
     * const lab = await prisma.lab.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LabFindFirstOrThrowArgs>(args?: SelectSubset<T, LabFindFirstOrThrowArgs<ExtArgs>>): Prisma__LabClient<$Result.GetResult<Prisma.$LabPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Labs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Labs
     * const labs = await prisma.lab.findMany()
     * 
     * // Get first 10 Labs
     * const labs = await prisma.lab.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const labWithIdOnly = await prisma.lab.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LabFindManyArgs>(args?: SelectSubset<T, LabFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Lab.
     * @param {LabCreateArgs} args - Arguments to create a Lab.
     * @example
     * // Create one Lab
     * const Lab = await prisma.lab.create({
     *   data: {
     *     // ... data to create a Lab
     *   }
     * })
     * 
     */
    create<T extends LabCreateArgs>(args: SelectSubset<T, LabCreateArgs<ExtArgs>>): Prisma__LabClient<$Result.GetResult<Prisma.$LabPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Labs.
     * @param {LabCreateManyArgs} args - Arguments to create many Labs.
     * @example
     * // Create many Labs
     * const lab = await prisma.lab.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LabCreateManyArgs>(args?: SelectSubset<T, LabCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Labs and returns the data saved in the database.
     * @param {LabCreateManyAndReturnArgs} args - Arguments to create many Labs.
     * @example
     * // Create many Labs
     * const lab = await prisma.lab.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Labs and only return the `id`
     * const labWithIdOnly = await prisma.lab.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LabCreateManyAndReturnArgs>(args?: SelectSubset<T, LabCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Lab.
     * @param {LabDeleteArgs} args - Arguments to delete one Lab.
     * @example
     * // Delete one Lab
     * const Lab = await prisma.lab.delete({
     *   where: {
     *     // ... filter to delete one Lab
     *   }
     * })
     * 
     */
    delete<T extends LabDeleteArgs>(args: SelectSubset<T, LabDeleteArgs<ExtArgs>>): Prisma__LabClient<$Result.GetResult<Prisma.$LabPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Lab.
     * @param {LabUpdateArgs} args - Arguments to update one Lab.
     * @example
     * // Update one Lab
     * const lab = await prisma.lab.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LabUpdateArgs>(args: SelectSubset<T, LabUpdateArgs<ExtArgs>>): Prisma__LabClient<$Result.GetResult<Prisma.$LabPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Labs.
     * @param {LabDeleteManyArgs} args - Arguments to filter Labs to delete.
     * @example
     * // Delete a few Labs
     * const { count } = await prisma.lab.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LabDeleteManyArgs>(args?: SelectSubset<T, LabDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Labs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Labs
     * const lab = await prisma.lab.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LabUpdateManyArgs>(args: SelectSubset<T, LabUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Labs and returns the data updated in the database.
     * @param {LabUpdateManyAndReturnArgs} args - Arguments to update many Labs.
     * @example
     * // Update many Labs
     * const lab = await prisma.lab.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Labs and only return the `id`
     * const labWithIdOnly = await prisma.lab.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LabUpdateManyAndReturnArgs>(args: SelectSubset<T, LabUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Lab.
     * @param {LabUpsertArgs} args - Arguments to update or create a Lab.
     * @example
     * // Update or create a Lab
     * const lab = await prisma.lab.upsert({
     *   create: {
     *     // ... data to create a Lab
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lab we want to update
     *   }
     * })
     */
    upsert<T extends LabUpsertArgs>(args: SelectSubset<T, LabUpsertArgs<ExtArgs>>): Prisma__LabClient<$Result.GetResult<Prisma.$LabPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Labs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabCountArgs} args - Arguments to filter Labs to count.
     * @example
     * // Count the number of Labs
     * const count = await prisma.lab.count({
     *   where: {
     *     // ... the filter for the Labs we want to count
     *   }
     * })
    **/
    count<T extends LabCountArgs>(
      args?: Subset<T, LabCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LabCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lab.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LabAggregateArgs>(args: Subset<T, LabAggregateArgs>): Prisma.PrismaPromise<GetLabAggregateType<T>>

    /**
     * Group by Lab.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LabGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LabGroupByArgs['orderBy'] }
        : { orderBy?: LabGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LabGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLabGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lab model
   */
  readonly fields: LabFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lab.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LabClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    timeSlots<T extends Lab$timeSlotsArgs<ExtArgs> = {}>(args?: Subset<T, Lab$timeSlotsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabTimeSlotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    financialRecords<T extends Lab$financialRecordsArgs<ExtArgs> = {}>(args?: Subset<T, Lab$financialRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinancialRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    clientAdmin<T extends ClientAdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientAdminDefaultArgs<ExtArgs>>): Prisma__ClientAdminClient<$Result.GetResult<Prisma.$ClientAdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lab model
   */
  interface LabFieldRefs {
    readonly id: FieldRef<"Lab", 'Int'>
    readonly name: FieldRef<"Lab", 'String'>
    readonly location: FieldRef<"Lab", 'String'>
    readonly totalPCs: FieldRef<"Lab", 'Int'>
    readonly isActive: FieldRef<"Lab", 'Boolean'>
    readonly clientAdminId: FieldRef<"Lab", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Lab findUnique
   */
  export type LabFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lab
     */
    select?: LabSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lab
     */
    omit?: LabOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabInclude<ExtArgs> | null
    /**
     * Filter, which Lab to fetch.
     */
    where: LabWhereUniqueInput
  }

  /**
   * Lab findUniqueOrThrow
   */
  export type LabFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lab
     */
    select?: LabSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lab
     */
    omit?: LabOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabInclude<ExtArgs> | null
    /**
     * Filter, which Lab to fetch.
     */
    where: LabWhereUniqueInput
  }

  /**
   * Lab findFirst
   */
  export type LabFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lab
     */
    select?: LabSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lab
     */
    omit?: LabOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabInclude<ExtArgs> | null
    /**
     * Filter, which Lab to fetch.
     */
    where?: LabWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Labs to fetch.
     */
    orderBy?: LabOrderByWithRelationInput | LabOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Labs.
     */
    cursor?: LabWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Labs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Labs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Labs.
     */
    distinct?: LabScalarFieldEnum | LabScalarFieldEnum[]
  }

  /**
   * Lab findFirstOrThrow
   */
  export type LabFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lab
     */
    select?: LabSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lab
     */
    omit?: LabOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabInclude<ExtArgs> | null
    /**
     * Filter, which Lab to fetch.
     */
    where?: LabWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Labs to fetch.
     */
    orderBy?: LabOrderByWithRelationInput | LabOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Labs.
     */
    cursor?: LabWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Labs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Labs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Labs.
     */
    distinct?: LabScalarFieldEnum | LabScalarFieldEnum[]
  }

  /**
   * Lab findMany
   */
  export type LabFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lab
     */
    select?: LabSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lab
     */
    omit?: LabOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabInclude<ExtArgs> | null
    /**
     * Filter, which Labs to fetch.
     */
    where?: LabWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Labs to fetch.
     */
    orderBy?: LabOrderByWithRelationInput | LabOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Labs.
     */
    cursor?: LabWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Labs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Labs.
     */
    skip?: number
    distinct?: LabScalarFieldEnum | LabScalarFieldEnum[]
  }

  /**
   * Lab create
   */
  export type LabCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lab
     */
    select?: LabSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lab
     */
    omit?: LabOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabInclude<ExtArgs> | null
    /**
     * The data needed to create a Lab.
     */
    data: XOR<LabCreateInput, LabUncheckedCreateInput>
  }

  /**
   * Lab createMany
   */
  export type LabCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Labs.
     */
    data: LabCreateManyInput | LabCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Lab createManyAndReturn
   */
  export type LabCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lab
     */
    select?: LabSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lab
     */
    omit?: LabOmit<ExtArgs> | null
    /**
     * The data used to create many Labs.
     */
    data: LabCreateManyInput | LabCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lab update
   */
  export type LabUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lab
     */
    select?: LabSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lab
     */
    omit?: LabOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabInclude<ExtArgs> | null
    /**
     * The data needed to update a Lab.
     */
    data: XOR<LabUpdateInput, LabUncheckedUpdateInput>
    /**
     * Choose, which Lab to update.
     */
    where: LabWhereUniqueInput
  }

  /**
   * Lab updateMany
   */
  export type LabUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Labs.
     */
    data: XOR<LabUpdateManyMutationInput, LabUncheckedUpdateManyInput>
    /**
     * Filter which Labs to update
     */
    where?: LabWhereInput
    /**
     * Limit how many Labs to update.
     */
    limit?: number
  }

  /**
   * Lab updateManyAndReturn
   */
  export type LabUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lab
     */
    select?: LabSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lab
     */
    omit?: LabOmit<ExtArgs> | null
    /**
     * The data used to update Labs.
     */
    data: XOR<LabUpdateManyMutationInput, LabUncheckedUpdateManyInput>
    /**
     * Filter which Labs to update
     */
    where?: LabWhereInput
    /**
     * Limit how many Labs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lab upsert
   */
  export type LabUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lab
     */
    select?: LabSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lab
     */
    omit?: LabOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabInclude<ExtArgs> | null
    /**
     * The filter to search for the Lab to update in case it exists.
     */
    where: LabWhereUniqueInput
    /**
     * In case the Lab found by the `where` argument doesn't exist, create a new Lab with this data.
     */
    create: XOR<LabCreateInput, LabUncheckedCreateInput>
    /**
     * In case the Lab was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LabUpdateInput, LabUncheckedUpdateInput>
  }

  /**
   * Lab delete
   */
  export type LabDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lab
     */
    select?: LabSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lab
     */
    omit?: LabOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabInclude<ExtArgs> | null
    /**
     * Filter which Lab to delete.
     */
    where: LabWhereUniqueInput
  }

  /**
   * Lab deleteMany
   */
  export type LabDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Labs to delete
     */
    where?: LabWhereInput
    /**
     * Limit how many Labs to delete.
     */
    limit?: number
  }

  /**
   * Lab.timeSlots
   */
  export type Lab$timeSlotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabTimeSlot
     */
    select?: LabTimeSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabTimeSlot
     */
    omit?: LabTimeSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabTimeSlotInclude<ExtArgs> | null
    where?: LabTimeSlotWhereInput
    orderBy?: LabTimeSlotOrderByWithRelationInput | LabTimeSlotOrderByWithRelationInput[]
    cursor?: LabTimeSlotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LabTimeSlotScalarFieldEnum | LabTimeSlotScalarFieldEnum[]
  }

  /**
   * Lab.financialRecords
   */
  export type Lab$financialRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialRecord
     */
    select?: FinancialRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialRecord
     */
    omit?: FinancialRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialRecordInclude<ExtArgs> | null
    where?: FinancialRecordWhereInput
    orderBy?: FinancialRecordOrderByWithRelationInput | FinancialRecordOrderByWithRelationInput[]
    cursor?: FinancialRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FinancialRecordScalarFieldEnum | FinancialRecordScalarFieldEnum[]
  }

  /**
   * Lab without action
   */
  export type LabDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lab
     */
    select?: LabSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lab
     */
    omit?: LabOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabInclude<ExtArgs> | null
  }


  /**
   * Model LabTimeSlot
   */

  export type AggregateLabTimeSlot = {
    _count: LabTimeSlotCountAggregateOutputType | null
    _avg: LabTimeSlotAvgAggregateOutputType | null
    _sum: LabTimeSlotSumAggregateOutputType | null
    _min: LabTimeSlotMinAggregateOutputType | null
    _max: LabTimeSlotMaxAggregateOutputType | null
  }

  export type LabTimeSlotAvgAggregateOutputType = {
    id: number | null
    labId: number | null
    availablePCs: number | null
  }

  export type LabTimeSlotSumAggregateOutputType = {
    id: number | null
    labId: number | null
    availablePCs: number | null
  }

  export type LabTimeSlotMinAggregateOutputType = {
    id: number | null
    startTime: string | null
    endTime: string | null
    day: string | null
    labId: number | null
    availablePCs: number | null
    clientAdminId: string | null
  }

  export type LabTimeSlotMaxAggregateOutputType = {
    id: number | null
    startTime: string | null
    endTime: string | null
    day: string | null
    labId: number | null
    availablePCs: number | null
    clientAdminId: string | null
  }

  export type LabTimeSlotCountAggregateOutputType = {
    id: number
    startTime: number
    endTime: number
    day: number
    labId: number
    availablePCs: number
    clientAdminId: number
    _all: number
  }


  export type LabTimeSlotAvgAggregateInputType = {
    id?: true
    labId?: true
    availablePCs?: true
  }

  export type LabTimeSlotSumAggregateInputType = {
    id?: true
    labId?: true
    availablePCs?: true
  }

  export type LabTimeSlotMinAggregateInputType = {
    id?: true
    startTime?: true
    endTime?: true
    day?: true
    labId?: true
    availablePCs?: true
    clientAdminId?: true
  }

  export type LabTimeSlotMaxAggregateInputType = {
    id?: true
    startTime?: true
    endTime?: true
    day?: true
    labId?: true
    availablePCs?: true
    clientAdminId?: true
  }

  export type LabTimeSlotCountAggregateInputType = {
    id?: true
    startTime?: true
    endTime?: true
    day?: true
    labId?: true
    availablePCs?: true
    clientAdminId?: true
    _all?: true
  }

  export type LabTimeSlotAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LabTimeSlot to aggregate.
     */
    where?: LabTimeSlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabTimeSlots to fetch.
     */
    orderBy?: LabTimeSlotOrderByWithRelationInput | LabTimeSlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LabTimeSlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabTimeSlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabTimeSlots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LabTimeSlots
    **/
    _count?: true | LabTimeSlotCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LabTimeSlotAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LabTimeSlotSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LabTimeSlotMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LabTimeSlotMaxAggregateInputType
  }

  export type GetLabTimeSlotAggregateType<T extends LabTimeSlotAggregateArgs> = {
        [P in keyof T & keyof AggregateLabTimeSlot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLabTimeSlot[P]>
      : GetScalarType<T[P], AggregateLabTimeSlot[P]>
  }




  export type LabTimeSlotGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabTimeSlotWhereInput
    orderBy?: LabTimeSlotOrderByWithAggregationInput | LabTimeSlotOrderByWithAggregationInput[]
    by: LabTimeSlotScalarFieldEnum[] | LabTimeSlotScalarFieldEnum
    having?: LabTimeSlotScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LabTimeSlotCountAggregateInputType | true
    _avg?: LabTimeSlotAvgAggregateInputType
    _sum?: LabTimeSlotSumAggregateInputType
    _min?: LabTimeSlotMinAggregateInputType
    _max?: LabTimeSlotMaxAggregateInputType
  }

  export type LabTimeSlotGroupByOutputType = {
    id: number
    startTime: string
    endTime: string
    day: string
    labId: number
    availablePCs: number
    clientAdminId: string
    _count: LabTimeSlotCountAggregateOutputType | null
    _avg: LabTimeSlotAvgAggregateOutputType | null
    _sum: LabTimeSlotSumAggregateOutputType | null
    _min: LabTimeSlotMinAggregateOutputType | null
    _max: LabTimeSlotMaxAggregateOutputType | null
  }

  type GetLabTimeSlotGroupByPayload<T extends LabTimeSlotGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LabTimeSlotGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LabTimeSlotGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LabTimeSlotGroupByOutputType[P]>
            : GetScalarType<T[P], LabTimeSlotGroupByOutputType[P]>
        }
      >
    >


  export type LabTimeSlotSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    startTime?: boolean
    endTime?: boolean
    day?: boolean
    labId?: boolean
    availablePCs?: boolean
    clientAdminId?: boolean
    lab?: boolean | LabDefaultArgs<ExtArgs>
    batches?: boolean | LabTimeSlot$batchesArgs<ExtArgs>
    allocations?: boolean | LabTimeSlot$allocationsArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
    _count?: boolean | LabTimeSlotCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["labTimeSlot"]>

  export type LabTimeSlotSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    startTime?: boolean
    endTime?: boolean
    day?: boolean
    labId?: boolean
    availablePCs?: boolean
    clientAdminId?: boolean
    lab?: boolean | LabDefaultArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["labTimeSlot"]>

  export type LabTimeSlotSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    startTime?: boolean
    endTime?: boolean
    day?: boolean
    labId?: boolean
    availablePCs?: boolean
    clientAdminId?: boolean
    lab?: boolean | LabDefaultArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["labTimeSlot"]>

  export type LabTimeSlotSelectScalar = {
    id?: boolean
    startTime?: boolean
    endTime?: boolean
    day?: boolean
    labId?: boolean
    availablePCs?: boolean
    clientAdminId?: boolean
  }

  export type LabTimeSlotOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "startTime" | "endTime" | "day" | "labId" | "availablePCs" | "clientAdminId", ExtArgs["result"]["labTimeSlot"]>
  export type LabTimeSlotInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lab?: boolean | LabDefaultArgs<ExtArgs>
    batches?: boolean | LabTimeSlot$batchesArgs<ExtArgs>
    allocations?: boolean | LabTimeSlot$allocationsArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
    _count?: boolean | LabTimeSlotCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LabTimeSlotIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lab?: boolean | LabDefaultArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }
  export type LabTimeSlotIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lab?: boolean | LabDefaultArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }

  export type $LabTimeSlotPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LabTimeSlot"
    objects: {
      lab: Prisma.$LabPayload<ExtArgs>
      batches: Prisma.$BatchPayload<ExtArgs>[]
      allocations: Prisma.$LabAllocationPayload<ExtArgs>[]
      clientAdmin: Prisma.$ClientAdminPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      startTime: string
      endTime: string
      day: string
      labId: number
      availablePCs: number
      clientAdminId: string
    }, ExtArgs["result"]["labTimeSlot"]>
    composites: {}
  }

  type LabTimeSlotGetPayload<S extends boolean | null | undefined | LabTimeSlotDefaultArgs> = $Result.GetResult<Prisma.$LabTimeSlotPayload, S>

  type LabTimeSlotCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LabTimeSlotFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LabTimeSlotCountAggregateInputType | true
    }

  export interface LabTimeSlotDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LabTimeSlot'], meta: { name: 'LabTimeSlot' } }
    /**
     * Find zero or one LabTimeSlot that matches the filter.
     * @param {LabTimeSlotFindUniqueArgs} args - Arguments to find a LabTimeSlot
     * @example
     * // Get one LabTimeSlot
     * const labTimeSlot = await prisma.labTimeSlot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LabTimeSlotFindUniqueArgs>(args: SelectSubset<T, LabTimeSlotFindUniqueArgs<ExtArgs>>): Prisma__LabTimeSlotClient<$Result.GetResult<Prisma.$LabTimeSlotPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LabTimeSlot that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LabTimeSlotFindUniqueOrThrowArgs} args - Arguments to find a LabTimeSlot
     * @example
     * // Get one LabTimeSlot
     * const labTimeSlot = await prisma.labTimeSlot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LabTimeSlotFindUniqueOrThrowArgs>(args: SelectSubset<T, LabTimeSlotFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LabTimeSlotClient<$Result.GetResult<Prisma.$LabTimeSlotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LabTimeSlot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabTimeSlotFindFirstArgs} args - Arguments to find a LabTimeSlot
     * @example
     * // Get one LabTimeSlot
     * const labTimeSlot = await prisma.labTimeSlot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LabTimeSlotFindFirstArgs>(args?: SelectSubset<T, LabTimeSlotFindFirstArgs<ExtArgs>>): Prisma__LabTimeSlotClient<$Result.GetResult<Prisma.$LabTimeSlotPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LabTimeSlot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabTimeSlotFindFirstOrThrowArgs} args - Arguments to find a LabTimeSlot
     * @example
     * // Get one LabTimeSlot
     * const labTimeSlot = await prisma.labTimeSlot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LabTimeSlotFindFirstOrThrowArgs>(args?: SelectSubset<T, LabTimeSlotFindFirstOrThrowArgs<ExtArgs>>): Prisma__LabTimeSlotClient<$Result.GetResult<Prisma.$LabTimeSlotPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LabTimeSlots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabTimeSlotFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LabTimeSlots
     * const labTimeSlots = await prisma.labTimeSlot.findMany()
     * 
     * // Get first 10 LabTimeSlots
     * const labTimeSlots = await prisma.labTimeSlot.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const labTimeSlotWithIdOnly = await prisma.labTimeSlot.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LabTimeSlotFindManyArgs>(args?: SelectSubset<T, LabTimeSlotFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabTimeSlotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LabTimeSlot.
     * @param {LabTimeSlotCreateArgs} args - Arguments to create a LabTimeSlot.
     * @example
     * // Create one LabTimeSlot
     * const LabTimeSlot = await prisma.labTimeSlot.create({
     *   data: {
     *     // ... data to create a LabTimeSlot
     *   }
     * })
     * 
     */
    create<T extends LabTimeSlotCreateArgs>(args: SelectSubset<T, LabTimeSlotCreateArgs<ExtArgs>>): Prisma__LabTimeSlotClient<$Result.GetResult<Prisma.$LabTimeSlotPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LabTimeSlots.
     * @param {LabTimeSlotCreateManyArgs} args - Arguments to create many LabTimeSlots.
     * @example
     * // Create many LabTimeSlots
     * const labTimeSlot = await prisma.labTimeSlot.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LabTimeSlotCreateManyArgs>(args?: SelectSubset<T, LabTimeSlotCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LabTimeSlots and returns the data saved in the database.
     * @param {LabTimeSlotCreateManyAndReturnArgs} args - Arguments to create many LabTimeSlots.
     * @example
     * // Create many LabTimeSlots
     * const labTimeSlot = await prisma.labTimeSlot.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LabTimeSlots and only return the `id`
     * const labTimeSlotWithIdOnly = await prisma.labTimeSlot.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LabTimeSlotCreateManyAndReturnArgs>(args?: SelectSubset<T, LabTimeSlotCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabTimeSlotPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LabTimeSlot.
     * @param {LabTimeSlotDeleteArgs} args - Arguments to delete one LabTimeSlot.
     * @example
     * // Delete one LabTimeSlot
     * const LabTimeSlot = await prisma.labTimeSlot.delete({
     *   where: {
     *     // ... filter to delete one LabTimeSlot
     *   }
     * })
     * 
     */
    delete<T extends LabTimeSlotDeleteArgs>(args: SelectSubset<T, LabTimeSlotDeleteArgs<ExtArgs>>): Prisma__LabTimeSlotClient<$Result.GetResult<Prisma.$LabTimeSlotPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LabTimeSlot.
     * @param {LabTimeSlotUpdateArgs} args - Arguments to update one LabTimeSlot.
     * @example
     * // Update one LabTimeSlot
     * const labTimeSlot = await prisma.labTimeSlot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LabTimeSlotUpdateArgs>(args: SelectSubset<T, LabTimeSlotUpdateArgs<ExtArgs>>): Prisma__LabTimeSlotClient<$Result.GetResult<Prisma.$LabTimeSlotPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LabTimeSlots.
     * @param {LabTimeSlotDeleteManyArgs} args - Arguments to filter LabTimeSlots to delete.
     * @example
     * // Delete a few LabTimeSlots
     * const { count } = await prisma.labTimeSlot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LabTimeSlotDeleteManyArgs>(args?: SelectSubset<T, LabTimeSlotDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LabTimeSlots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabTimeSlotUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LabTimeSlots
     * const labTimeSlot = await prisma.labTimeSlot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LabTimeSlotUpdateManyArgs>(args: SelectSubset<T, LabTimeSlotUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LabTimeSlots and returns the data updated in the database.
     * @param {LabTimeSlotUpdateManyAndReturnArgs} args - Arguments to update many LabTimeSlots.
     * @example
     * // Update many LabTimeSlots
     * const labTimeSlot = await prisma.labTimeSlot.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LabTimeSlots and only return the `id`
     * const labTimeSlotWithIdOnly = await prisma.labTimeSlot.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LabTimeSlotUpdateManyAndReturnArgs>(args: SelectSubset<T, LabTimeSlotUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabTimeSlotPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LabTimeSlot.
     * @param {LabTimeSlotUpsertArgs} args - Arguments to update or create a LabTimeSlot.
     * @example
     * // Update or create a LabTimeSlot
     * const labTimeSlot = await prisma.labTimeSlot.upsert({
     *   create: {
     *     // ... data to create a LabTimeSlot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LabTimeSlot we want to update
     *   }
     * })
     */
    upsert<T extends LabTimeSlotUpsertArgs>(args: SelectSubset<T, LabTimeSlotUpsertArgs<ExtArgs>>): Prisma__LabTimeSlotClient<$Result.GetResult<Prisma.$LabTimeSlotPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LabTimeSlots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabTimeSlotCountArgs} args - Arguments to filter LabTimeSlots to count.
     * @example
     * // Count the number of LabTimeSlots
     * const count = await prisma.labTimeSlot.count({
     *   where: {
     *     // ... the filter for the LabTimeSlots we want to count
     *   }
     * })
    **/
    count<T extends LabTimeSlotCountArgs>(
      args?: Subset<T, LabTimeSlotCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LabTimeSlotCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LabTimeSlot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabTimeSlotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LabTimeSlotAggregateArgs>(args: Subset<T, LabTimeSlotAggregateArgs>): Prisma.PrismaPromise<GetLabTimeSlotAggregateType<T>>

    /**
     * Group by LabTimeSlot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabTimeSlotGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LabTimeSlotGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LabTimeSlotGroupByArgs['orderBy'] }
        : { orderBy?: LabTimeSlotGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LabTimeSlotGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLabTimeSlotGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LabTimeSlot model
   */
  readonly fields: LabTimeSlotFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LabTimeSlot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LabTimeSlotClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lab<T extends LabDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LabDefaultArgs<ExtArgs>>): Prisma__LabClient<$Result.GetResult<Prisma.$LabPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    batches<T extends LabTimeSlot$batchesArgs<ExtArgs> = {}>(args?: Subset<T, LabTimeSlot$batchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    allocations<T extends LabTimeSlot$allocationsArgs<ExtArgs> = {}>(args?: Subset<T, LabTimeSlot$allocationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabAllocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    clientAdmin<T extends ClientAdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientAdminDefaultArgs<ExtArgs>>): Prisma__ClientAdminClient<$Result.GetResult<Prisma.$ClientAdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LabTimeSlot model
   */
  interface LabTimeSlotFieldRefs {
    readonly id: FieldRef<"LabTimeSlot", 'Int'>
    readonly startTime: FieldRef<"LabTimeSlot", 'String'>
    readonly endTime: FieldRef<"LabTimeSlot", 'String'>
    readonly day: FieldRef<"LabTimeSlot", 'String'>
    readonly labId: FieldRef<"LabTimeSlot", 'Int'>
    readonly availablePCs: FieldRef<"LabTimeSlot", 'Int'>
    readonly clientAdminId: FieldRef<"LabTimeSlot", 'String'>
  }
    

  // Custom InputTypes
  /**
   * LabTimeSlot findUnique
   */
  export type LabTimeSlotFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabTimeSlot
     */
    select?: LabTimeSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabTimeSlot
     */
    omit?: LabTimeSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabTimeSlotInclude<ExtArgs> | null
    /**
     * Filter, which LabTimeSlot to fetch.
     */
    where: LabTimeSlotWhereUniqueInput
  }

  /**
   * LabTimeSlot findUniqueOrThrow
   */
  export type LabTimeSlotFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabTimeSlot
     */
    select?: LabTimeSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabTimeSlot
     */
    omit?: LabTimeSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabTimeSlotInclude<ExtArgs> | null
    /**
     * Filter, which LabTimeSlot to fetch.
     */
    where: LabTimeSlotWhereUniqueInput
  }

  /**
   * LabTimeSlot findFirst
   */
  export type LabTimeSlotFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabTimeSlot
     */
    select?: LabTimeSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabTimeSlot
     */
    omit?: LabTimeSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabTimeSlotInclude<ExtArgs> | null
    /**
     * Filter, which LabTimeSlot to fetch.
     */
    where?: LabTimeSlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabTimeSlots to fetch.
     */
    orderBy?: LabTimeSlotOrderByWithRelationInput | LabTimeSlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LabTimeSlots.
     */
    cursor?: LabTimeSlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabTimeSlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabTimeSlots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LabTimeSlots.
     */
    distinct?: LabTimeSlotScalarFieldEnum | LabTimeSlotScalarFieldEnum[]
  }

  /**
   * LabTimeSlot findFirstOrThrow
   */
  export type LabTimeSlotFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabTimeSlot
     */
    select?: LabTimeSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabTimeSlot
     */
    omit?: LabTimeSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabTimeSlotInclude<ExtArgs> | null
    /**
     * Filter, which LabTimeSlot to fetch.
     */
    where?: LabTimeSlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabTimeSlots to fetch.
     */
    orderBy?: LabTimeSlotOrderByWithRelationInput | LabTimeSlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LabTimeSlots.
     */
    cursor?: LabTimeSlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabTimeSlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabTimeSlots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LabTimeSlots.
     */
    distinct?: LabTimeSlotScalarFieldEnum | LabTimeSlotScalarFieldEnum[]
  }

  /**
   * LabTimeSlot findMany
   */
  export type LabTimeSlotFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabTimeSlot
     */
    select?: LabTimeSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabTimeSlot
     */
    omit?: LabTimeSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabTimeSlotInclude<ExtArgs> | null
    /**
     * Filter, which LabTimeSlots to fetch.
     */
    where?: LabTimeSlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabTimeSlots to fetch.
     */
    orderBy?: LabTimeSlotOrderByWithRelationInput | LabTimeSlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LabTimeSlots.
     */
    cursor?: LabTimeSlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabTimeSlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabTimeSlots.
     */
    skip?: number
    distinct?: LabTimeSlotScalarFieldEnum | LabTimeSlotScalarFieldEnum[]
  }

  /**
   * LabTimeSlot create
   */
  export type LabTimeSlotCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabTimeSlot
     */
    select?: LabTimeSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabTimeSlot
     */
    omit?: LabTimeSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabTimeSlotInclude<ExtArgs> | null
    /**
     * The data needed to create a LabTimeSlot.
     */
    data: XOR<LabTimeSlotCreateInput, LabTimeSlotUncheckedCreateInput>
  }

  /**
   * LabTimeSlot createMany
   */
  export type LabTimeSlotCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LabTimeSlots.
     */
    data: LabTimeSlotCreateManyInput | LabTimeSlotCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LabTimeSlot createManyAndReturn
   */
  export type LabTimeSlotCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabTimeSlot
     */
    select?: LabTimeSlotSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LabTimeSlot
     */
    omit?: LabTimeSlotOmit<ExtArgs> | null
    /**
     * The data used to create many LabTimeSlots.
     */
    data: LabTimeSlotCreateManyInput | LabTimeSlotCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabTimeSlotIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LabTimeSlot update
   */
  export type LabTimeSlotUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabTimeSlot
     */
    select?: LabTimeSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabTimeSlot
     */
    omit?: LabTimeSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabTimeSlotInclude<ExtArgs> | null
    /**
     * The data needed to update a LabTimeSlot.
     */
    data: XOR<LabTimeSlotUpdateInput, LabTimeSlotUncheckedUpdateInput>
    /**
     * Choose, which LabTimeSlot to update.
     */
    where: LabTimeSlotWhereUniqueInput
  }

  /**
   * LabTimeSlot updateMany
   */
  export type LabTimeSlotUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LabTimeSlots.
     */
    data: XOR<LabTimeSlotUpdateManyMutationInput, LabTimeSlotUncheckedUpdateManyInput>
    /**
     * Filter which LabTimeSlots to update
     */
    where?: LabTimeSlotWhereInput
    /**
     * Limit how many LabTimeSlots to update.
     */
    limit?: number
  }

  /**
   * LabTimeSlot updateManyAndReturn
   */
  export type LabTimeSlotUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabTimeSlot
     */
    select?: LabTimeSlotSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LabTimeSlot
     */
    omit?: LabTimeSlotOmit<ExtArgs> | null
    /**
     * The data used to update LabTimeSlots.
     */
    data: XOR<LabTimeSlotUpdateManyMutationInput, LabTimeSlotUncheckedUpdateManyInput>
    /**
     * Filter which LabTimeSlots to update
     */
    where?: LabTimeSlotWhereInput
    /**
     * Limit how many LabTimeSlots to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabTimeSlotIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LabTimeSlot upsert
   */
  export type LabTimeSlotUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabTimeSlot
     */
    select?: LabTimeSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabTimeSlot
     */
    omit?: LabTimeSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabTimeSlotInclude<ExtArgs> | null
    /**
     * The filter to search for the LabTimeSlot to update in case it exists.
     */
    where: LabTimeSlotWhereUniqueInput
    /**
     * In case the LabTimeSlot found by the `where` argument doesn't exist, create a new LabTimeSlot with this data.
     */
    create: XOR<LabTimeSlotCreateInput, LabTimeSlotUncheckedCreateInput>
    /**
     * In case the LabTimeSlot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LabTimeSlotUpdateInput, LabTimeSlotUncheckedUpdateInput>
  }

  /**
   * LabTimeSlot delete
   */
  export type LabTimeSlotDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabTimeSlot
     */
    select?: LabTimeSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabTimeSlot
     */
    omit?: LabTimeSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabTimeSlotInclude<ExtArgs> | null
    /**
     * Filter which LabTimeSlot to delete.
     */
    where: LabTimeSlotWhereUniqueInput
  }

  /**
   * LabTimeSlot deleteMany
   */
  export type LabTimeSlotDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LabTimeSlots to delete
     */
    where?: LabTimeSlotWhereInput
    /**
     * Limit how many LabTimeSlots to delete.
     */
    limit?: number
  }

  /**
   * LabTimeSlot.batches
   */
  export type LabTimeSlot$batchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    where?: BatchWhereInput
    orderBy?: BatchOrderByWithRelationInput | BatchOrderByWithRelationInput[]
    cursor?: BatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BatchScalarFieldEnum | BatchScalarFieldEnum[]
  }

  /**
   * LabTimeSlot.allocations
   */
  export type LabTimeSlot$allocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabAllocation
     */
    select?: LabAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabAllocation
     */
    omit?: LabAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabAllocationInclude<ExtArgs> | null
    where?: LabAllocationWhereInput
    orderBy?: LabAllocationOrderByWithRelationInput | LabAllocationOrderByWithRelationInput[]
    cursor?: LabAllocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LabAllocationScalarFieldEnum | LabAllocationScalarFieldEnum[]
  }

  /**
   * LabTimeSlot without action
   */
  export type LabTimeSlotDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabTimeSlot
     */
    select?: LabTimeSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabTimeSlot
     */
    omit?: LabTimeSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabTimeSlotInclude<ExtArgs> | null
  }


  /**
   * Model PaymentStructureType
   */

  export type AggregatePaymentStructureType = {
    _count: PaymentStructureTypeCountAggregateOutputType | null
    _avg: PaymentStructureTypeAvgAggregateOutputType | null
    _sum: PaymentStructureTypeSumAggregateOutputType | null
    _min: PaymentStructureTypeMinAggregateOutputType | null
    _max: PaymentStructureTypeMaxAggregateOutputType | null
  }

  export type PaymentStructureTypeAvgAggregateOutputType = {
    id: number | null
    installmentCount: number | null
  }

  export type PaymentStructureTypeSumAggregateOutputType = {
    id: number | null
    installmentCount: number | null
  }

  export type PaymentStructureTypeMinAggregateOutputType = {
    id: number | null
    name: $Enums.PaymentType | null
    installmentCount: number | null
  }

  export type PaymentStructureTypeMaxAggregateOutputType = {
    id: number | null
    name: $Enums.PaymentType | null
    installmentCount: number | null
  }

  export type PaymentStructureTypeCountAggregateOutputType = {
    id: number
    name: number
    installmentCount: number
    _all: number
  }


  export type PaymentStructureTypeAvgAggregateInputType = {
    id?: true
    installmentCount?: true
  }

  export type PaymentStructureTypeSumAggregateInputType = {
    id?: true
    installmentCount?: true
  }

  export type PaymentStructureTypeMinAggregateInputType = {
    id?: true
    name?: true
    installmentCount?: true
  }

  export type PaymentStructureTypeMaxAggregateInputType = {
    id?: true
    name?: true
    installmentCount?: true
  }

  export type PaymentStructureTypeCountAggregateInputType = {
    id?: true
    name?: true
    installmentCount?: true
    _all?: true
  }

  export type PaymentStructureTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentStructureType to aggregate.
     */
    where?: PaymentStructureTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentStructureTypes to fetch.
     */
    orderBy?: PaymentStructureTypeOrderByWithRelationInput | PaymentStructureTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentStructureTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentStructureTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentStructureTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentStructureTypes
    **/
    _count?: true | PaymentStructureTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentStructureTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentStructureTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentStructureTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentStructureTypeMaxAggregateInputType
  }

  export type GetPaymentStructureTypeAggregateType<T extends PaymentStructureTypeAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentStructureType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentStructureType[P]>
      : GetScalarType<T[P], AggregatePaymentStructureType[P]>
  }




  export type PaymentStructureTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentStructureTypeWhereInput
    orderBy?: PaymentStructureTypeOrderByWithAggregationInput | PaymentStructureTypeOrderByWithAggregationInput[]
    by: PaymentStructureTypeScalarFieldEnum[] | PaymentStructureTypeScalarFieldEnum
    having?: PaymentStructureTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentStructureTypeCountAggregateInputType | true
    _avg?: PaymentStructureTypeAvgAggregateInputType
    _sum?: PaymentStructureTypeSumAggregateInputType
    _min?: PaymentStructureTypeMinAggregateInputType
    _max?: PaymentStructureTypeMaxAggregateInputType
  }

  export type PaymentStructureTypeGroupByOutputType = {
    id: number
    name: $Enums.PaymentType
    installmentCount: number | null
    _count: PaymentStructureTypeCountAggregateOutputType | null
    _avg: PaymentStructureTypeAvgAggregateOutputType | null
    _sum: PaymentStructureTypeSumAggregateOutputType | null
    _min: PaymentStructureTypeMinAggregateOutputType | null
    _max: PaymentStructureTypeMaxAggregateOutputType | null
  }

  type GetPaymentStructureTypeGroupByPayload<T extends PaymentStructureTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentStructureTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentStructureTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentStructureTypeGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentStructureTypeGroupByOutputType[P]>
        }
      >
    >


  export type PaymentStructureTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    installmentCount?: boolean
  }, ExtArgs["result"]["paymentStructureType"]>

  export type PaymentStructureTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    installmentCount?: boolean
  }, ExtArgs["result"]["paymentStructureType"]>

  export type PaymentStructureTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    installmentCount?: boolean
  }, ExtArgs["result"]["paymentStructureType"]>

  export type PaymentStructureTypeSelectScalar = {
    id?: boolean
    name?: boolean
    installmentCount?: boolean
  }

  export type PaymentStructureTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "installmentCount", ExtArgs["result"]["paymentStructureType"]>

  export type $PaymentStructureTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaymentStructureType"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: $Enums.PaymentType
      installmentCount: number | null
    }, ExtArgs["result"]["paymentStructureType"]>
    composites: {}
  }

  type PaymentStructureTypeGetPayload<S extends boolean | null | undefined | PaymentStructureTypeDefaultArgs> = $Result.GetResult<Prisma.$PaymentStructureTypePayload, S>

  type PaymentStructureTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentStructureTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentStructureTypeCountAggregateInputType | true
    }

  export interface PaymentStructureTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaymentStructureType'], meta: { name: 'PaymentStructureType' } }
    /**
     * Find zero or one PaymentStructureType that matches the filter.
     * @param {PaymentStructureTypeFindUniqueArgs} args - Arguments to find a PaymentStructureType
     * @example
     * // Get one PaymentStructureType
     * const paymentStructureType = await prisma.paymentStructureType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentStructureTypeFindUniqueArgs>(args: SelectSubset<T, PaymentStructureTypeFindUniqueArgs<ExtArgs>>): Prisma__PaymentStructureTypeClient<$Result.GetResult<Prisma.$PaymentStructureTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PaymentStructureType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentStructureTypeFindUniqueOrThrowArgs} args - Arguments to find a PaymentStructureType
     * @example
     * // Get one PaymentStructureType
     * const paymentStructureType = await prisma.paymentStructureType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentStructureTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentStructureTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentStructureTypeClient<$Result.GetResult<Prisma.$PaymentStructureTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentStructureType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentStructureTypeFindFirstArgs} args - Arguments to find a PaymentStructureType
     * @example
     * // Get one PaymentStructureType
     * const paymentStructureType = await prisma.paymentStructureType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentStructureTypeFindFirstArgs>(args?: SelectSubset<T, PaymentStructureTypeFindFirstArgs<ExtArgs>>): Prisma__PaymentStructureTypeClient<$Result.GetResult<Prisma.$PaymentStructureTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentStructureType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentStructureTypeFindFirstOrThrowArgs} args - Arguments to find a PaymentStructureType
     * @example
     * // Get one PaymentStructureType
     * const paymentStructureType = await prisma.paymentStructureType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentStructureTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentStructureTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentStructureTypeClient<$Result.GetResult<Prisma.$PaymentStructureTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PaymentStructureTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentStructureTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentStructureTypes
     * const paymentStructureTypes = await prisma.paymentStructureType.findMany()
     * 
     * // Get first 10 PaymentStructureTypes
     * const paymentStructureTypes = await prisma.paymentStructureType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentStructureTypeWithIdOnly = await prisma.paymentStructureType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentStructureTypeFindManyArgs>(args?: SelectSubset<T, PaymentStructureTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentStructureTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PaymentStructureType.
     * @param {PaymentStructureTypeCreateArgs} args - Arguments to create a PaymentStructureType.
     * @example
     * // Create one PaymentStructureType
     * const PaymentStructureType = await prisma.paymentStructureType.create({
     *   data: {
     *     // ... data to create a PaymentStructureType
     *   }
     * })
     * 
     */
    create<T extends PaymentStructureTypeCreateArgs>(args: SelectSubset<T, PaymentStructureTypeCreateArgs<ExtArgs>>): Prisma__PaymentStructureTypeClient<$Result.GetResult<Prisma.$PaymentStructureTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PaymentStructureTypes.
     * @param {PaymentStructureTypeCreateManyArgs} args - Arguments to create many PaymentStructureTypes.
     * @example
     * // Create many PaymentStructureTypes
     * const paymentStructureType = await prisma.paymentStructureType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentStructureTypeCreateManyArgs>(args?: SelectSubset<T, PaymentStructureTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PaymentStructureTypes and returns the data saved in the database.
     * @param {PaymentStructureTypeCreateManyAndReturnArgs} args - Arguments to create many PaymentStructureTypes.
     * @example
     * // Create many PaymentStructureTypes
     * const paymentStructureType = await prisma.paymentStructureType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PaymentStructureTypes and only return the `id`
     * const paymentStructureTypeWithIdOnly = await prisma.paymentStructureType.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentStructureTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentStructureTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentStructureTypePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PaymentStructureType.
     * @param {PaymentStructureTypeDeleteArgs} args - Arguments to delete one PaymentStructureType.
     * @example
     * // Delete one PaymentStructureType
     * const PaymentStructureType = await prisma.paymentStructureType.delete({
     *   where: {
     *     // ... filter to delete one PaymentStructureType
     *   }
     * })
     * 
     */
    delete<T extends PaymentStructureTypeDeleteArgs>(args: SelectSubset<T, PaymentStructureTypeDeleteArgs<ExtArgs>>): Prisma__PaymentStructureTypeClient<$Result.GetResult<Prisma.$PaymentStructureTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PaymentStructureType.
     * @param {PaymentStructureTypeUpdateArgs} args - Arguments to update one PaymentStructureType.
     * @example
     * // Update one PaymentStructureType
     * const paymentStructureType = await prisma.paymentStructureType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentStructureTypeUpdateArgs>(args: SelectSubset<T, PaymentStructureTypeUpdateArgs<ExtArgs>>): Prisma__PaymentStructureTypeClient<$Result.GetResult<Prisma.$PaymentStructureTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PaymentStructureTypes.
     * @param {PaymentStructureTypeDeleteManyArgs} args - Arguments to filter PaymentStructureTypes to delete.
     * @example
     * // Delete a few PaymentStructureTypes
     * const { count } = await prisma.paymentStructureType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentStructureTypeDeleteManyArgs>(args?: SelectSubset<T, PaymentStructureTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentStructureTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentStructureTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentStructureTypes
     * const paymentStructureType = await prisma.paymentStructureType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentStructureTypeUpdateManyArgs>(args: SelectSubset<T, PaymentStructureTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentStructureTypes and returns the data updated in the database.
     * @param {PaymentStructureTypeUpdateManyAndReturnArgs} args - Arguments to update many PaymentStructureTypes.
     * @example
     * // Update many PaymentStructureTypes
     * const paymentStructureType = await prisma.paymentStructureType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PaymentStructureTypes and only return the `id`
     * const paymentStructureTypeWithIdOnly = await prisma.paymentStructureType.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentStructureTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentStructureTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentStructureTypePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PaymentStructureType.
     * @param {PaymentStructureTypeUpsertArgs} args - Arguments to update or create a PaymentStructureType.
     * @example
     * // Update or create a PaymentStructureType
     * const paymentStructureType = await prisma.paymentStructureType.upsert({
     *   create: {
     *     // ... data to create a PaymentStructureType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentStructureType we want to update
     *   }
     * })
     */
    upsert<T extends PaymentStructureTypeUpsertArgs>(args: SelectSubset<T, PaymentStructureTypeUpsertArgs<ExtArgs>>): Prisma__PaymentStructureTypeClient<$Result.GetResult<Prisma.$PaymentStructureTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PaymentStructureTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentStructureTypeCountArgs} args - Arguments to filter PaymentStructureTypes to count.
     * @example
     * // Count the number of PaymentStructureTypes
     * const count = await prisma.paymentStructureType.count({
     *   where: {
     *     // ... the filter for the PaymentStructureTypes we want to count
     *   }
     * })
    **/
    count<T extends PaymentStructureTypeCountArgs>(
      args?: Subset<T, PaymentStructureTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentStructureTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentStructureType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentStructureTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentStructureTypeAggregateArgs>(args: Subset<T, PaymentStructureTypeAggregateArgs>): Prisma.PrismaPromise<GetPaymentStructureTypeAggregateType<T>>

    /**
     * Group by PaymentStructureType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentStructureTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentStructureTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentStructureTypeGroupByArgs['orderBy'] }
        : { orderBy?: PaymentStructureTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentStructureTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentStructureTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PaymentStructureType model
   */
  readonly fields: PaymentStructureTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentStructureType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentStructureTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PaymentStructureType model
   */
  interface PaymentStructureTypeFieldRefs {
    readonly id: FieldRef<"PaymentStructureType", 'Int'>
    readonly name: FieldRef<"PaymentStructureType", 'PaymentType'>
    readonly installmentCount: FieldRef<"PaymentStructureType", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PaymentStructureType findUnique
   */
  export type PaymentStructureTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentStructureType
     */
    select?: PaymentStructureTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentStructureType
     */
    omit?: PaymentStructureTypeOmit<ExtArgs> | null
    /**
     * Filter, which PaymentStructureType to fetch.
     */
    where: PaymentStructureTypeWhereUniqueInput
  }

  /**
   * PaymentStructureType findUniqueOrThrow
   */
  export type PaymentStructureTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentStructureType
     */
    select?: PaymentStructureTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentStructureType
     */
    omit?: PaymentStructureTypeOmit<ExtArgs> | null
    /**
     * Filter, which PaymentStructureType to fetch.
     */
    where: PaymentStructureTypeWhereUniqueInput
  }

  /**
   * PaymentStructureType findFirst
   */
  export type PaymentStructureTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentStructureType
     */
    select?: PaymentStructureTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentStructureType
     */
    omit?: PaymentStructureTypeOmit<ExtArgs> | null
    /**
     * Filter, which PaymentStructureType to fetch.
     */
    where?: PaymentStructureTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentStructureTypes to fetch.
     */
    orderBy?: PaymentStructureTypeOrderByWithRelationInput | PaymentStructureTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentStructureTypes.
     */
    cursor?: PaymentStructureTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentStructureTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentStructureTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentStructureTypes.
     */
    distinct?: PaymentStructureTypeScalarFieldEnum | PaymentStructureTypeScalarFieldEnum[]
  }

  /**
   * PaymentStructureType findFirstOrThrow
   */
  export type PaymentStructureTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentStructureType
     */
    select?: PaymentStructureTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentStructureType
     */
    omit?: PaymentStructureTypeOmit<ExtArgs> | null
    /**
     * Filter, which PaymentStructureType to fetch.
     */
    where?: PaymentStructureTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentStructureTypes to fetch.
     */
    orderBy?: PaymentStructureTypeOrderByWithRelationInput | PaymentStructureTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentStructureTypes.
     */
    cursor?: PaymentStructureTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentStructureTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentStructureTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentStructureTypes.
     */
    distinct?: PaymentStructureTypeScalarFieldEnum | PaymentStructureTypeScalarFieldEnum[]
  }

  /**
   * PaymentStructureType findMany
   */
  export type PaymentStructureTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentStructureType
     */
    select?: PaymentStructureTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentStructureType
     */
    omit?: PaymentStructureTypeOmit<ExtArgs> | null
    /**
     * Filter, which PaymentStructureTypes to fetch.
     */
    where?: PaymentStructureTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentStructureTypes to fetch.
     */
    orderBy?: PaymentStructureTypeOrderByWithRelationInput | PaymentStructureTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentStructureTypes.
     */
    cursor?: PaymentStructureTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentStructureTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentStructureTypes.
     */
    skip?: number
    distinct?: PaymentStructureTypeScalarFieldEnum | PaymentStructureTypeScalarFieldEnum[]
  }

  /**
   * PaymentStructureType create
   */
  export type PaymentStructureTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentStructureType
     */
    select?: PaymentStructureTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentStructureType
     */
    omit?: PaymentStructureTypeOmit<ExtArgs> | null
    /**
     * The data needed to create a PaymentStructureType.
     */
    data: XOR<PaymentStructureTypeCreateInput, PaymentStructureTypeUncheckedCreateInput>
  }

  /**
   * PaymentStructureType createMany
   */
  export type PaymentStructureTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaymentStructureTypes.
     */
    data: PaymentStructureTypeCreateManyInput | PaymentStructureTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentStructureType createManyAndReturn
   */
  export type PaymentStructureTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentStructureType
     */
    select?: PaymentStructureTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentStructureType
     */
    omit?: PaymentStructureTypeOmit<ExtArgs> | null
    /**
     * The data used to create many PaymentStructureTypes.
     */
    data: PaymentStructureTypeCreateManyInput | PaymentStructureTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentStructureType update
   */
  export type PaymentStructureTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentStructureType
     */
    select?: PaymentStructureTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentStructureType
     */
    omit?: PaymentStructureTypeOmit<ExtArgs> | null
    /**
     * The data needed to update a PaymentStructureType.
     */
    data: XOR<PaymentStructureTypeUpdateInput, PaymentStructureTypeUncheckedUpdateInput>
    /**
     * Choose, which PaymentStructureType to update.
     */
    where: PaymentStructureTypeWhereUniqueInput
  }

  /**
   * PaymentStructureType updateMany
   */
  export type PaymentStructureTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaymentStructureTypes.
     */
    data: XOR<PaymentStructureTypeUpdateManyMutationInput, PaymentStructureTypeUncheckedUpdateManyInput>
    /**
     * Filter which PaymentStructureTypes to update
     */
    where?: PaymentStructureTypeWhereInput
    /**
     * Limit how many PaymentStructureTypes to update.
     */
    limit?: number
  }

  /**
   * PaymentStructureType updateManyAndReturn
   */
  export type PaymentStructureTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentStructureType
     */
    select?: PaymentStructureTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentStructureType
     */
    omit?: PaymentStructureTypeOmit<ExtArgs> | null
    /**
     * The data used to update PaymentStructureTypes.
     */
    data: XOR<PaymentStructureTypeUpdateManyMutationInput, PaymentStructureTypeUncheckedUpdateManyInput>
    /**
     * Filter which PaymentStructureTypes to update
     */
    where?: PaymentStructureTypeWhereInput
    /**
     * Limit how many PaymentStructureTypes to update.
     */
    limit?: number
  }

  /**
   * PaymentStructureType upsert
   */
  export type PaymentStructureTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentStructureType
     */
    select?: PaymentStructureTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentStructureType
     */
    omit?: PaymentStructureTypeOmit<ExtArgs> | null
    /**
     * The filter to search for the PaymentStructureType to update in case it exists.
     */
    where: PaymentStructureTypeWhereUniqueInput
    /**
     * In case the PaymentStructureType found by the `where` argument doesn't exist, create a new PaymentStructureType with this data.
     */
    create: XOR<PaymentStructureTypeCreateInput, PaymentStructureTypeUncheckedCreateInput>
    /**
     * In case the PaymentStructureType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentStructureTypeUpdateInput, PaymentStructureTypeUncheckedUpdateInput>
  }

  /**
   * PaymentStructureType delete
   */
  export type PaymentStructureTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentStructureType
     */
    select?: PaymentStructureTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentStructureType
     */
    omit?: PaymentStructureTypeOmit<ExtArgs> | null
    /**
     * Filter which PaymentStructureType to delete.
     */
    where: PaymentStructureTypeWhereUniqueInput
  }

  /**
   * PaymentStructureType deleteMany
   */
  export type PaymentStructureTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentStructureTypes to delete
     */
    where?: PaymentStructureTypeWhereInput
    /**
     * Limit how many PaymentStructureTypes to delete.
     */
    limit?: number
  }

  /**
   * PaymentStructureType without action
   */
  export type PaymentStructureTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentStructureType
     */
    select?: PaymentStructureTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentStructureType
     */
    omit?: PaymentStructureTypeOmit<ExtArgs> | null
  }


  /**
   * Model InstallmentDetail
   */

  export type AggregateInstallmentDetail = {
    _count: InstallmentDetailCountAggregateOutputType | null
    _avg: InstallmentDetailAvgAggregateOutputType | null
    _sum: InstallmentDetailSumAggregateOutputType | null
    _min: InstallmentDetailMinAggregateOutputType | null
    _max: InstallmentDetailMaxAggregateOutputType | null
  }

  export type InstallmentDetailAvgAggregateOutputType = {
    id: number | null
    CourseFeeStructureId: number | null
    number: number | null
    amount: number | null
  }

  export type InstallmentDetailSumAggregateOutputType = {
    id: number | null
    CourseFeeStructureId: number | null
    number: number | null
    amount: number | null
  }

  export type InstallmentDetailMinAggregateOutputType = {
    id: number | null
    CourseFeeStructureId: number | null
    number: number | null
    amount: number | null
  }

  export type InstallmentDetailMaxAggregateOutputType = {
    id: number | null
    CourseFeeStructureId: number | null
    number: number | null
    amount: number | null
  }

  export type InstallmentDetailCountAggregateOutputType = {
    id: number
    CourseFeeStructureId: number
    number: number
    amount: number
    _all: number
  }


  export type InstallmentDetailAvgAggregateInputType = {
    id?: true
    CourseFeeStructureId?: true
    number?: true
    amount?: true
  }

  export type InstallmentDetailSumAggregateInputType = {
    id?: true
    CourseFeeStructureId?: true
    number?: true
    amount?: true
  }

  export type InstallmentDetailMinAggregateInputType = {
    id?: true
    CourseFeeStructureId?: true
    number?: true
    amount?: true
  }

  export type InstallmentDetailMaxAggregateInputType = {
    id?: true
    CourseFeeStructureId?: true
    number?: true
    amount?: true
  }

  export type InstallmentDetailCountAggregateInputType = {
    id?: true
    CourseFeeStructureId?: true
    number?: true
    amount?: true
    _all?: true
  }

  export type InstallmentDetailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InstallmentDetail to aggregate.
     */
    where?: InstallmentDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstallmentDetails to fetch.
     */
    orderBy?: InstallmentDetailOrderByWithRelationInput | InstallmentDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InstallmentDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstallmentDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstallmentDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InstallmentDetails
    **/
    _count?: true | InstallmentDetailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InstallmentDetailAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InstallmentDetailSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InstallmentDetailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InstallmentDetailMaxAggregateInputType
  }

  export type GetInstallmentDetailAggregateType<T extends InstallmentDetailAggregateArgs> = {
        [P in keyof T & keyof AggregateInstallmentDetail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInstallmentDetail[P]>
      : GetScalarType<T[P], AggregateInstallmentDetail[P]>
  }




  export type InstallmentDetailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstallmentDetailWhereInput
    orderBy?: InstallmentDetailOrderByWithAggregationInput | InstallmentDetailOrderByWithAggregationInput[]
    by: InstallmentDetailScalarFieldEnum[] | InstallmentDetailScalarFieldEnum
    having?: InstallmentDetailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InstallmentDetailCountAggregateInputType | true
    _avg?: InstallmentDetailAvgAggregateInputType
    _sum?: InstallmentDetailSumAggregateInputType
    _min?: InstallmentDetailMinAggregateInputType
    _max?: InstallmentDetailMaxAggregateInputType
  }

  export type InstallmentDetailGroupByOutputType = {
    id: number
    CourseFeeStructureId: number
    number: number
    amount: number
    _count: InstallmentDetailCountAggregateOutputType | null
    _avg: InstallmentDetailAvgAggregateOutputType | null
    _sum: InstallmentDetailSumAggregateOutputType | null
    _min: InstallmentDetailMinAggregateOutputType | null
    _max: InstallmentDetailMaxAggregateOutputType | null
  }

  type GetInstallmentDetailGroupByPayload<T extends InstallmentDetailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InstallmentDetailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InstallmentDetailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InstallmentDetailGroupByOutputType[P]>
            : GetScalarType<T[P], InstallmentDetailGroupByOutputType[P]>
        }
      >
    >


  export type InstallmentDetailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    CourseFeeStructureId?: boolean
    number?: boolean
    amount?: boolean
    feeStructures?: boolean | InstallmentDetail$feeStructuresArgs<ExtArgs>
    CourseFeeStructure?: boolean | CourseFeeStructureDefaultArgs<ExtArgs>
    _count?: boolean | InstallmentDetailCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["installmentDetail"]>

  export type InstallmentDetailSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    CourseFeeStructureId?: boolean
    number?: boolean
    amount?: boolean
    CourseFeeStructure?: boolean | CourseFeeStructureDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["installmentDetail"]>

  export type InstallmentDetailSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    CourseFeeStructureId?: boolean
    number?: boolean
    amount?: boolean
    CourseFeeStructure?: boolean | CourseFeeStructureDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["installmentDetail"]>

  export type InstallmentDetailSelectScalar = {
    id?: boolean
    CourseFeeStructureId?: boolean
    number?: boolean
    amount?: boolean
  }

  export type InstallmentDetailOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "CourseFeeStructureId" | "number" | "amount", ExtArgs["result"]["installmentDetail"]>
  export type InstallmentDetailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feeStructures?: boolean | InstallmentDetail$feeStructuresArgs<ExtArgs>
    CourseFeeStructure?: boolean | CourseFeeStructureDefaultArgs<ExtArgs>
    _count?: boolean | InstallmentDetailCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InstallmentDetailIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CourseFeeStructure?: boolean | CourseFeeStructureDefaultArgs<ExtArgs>
  }
  export type InstallmentDetailIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CourseFeeStructure?: boolean | CourseFeeStructureDefaultArgs<ExtArgs>
  }

  export type $InstallmentDetailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InstallmentDetail"
    objects: {
      feeStructures: Prisma.$FeeStructurePayload<ExtArgs>[]
      CourseFeeStructure: Prisma.$CourseFeeStructurePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      CourseFeeStructureId: number
      number: number
      amount: number
    }, ExtArgs["result"]["installmentDetail"]>
    composites: {}
  }

  type InstallmentDetailGetPayload<S extends boolean | null | undefined | InstallmentDetailDefaultArgs> = $Result.GetResult<Prisma.$InstallmentDetailPayload, S>

  type InstallmentDetailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InstallmentDetailFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InstallmentDetailCountAggregateInputType | true
    }

  export interface InstallmentDetailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InstallmentDetail'], meta: { name: 'InstallmentDetail' } }
    /**
     * Find zero or one InstallmentDetail that matches the filter.
     * @param {InstallmentDetailFindUniqueArgs} args - Arguments to find a InstallmentDetail
     * @example
     * // Get one InstallmentDetail
     * const installmentDetail = await prisma.installmentDetail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InstallmentDetailFindUniqueArgs>(args: SelectSubset<T, InstallmentDetailFindUniqueArgs<ExtArgs>>): Prisma__InstallmentDetailClient<$Result.GetResult<Prisma.$InstallmentDetailPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InstallmentDetail that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InstallmentDetailFindUniqueOrThrowArgs} args - Arguments to find a InstallmentDetail
     * @example
     * // Get one InstallmentDetail
     * const installmentDetail = await prisma.installmentDetail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InstallmentDetailFindUniqueOrThrowArgs>(args: SelectSubset<T, InstallmentDetailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InstallmentDetailClient<$Result.GetResult<Prisma.$InstallmentDetailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InstallmentDetail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstallmentDetailFindFirstArgs} args - Arguments to find a InstallmentDetail
     * @example
     * // Get one InstallmentDetail
     * const installmentDetail = await prisma.installmentDetail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InstallmentDetailFindFirstArgs>(args?: SelectSubset<T, InstallmentDetailFindFirstArgs<ExtArgs>>): Prisma__InstallmentDetailClient<$Result.GetResult<Prisma.$InstallmentDetailPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InstallmentDetail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstallmentDetailFindFirstOrThrowArgs} args - Arguments to find a InstallmentDetail
     * @example
     * // Get one InstallmentDetail
     * const installmentDetail = await prisma.installmentDetail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InstallmentDetailFindFirstOrThrowArgs>(args?: SelectSubset<T, InstallmentDetailFindFirstOrThrowArgs<ExtArgs>>): Prisma__InstallmentDetailClient<$Result.GetResult<Prisma.$InstallmentDetailPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InstallmentDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstallmentDetailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InstallmentDetails
     * const installmentDetails = await prisma.installmentDetail.findMany()
     * 
     * // Get first 10 InstallmentDetails
     * const installmentDetails = await prisma.installmentDetail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const installmentDetailWithIdOnly = await prisma.installmentDetail.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InstallmentDetailFindManyArgs>(args?: SelectSubset<T, InstallmentDetailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstallmentDetailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InstallmentDetail.
     * @param {InstallmentDetailCreateArgs} args - Arguments to create a InstallmentDetail.
     * @example
     * // Create one InstallmentDetail
     * const InstallmentDetail = await prisma.installmentDetail.create({
     *   data: {
     *     // ... data to create a InstallmentDetail
     *   }
     * })
     * 
     */
    create<T extends InstallmentDetailCreateArgs>(args: SelectSubset<T, InstallmentDetailCreateArgs<ExtArgs>>): Prisma__InstallmentDetailClient<$Result.GetResult<Prisma.$InstallmentDetailPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InstallmentDetails.
     * @param {InstallmentDetailCreateManyArgs} args - Arguments to create many InstallmentDetails.
     * @example
     * // Create many InstallmentDetails
     * const installmentDetail = await prisma.installmentDetail.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InstallmentDetailCreateManyArgs>(args?: SelectSubset<T, InstallmentDetailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InstallmentDetails and returns the data saved in the database.
     * @param {InstallmentDetailCreateManyAndReturnArgs} args - Arguments to create many InstallmentDetails.
     * @example
     * // Create many InstallmentDetails
     * const installmentDetail = await prisma.installmentDetail.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InstallmentDetails and only return the `id`
     * const installmentDetailWithIdOnly = await prisma.installmentDetail.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InstallmentDetailCreateManyAndReturnArgs>(args?: SelectSubset<T, InstallmentDetailCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstallmentDetailPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InstallmentDetail.
     * @param {InstallmentDetailDeleteArgs} args - Arguments to delete one InstallmentDetail.
     * @example
     * // Delete one InstallmentDetail
     * const InstallmentDetail = await prisma.installmentDetail.delete({
     *   where: {
     *     // ... filter to delete one InstallmentDetail
     *   }
     * })
     * 
     */
    delete<T extends InstallmentDetailDeleteArgs>(args: SelectSubset<T, InstallmentDetailDeleteArgs<ExtArgs>>): Prisma__InstallmentDetailClient<$Result.GetResult<Prisma.$InstallmentDetailPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InstallmentDetail.
     * @param {InstallmentDetailUpdateArgs} args - Arguments to update one InstallmentDetail.
     * @example
     * // Update one InstallmentDetail
     * const installmentDetail = await prisma.installmentDetail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InstallmentDetailUpdateArgs>(args: SelectSubset<T, InstallmentDetailUpdateArgs<ExtArgs>>): Prisma__InstallmentDetailClient<$Result.GetResult<Prisma.$InstallmentDetailPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InstallmentDetails.
     * @param {InstallmentDetailDeleteManyArgs} args - Arguments to filter InstallmentDetails to delete.
     * @example
     * // Delete a few InstallmentDetails
     * const { count } = await prisma.installmentDetail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InstallmentDetailDeleteManyArgs>(args?: SelectSubset<T, InstallmentDetailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InstallmentDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstallmentDetailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InstallmentDetails
     * const installmentDetail = await prisma.installmentDetail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InstallmentDetailUpdateManyArgs>(args: SelectSubset<T, InstallmentDetailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InstallmentDetails and returns the data updated in the database.
     * @param {InstallmentDetailUpdateManyAndReturnArgs} args - Arguments to update many InstallmentDetails.
     * @example
     * // Update many InstallmentDetails
     * const installmentDetail = await prisma.installmentDetail.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InstallmentDetails and only return the `id`
     * const installmentDetailWithIdOnly = await prisma.installmentDetail.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InstallmentDetailUpdateManyAndReturnArgs>(args: SelectSubset<T, InstallmentDetailUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstallmentDetailPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InstallmentDetail.
     * @param {InstallmentDetailUpsertArgs} args - Arguments to update or create a InstallmentDetail.
     * @example
     * // Update or create a InstallmentDetail
     * const installmentDetail = await prisma.installmentDetail.upsert({
     *   create: {
     *     // ... data to create a InstallmentDetail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InstallmentDetail we want to update
     *   }
     * })
     */
    upsert<T extends InstallmentDetailUpsertArgs>(args: SelectSubset<T, InstallmentDetailUpsertArgs<ExtArgs>>): Prisma__InstallmentDetailClient<$Result.GetResult<Prisma.$InstallmentDetailPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InstallmentDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstallmentDetailCountArgs} args - Arguments to filter InstallmentDetails to count.
     * @example
     * // Count the number of InstallmentDetails
     * const count = await prisma.installmentDetail.count({
     *   where: {
     *     // ... the filter for the InstallmentDetails we want to count
     *   }
     * })
    **/
    count<T extends InstallmentDetailCountArgs>(
      args?: Subset<T, InstallmentDetailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InstallmentDetailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InstallmentDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstallmentDetailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InstallmentDetailAggregateArgs>(args: Subset<T, InstallmentDetailAggregateArgs>): Prisma.PrismaPromise<GetInstallmentDetailAggregateType<T>>

    /**
     * Group by InstallmentDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstallmentDetailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InstallmentDetailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InstallmentDetailGroupByArgs['orderBy'] }
        : { orderBy?: InstallmentDetailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InstallmentDetailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInstallmentDetailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InstallmentDetail model
   */
  readonly fields: InstallmentDetailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InstallmentDetail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InstallmentDetailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    feeStructures<T extends InstallmentDetail$feeStructuresArgs<ExtArgs> = {}>(args?: Subset<T, InstallmentDetail$feeStructuresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeeStructurePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    CourseFeeStructure<T extends CourseFeeStructureDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseFeeStructureDefaultArgs<ExtArgs>>): Prisma__CourseFeeStructureClient<$Result.GetResult<Prisma.$CourseFeeStructurePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InstallmentDetail model
   */
  interface InstallmentDetailFieldRefs {
    readonly id: FieldRef<"InstallmentDetail", 'Int'>
    readonly CourseFeeStructureId: FieldRef<"InstallmentDetail", 'Int'>
    readonly number: FieldRef<"InstallmentDetail", 'Int'>
    readonly amount: FieldRef<"InstallmentDetail", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * InstallmentDetail findUnique
   */
  export type InstallmentDetailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstallmentDetail
     */
    select?: InstallmentDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstallmentDetail
     */
    omit?: InstallmentDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallmentDetailInclude<ExtArgs> | null
    /**
     * Filter, which InstallmentDetail to fetch.
     */
    where: InstallmentDetailWhereUniqueInput
  }

  /**
   * InstallmentDetail findUniqueOrThrow
   */
  export type InstallmentDetailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstallmentDetail
     */
    select?: InstallmentDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstallmentDetail
     */
    omit?: InstallmentDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallmentDetailInclude<ExtArgs> | null
    /**
     * Filter, which InstallmentDetail to fetch.
     */
    where: InstallmentDetailWhereUniqueInput
  }

  /**
   * InstallmentDetail findFirst
   */
  export type InstallmentDetailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstallmentDetail
     */
    select?: InstallmentDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstallmentDetail
     */
    omit?: InstallmentDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallmentDetailInclude<ExtArgs> | null
    /**
     * Filter, which InstallmentDetail to fetch.
     */
    where?: InstallmentDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstallmentDetails to fetch.
     */
    orderBy?: InstallmentDetailOrderByWithRelationInput | InstallmentDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InstallmentDetails.
     */
    cursor?: InstallmentDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstallmentDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstallmentDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InstallmentDetails.
     */
    distinct?: InstallmentDetailScalarFieldEnum | InstallmentDetailScalarFieldEnum[]
  }

  /**
   * InstallmentDetail findFirstOrThrow
   */
  export type InstallmentDetailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstallmentDetail
     */
    select?: InstallmentDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstallmentDetail
     */
    omit?: InstallmentDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallmentDetailInclude<ExtArgs> | null
    /**
     * Filter, which InstallmentDetail to fetch.
     */
    where?: InstallmentDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstallmentDetails to fetch.
     */
    orderBy?: InstallmentDetailOrderByWithRelationInput | InstallmentDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InstallmentDetails.
     */
    cursor?: InstallmentDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstallmentDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstallmentDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InstallmentDetails.
     */
    distinct?: InstallmentDetailScalarFieldEnum | InstallmentDetailScalarFieldEnum[]
  }

  /**
   * InstallmentDetail findMany
   */
  export type InstallmentDetailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstallmentDetail
     */
    select?: InstallmentDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstallmentDetail
     */
    omit?: InstallmentDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallmentDetailInclude<ExtArgs> | null
    /**
     * Filter, which InstallmentDetails to fetch.
     */
    where?: InstallmentDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstallmentDetails to fetch.
     */
    orderBy?: InstallmentDetailOrderByWithRelationInput | InstallmentDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InstallmentDetails.
     */
    cursor?: InstallmentDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstallmentDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstallmentDetails.
     */
    skip?: number
    distinct?: InstallmentDetailScalarFieldEnum | InstallmentDetailScalarFieldEnum[]
  }

  /**
   * InstallmentDetail create
   */
  export type InstallmentDetailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstallmentDetail
     */
    select?: InstallmentDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstallmentDetail
     */
    omit?: InstallmentDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallmentDetailInclude<ExtArgs> | null
    /**
     * The data needed to create a InstallmentDetail.
     */
    data: XOR<InstallmentDetailCreateInput, InstallmentDetailUncheckedCreateInput>
  }

  /**
   * InstallmentDetail createMany
   */
  export type InstallmentDetailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InstallmentDetails.
     */
    data: InstallmentDetailCreateManyInput | InstallmentDetailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InstallmentDetail createManyAndReturn
   */
  export type InstallmentDetailCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstallmentDetail
     */
    select?: InstallmentDetailSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InstallmentDetail
     */
    omit?: InstallmentDetailOmit<ExtArgs> | null
    /**
     * The data used to create many InstallmentDetails.
     */
    data: InstallmentDetailCreateManyInput | InstallmentDetailCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallmentDetailIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InstallmentDetail update
   */
  export type InstallmentDetailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstallmentDetail
     */
    select?: InstallmentDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstallmentDetail
     */
    omit?: InstallmentDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallmentDetailInclude<ExtArgs> | null
    /**
     * The data needed to update a InstallmentDetail.
     */
    data: XOR<InstallmentDetailUpdateInput, InstallmentDetailUncheckedUpdateInput>
    /**
     * Choose, which InstallmentDetail to update.
     */
    where: InstallmentDetailWhereUniqueInput
  }

  /**
   * InstallmentDetail updateMany
   */
  export type InstallmentDetailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InstallmentDetails.
     */
    data: XOR<InstallmentDetailUpdateManyMutationInput, InstallmentDetailUncheckedUpdateManyInput>
    /**
     * Filter which InstallmentDetails to update
     */
    where?: InstallmentDetailWhereInput
    /**
     * Limit how many InstallmentDetails to update.
     */
    limit?: number
  }

  /**
   * InstallmentDetail updateManyAndReturn
   */
  export type InstallmentDetailUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstallmentDetail
     */
    select?: InstallmentDetailSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InstallmentDetail
     */
    omit?: InstallmentDetailOmit<ExtArgs> | null
    /**
     * The data used to update InstallmentDetails.
     */
    data: XOR<InstallmentDetailUpdateManyMutationInput, InstallmentDetailUncheckedUpdateManyInput>
    /**
     * Filter which InstallmentDetails to update
     */
    where?: InstallmentDetailWhereInput
    /**
     * Limit how many InstallmentDetails to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallmentDetailIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InstallmentDetail upsert
   */
  export type InstallmentDetailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstallmentDetail
     */
    select?: InstallmentDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstallmentDetail
     */
    omit?: InstallmentDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallmentDetailInclude<ExtArgs> | null
    /**
     * The filter to search for the InstallmentDetail to update in case it exists.
     */
    where: InstallmentDetailWhereUniqueInput
    /**
     * In case the InstallmentDetail found by the `where` argument doesn't exist, create a new InstallmentDetail with this data.
     */
    create: XOR<InstallmentDetailCreateInput, InstallmentDetailUncheckedCreateInput>
    /**
     * In case the InstallmentDetail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InstallmentDetailUpdateInput, InstallmentDetailUncheckedUpdateInput>
  }

  /**
   * InstallmentDetail delete
   */
  export type InstallmentDetailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstallmentDetail
     */
    select?: InstallmentDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstallmentDetail
     */
    omit?: InstallmentDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallmentDetailInclude<ExtArgs> | null
    /**
     * Filter which InstallmentDetail to delete.
     */
    where: InstallmentDetailWhereUniqueInput
  }

  /**
   * InstallmentDetail deleteMany
   */
  export type InstallmentDetailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InstallmentDetails to delete
     */
    where?: InstallmentDetailWhereInput
    /**
     * Limit how many InstallmentDetails to delete.
     */
    limit?: number
  }

  /**
   * InstallmentDetail.feeStructures
   */
  export type InstallmentDetail$feeStructuresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeStructure
     */
    select?: FeeStructureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeStructure
     */
    omit?: FeeStructureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeStructureInclude<ExtArgs> | null
    where?: FeeStructureWhereInput
    orderBy?: FeeStructureOrderByWithRelationInput | FeeStructureOrderByWithRelationInput[]
    cursor?: FeeStructureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeeStructureScalarFieldEnum | FeeStructureScalarFieldEnum[]
  }

  /**
   * InstallmentDetail without action
   */
  export type InstallmentDetailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstallmentDetail
     */
    select?: InstallmentDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstallmentDetail
     */
    omit?: InstallmentDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallmentDetailInclude<ExtArgs> | null
  }


  /**
   * Model LabAllocation
   */

  export type AggregateLabAllocation = {
    _count: LabAllocationCountAggregateOutputType | null
    _avg: LabAllocationAvgAggregateOutputType | null
    _sum: LabAllocationSumAggregateOutputType | null
    _min: LabAllocationMinAggregateOutputType | null
    _max: LabAllocationMaxAggregateOutputType | null
  }

  export type LabAllocationAvgAggregateOutputType = {
    id: number | null
    labTimeSlotId: number | null
    studentId: number | null
    pcNumber: number | null
  }

  export type LabAllocationSumAggregateOutputType = {
    id: number | null
    labTimeSlotId: number | null
    studentId: number | null
    pcNumber: number | null
  }

  export type LabAllocationMinAggregateOutputType = {
    id: number | null
    labTimeSlotId: number | null
    studentId: number | null
    pcNumber: number | null
    assignedAt: Date | null
    clientAdminId: string | null
  }

  export type LabAllocationMaxAggregateOutputType = {
    id: number | null
    labTimeSlotId: number | null
    studentId: number | null
    pcNumber: number | null
    assignedAt: Date | null
    clientAdminId: string | null
  }

  export type LabAllocationCountAggregateOutputType = {
    id: number
    labTimeSlotId: number
    studentId: number
    pcNumber: number
    assignedAt: number
    clientAdminId: number
    _all: number
  }


  export type LabAllocationAvgAggregateInputType = {
    id?: true
    labTimeSlotId?: true
    studentId?: true
    pcNumber?: true
  }

  export type LabAllocationSumAggregateInputType = {
    id?: true
    labTimeSlotId?: true
    studentId?: true
    pcNumber?: true
  }

  export type LabAllocationMinAggregateInputType = {
    id?: true
    labTimeSlotId?: true
    studentId?: true
    pcNumber?: true
    assignedAt?: true
    clientAdminId?: true
  }

  export type LabAllocationMaxAggregateInputType = {
    id?: true
    labTimeSlotId?: true
    studentId?: true
    pcNumber?: true
    assignedAt?: true
    clientAdminId?: true
  }

  export type LabAllocationCountAggregateInputType = {
    id?: true
    labTimeSlotId?: true
    studentId?: true
    pcNumber?: true
    assignedAt?: true
    clientAdminId?: true
    _all?: true
  }

  export type LabAllocationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LabAllocation to aggregate.
     */
    where?: LabAllocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabAllocations to fetch.
     */
    orderBy?: LabAllocationOrderByWithRelationInput | LabAllocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LabAllocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabAllocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabAllocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LabAllocations
    **/
    _count?: true | LabAllocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LabAllocationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LabAllocationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LabAllocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LabAllocationMaxAggregateInputType
  }

  export type GetLabAllocationAggregateType<T extends LabAllocationAggregateArgs> = {
        [P in keyof T & keyof AggregateLabAllocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLabAllocation[P]>
      : GetScalarType<T[P], AggregateLabAllocation[P]>
  }




  export type LabAllocationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabAllocationWhereInput
    orderBy?: LabAllocationOrderByWithAggregationInput | LabAllocationOrderByWithAggregationInput[]
    by: LabAllocationScalarFieldEnum[] | LabAllocationScalarFieldEnum
    having?: LabAllocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LabAllocationCountAggregateInputType | true
    _avg?: LabAllocationAvgAggregateInputType
    _sum?: LabAllocationSumAggregateInputType
    _min?: LabAllocationMinAggregateInputType
    _max?: LabAllocationMaxAggregateInputType
  }

  export type LabAllocationGroupByOutputType = {
    id: number
    labTimeSlotId: number
    studentId: number
    pcNumber: number
    assignedAt: Date
    clientAdminId: string
    _count: LabAllocationCountAggregateOutputType | null
    _avg: LabAllocationAvgAggregateOutputType | null
    _sum: LabAllocationSumAggregateOutputType | null
    _min: LabAllocationMinAggregateOutputType | null
    _max: LabAllocationMaxAggregateOutputType | null
  }

  type GetLabAllocationGroupByPayload<T extends LabAllocationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LabAllocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LabAllocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LabAllocationGroupByOutputType[P]>
            : GetScalarType<T[P], LabAllocationGroupByOutputType[P]>
        }
      >
    >


  export type LabAllocationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    labTimeSlotId?: boolean
    studentId?: boolean
    pcNumber?: boolean
    assignedAt?: boolean
    clientAdminId?: boolean
    labTimeSlot?: boolean | LabTimeSlotDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["labAllocation"]>

  export type LabAllocationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    labTimeSlotId?: boolean
    studentId?: boolean
    pcNumber?: boolean
    assignedAt?: boolean
    clientAdminId?: boolean
    labTimeSlot?: boolean | LabTimeSlotDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["labAllocation"]>

  export type LabAllocationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    labTimeSlotId?: boolean
    studentId?: boolean
    pcNumber?: boolean
    assignedAt?: boolean
    clientAdminId?: boolean
    labTimeSlot?: boolean | LabTimeSlotDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["labAllocation"]>

  export type LabAllocationSelectScalar = {
    id?: boolean
    labTimeSlotId?: boolean
    studentId?: boolean
    pcNumber?: boolean
    assignedAt?: boolean
    clientAdminId?: boolean
  }

  export type LabAllocationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "labTimeSlotId" | "studentId" | "pcNumber" | "assignedAt" | "clientAdminId", ExtArgs["result"]["labAllocation"]>
  export type LabAllocationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    labTimeSlot?: boolean | LabTimeSlotDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }
  export type LabAllocationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    labTimeSlot?: boolean | LabTimeSlotDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }
  export type LabAllocationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    labTimeSlot?: boolean | LabTimeSlotDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }

  export type $LabAllocationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LabAllocation"
    objects: {
      labTimeSlot: Prisma.$LabTimeSlotPayload<ExtArgs>
      student: Prisma.$StudentPayload<ExtArgs>
      clientAdmin: Prisma.$ClientAdminPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      labTimeSlotId: number
      studentId: number
      pcNumber: number
      assignedAt: Date
      clientAdminId: string
    }, ExtArgs["result"]["labAllocation"]>
    composites: {}
  }

  type LabAllocationGetPayload<S extends boolean | null | undefined | LabAllocationDefaultArgs> = $Result.GetResult<Prisma.$LabAllocationPayload, S>

  type LabAllocationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LabAllocationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LabAllocationCountAggregateInputType | true
    }

  export interface LabAllocationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LabAllocation'], meta: { name: 'LabAllocation' } }
    /**
     * Find zero or one LabAllocation that matches the filter.
     * @param {LabAllocationFindUniqueArgs} args - Arguments to find a LabAllocation
     * @example
     * // Get one LabAllocation
     * const labAllocation = await prisma.labAllocation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LabAllocationFindUniqueArgs>(args: SelectSubset<T, LabAllocationFindUniqueArgs<ExtArgs>>): Prisma__LabAllocationClient<$Result.GetResult<Prisma.$LabAllocationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LabAllocation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LabAllocationFindUniqueOrThrowArgs} args - Arguments to find a LabAllocation
     * @example
     * // Get one LabAllocation
     * const labAllocation = await prisma.labAllocation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LabAllocationFindUniqueOrThrowArgs>(args: SelectSubset<T, LabAllocationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LabAllocationClient<$Result.GetResult<Prisma.$LabAllocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LabAllocation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabAllocationFindFirstArgs} args - Arguments to find a LabAllocation
     * @example
     * // Get one LabAllocation
     * const labAllocation = await prisma.labAllocation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LabAllocationFindFirstArgs>(args?: SelectSubset<T, LabAllocationFindFirstArgs<ExtArgs>>): Prisma__LabAllocationClient<$Result.GetResult<Prisma.$LabAllocationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LabAllocation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabAllocationFindFirstOrThrowArgs} args - Arguments to find a LabAllocation
     * @example
     * // Get one LabAllocation
     * const labAllocation = await prisma.labAllocation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LabAllocationFindFirstOrThrowArgs>(args?: SelectSubset<T, LabAllocationFindFirstOrThrowArgs<ExtArgs>>): Prisma__LabAllocationClient<$Result.GetResult<Prisma.$LabAllocationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LabAllocations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabAllocationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LabAllocations
     * const labAllocations = await prisma.labAllocation.findMany()
     * 
     * // Get first 10 LabAllocations
     * const labAllocations = await prisma.labAllocation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const labAllocationWithIdOnly = await prisma.labAllocation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LabAllocationFindManyArgs>(args?: SelectSubset<T, LabAllocationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabAllocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LabAllocation.
     * @param {LabAllocationCreateArgs} args - Arguments to create a LabAllocation.
     * @example
     * // Create one LabAllocation
     * const LabAllocation = await prisma.labAllocation.create({
     *   data: {
     *     // ... data to create a LabAllocation
     *   }
     * })
     * 
     */
    create<T extends LabAllocationCreateArgs>(args: SelectSubset<T, LabAllocationCreateArgs<ExtArgs>>): Prisma__LabAllocationClient<$Result.GetResult<Prisma.$LabAllocationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LabAllocations.
     * @param {LabAllocationCreateManyArgs} args - Arguments to create many LabAllocations.
     * @example
     * // Create many LabAllocations
     * const labAllocation = await prisma.labAllocation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LabAllocationCreateManyArgs>(args?: SelectSubset<T, LabAllocationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LabAllocations and returns the data saved in the database.
     * @param {LabAllocationCreateManyAndReturnArgs} args - Arguments to create many LabAllocations.
     * @example
     * // Create many LabAllocations
     * const labAllocation = await prisma.labAllocation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LabAllocations and only return the `id`
     * const labAllocationWithIdOnly = await prisma.labAllocation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LabAllocationCreateManyAndReturnArgs>(args?: SelectSubset<T, LabAllocationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabAllocationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LabAllocation.
     * @param {LabAllocationDeleteArgs} args - Arguments to delete one LabAllocation.
     * @example
     * // Delete one LabAllocation
     * const LabAllocation = await prisma.labAllocation.delete({
     *   where: {
     *     // ... filter to delete one LabAllocation
     *   }
     * })
     * 
     */
    delete<T extends LabAllocationDeleteArgs>(args: SelectSubset<T, LabAllocationDeleteArgs<ExtArgs>>): Prisma__LabAllocationClient<$Result.GetResult<Prisma.$LabAllocationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LabAllocation.
     * @param {LabAllocationUpdateArgs} args - Arguments to update one LabAllocation.
     * @example
     * // Update one LabAllocation
     * const labAllocation = await prisma.labAllocation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LabAllocationUpdateArgs>(args: SelectSubset<T, LabAllocationUpdateArgs<ExtArgs>>): Prisma__LabAllocationClient<$Result.GetResult<Prisma.$LabAllocationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LabAllocations.
     * @param {LabAllocationDeleteManyArgs} args - Arguments to filter LabAllocations to delete.
     * @example
     * // Delete a few LabAllocations
     * const { count } = await prisma.labAllocation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LabAllocationDeleteManyArgs>(args?: SelectSubset<T, LabAllocationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LabAllocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabAllocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LabAllocations
     * const labAllocation = await prisma.labAllocation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LabAllocationUpdateManyArgs>(args: SelectSubset<T, LabAllocationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LabAllocations and returns the data updated in the database.
     * @param {LabAllocationUpdateManyAndReturnArgs} args - Arguments to update many LabAllocations.
     * @example
     * // Update many LabAllocations
     * const labAllocation = await prisma.labAllocation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LabAllocations and only return the `id`
     * const labAllocationWithIdOnly = await prisma.labAllocation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LabAllocationUpdateManyAndReturnArgs>(args: SelectSubset<T, LabAllocationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabAllocationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LabAllocation.
     * @param {LabAllocationUpsertArgs} args - Arguments to update or create a LabAllocation.
     * @example
     * // Update or create a LabAllocation
     * const labAllocation = await prisma.labAllocation.upsert({
     *   create: {
     *     // ... data to create a LabAllocation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LabAllocation we want to update
     *   }
     * })
     */
    upsert<T extends LabAllocationUpsertArgs>(args: SelectSubset<T, LabAllocationUpsertArgs<ExtArgs>>): Prisma__LabAllocationClient<$Result.GetResult<Prisma.$LabAllocationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LabAllocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabAllocationCountArgs} args - Arguments to filter LabAllocations to count.
     * @example
     * // Count the number of LabAllocations
     * const count = await prisma.labAllocation.count({
     *   where: {
     *     // ... the filter for the LabAllocations we want to count
     *   }
     * })
    **/
    count<T extends LabAllocationCountArgs>(
      args?: Subset<T, LabAllocationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LabAllocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LabAllocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabAllocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LabAllocationAggregateArgs>(args: Subset<T, LabAllocationAggregateArgs>): Prisma.PrismaPromise<GetLabAllocationAggregateType<T>>

    /**
     * Group by LabAllocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabAllocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LabAllocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LabAllocationGroupByArgs['orderBy'] }
        : { orderBy?: LabAllocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LabAllocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLabAllocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LabAllocation model
   */
  readonly fields: LabAllocationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LabAllocation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LabAllocationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    labTimeSlot<T extends LabTimeSlotDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LabTimeSlotDefaultArgs<ExtArgs>>): Prisma__LabTimeSlotClient<$Result.GetResult<Prisma.$LabTimeSlotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    clientAdmin<T extends ClientAdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientAdminDefaultArgs<ExtArgs>>): Prisma__ClientAdminClient<$Result.GetResult<Prisma.$ClientAdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LabAllocation model
   */
  interface LabAllocationFieldRefs {
    readonly id: FieldRef<"LabAllocation", 'Int'>
    readonly labTimeSlotId: FieldRef<"LabAllocation", 'Int'>
    readonly studentId: FieldRef<"LabAllocation", 'Int'>
    readonly pcNumber: FieldRef<"LabAllocation", 'Int'>
    readonly assignedAt: FieldRef<"LabAllocation", 'DateTime'>
    readonly clientAdminId: FieldRef<"LabAllocation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * LabAllocation findUnique
   */
  export type LabAllocationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabAllocation
     */
    select?: LabAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabAllocation
     */
    omit?: LabAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabAllocationInclude<ExtArgs> | null
    /**
     * Filter, which LabAllocation to fetch.
     */
    where: LabAllocationWhereUniqueInput
  }

  /**
   * LabAllocation findUniqueOrThrow
   */
  export type LabAllocationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabAllocation
     */
    select?: LabAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabAllocation
     */
    omit?: LabAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabAllocationInclude<ExtArgs> | null
    /**
     * Filter, which LabAllocation to fetch.
     */
    where: LabAllocationWhereUniqueInput
  }

  /**
   * LabAllocation findFirst
   */
  export type LabAllocationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabAllocation
     */
    select?: LabAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabAllocation
     */
    omit?: LabAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabAllocationInclude<ExtArgs> | null
    /**
     * Filter, which LabAllocation to fetch.
     */
    where?: LabAllocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabAllocations to fetch.
     */
    orderBy?: LabAllocationOrderByWithRelationInput | LabAllocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LabAllocations.
     */
    cursor?: LabAllocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabAllocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabAllocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LabAllocations.
     */
    distinct?: LabAllocationScalarFieldEnum | LabAllocationScalarFieldEnum[]
  }

  /**
   * LabAllocation findFirstOrThrow
   */
  export type LabAllocationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabAllocation
     */
    select?: LabAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabAllocation
     */
    omit?: LabAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabAllocationInclude<ExtArgs> | null
    /**
     * Filter, which LabAllocation to fetch.
     */
    where?: LabAllocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabAllocations to fetch.
     */
    orderBy?: LabAllocationOrderByWithRelationInput | LabAllocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LabAllocations.
     */
    cursor?: LabAllocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabAllocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabAllocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LabAllocations.
     */
    distinct?: LabAllocationScalarFieldEnum | LabAllocationScalarFieldEnum[]
  }

  /**
   * LabAllocation findMany
   */
  export type LabAllocationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabAllocation
     */
    select?: LabAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabAllocation
     */
    omit?: LabAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabAllocationInclude<ExtArgs> | null
    /**
     * Filter, which LabAllocations to fetch.
     */
    where?: LabAllocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabAllocations to fetch.
     */
    orderBy?: LabAllocationOrderByWithRelationInput | LabAllocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LabAllocations.
     */
    cursor?: LabAllocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabAllocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabAllocations.
     */
    skip?: number
    distinct?: LabAllocationScalarFieldEnum | LabAllocationScalarFieldEnum[]
  }

  /**
   * LabAllocation create
   */
  export type LabAllocationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabAllocation
     */
    select?: LabAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabAllocation
     */
    omit?: LabAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabAllocationInclude<ExtArgs> | null
    /**
     * The data needed to create a LabAllocation.
     */
    data: XOR<LabAllocationCreateInput, LabAllocationUncheckedCreateInput>
  }

  /**
   * LabAllocation createMany
   */
  export type LabAllocationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LabAllocations.
     */
    data: LabAllocationCreateManyInput | LabAllocationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LabAllocation createManyAndReturn
   */
  export type LabAllocationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabAllocation
     */
    select?: LabAllocationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LabAllocation
     */
    omit?: LabAllocationOmit<ExtArgs> | null
    /**
     * The data used to create many LabAllocations.
     */
    data: LabAllocationCreateManyInput | LabAllocationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabAllocationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LabAllocation update
   */
  export type LabAllocationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabAllocation
     */
    select?: LabAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabAllocation
     */
    omit?: LabAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabAllocationInclude<ExtArgs> | null
    /**
     * The data needed to update a LabAllocation.
     */
    data: XOR<LabAllocationUpdateInput, LabAllocationUncheckedUpdateInput>
    /**
     * Choose, which LabAllocation to update.
     */
    where: LabAllocationWhereUniqueInput
  }

  /**
   * LabAllocation updateMany
   */
  export type LabAllocationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LabAllocations.
     */
    data: XOR<LabAllocationUpdateManyMutationInput, LabAllocationUncheckedUpdateManyInput>
    /**
     * Filter which LabAllocations to update
     */
    where?: LabAllocationWhereInput
    /**
     * Limit how many LabAllocations to update.
     */
    limit?: number
  }

  /**
   * LabAllocation updateManyAndReturn
   */
  export type LabAllocationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabAllocation
     */
    select?: LabAllocationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LabAllocation
     */
    omit?: LabAllocationOmit<ExtArgs> | null
    /**
     * The data used to update LabAllocations.
     */
    data: XOR<LabAllocationUpdateManyMutationInput, LabAllocationUncheckedUpdateManyInput>
    /**
     * Filter which LabAllocations to update
     */
    where?: LabAllocationWhereInput
    /**
     * Limit how many LabAllocations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabAllocationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LabAllocation upsert
   */
  export type LabAllocationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabAllocation
     */
    select?: LabAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabAllocation
     */
    omit?: LabAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabAllocationInclude<ExtArgs> | null
    /**
     * The filter to search for the LabAllocation to update in case it exists.
     */
    where: LabAllocationWhereUniqueInput
    /**
     * In case the LabAllocation found by the `where` argument doesn't exist, create a new LabAllocation with this data.
     */
    create: XOR<LabAllocationCreateInput, LabAllocationUncheckedCreateInput>
    /**
     * In case the LabAllocation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LabAllocationUpdateInput, LabAllocationUncheckedUpdateInput>
  }

  /**
   * LabAllocation delete
   */
  export type LabAllocationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabAllocation
     */
    select?: LabAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabAllocation
     */
    omit?: LabAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabAllocationInclude<ExtArgs> | null
    /**
     * Filter which LabAllocation to delete.
     */
    where: LabAllocationWhereUniqueInput
  }

  /**
   * LabAllocation deleteMany
   */
  export type LabAllocationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LabAllocations to delete
     */
    where?: LabAllocationWhereInput
    /**
     * Limit how many LabAllocations to delete.
     */
    limit?: number
  }

  /**
   * LabAllocation without action
   */
  export type LabAllocationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabAllocation
     */
    select?: LabAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabAllocation
     */
    omit?: LabAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabAllocationInclude<ExtArgs> | null
  }


  /**
   * Model StudentCourse
   */

  export type AggregateStudentCourse = {
    _count: StudentCourseCountAggregateOutputType | null
    _avg: StudentCourseAvgAggregateOutputType | null
    _sum: StudentCourseSumAggregateOutputType | null
    _min: StudentCourseMinAggregateOutputType | null
    _max: StudentCourseMaxAggregateOutputType | null
  }

  export type StudentCourseAvgAggregateOutputType = {
    id: number | null
    studentId: number | null
    courseId: number | null
    batchId: number | null
  }

  export type StudentCourseSumAggregateOutputType = {
    id: number | null
    studentId: number | null
    courseId: number | null
    batchId: number | null
  }

  export type StudentCourseMinAggregateOutputType = {
    id: number | null
    studentId: number | null
    courseId: number | null
    startDate: Date | null
    endDate: Date | null
    studentCode: string | null
    batchId: number | null
    internalNotes: string | null
    status: string | null
    clientAdminId: string | null
  }

  export type StudentCourseMaxAggregateOutputType = {
    id: number | null
    studentId: number | null
    courseId: number | null
    startDate: Date | null
    endDate: Date | null
    studentCode: string | null
    batchId: number | null
    internalNotes: string | null
    status: string | null
    clientAdminId: string | null
  }

  export type StudentCourseCountAggregateOutputType = {
    id: number
    studentId: number
    courseId: number
    startDate: number
    endDate: number
    studentCode: number
    batchId: number
    internalNotes: number
    status: number
    clientAdminId: number
    _all: number
  }


  export type StudentCourseAvgAggregateInputType = {
    id?: true
    studentId?: true
    courseId?: true
    batchId?: true
  }

  export type StudentCourseSumAggregateInputType = {
    id?: true
    studentId?: true
    courseId?: true
    batchId?: true
  }

  export type StudentCourseMinAggregateInputType = {
    id?: true
    studentId?: true
    courseId?: true
    startDate?: true
    endDate?: true
    studentCode?: true
    batchId?: true
    internalNotes?: true
    status?: true
    clientAdminId?: true
  }

  export type StudentCourseMaxAggregateInputType = {
    id?: true
    studentId?: true
    courseId?: true
    startDate?: true
    endDate?: true
    studentCode?: true
    batchId?: true
    internalNotes?: true
    status?: true
    clientAdminId?: true
  }

  export type StudentCourseCountAggregateInputType = {
    id?: true
    studentId?: true
    courseId?: true
    startDate?: true
    endDate?: true
    studentCode?: true
    batchId?: true
    internalNotes?: true
    status?: true
    clientAdminId?: true
    _all?: true
  }

  export type StudentCourseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentCourse to aggregate.
     */
    where?: StudentCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentCourses to fetch.
     */
    orderBy?: StudentCourseOrderByWithRelationInput | StudentCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentCourses
    **/
    _count?: true | StudentCourseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentCourseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentCourseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentCourseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentCourseMaxAggregateInputType
  }

  export type GetStudentCourseAggregateType<T extends StudentCourseAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentCourse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentCourse[P]>
      : GetScalarType<T[P], AggregateStudentCourse[P]>
  }




  export type StudentCourseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentCourseWhereInput
    orderBy?: StudentCourseOrderByWithAggregationInput | StudentCourseOrderByWithAggregationInput[]
    by: StudentCourseScalarFieldEnum[] | StudentCourseScalarFieldEnum
    having?: StudentCourseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentCourseCountAggregateInputType | true
    _avg?: StudentCourseAvgAggregateInputType
    _sum?: StudentCourseSumAggregateInputType
    _min?: StudentCourseMinAggregateInputType
    _max?: StudentCourseMaxAggregateInputType
  }

  export type StudentCourseGroupByOutputType = {
    id: number
    studentId: number
    courseId: number
    startDate: Date
    endDate: Date
    studentCode: string
    batchId: number | null
    internalNotes: string | null
    status: string
    clientAdminId: string
    _count: StudentCourseCountAggregateOutputType | null
    _avg: StudentCourseAvgAggregateOutputType | null
    _sum: StudentCourseSumAggregateOutputType | null
    _min: StudentCourseMinAggregateOutputType | null
    _max: StudentCourseMaxAggregateOutputType | null
  }

  type GetStudentCourseGroupByPayload<T extends StudentCourseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentCourseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentCourseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentCourseGroupByOutputType[P]>
            : GetScalarType<T[P], StudentCourseGroupByOutputType[P]>
        }
      >
    >


  export type StudentCourseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    courseId?: boolean
    startDate?: boolean
    endDate?: boolean
    studentCode?: boolean
    batchId?: boolean
    internalNotes?: boolean
    status?: boolean
    clientAdminId?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    batch?: boolean | StudentCourse$batchArgs<ExtArgs>
    certificate?: boolean | StudentCourse$certificateArgs<ExtArgs>
    completions?: boolean | StudentCourse$completionsArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
    _count?: boolean | StudentCourseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentCourse"]>

  export type StudentCourseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    courseId?: boolean
    startDate?: boolean
    endDate?: boolean
    studentCode?: boolean
    batchId?: boolean
    internalNotes?: boolean
    status?: boolean
    clientAdminId?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    batch?: boolean | StudentCourse$batchArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentCourse"]>

  export type StudentCourseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    courseId?: boolean
    startDate?: boolean
    endDate?: boolean
    studentCode?: boolean
    batchId?: boolean
    internalNotes?: boolean
    status?: boolean
    clientAdminId?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    batch?: boolean | StudentCourse$batchArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentCourse"]>

  export type StudentCourseSelectScalar = {
    id?: boolean
    studentId?: boolean
    courseId?: boolean
    startDate?: boolean
    endDate?: boolean
    studentCode?: boolean
    batchId?: boolean
    internalNotes?: boolean
    status?: boolean
    clientAdminId?: boolean
  }

  export type StudentCourseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "courseId" | "startDate" | "endDate" | "studentCode" | "batchId" | "internalNotes" | "status" | "clientAdminId", ExtArgs["result"]["studentCourse"]>
  export type StudentCourseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    batch?: boolean | StudentCourse$batchArgs<ExtArgs>
    certificate?: boolean | StudentCourse$certificateArgs<ExtArgs>
    completions?: boolean | StudentCourse$completionsArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
    _count?: boolean | StudentCourseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StudentCourseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    batch?: boolean | StudentCourse$batchArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }
  export type StudentCourseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    batch?: boolean | StudentCourse$batchArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }

  export type $StudentCoursePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentCourse"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      course: Prisma.$CoursePayload<ExtArgs>
      batch: Prisma.$BatchPayload<ExtArgs> | null
      certificate: Prisma.$CertificatePayload<ExtArgs> | null
      completions: Prisma.$CourseCompletionPayload<ExtArgs>[]
      clientAdmin: Prisma.$ClientAdminPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      studentId: number
      courseId: number
      startDate: Date
      endDate: Date
      studentCode: string
      batchId: number | null
      internalNotes: string | null
      status: string
      clientAdminId: string
    }, ExtArgs["result"]["studentCourse"]>
    composites: {}
  }

  type StudentCourseGetPayload<S extends boolean | null | undefined | StudentCourseDefaultArgs> = $Result.GetResult<Prisma.$StudentCoursePayload, S>

  type StudentCourseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudentCourseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentCourseCountAggregateInputType | true
    }

  export interface StudentCourseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentCourse'], meta: { name: 'StudentCourse' } }
    /**
     * Find zero or one StudentCourse that matches the filter.
     * @param {StudentCourseFindUniqueArgs} args - Arguments to find a StudentCourse
     * @example
     * // Get one StudentCourse
     * const studentCourse = await prisma.studentCourse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentCourseFindUniqueArgs>(args: SelectSubset<T, StudentCourseFindUniqueArgs<ExtArgs>>): Prisma__StudentCourseClient<$Result.GetResult<Prisma.$StudentCoursePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StudentCourse that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudentCourseFindUniqueOrThrowArgs} args - Arguments to find a StudentCourse
     * @example
     * // Get one StudentCourse
     * const studentCourse = await prisma.studentCourse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentCourseFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentCourseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentCourseClient<$Result.GetResult<Prisma.$StudentCoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentCourse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentCourseFindFirstArgs} args - Arguments to find a StudentCourse
     * @example
     * // Get one StudentCourse
     * const studentCourse = await prisma.studentCourse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentCourseFindFirstArgs>(args?: SelectSubset<T, StudentCourseFindFirstArgs<ExtArgs>>): Prisma__StudentCourseClient<$Result.GetResult<Prisma.$StudentCoursePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentCourse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentCourseFindFirstOrThrowArgs} args - Arguments to find a StudentCourse
     * @example
     * // Get one StudentCourse
     * const studentCourse = await prisma.studentCourse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentCourseFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentCourseFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentCourseClient<$Result.GetResult<Prisma.$StudentCoursePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StudentCourses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentCourseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentCourses
     * const studentCourses = await prisma.studentCourse.findMany()
     * 
     * // Get first 10 StudentCourses
     * const studentCourses = await prisma.studentCourse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentCourseWithIdOnly = await prisma.studentCourse.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentCourseFindManyArgs>(args?: SelectSubset<T, StudentCourseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentCoursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StudentCourse.
     * @param {StudentCourseCreateArgs} args - Arguments to create a StudentCourse.
     * @example
     * // Create one StudentCourse
     * const StudentCourse = await prisma.studentCourse.create({
     *   data: {
     *     // ... data to create a StudentCourse
     *   }
     * })
     * 
     */
    create<T extends StudentCourseCreateArgs>(args: SelectSubset<T, StudentCourseCreateArgs<ExtArgs>>): Prisma__StudentCourseClient<$Result.GetResult<Prisma.$StudentCoursePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StudentCourses.
     * @param {StudentCourseCreateManyArgs} args - Arguments to create many StudentCourses.
     * @example
     * // Create many StudentCourses
     * const studentCourse = await prisma.studentCourse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentCourseCreateManyArgs>(args?: SelectSubset<T, StudentCourseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StudentCourses and returns the data saved in the database.
     * @param {StudentCourseCreateManyAndReturnArgs} args - Arguments to create many StudentCourses.
     * @example
     * // Create many StudentCourses
     * const studentCourse = await prisma.studentCourse.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StudentCourses and only return the `id`
     * const studentCourseWithIdOnly = await prisma.studentCourse.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentCourseCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentCourseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentCoursePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StudentCourse.
     * @param {StudentCourseDeleteArgs} args - Arguments to delete one StudentCourse.
     * @example
     * // Delete one StudentCourse
     * const StudentCourse = await prisma.studentCourse.delete({
     *   where: {
     *     // ... filter to delete one StudentCourse
     *   }
     * })
     * 
     */
    delete<T extends StudentCourseDeleteArgs>(args: SelectSubset<T, StudentCourseDeleteArgs<ExtArgs>>): Prisma__StudentCourseClient<$Result.GetResult<Prisma.$StudentCoursePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StudentCourse.
     * @param {StudentCourseUpdateArgs} args - Arguments to update one StudentCourse.
     * @example
     * // Update one StudentCourse
     * const studentCourse = await prisma.studentCourse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentCourseUpdateArgs>(args: SelectSubset<T, StudentCourseUpdateArgs<ExtArgs>>): Prisma__StudentCourseClient<$Result.GetResult<Prisma.$StudentCoursePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StudentCourses.
     * @param {StudentCourseDeleteManyArgs} args - Arguments to filter StudentCourses to delete.
     * @example
     * // Delete a few StudentCourses
     * const { count } = await prisma.studentCourse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentCourseDeleteManyArgs>(args?: SelectSubset<T, StudentCourseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentCourses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentCourseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentCourses
     * const studentCourse = await prisma.studentCourse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentCourseUpdateManyArgs>(args: SelectSubset<T, StudentCourseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentCourses and returns the data updated in the database.
     * @param {StudentCourseUpdateManyAndReturnArgs} args - Arguments to update many StudentCourses.
     * @example
     * // Update many StudentCourses
     * const studentCourse = await prisma.studentCourse.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StudentCourses and only return the `id`
     * const studentCourseWithIdOnly = await prisma.studentCourse.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StudentCourseUpdateManyAndReturnArgs>(args: SelectSubset<T, StudentCourseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentCoursePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StudentCourse.
     * @param {StudentCourseUpsertArgs} args - Arguments to update or create a StudentCourse.
     * @example
     * // Update or create a StudentCourse
     * const studentCourse = await prisma.studentCourse.upsert({
     *   create: {
     *     // ... data to create a StudentCourse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentCourse we want to update
     *   }
     * })
     */
    upsert<T extends StudentCourseUpsertArgs>(args: SelectSubset<T, StudentCourseUpsertArgs<ExtArgs>>): Prisma__StudentCourseClient<$Result.GetResult<Prisma.$StudentCoursePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StudentCourses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentCourseCountArgs} args - Arguments to filter StudentCourses to count.
     * @example
     * // Count the number of StudentCourses
     * const count = await prisma.studentCourse.count({
     *   where: {
     *     // ... the filter for the StudentCourses we want to count
     *   }
     * })
    **/
    count<T extends StudentCourseCountArgs>(
      args?: Subset<T, StudentCourseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentCourseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentCourse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentCourseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentCourseAggregateArgs>(args: Subset<T, StudentCourseAggregateArgs>): Prisma.PrismaPromise<GetStudentCourseAggregateType<T>>

    /**
     * Group by StudentCourse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentCourseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentCourseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentCourseGroupByArgs['orderBy'] }
        : { orderBy?: StudentCourseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentCourseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentCourseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentCourse model
   */
  readonly fields: StudentCourseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentCourse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentCourseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    batch<T extends StudentCourse$batchArgs<ExtArgs> = {}>(args?: Subset<T, StudentCourse$batchArgs<ExtArgs>>): Prisma__BatchClient<$Result.GetResult<Prisma.$BatchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    certificate<T extends StudentCourse$certificateArgs<ExtArgs> = {}>(args?: Subset<T, StudentCourse$certificateArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    completions<T extends StudentCourse$completionsArgs<ExtArgs> = {}>(args?: Subset<T, StudentCourse$completionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseCompletionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    clientAdmin<T extends ClientAdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientAdminDefaultArgs<ExtArgs>>): Prisma__ClientAdminClient<$Result.GetResult<Prisma.$ClientAdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudentCourse model
   */
  interface StudentCourseFieldRefs {
    readonly id: FieldRef<"StudentCourse", 'Int'>
    readonly studentId: FieldRef<"StudentCourse", 'Int'>
    readonly courseId: FieldRef<"StudentCourse", 'Int'>
    readonly startDate: FieldRef<"StudentCourse", 'DateTime'>
    readonly endDate: FieldRef<"StudentCourse", 'DateTime'>
    readonly studentCode: FieldRef<"StudentCourse", 'String'>
    readonly batchId: FieldRef<"StudentCourse", 'Int'>
    readonly internalNotes: FieldRef<"StudentCourse", 'String'>
    readonly status: FieldRef<"StudentCourse", 'String'>
    readonly clientAdminId: FieldRef<"StudentCourse", 'String'>
  }
    

  // Custom InputTypes
  /**
   * StudentCourse findUnique
   */
  export type StudentCourseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentCourse
     */
    select?: StudentCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentCourse
     */
    omit?: StudentCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentCourseInclude<ExtArgs> | null
    /**
     * Filter, which StudentCourse to fetch.
     */
    where: StudentCourseWhereUniqueInput
  }

  /**
   * StudentCourse findUniqueOrThrow
   */
  export type StudentCourseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentCourse
     */
    select?: StudentCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentCourse
     */
    omit?: StudentCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentCourseInclude<ExtArgs> | null
    /**
     * Filter, which StudentCourse to fetch.
     */
    where: StudentCourseWhereUniqueInput
  }

  /**
   * StudentCourse findFirst
   */
  export type StudentCourseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentCourse
     */
    select?: StudentCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentCourse
     */
    omit?: StudentCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentCourseInclude<ExtArgs> | null
    /**
     * Filter, which StudentCourse to fetch.
     */
    where?: StudentCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentCourses to fetch.
     */
    orderBy?: StudentCourseOrderByWithRelationInput | StudentCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentCourses.
     */
    cursor?: StudentCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentCourses.
     */
    distinct?: StudentCourseScalarFieldEnum | StudentCourseScalarFieldEnum[]
  }

  /**
   * StudentCourse findFirstOrThrow
   */
  export type StudentCourseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentCourse
     */
    select?: StudentCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentCourse
     */
    omit?: StudentCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentCourseInclude<ExtArgs> | null
    /**
     * Filter, which StudentCourse to fetch.
     */
    where?: StudentCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentCourses to fetch.
     */
    orderBy?: StudentCourseOrderByWithRelationInput | StudentCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentCourses.
     */
    cursor?: StudentCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentCourses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentCourses.
     */
    distinct?: StudentCourseScalarFieldEnum | StudentCourseScalarFieldEnum[]
  }

  /**
   * StudentCourse findMany
   */
  export type StudentCourseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentCourse
     */
    select?: StudentCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentCourse
     */
    omit?: StudentCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentCourseInclude<ExtArgs> | null
    /**
     * Filter, which StudentCourses to fetch.
     */
    where?: StudentCourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentCourses to fetch.
     */
    orderBy?: StudentCourseOrderByWithRelationInput | StudentCourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentCourses.
     */
    cursor?: StudentCourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentCourses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentCourses.
     */
    skip?: number
    distinct?: StudentCourseScalarFieldEnum | StudentCourseScalarFieldEnum[]
  }

  /**
   * StudentCourse create
   */
  export type StudentCourseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentCourse
     */
    select?: StudentCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentCourse
     */
    omit?: StudentCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentCourseInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentCourse.
     */
    data: XOR<StudentCourseCreateInput, StudentCourseUncheckedCreateInput>
  }

  /**
   * StudentCourse createMany
   */
  export type StudentCourseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentCourses.
     */
    data: StudentCourseCreateManyInput | StudentCourseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StudentCourse createManyAndReturn
   */
  export type StudentCourseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentCourse
     */
    select?: StudentCourseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StudentCourse
     */
    omit?: StudentCourseOmit<ExtArgs> | null
    /**
     * The data used to create many StudentCourses.
     */
    data: StudentCourseCreateManyInput | StudentCourseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentCourseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentCourse update
   */
  export type StudentCourseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentCourse
     */
    select?: StudentCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentCourse
     */
    omit?: StudentCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentCourseInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentCourse.
     */
    data: XOR<StudentCourseUpdateInput, StudentCourseUncheckedUpdateInput>
    /**
     * Choose, which StudentCourse to update.
     */
    where: StudentCourseWhereUniqueInput
  }

  /**
   * StudentCourse updateMany
   */
  export type StudentCourseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentCourses.
     */
    data: XOR<StudentCourseUpdateManyMutationInput, StudentCourseUncheckedUpdateManyInput>
    /**
     * Filter which StudentCourses to update
     */
    where?: StudentCourseWhereInput
    /**
     * Limit how many StudentCourses to update.
     */
    limit?: number
  }

  /**
   * StudentCourse updateManyAndReturn
   */
  export type StudentCourseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentCourse
     */
    select?: StudentCourseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StudentCourse
     */
    omit?: StudentCourseOmit<ExtArgs> | null
    /**
     * The data used to update StudentCourses.
     */
    data: XOR<StudentCourseUpdateManyMutationInput, StudentCourseUncheckedUpdateManyInput>
    /**
     * Filter which StudentCourses to update
     */
    where?: StudentCourseWhereInput
    /**
     * Limit how many StudentCourses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentCourseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentCourse upsert
   */
  export type StudentCourseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentCourse
     */
    select?: StudentCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentCourse
     */
    omit?: StudentCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentCourseInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentCourse to update in case it exists.
     */
    where: StudentCourseWhereUniqueInput
    /**
     * In case the StudentCourse found by the `where` argument doesn't exist, create a new StudentCourse with this data.
     */
    create: XOR<StudentCourseCreateInput, StudentCourseUncheckedCreateInput>
    /**
     * In case the StudentCourse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentCourseUpdateInput, StudentCourseUncheckedUpdateInput>
  }

  /**
   * StudentCourse delete
   */
  export type StudentCourseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentCourse
     */
    select?: StudentCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentCourse
     */
    omit?: StudentCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentCourseInclude<ExtArgs> | null
    /**
     * Filter which StudentCourse to delete.
     */
    where: StudentCourseWhereUniqueInput
  }

  /**
   * StudentCourse deleteMany
   */
  export type StudentCourseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentCourses to delete
     */
    where?: StudentCourseWhereInput
    /**
     * Limit how many StudentCourses to delete.
     */
    limit?: number
  }

  /**
   * StudentCourse.batch
   */
  export type StudentCourse$batchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batch
     */
    select?: BatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batch
     */
    omit?: BatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BatchInclude<ExtArgs> | null
    where?: BatchWhereInput
  }

  /**
   * StudentCourse.certificate
   */
  export type StudentCourse$certificateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    where?: CertificateWhereInput
  }

  /**
   * StudentCourse.completions
   */
  export type StudentCourse$completionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseCompletion
     */
    select?: CourseCompletionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseCompletion
     */
    omit?: CourseCompletionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseCompletionInclude<ExtArgs> | null
    where?: CourseCompletionWhereInput
    orderBy?: CourseCompletionOrderByWithRelationInput | CourseCompletionOrderByWithRelationInput[]
    cursor?: CourseCompletionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseCompletionScalarFieldEnum | CourseCompletionScalarFieldEnum[]
  }

  /**
   * StudentCourse without action
   */
  export type StudentCourseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentCourse
     */
    select?: StudentCourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentCourse
     */
    omit?: StudentCourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentCourseInclude<ExtArgs> | null
  }


  /**
   * Model FeeStructure
   */

  export type AggregateFeeStructure = {
    _count: FeeStructureCountAggregateOutputType | null
    _avg: FeeStructureAvgAggregateOutputType | null
    _sum: FeeStructureSumAggregateOutputType | null
    _min: FeeStructureMinAggregateOutputType | null
    _max: FeeStructureMaxAggregateOutputType | null
  }

  export type FeeStructureAvgAggregateOutputType = {
    id: number | null
    studentId: number | null
    courseId: number | null
    totalAmount: number | null
    installmentCount: number | null
    installmentTypeId: number | null
  }

  export type FeeStructureSumAggregateOutputType = {
    id: number | null
    studentId: number | null
    courseId: number | null
    totalAmount: number | null
    installmentCount: number | null
    installmentTypeId: number | null
  }

  export type FeeStructureMinAggregateOutputType = {
    id: number | null
    studentId: number | null
    courseId: number | null
    totalAmount: number | null
    paymentType: $Enums.PaymentType | null
    installmentCount: number | null
    installmentTypeId: number | null
    clientAdminId: string | null
  }

  export type FeeStructureMaxAggregateOutputType = {
    id: number | null
    studentId: number | null
    courseId: number | null
    totalAmount: number | null
    paymentType: $Enums.PaymentType | null
    installmentCount: number | null
    installmentTypeId: number | null
    clientAdminId: string | null
  }

  export type FeeStructureCountAggregateOutputType = {
    id: number
    studentId: number
    courseId: number
    totalAmount: number
    paymentType: number
    installmentCount: number
    installmentTypeId: number
    clientAdminId: number
    _all: number
  }


  export type FeeStructureAvgAggregateInputType = {
    id?: true
    studentId?: true
    courseId?: true
    totalAmount?: true
    installmentCount?: true
    installmentTypeId?: true
  }

  export type FeeStructureSumAggregateInputType = {
    id?: true
    studentId?: true
    courseId?: true
    totalAmount?: true
    installmentCount?: true
    installmentTypeId?: true
  }

  export type FeeStructureMinAggregateInputType = {
    id?: true
    studentId?: true
    courseId?: true
    totalAmount?: true
    paymentType?: true
    installmentCount?: true
    installmentTypeId?: true
    clientAdminId?: true
  }

  export type FeeStructureMaxAggregateInputType = {
    id?: true
    studentId?: true
    courseId?: true
    totalAmount?: true
    paymentType?: true
    installmentCount?: true
    installmentTypeId?: true
    clientAdminId?: true
  }

  export type FeeStructureCountAggregateInputType = {
    id?: true
    studentId?: true
    courseId?: true
    totalAmount?: true
    paymentType?: true
    installmentCount?: true
    installmentTypeId?: true
    clientAdminId?: true
    _all?: true
  }

  export type FeeStructureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeeStructure to aggregate.
     */
    where?: FeeStructureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeeStructures to fetch.
     */
    orderBy?: FeeStructureOrderByWithRelationInput | FeeStructureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeeStructureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeeStructures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeeStructures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FeeStructures
    **/
    _count?: true | FeeStructureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeeStructureAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeeStructureSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeeStructureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeeStructureMaxAggregateInputType
  }

  export type GetFeeStructureAggregateType<T extends FeeStructureAggregateArgs> = {
        [P in keyof T & keyof AggregateFeeStructure]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeeStructure[P]>
      : GetScalarType<T[P], AggregateFeeStructure[P]>
  }




  export type FeeStructureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeeStructureWhereInput
    orderBy?: FeeStructureOrderByWithAggregationInput | FeeStructureOrderByWithAggregationInput[]
    by: FeeStructureScalarFieldEnum[] | FeeStructureScalarFieldEnum
    having?: FeeStructureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeeStructureCountAggregateInputType | true
    _avg?: FeeStructureAvgAggregateInputType
    _sum?: FeeStructureSumAggregateInputType
    _min?: FeeStructureMinAggregateInputType
    _max?: FeeStructureMaxAggregateInputType
  }

  export type FeeStructureGroupByOutputType = {
    id: number
    studentId: number
    courseId: number
    totalAmount: number
    paymentType: $Enums.PaymentType
    installmentCount: number | null
    installmentTypeId: number | null
    clientAdminId: string
    _count: FeeStructureCountAggregateOutputType | null
    _avg: FeeStructureAvgAggregateOutputType | null
    _sum: FeeStructureSumAggregateOutputType | null
    _min: FeeStructureMinAggregateOutputType | null
    _max: FeeStructureMaxAggregateOutputType | null
  }

  type GetFeeStructureGroupByPayload<T extends FeeStructureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeeStructureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeeStructureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeeStructureGroupByOutputType[P]>
            : GetScalarType<T[P], FeeStructureGroupByOutputType[P]>
        }
      >
    >


  export type FeeStructureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    courseId?: boolean
    totalAmount?: boolean
    paymentType?: boolean
    installmentCount?: boolean
    installmentTypeId?: boolean
    clientAdminId?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    installment?: boolean | FeeStructure$installmentArgs<ExtArgs>
    studentFees?: boolean | FeeStructure$studentFeesArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
    _count?: boolean | FeeStructureCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feeStructure"]>

  export type FeeStructureSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    courseId?: boolean
    totalAmount?: boolean
    paymentType?: boolean
    installmentCount?: boolean
    installmentTypeId?: boolean
    clientAdminId?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    installment?: boolean | FeeStructure$installmentArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feeStructure"]>

  export type FeeStructureSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    courseId?: boolean
    totalAmount?: boolean
    paymentType?: boolean
    installmentCount?: boolean
    installmentTypeId?: boolean
    clientAdminId?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    installment?: boolean | FeeStructure$installmentArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feeStructure"]>

  export type FeeStructureSelectScalar = {
    id?: boolean
    studentId?: boolean
    courseId?: boolean
    totalAmount?: boolean
    paymentType?: boolean
    installmentCount?: boolean
    installmentTypeId?: boolean
    clientAdminId?: boolean
  }

  export type FeeStructureOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "courseId" | "totalAmount" | "paymentType" | "installmentCount" | "installmentTypeId" | "clientAdminId", ExtArgs["result"]["feeStructure"]>
  export type FeeStructureInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    installment?: boolean | FeeStructure$installmentArgs<ExtArgs>
    studentFees?: boolean | FeeStructure$studentFeesArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
    _count?: boolean | FeeStructureCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FeeStructureIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    installment?: boolean | FeeStructure$installmentArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }
  export type FeeStructureIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    installment?: boolean | FeeStructure$installmentArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }

  export type $FeeStructurePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FeeStructure"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      course: Prisma.$CoursePayload<ExtArgs>
      installment: Prisma.$InstallmentDetailPayload<ExtArgs> | null
      studentFees: Prisma.$StudentFeePayload<ExtArgs>[]
      clientAdmin: Prisma.$ClientAdminPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      studentId: number
      courseId: number
      totalAmount: number
      paymentType: $Enums.PaymentType
      installmentCount: number | null
      installmentTypeId: number | null
      clientAdminId: string
    }, ExtArgs["result"]["feeStructure"]>
    composites: {}
  }

  type FeeStructureGetPayload<S extends boolean | null | undefined | FeeStructureDefaultArgs> = $Result.GetResult<Prisma.$FeeStructurePayload, S>

  type FeeStructureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FeeStructureFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FeeStructureCountAggregateInputType | true
    }

  export interface FeeStructureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FeeStructure'], meta: { name: 'FeeStructure' } }
    /**
     * Find zero or one FeeStructure that matches the filter.
     * @param {FeeStructureFindUniqueArgs} args - Arguments to find a FeeStructure
     * @example
     * // Get one FeeStructure
     * const feeStructure = await prisma.feeStructure.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeeStructureFindUniqueArgs>(args: SelectSubset<T, FeeStructureFindUniqueArgs<ExtArgs>>): Prisma__FeeStructureClient<$Result.GetResult<Prisma.$FeeStructurePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FeeStructure that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FeeStructureFindUniqueOrThrowArgs} args - Arguments to find a FeeStructure
     * @example
     * // Get one FeeStructure
     * const feeStructure = await prisma.feeStructure.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeeStructureFindUniqueOrThrowArgs>(args: SelectSubset<T, FeeStructureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeeStructureClient<$Result.GetResult<Prisma.$FeeStructurePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FeeStructure that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeStructureFindFirstArgs} args - Arguments to find a FeeStructure
     * @example
     * // Get one FeeStructure
     * const feeStructure = await prisma.feeStructure.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeeStructureFindFirstArgs>(args?: SelectSubset<T, FeeStructureFindFirstArgs<ExtArgs>>): Prisma__FeeStructureClient<$Result.GetResult<Prisma.$FeeStructurePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FeeStructure that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeStructureFindFirstOrThrowArgs} args - Arguments to find a FeeStructure
     * @example
     * // Get one FeeStructure
     * const feeStructure = await prisma.feeStructure.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeeStructureFindFirstOrThrowArgs>(args?: SelectSubset<T, FeeStructureFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeeStructureClient<$Result.GetResult<Prisma.$FeeStructurePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FeeStructures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeStructureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FeeStructures
     * const feeStructures = await prisma.feeStructure.findMany()
     * 
     * // Get first 10 FeeStructures
     * const feeStructures = await prisma.feeStructure.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const feeStructureWithIdOnly = await prisma.feeStructure.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FeeStructureFindManyArgs>(args?: SelectSubset<T, FeeStructureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeeStructurePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FeeStructure.
     * @param {FeeStructureCreateArgs} args - Arguments to create a FeeStructure.
     * @example
     * // Create one FeeStructure
     * const FeeStructure = await prisma.feeStructure.create({
     *   data: {
     *     // ... data to create a FeeStructure
     *   }
     * })
     * 
     */
    create<T extends FeeStructureCreateArgs>(args: SelectSubset<T, FeeStructureCreateArgs<ExtArgs>>): Prisma__FeeStructureClient<$Result.GetResult<Prisma.$FeeStructurePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FeeStructures.
     * @param {FeeStructureCreateManyArgs} args - Arguments to create many FeeStructures.
     * @example
     * // Create many FeeStructures
     * const feeStructure = await prisma.feeStructure.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeeStructureCreateManyArgs>(args?: SelectSubset<T, FeeStructureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FeeStructures and returns the data saved in the database.
     * @param {FeeStructureCreateManyAndReturnArgs} args - Arguments to create many FeeStructures.
     * @example
     * // Create many FeeStructures
     * const feeStructure = await prisma.feeStructure.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FeeStructures and only return the `id`
     * const feeStructureWithIdOnly = await prisma.feeStructure.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FeeStructureCreateManyAndReturnArgs>(args?: SelectSubset<T, FeeStructureCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeeStructurePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FeeStructure.
     * @param {FeeStructureDeleteArgs} args - Arguments to delete one FeeStructure.
     * @example
     * // Delete one FeeStructure
     * const FeeStructure = await prisma.feeStructure.delete({
     *   where: {
     *     // ... filter to delete one FeeStructure
     *   }
     * })
     * 
     */
    delete<T extends FeeStructureDeleteArgs>(args: SelectSubset<T, FeeStructureDeleteArgs<ExtArgs>>): Prisma__FeeStructureClient<$Result.GetResult<Prisma.$FeeStructurePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FeeStructure.
     * @param {FeeStructureUpdateArgs} args - Arguments to update one FeeStructure.
     * @example
     * // Update one FeeStructure
     * const feeStructure = await prisma.feeStructure.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeeStructureUpdateArgs>(args: SelectSubset<T, FeeStructureUpdateArgs<ExtArgs>>): Prisma__FeeStructureClient<$Result.GetResult<Prisma.$FeeStructurePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FeeStructures.
     * @param {FeeStructureDeleteManyArgs} args - Arguments to filter FeeStructures to delete.
     * @example
     * // Delete a few FeeStructures
     * const { count } = await prisma.feeStructure.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeeStructureDeleteManyArgs>(args?: SelectSubset<T, FeeStructureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeeStructures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeStructureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FeeStructures
     * const feeStructure = await prisma.feeStructure.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeeStructureUpdateManyArgs>(args: SelectSubset<T, FeeStructureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeeStructures and returns the data updated in the database.
     * @param {FeeStructureUpdateManyAndReturnArgs} args - Arguments to update many FeeStructures.
     * @example
     * // Update many FeeStructures
     * const feeStructure = await prisma.feeStructure.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FeeStructures and only return the `id`
     * const feeStructureWithIdOnly = await prisma.feeStructure.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FeeStructureUpdateManyAndReturnArgs>(args: SelectSubset<T, FeeStructureUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeeStructurePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FeeStructure.
     * @param {FeeStructureUpsertArgs} args - Arguments to update or create a FeeStructure.
     * @example
     * // Update or create a FeeStructure
     * const feeStructure = await prisma.feeStructure.upsert({
     *   create: {
     *     // ... data to create a FeeStructure
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FeeStructure we want to update
     *   }
     * })
     */
    upsert<T extends FeeStructureUpsertArgs>(args: SelectSubset<T, FeeStructureUpsertArgs<ExtArgs>>): Prisma__FeeStructureClient<$Result.GetResult<Prisma.$FeeStructurePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FeeStructures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeStructureCountArgs} args - Arguments to filter FeeStructures to count.
     * @example
     * // Count the number of FeeStructures
     * const count = await prisma.feeStructure.count({
     *   where: {
     *     // ... the filter for the FeeStructures we want to count
     *   }
     * })
    **/
    count<T extends FeeStructureCountArgs>(
      args?: Subset<T, FeeStructureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeeStructureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FeeStructure.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeStructureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeeStructureAggregateArgs>(args: Subset<T, FeeStructureAggregateArgs>): Prisma.PrismaPromise<GetFeeStructureAggregateType<T>>

    /**
     * Group by FeeStructure.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeStructureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeeStructureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeeStructureGroupByArgs['orderBy'] }
        : { orderBy?: FeeStructureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeeStructureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeeStructureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FeeStructure model
   */
  readonly fields: FeeStructureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FeeStructure.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeeStructureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    installment<T extends FeeStructure$installmentArgs<ExtArgs> = {}>(args?: Subset<T, FeeStructure$installmentArgs<ExtArgs>>): Prisma__InstallmentDetailClient<$Result.GetResult<Prisma.$InstallmentDetailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    studentFees<T extends FeeStructure$studentFeesArgs<ExtArgs> = {}>(args?: Subset<T, FeeStructure$studentFeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentFeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    clientAdmin<T extends ClientAdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientAdminDefaultArgs<ExtArgs>>): Prisma__ClientAdminClient<$Result.GetResult<Prisma.$ClientAdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FeeStructure model
   */
  interface FeeStructureFieldRefs {
    readonly id: FieldRef<"FeeStructure", 'Int'>
    readonly studentId: FieldRef<"FeeStructure", 'Int'>
    readonly courseId: FieldRef<"FeeStructure", 'Int'>
    readonly totalAmount: FieldRef<"FeeStructure", 'Float'>
    readonly paymentType: FieldRef<"FeeStructure", 'PaymentType'>
    readonly installmentCount: FieldRef<"FeeStructure", 'Int'>
    readonly installmentTypeId: FieldRef<"FeeStructure", 'Int'>
    readonly clientAdminId: FieldRef<"FeeStructure", 'String'>
  }
    

  // Custom InputTypes
  /**
   * FeeStructure findUnique
   */
  export type FeeStructureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeStructure
     */
    select?: FeeStructureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeStructure
     */
    omit?: FeeStructureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeStructureInclude<ExtArgs> | null
    /**
     * Filter, which FeeStructure to fetch.
     */
    where: FeeStructureWhereUniqueInput
  }

  /**
   * FeeStructure findUniqueOrThrow
   */
  export type FeeStructureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeStructure
     */
    select?: FeeStructureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeStructure
     */
    omit?: FeeStructureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeStructureInclude<ExtArgs> | null
    /**
     * Filter, which FeeStructure to fetch.
     */
    where: FeeStructureWhereUniqueInput
  }

  /**
   * FeeStructure findFirst
   */
  export type FeeStructureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeStructure
     */
    select?: FeeStructureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeStructure
     */
    omit?: FeeStructureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeStructureInclude<ExtArgs> | null
    /**
     * Filter, which FeeStructure to fetch.
     */
    where?: FeeStructureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeeStructures to fetch.
     */
    orderBy?: FeeStructureOrderByWithRelationInput | FeeStructureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeeStructures.
     */
    cursor?: FeeStructureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeeStructures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeeStructures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeeStructures.
     */
    distinct?: FeeStructureScalarFieldEnum | FeeStructureScalarFieldEnum[]
  }

  /**
   * FeeStructure findFirstOrThrow
   */
  export type FeeStructureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeStructure
     */
    select?: FeeStructureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeStructure
     */
    omit?: FeeStructureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeStructureInclude<ExtArgs> | null
    /**
     * Filter, which FeeStructure to fetch.
     */
    where?: FeeStructureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeeStructures to fetch.
     */
    orderBy?: FeeStructureOrderByWithRelationInput | FeeStructureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeeStructures.
     */
    cursor?: FeeStructureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeeStructures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeeStructures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeeStructures.
     */
    distinct?: FeeStructureScalarFieldEnum | FeeStructureScalarFieldEnum[]
  }

  /**
   * FeeStructure findMany
   */
  export type FeeStructureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeStructure
     */
    select?: FeeStructureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeStructure
     */
    omit?: FeeStructureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeStructureInclude<ExtArgs> | null
    /**
     * Filter, which FeeStructures to fetch.
     */
    where?: FeeStructureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeeStructures to fetch.
     */
    orderBy?: FeeStructureOrderByWithRelationInput | FeeStructureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FeeStructures.
     */
    cursor?: FeeStructureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeeStructures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeeStructures.
     */
    skip?: number
    distinct?: FeeStructureScalarFieldEnum | FeeStructureScalarFieldEnum[]
  }

  /**
   * FeeStructure create
   */
  export type FeeStructureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeStructure
     */
    select?: FeeStructureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeStructure
     */
    omit?: FeeStructureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeStructureInclude<ExtArgs> | null
    /**
     * The data needed to create a FeeStructure.
     */
    data: XOR<FeeStructureCreateInput, FeeStructureUncheckedCreateInput>
  }

  /**
   * FeeStructure createMany
   */
  export type FeeStructureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FeeStructures.
     */
    data: FeeStructureCreateManyInput | FeeStructureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FeeStructure createManyAndReturn
   */
  export type FeeStructureCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeStructure
     */
    select?: FeeStructureSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FeeStructure
     */
    omit?: FeeStructureOmit<ExtArgs> | null
    /**
     * The data used to create many FeeStructures.
     */
    data: FeeStructureCreateManyInput | FeeStructureCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeStructureIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FeeStructure update
   */
  export type FeeStructureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeStructure
     */
    select?: FeeStructureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeStructure
     */
    omit?: FeeStructureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeStructureInclude<ExtArgs> | null
    /**
     * The data needed to update a FeeStructure.
     */
    data: XOR<FeeStructureUpdateInput, FeeStructureUncheckedUpdateInput>
    /**
     * Choose, which FeeStructure to update.
     */
    where: FeeStructureWhereUniqueInput
  }

  /**
   * FeeStructure updateMany
   */
  export type FeeStructureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FeeStructures.
     */
    data: XOR<FeeStructureUpdateManyMutationInput, FeeStructureUncheckedUpdateManyInput>
    /**
     * Filter which FeeStructures to update
     */
    where?: FeeStructureWhereInput
    /**
     * Limit how many FeeStructures to update.
     */
    limit?: number
  }

  /**
   * FeeStructure updateManyAndReturn
   */
  export type FeeStructureUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeStructure
     */
    select?: FeeStructureSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FeeStructure
     */
    omit?: FeeStructureOmit<ExtArgs> | null
    /**
     * The data used to update FeeStructures.
     */
    data: XOR<FeeStructureUpdateManyMutationInput, FeeStructureUncheckedUpdateManyInput>
    /**
     * Filter which FeeStructures to update
     */
    where?: FeeStructureWhereInput
    /**
     * Limit how many FeeStructures to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeStructureIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FeeStructure upsert
   */
  export type FeeStructureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeStructure
     */
    select?: FeeStructureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeStructure
     */
    omit?: FeeStructureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeStructureInclude<ExtArgs> | null
    /**
     * The filter to search for the FeeStructure to update in case it exists.
     */
    where: FeeStructureWhereUniqueInput
    /**
     * In case the FeeStructure found by the `where` argument doesn't exist, create a new FeeStructure with this data.
     */
    create: XOR<FeeStructureCreateInput, FeeStructureUncheckedCreateInput>
    /**
     * In case the FeeStructure was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeeStructureUpdateInput, FeeStructureUncheckedUpdateInput>
  }

  /**
   * FeeStructure delete
   */
  export type FeeStructureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeStructure
     */
    select?: FeeStructureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeStructure
     */
    omit?: FeeStructureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeStructureInclude<ExtArgs> | null
    /**
     * Filter which FeeStructure to delete.
     */
    where: FeeStructureWhereUniqueInput
  }

  /**
   * FeeStructure deleteMany
   */
  export type FeeStructureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeeStructures to delete
     */
    where?: FeeStructureWhereInput
    /**
     * Limit how many FeeStructures to delete.
     */
    limit?: number
  }

  /**
   * FeeStructure.installment
   */
  export type FeeStructure$installmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstallmentDetail
     */
    select?: InstallmentDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstallmentDetail
     */
    omit?: InstallmentDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallmentDetailInclude<ExtArgs> | null
    where?: InstallmentDetailWhereInput
  }

  /**
   * FeeStructure.studentFees
   */
  export type FeeStructure$studentFeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentFee
     */
    select?: StudentFeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentFee
     */
    omit?: StudentFeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentFeeInclude<ExtArgs> | null
    where?: StudentFeeWhereInput
    orderBy?: StudentFeeOrderByWithRelationInput | StudentFeeOrderByWithRelationInput[]
    cursor?: StudentFeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentFeeScalarFieldEnum | StudentFeeScalarFieldEnum[]
  }

  /**
   * FeeStructure without action
   */
  export type FeeStructureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeStructure
     */
    select?: FeeStructureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeStructure
     */
    omit?: FeeStructureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeStructureInclude<ExtArgs> | null
  }


  /**
   * Model StudentFeeLog
   */

  export type AggregateStudentFeeLog = {
    _count: StudentFeeLogCountAggregateOutputType | null
    _avg: StudentFeeLogAvgAggregateOutputType | null
    _sum: StudentFeeLogSumAggregateOutputType | null
    _min: StudentFeeLogMinAggregateOutputType | null
    _max: StudentFeeLogMaxAggregateOutputType | null
  }

  export type StudentFeeLogAvgAggregateOutputType = {
    id: number | null
    studentFeeId: number | null
    amountPaid: number | null
  }

  export type StudentFeeLogSumAggregateOutputType = {
    id: number | null
    studentFeeId: number | null
    amountPaid: number | null
  }

  export type StudentFeeLogMinAggregateOutputType = {
    id: number | null
    studentFeeId: number | null
    amountPaid: number | null
    paymentDate: Date | null
    paymentMode: $Enums.PaymentMode | null
    receiptNo: string | null
  }

  export type StudentFeeLogMaxAggregateOutputType = {
    id: number | null
    studentFeeId: number | null
    amountPaid: number | null
    paymentDate: Date | null
    paymentMode: $Enums.PaymentMode | null
    receiptNo: string | null
  }

  export type StudentFeeLogCountAggregateOutputType = {
    id: number
    studentFeeId: number
    amountPaid: number
    paymentDate: number
    paymentMode: number
    receiptNo: number
    _all: number
  }


  export type StudentFeeLogAvgAggregateInputType = {
    id?: true
    studentFeeId?: true
    amountPaid?: true
  }

  export type StudentFeeLogSumAggregateInputType = {
    id?: true
    studentFeeId?: true
    amountPaid?: true
  }

  export type StudentFeeLogMinAggregateInputType = {
    id?: true
    studentFeeId?: true
    amountPaid?: true
    paymentDate?: true
    paymentMode?: true
    receiptNo?: true
  }

  export type StudentFeeLogMaxAggregateInputType = {
    id?: true
    studentFeeId?: true
    amountPaid?: true
    paymentDate?: true
    paymentMode?: true
    receiptNo?: true
  }

  export type StudentFeeLogCountAggregateInputType = {
    id?: true
    studentFeeId?: true
    amountPaid?: true
    paymentDate?: true
    paymentMode?: true
    receiptNo?: true
    _all?: true
  }

  export type StudentFeeLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentFeeLog to aggregate.
     */
    where?: StudentFeeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentFeeLogs to fetch.
     */
    orderBy?: StudentFeeLogOrderByWithRelationInput | StudentFeeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentFeeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentFeeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentFeeLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentFeeLogs
    **/
    _count?: true | StudentFeeLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentFeeLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentFeeLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentFeeLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentFeeLogMaxAggregateInputType
  }

  export type GetStudentFeeLogAggregateType<T extends StudentFeeLogAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentFeeLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentFeeLog[P]>
      : GetScalarType<T[P], AggregateStudentFeeLog[P]>
  }




  export type StudentFeeLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentFeeLogWhereInput
    orderBy?: StudentFeeLogOrderByWithAggregationInput | StudentFeeLogOrderByWithAggregationInput[]
    by: StudentFeeLogScalarFieldEnum[] | StudentFeeLogScalarFieldEnum
    having?: StudentFeeLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentFeeLogCountAggregateInputType | true
    _avg?: StudentFeeLogAvgAggregateInputType
    _sum?: StudentFeeLogSumAggregateInputType
    _min?: StudentFeeLogMinAggregateInputType
    _max?: StudentFeeLogMaxAggregateInputType
  }

  export type StudentFeeLogGroupByOutputType = {
    id: number
    studentFeeId: number
    amountPaid: number
    paymentDate: Date
    paymentMode: $Enums.PaymentMode
    receiptNo: string
    _count: StudentFeeLogCountAggregateOutputType | null
    _avg: StudentFeeLogAvgAggregateOutputType | null
    _sum: StudentFeeLogSumAggregateOutputType | null
    _min: StudentFeeLogMinAggregateOutputType | null
    _max: StudentFeeLogMaxAggregateOutputType | null
  }

  type GetStudentFeeLogGroupByPayload<T extends StudentFeeLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentFeeLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentFeeLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentFeeLogGroupByOutputType[P]>
            : GetScalarType<T[P], StudentFeeLogGroupByOutputType[P]>
        }
      >
    >


  export type StudentFeeLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentFeeId?: boolean
    amountPaid?: boolean
    paymentDate?: boolean
    paymentMode?: boolean
    receiptNo?: boolean
    studentFee?: boolean | StudentFeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentFeeLog"]>

  export type StudentFeeLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentFeeId?: boolean
    amountPaid?: boolean
    paymentDate?: boolean
    paymentMode?: boolean
    receiptNo?: boolean
    studentFee?: boolean | StudentFeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentFeeLog"]>

  export type StudentFeeLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentFeeId?: boolean
    amountPaid?: boolean
    paymentDate?: boolean
    paymentMode?: boolean
    receiptNo?: boolean
    studentFee?: boolean | StudentFeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentFeeLog"]>

  export type StudentFeeLogSelectScalar = {
    id?: boolean
    studentFeeId?: boolean
    amountPaid?: boolean
    paymentDate?: boolean
    paymentMode?: boolean
    receiptNo?: boolean
  }

  export type StudentFeeLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentFeeId" | "amountPaid" | "paymentDate" | "paymentMode" | "receiptNo", ExtArgs["result"]["studentFeeLog"]>
  export type StudentFeeLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    studentFee?: boolean | StudentFeeDefaultArgs<ExtArgs>
  }
  export type StudentFeeLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    studentFee?: boolean | StudentFeeDefaultArgs<ExtArgs>
  }
  export type StudentFeeLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    studentFee?: boolean | StudentFeeDefaultArgs<ExtArgs>
  }

  export type $StudentFeeLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentFeeLog"
    objects: {
      studentFee: Prisma.$StudentFeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      studentFeeId: number
      amountPaid: number
      paymentDate: Date
      paymentMode: $Enums.PaymentMode
      receiptNo: string
    }, ExtArgs["result"]["studentFeeLog"]>
    composites: {}
  }

  type StudentFeeLogGetPayload<S extends boolean | null | undefined | StudentFeeLogDefaultArgs> = $Result.GetResult<Prisma.$StudentFeeLogPayload, S>

  type StudentFeeLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudentFeeLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentFeeLogCountAggregateInputType | true
    }

  export interface StudentFeeLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentFeeLog'], meta: { name: 'StudentFeeLog' } }
    /**
     * Find zero or one StudentFeeLog that matches the filter.
     * @param {StudentFeeLogFindUniqueArgs} args - Arguments to find a StudentFeeLog
     * @example
     * // Get one StudentFeeLog
     * const studentFeeLog = await prisma.studentFeeLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentFeeLogFindUniqueArgs>(args: SelectSubset<T, StudentFeeLogFindUniqueArgs<ExtArgs>>): Prisma__StudentFeeLogClient<$Result.GetResult<Prisma.$StudentFeeLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StudentFeeLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudentFeeLogFindUniqueOrThrowArgs} args - Arguments to find a StudentFeeLog
     * @example
     * // Get one StudentFeeLog
     * const studentFeeLog = await prisma.studentFeeLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentFeeLogFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentFeeLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentFeeLogClient<$Result.GetResult<Prisma.$StudentFeeLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentFeeLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFeeLogFindFirstArgs} args - Arguments to find a StudentFeeLog
     * @example
     * // Get one StudentFeeLog
     * const studentFeeLog = await prisma.studentFeeLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentFeeLogFindFirstArgs>(args?: SelectSubset<T, StudentFeeLogFindFirstArgs<ExtArgs>>): Prisma__StudentFeeLogClient<$Result.GetResult<Prisma.$StudentFeeLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentFeeLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFeeLogFindFirstOrThrowArgs} args - Arguments to find a StudentFeeLog
     * @example
     * // Get one StudentFeeLog
     * const studentFeeLog = await prisma.studentFeeLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentFeeLogFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentFeeLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentFeeLogClient<$Result.GetResult<Prisma.$StudentFeeLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StudentFeeLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFeeLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentFeeLogs
     * const studentFeeLogs = await prisma.studentFeeLog.findMany()
     * 
     * // Get first 10 StudentFeeLogs
     * const studentFeeLogs = await prisma.studentFeeLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentFeeLogWithIdOnly = await prisma.studentFeeLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentFeeLogFindManyArgs>(args?: SelectSubset<T, StudentFeeLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentFeeLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StudentFeeLog.
     * @param {StudentFeeLogCreateArgs} args - Arguments to create a StudentFeeLog.
     * @example
     * // Create one StudentFeeLog
     * const StudentFeeLog = await prisma.studentFeeLog.create({
     *   data: {
     *     // ... data to create a StudentFeeLog
     *   }
     * })
     * 
     */
    create<T extends StudentFeeLogCreateArgs>(args: SelectSubset<T, StudentFeeLogCreateArgs<ExtArgs>>): Prisma__StudentFeeLogClient<$Result.GetResult<Prisma.$StudentFeeLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StudentFeeLogs.
     * @param {StudentFeeLogCreateManyArgs} args - Arguments to create many StudentFeeLogs.
     * @example
     * // Create many StudentFeeLogs
     * const studentFeeLog = await prisma.studentFeeLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentFeeLogCreateManyArgs>(args?: SelectSubset<T, StudentFeeLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StudentFeeLogs and returns the data saved in the database.
     * @param {StudentFeeLogCreateManyAndReturnArgs} args - Arguments to create many StudentFeeLogs.
     * @example
     * // Create many StudentFeeLogs
     * const studentFeeLog = await prisma.studentFeeLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StudentFeeLogs and only return the `id`
     * const studentFeeLogWithIdOnly = await prisma.studentFeeLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentFeeLogCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentFeeLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentFeeLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StudentFeeLog.
     * @param {StudentFeeLogDeleteArgs} args - Arguments to delete one StudentFeeLog.
     * @example
     * // Delete one StudentFeeLog
     * const StudentFeeLog = await prisma.studentFeeLog.delete({
     *   where: {
     *     // ... filter to delete one StudentFeeLog
     *   }
     * })
     * 
     */
    delete<T extends StudentFeeLogDeleteArgs>(args: SelectSubset<T, StudentFeeLogDeleteArgs<ExtArgs>>): Prisma__StudentFeeLogClient<$Result.GetResult<Prisma.$StudentFeeLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StudentFeeLog.
     * @param {StudentFeeLogUpdateArgs} args - Arguments to update one StudentFeeLog.
     * @example
     * // Update one StudentFeeLog
     * const studentFeeLog = await prisma.studentFeeLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentFeeLogUpdateArgs>(args: SelectSubset<T, StudentFeeLogUpdateArgs<ExtArgs>>): Prisma__StudentFeeLogClient<$Result.GetResult<Prisma.$StudentFeeLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StudentFeeLogs.
     * @param {StudentFeeLogDeleteManyArgs} args - Arguments to filter StudentFeeLogs to delete.
     * @example
     * // Delete a few StudentFeeLogs
     * const { count } = await prisma.studentFeeLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentFeeLogDeleteManyArgs>(args?: SelectSubset<T, StudentFeeLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentFeeLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFeeLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentFeeLogs
     * const studentFeeLog = await prisma.studentFeeLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentFeeLogUpdateManyArgs>(args: SelectSubset<T, StudentFeeLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentFeeLogs and returns the data updated in the database.
     * @param {StudentFeeLogUpdateManyAndReturnArgs} args - Arguments to update many StudentFeeLogs.
     * @example
     * // Update many StudentFeeLogs
     * const studentFeeLog = await prisma.studentFeeLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StudentFeeLogs and only return the `id`
     * const studentFeeLogWithIdOnly = await prisma.studentFeeLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StudentFeeLogUpdateManyAndReturnArgs>(args: SelectSubset<T, StudentFeeLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentFeeLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StudentFeeLog.
     * @param {StudentFeeLogUpsertArgs} args - Arguments to update or create a StudentFeeLog.
     * @example
     * // Update or create a StudentFeeLog
     * const studentFeeLog = await prisma.studentFeeLog.upsert({
     *   create: {
     *     // ... data to create a StudentFeeLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentFeeLog we want to update
     *   }
     * })
     */
    upsert<T extends StudentFeeLogUpsertArgs>(args: SelectSubset<T, StudentFeeLogUpsertArgs<ExtArgs>>): Prisma__StudentFeeLogClient<$Result.GetResult<Prisma.$StudentFeeLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StudentFeeLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFeeLogCountArgs} args - Arguments to filter StudentFeeLogs to count.
     * @example
     * // Count the number of StudentFeeLogs
     * const count = await prisma.studentFeeLog.count({
     *   where: {
     *     // ... the filter for the StudentFeeLogs we want to count
     *   }
     * })
    **/
    count<T extends StudentFeeLogCountArgs>(
      args?: Subset<T, StudentFeeLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentFeeLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentFeeLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFeeLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentFeeLogAggregateArgs>(args: Subset<T, StudentFeeLogAggregateArgs>): Prisma.PrismaPromise<GetStudentFeeLogAggregateType<T>>

    /**
     * Group by StudentFeeLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFeeLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentFeeLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentFeeLogGroupByArgs['orderBy'] }
        : { orderBy?: StudentFeeLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentFeeLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentFeeLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentFeeLog model
   */
  readonly fields: StudentFeeLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentFeeLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentFeeLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    studentFee<T extends StudentFeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentFeeDefaultArgs<ExtArgs>>): Prisma__StudentFeeClient<$Result.GetResult<Prisma.$StudentFeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudentFeeLog model
   */
  interface StudentFeeLogFieldRefs {
    readonly id: FieldRef<"StudentFeeLog", 'Int'>
    readonly studentFeeId: FieldRef<"StudentFeeLog", 'Int'>
    readonly amountPaid: FieldRef<"StudentFeeLog", 'Float'>
    readonly paymentDate: FieldRef<"StudentFeeLog", 'DateTime'>
    readonly paymentMode: FieldRef<"StudentFeeLog", 'PaymentMode'>
    readonly receiptNo: FieldRef<"StudentFeeLog", 'String'>
  }
    

  // Custom InputTypes
  /**
   * StudentFeeLog findUnique
   */
  export type StudentFeeLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentFeeLog
     */
    select?: StudentFeeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentFeeLog
     */
    omit?: StudentFeeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentFeeLogInclude<ExtArgs> | null
    /**
     * Filter, which StudentFeeLog to fetch.
     */
    where: StudentFeeLogWhereUniqueInput
  }

  /**
   * StudentFeeLog findUniqueOrThrow
   */
  export type StudentFeeLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentFeeLog
     */
    select?: StudentFeeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentFeeLog
     */
    omit?: StudentFeeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentFeeLogInclude<ExtArgs> | null
    /**
     * Filter, which StudentFeeLog to fetch.
     */
    where: StudentFeeLogWhereUniqueInput
  }

  /**
   * StudentFeeLog findFirst
   */
  export type StudentFeeLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentFeeLog
     */
    select?: StudentFeeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentFeeLog
     */
    omit?: StudentFeeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentFeeLogInclude<ExtArgs> | null
    /**
     * Filter, which StudentFeeLog to fetch.
     */
    where?: StudentFeeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentFeeLogs to fetch.
     */
    orderBy?: StudentFeeLogOrderByWithRelationInput | StudentFeeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentFeeLogs.
     */
    cursor?: StudentFeeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentFeeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentFeeLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentFeeLogs.
     */
    distinct?: StudentFeeLogScalarFieldEnum | StudentFeeLogScalarFieldEnum[]
  }

  /**
   * StudentFeeLog findFirstOrThrow
   */
  export type StudentFeeLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentFeeLog
     */
    select?: StudentFeeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentFeeLog
     */
    omit?: StudentFeeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentFeeLogInclude<ExtArgs> | null
    /**
     * Filter, which StudentFeeLog to fetch.
     */
    where?: StudentFeeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentFeeLogs to fetch.
     */
    orderBy?: StudentFeeLogOrderByWithRelationInput | StudentFeeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentFeeLogs.
     */
    cursor?: StudentFeeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentFeeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentFeeLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentFeeLogs.
     */
    distinct?: StudentFeeLogScalarFieldEnum | StudentFeeLogScalarFieldEnum[]
  }

  /**
   * StudentFeeLog findMany
   */
  export type StudentFeeLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentFeeLog
     */
    select?: StudentFeeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentFeeLog
     */
    omit?: StudentFeeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentFeeLogInclude<ExtArgs> | null
    /**
     * Filter, which StudentFeeLogs to fetch.
     */
    where?: StudentFeeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentFeeLogs to fetch.
     */
    orderBy?: StudentFeeLogOrderByWithRelationInput | StudentFeeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentFeeLogs.
     */
    cursor?: StudentFeeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentFeeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentFeeLogs.
     */
    skip?: number
    distinct?: StudentFeeLogScalarFieldEnum | StudentFeeLogScalarFieldEnum[]
  }

  /**
   * StudentFeeLog create
   */
  export type StudentFeeLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentFeeLog
     */
    select?: StudentFeeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentFeeLog
     */
    omit?: StudentFeeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentFeeLogInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentFeeLog.
     */
    data: XOR<StudentFeeLogCreateInput, StudentFeeLogUncheckedCreateInput>
  }

  /**
   * StudentFeeLog createMany
   */
  export type StudentFeeLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentFeeLogs.
     */
    data: StudentFeeLogCreateManyInput | StudentFeeLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StudentFeeLog createManyAndReturn
   */
  export type StudentFeeLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentFeeLog
     */
    select?: StudentFeeLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StudentFeeLog
     */
    omit?: StudentFeeLogOmit<ExtArgs> | null
    /**
     * The data used to create many StudentFeeLogs.
     */
    data: StudentFeeLogCreateManyInput | StudentFeeLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentFeeLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentFeeLog update
   */
  export type StudentFeeLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentFeeLog
     */
    select?: StudentFeeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentFeeLog
     */
    omit?: StudentFeeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentFeeLogInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentFeeLog.
     */
    data: XOR<StudentFeeLogUpdateInput, StudentFeeLogUncheckedUpdateInput>
    /**
     * Choose, which StudentFeeLog to update.
     */
    where: StudentFeeLogWhereUniqueInput
  }

  /**
   * StudentFeeLog updateMany
   */
  export type StudentFeeLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentFeeLogs.
     */
    data: XOR<StudentFeeLogUpdateManyMutationInput, StudentFeeLogUncheckedUpdateManyInput>
    /**
     * Filter which StudentFeeLogs to update
     */
    where?: StudentFeeLogWhereInput
    /**
     * Limit how many StudentFeeLogs to update.
     */
    limit?: number
  }

  /**
   * StudentFeeLog updateManyAndReturn
   */
  export type StudentFeeLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentFeeLog
     */
    select?: StudentFeeLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StudentFeeLog
     */
    omit?: StudentFeeLogOmit<ExtArgs> | null
    /**
     * The data used to update StudentFeeLogs.
     */
    data: XOR<StudentFeeLogUpdateManyMutationInput, StudentFeeLogUncheckedUpdateManyInput>
    /**
     * Filter which StudentFeeLogs to update
     */
    where?: StudentFeeLogWhereInput
    /**
     * Limit how many StudentFeeLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentFeeLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentFeeLog upsert
   */
  export type StudentFeeLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentFeeLog
     */
    select?: StudentFeeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentFeeLog
     */
    omit?: StudentFeeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentFeeLogInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentFeeLog to update in case it exists.
     */
    where: StudentFeeLogWhereUniqueInput
    /**
     * In case the StudentFeeLog found by the `where` argument doesn't exist, create a new StudentFeeLog with this data.
     */
    create: XOR<StudentFeeLogCreateInput, StudentFeeLogUncheckedCreateInput>
    /**
     * In case the StudentFeeLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentFeeLogUpdateInput, StudentFeeLogUncheckedUpdateInput>
  }

  /**
   * StudentFeeLog delete
   */
  export type StudentFeeLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentFeeLog
     */
    select?: StudentFeeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentFeeLog
     */
    omit?: StudentFeeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentFeeLogInclude<ExtArgs> | null
    /**
     * Filter which StudentFeeLog to delete.
     */
    where: StudentFeeLogWhereUniqueInput
  }

  /**
   * StudentFeeLog deleteMany
   */
  export type StudentFeeLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentFeeLogs to delete
     */
    where?: StudentFeeLogWhereInput
    /**
     * Limit how many StudentFeeLogs to delete.
     */
    limit?: number
  }

  /**
   * StudentFeeLog without action
   */
  export type StudentFeeLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentFeeLog
     */
    select?: StudentFeeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentFeeLog
     */
    omit?: StudentFeeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentFeeLogInclude<ExtArgs> | null
  }


  /**
   * Model StudentFee
   */

  export type AggregateStudentFee = {
    _count: StudentFeeCountAggregateOutputType | null
    _avg: StudentFeeAvgAggregateOutputType | null
    _sum: StudentFeeSumAggregateOutputType | null
    _min: StudentFeeMinAggregateOutputType | null
    _max: StudentFeeMaxAggregateOutputType | null
  }

  export type StudentFeeAvgAggregateOutputType = {
    id: number | null
    studentId: number | null
    courseId: number | null
    amountDue: number | null
    amountPaid: number | null
  }

  export type StudentFeeSumAggregateOutputType = {
    id: number | null
    studentId: number | null
    courseId: number | null
    amountDue: number | null
    amountPaid: number | null
  }

  export type StudentFeeMinAggregateOutputType = {
    id: number | null
    studentId: number | null
    courseId: number | null
    dueDate: Date | null
    amountDue: number | null
    amountPaid: number | null
    paymentDate: Date | null
    paymentMode: $Enums.PaymentMode | null
    receiptNo: string | null
    paymentStatus: $Enums.PaymentStatus | null
    clientAdminId: string | null
  }

  export type StudentFeeMaxAggregateOutputType = {
    id: number | null
    studentId: number | null
    courseId: number | null
    dueDate: Date | null
    amountDue: number | null
    amountPaid: number | null
    paymentDate: Date | null
    paymentMode: $Enums.PaymentMode | null
    receiptNo: string | null
    paymentStatus: $Enums.PaymentStatus | null
    clientAdminId: string | null
  }

  export type StudentFeeCountAggregateOutputType = {
    id: number
    studentId: number
    courseId: number
    dueDate: number
    amountDue: number
    amountPaid: number
    paymentDate: number
    paymentMode: number
    receiptNo: number
    paymentStatus: number
    clientAdminId: number
    _all: number
  }


  export type StudentFeeAvgAggregateInputType = {
    id?: true
    studentId?: true
    courseId?: true
    amountDue?: true
    amountPaid?: true
  }

  export type StudentFeeSumAggregateInputType = {
    id?: true
    studentId?: true
    courseId?: true
    amountDue?: true
    amountPaid?: true
  }

  export type StudentFeeMinAggregateInputType = {
    id?: true
    studentId?: true
    courseId?: true
    dueDate?: true
    amountDue?: true
    amountPaid?: true
    paymentDate?: true
    paymentMode?: true
    receiptNo?: true
    paymentStatus?: true
    clientAdminId?: true
  }

  export type StudentFeeMaxAggregateInputType = {
    id?: true
    studentId?: true
    courseId?: true
    dueDate?: true
    amountDue?: true
    amountPaid?: true
    paymentDate?: true
    paymentMode?: true
    receiptNo?: true
    paymentStatus?: true
    clientAdminId?: true
  }

  export type StudentFeeCountAggregateInputType = {
    id?: true
    studentId?: true
    courseId?: true
    dueDate?: true
    amountDue?: true
    amountPaid?: true
    paymentDate?: true
    paymentMode?: true
    receiptNo?: true
    paymentStatus?: true
    clientAdminId?: true
    _all?: true
  }

  export type StudentFeeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentFee to aggregate.
     */
    where?: StudentFeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentFees to fetch.
     */
    orderBy?: StudentFeeOrderByWithRelationInput | StudentFeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentFeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentFees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentFees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentFees
    **/
    _count?: true | StudentFeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentFeeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentFeeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentFeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentFeeMaxAggregateInputType
  }

  export type GetStudentFeeAggregateType<T extends StudentFeeAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentFee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentFee[P]>
      : GetScalarType<T[P], AggregateStudentFee[P]>
  }




  export type StudentFeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentFeeWhereInput
    orderBy?: StudentFeeOrderByWithAggregationInput | StudentFeeOrderByWithAggregationInput[]
    by: StudentFeeScalarFieldEnum[] | StudentFeeScalarFieldEnum
    having?: StudentFeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentFeeCountAggregateInputType | true
    _avg?: StudentFeeAvgAggregateInputType
    _sum?: StudentFeeSumAggregateInputType
    _min?: StudentFeeMinAggregateInputType
    _max?: StudentFeeMaxAggregateInputType
  }

  export type StudentFeeGroupByOutputType = {
    id: number
    studentId: number
    courseId: number
    dueDate: Date
    amountDue: number
    amountPaid: number
    paymentDate: Date | null
    paymentMode: $Enums.PaymentMode
    receiptNo: string
    paymentStatus: $Enums.PaymentStatus
    clientAdminId: string
    _count: StudentFeeCountAggregateOutputType | null
    _avg: StudentFeeAvgAggregateOutputType | null
    _sum: StudentFeeSumAggregateOutputType | null
    _min: StudentFeeMinAggregateOutputType | null
    _max: StudentFeeMaxAggregateOutputType | null
  }

  type GetStudentFeeGroupByPayload<T extends StudentFeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentFeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentFeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentFeeGroupByOutputType[P]>
            : GetScalarType<T[P], StudentFeeGroupByOutputType[P]>
        }
      >
    >


  export type StudentFeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    courseId?: boolean
    dueDate?: boolean
    amountDue?: boolean
    amountPaid?: boolean
    paymentDate?: boolean
    paymentMode?: boolean
    receiptNo?: boolean
    paymentStatus?: boolean
    clientAdminId?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    feeLogs?: boolean | StudentFee$feeLogsArgs<ExtArgs>
    feeStructure?: boolean | StudentFee$feeStructureArgs<ExtArgs>
    notification?: boolean | StudentFee$notificationArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
    _count?: boolean | StudentFeeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentFee"]>

  export type StudentFeeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    courseId?: boolean
    dueDate?: boolean
    amountDue?: boolean
    amountPaid?: boolean
    paymentDate?: boolean
    paymentMode?: boolean
    receiptNo?: boolean
    paymentStatus?: boolean
    clientAdminId?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    feeStructure?: boolean | StudentFee$feeStructureArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentFee"]>

  export type StudentFeeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    courseId?: boolean
    dueDate?: boolean
    amountDue?: boolean
    amountPaid?: boolean
    paymentDate?: boolean
    paymentMode?: boolean
    receiptNo?: boolean
    paymentStatus?: boolean
    clientAdminId?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    feeStructure?: boolean | StudentFee$feeStructureArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentFee"]>

  export type StudentFeeSelectScalar = {
    id?: boolean
    studentId?: boolean
    courseId?: boolean
    dueDate?: boolean
    amountDue?: boolean
    amountPaid?: boolean
    paymentDate?: boolean
    paymentMode?: boolean
    receiptNo?: boolean
    paymentStatus?: boolean
    clientAdminId?: boolean
  }

  export type StudentFeeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "courseId" | "dueDate" | "amountDue" | "amountPaid" | "paymentDate" | "paymentMode" | "receiptNo" | "paymentStatus" | "clientAdminId", ExtArgs["result"]["studentFee"]>
  export type StudentFeeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    feeLogs?: boolean | StudentFee$feeLogsArgs<ExtArgs>
    feeStructure?: boolean | StudentFee$feeStructureArgs<ExtArgs>
    notification?: boolean | StudentFee$notificationArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
    _count?: boolean | StudentFeeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StudentFeeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    feeStructure?: boolean | StudentFee$feeStructureArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }
  export type StudentFeeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    feeStructure?: boolean | StudentFee$feeStructureArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }

  export type $StudentFeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentFee"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      course: Prisma.$CoursePayload<ExtArgs>
      feeLogs: Prisma.$StudentFeeLogPayload<ExtArgs>[]
      feeStructure: Prisma.$FeeStructurePayload<ExtArgs> | null
      notification: Prisma.$NotificationPayload<ExtArgs> | null
      clientAdmin: Prisma.$ClientAdminPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      studentId: number
      courseId: number
      dueDate: Date
      amountDue: number
      amountPaid: number
      paymentDate: Date | null
      paymentMode: $Enums.PaymentMode
      receiptNo: string
      paymentStatus: $Enums.PaymentStatus
      clientAdminId: string
    }, ExtArgs["result"]["studentFee"]>
    composites: {}
  }

  type StudentFeeGetPayload<S extends boolean | null | undefined | StudentFeeDefaultArgs> = $Result.GetResult<Prisma.$StudentFeePayload, S>

  type StudentFeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudentFeeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentFeeCountAggregateInputType | true
    }

  export interface StudentFeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentFee'], meta: { name: 'StudentFee' } }
    /**
     * Find zero or one StudentFee that matches the filter.
     * @param {StudentFeeFindUniqueArgs} args - Arguments to find a StudentFee
     * @example
     * // Get one StudentFee
     * const studentFee = await prisma.studentFee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentFeeFindUniqueArgs>(args: SelectSubset<T, StudentFeeFindUniqueArgs<ExtArgs>>): Prisma__StudentFeeClient<$Result.GetResult<Prisma.$StudentFeePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StudentFee that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudentFeeFindUniqueOrThrowArgs} args - Arguments to find a StudentFee
     * @example
     * // Get one StudentFee
     * const studentFee = await prisma.studentFee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentFeeFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentFeeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentFeeClient<$Result.GetResult<Prisma.$StudentFeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentFee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFeeFindFirstArgs} args - Arguments to find a StudentFee
     * @example
     * // Get one StudentFee
     * const studentFee = await prisma.studentFee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentFeeFindFirstArgs>(args?: SelectSubset<T, StudentFeeFindFirstArgs<ExtArgs>>): Prisma__StudentFeeClient<$Result.GetResult<Prisma.$StudentFeePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentFee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFeeFindFirstOrThrowArgs} args - Arguments to find a StudentFee
     * @example
     * // Get one StudentFee
     * const studentFee = await prisma.studentFee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentFeeFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentFeeFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentFeeClient<$Result.GetResult<Prisma.$StudentFeePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StudentFees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFeeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentFees
     * const studentFees = await prisma.studentFee.findMany()
     * 
     * // Get first 10 StudentFees
     * const studentFees = await prisma.studentFee.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentFeeWithIdOnly = await prisma.studentFee.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentFeeFindManyArgs>(args?: SelectSubset<T, StudentFeeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentFeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StudentFee.
     * @param {StudentFeeCreateArgs} args - Arguments to create a StudentFee.
     * @example
     * // Create one StudentFee
     * const StudentFee = await prisma.studentFee.create({
     *   data: {
     *     // ... data to create a StudentFee
     *   }
     * })
     * 
     */
    create<T extends StudentFeeCreateArgs>(args: SelectSubset<T, StudentFeeCreateArgs<ExtArgs>>): Prisma__StudentFeeClient<$Result.GetResult<Prisma.$StudentFeePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StudentFees.
     * @param {StudentFeeCreateManyArgs} args - Arguments to create many StudentFees.
     * @example
     * // Create many StudentFees
     * const studentFee = await prisma.studentFee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentFeeCreateManyArgs>(args?: SelectSubset<T, StudentFeeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StudentFees and returns the data saved in the database.
     * @param {StudentFeeCreateManyAndReturnArgs} args - Arguments to create many StudentFees.
     * @example
     * // Create many StudentFees
     * const studentFee = await prisma.studentFee.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StudentFees and only return the `id`
     * const studentFeeWithIdOnly = await prisma.studentFee.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentFeeCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentFeeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentFeePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StudentFee.
     * @param {StudentFeeDeleteArgs} args - Arguments to delete one StudentFee.
     * @example
     * // Delete one StudentFee
     * const StudentFee = await prisma.studentFee.delete({
     *   where: {
     *     // ... filter to delete one StudentFee
     *   }
     * })
     * 
     */
    delete<T extends StudentFeeDeleteArgs>(args: SelectSubset<T, StudentFeeDeleteArgs<ExtArgs>>): Prisma__StudentFeeClient<$Result.GetResult<Prisma.$StudentFeePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StudentFee.
     * @param {StudentFeeUpdateArgs} args - Arguments to update one StudentFee.
     * @example
     * // Update one StudentFee
     * const studentFee = await prisma.studentFee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentFeeUpdateArgs>(args: SelectSubset<T, StudentFeeUpdateArgs<ExtArgs>>): Prisma__StudentFeeClient<$Result.GetResult<Prisma.$StudentFeePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StudentFees.
     * @param {StudentFeeDeleteManyArgs} args - Arguments to filter StudentFees to delete.
     * @example
     * // Delete a few StudentFees
     * const { count } = await prisma.studentFee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentFeeDeleteManyArgs>(args?: SelectSubset<T, StudentFeeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentFees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentFees
     * const studentFee = await prisma.studentFee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentFeeUpdateManyArgs>(args: SelectSubset<T, StudentFeeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentFees and returns the data updated in the database.
     * @param {StudentFeeUpdateManyAndReturnArgs} args - Arguments to update many StudentFees.
     * @example
     * // Update many StudentFees
     * const studentFee = await prisma.studentFee.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StudentFees and only return the `id`
     * const studentFeeWithIdOnly = await prisma.studentFee.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StudentFeeUpdateManyAndReturnArgs>(args: SelectSubset<T, StudentFeeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentFeePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StudentFee.
     * @param {StudentFeeUpsertArgs} args - Arguments to update or create a StudentFee.
     * @example
     * // Update or create a StudentFee
     * const studentFee = await prisma.studentFee.upsert({
     *   create: {
     *     // ... data to create a StudentFee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentFee we want to update
     *   }
     * })
     */
    upsert<T extends StudentFeeUpsertArgs>(args: SelectSubset<T, StudentFeeUpsertArgs<ExtArgs>>): Prisma__StudentFeeClient<$Result.GetResult<Prisma.$StudentFeePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StudentFees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFeeCountArgs} args - Arguments to filter StudentFees to count.
     * @example
     * // Count the number of StudentFees
     * const count = await prisma.studentFee.count({
     *   where: {
     *     // ... the filter for the StudentFees we want to count
     *   }
     * })
    **/
    count<T extends StudentFeeCountArgs>(
      args?: Subset<T, StudentFeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentFeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentFee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentFeeAggregateArgs>(args: Subset<T, StudentFeeAggregateArgs>): Prisma.PrismaPromise<GetStudentFeeAggregateType<T>>

    /**
     * Group by StudentFee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentFeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentFeeGroupByArgs['orderBy'] }
        : { orderBy?: StudentFeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentFeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentFeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentFee model
   */
  readonly fields: StudentFeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentFee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentFeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    feeLogs<T extends StudentFee$feeLogsArgs<ExtArgs> = {}>(args?: Subset<T, StudentFee$feeLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentFeeLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    feeStructure<T extends StudentFee$feeStructureArgs<ExtArgs> = {}>(args?: Subset<T, StudentFee$feeStructureArgs<ExtArgs>>): Prisma__FeeStructureClient<$Result.GetResult<Prisma.$FeeStructurePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    notification<T extends StudentFee$notificationArgs<ExtArgs> = {}>(args?: Subset<T, StudentFee$notificationArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    clientAdmin<T extends ClientAdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientAdminDefaultArgs<ExtArgs>>): Prisma__ClientAdminClient<$Result.GetResult<Prisma.$ClientAdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudentFee model
   */
  interface StudentFeeFieldRefs {
    readonly id: FieldRef<"StudentFee", 'Int'>
    readonly studentId: FieldRef<"StudentFee", 'Int'>
    readonly courseId: FieldRef<"StudentFee", 'Int'>
    readonly dueDate: FieldRef<"StudentFee", 'DateTime'>
    readonly amountDue: FieldRef<"StudentFee", 'Float'>
    readonly amountPaid: FieldRef<"StudentFee", 'Float'>
    readonly paymentDate: FieldRef<"StudentFee", 'DateTime'>
    readonly paymentMode: FieldRef<"StudentFee", 'PaymentMode'>
    readonly receiptNo: FieldRef<"StudentFee", 'String'>
    readonly paymentStatus: FieldRef<"StudentFee", 'PaymentStatus'>
    readonly clientAdminId: FieldRef<"StudentFee", 'String'>
  }
    

  // Custom InputTypes
  /**
   * StudentFee findUnique
   */
  export type StudentFeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentFee
     */
    select?: StudentFeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentFee
     */
    omit?: StudentFeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentFeeInclude<ExtArgs> | null
    /**
     * Filter, which StudentFee to fetch.
     */
    where: StudentFeeWhereUniqueInput
  }

  /**
   * StudentFee findUniqueOrThrow
   */
  export type StudentFeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentFee
     */
    select?: StudentFeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentFee
     */
    omit?: StudentFeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentFeeInclude<ExtArgs> | null
    /**
     * Filter, which StudentFee to fetch.
     */
    where: StudentFeeWhereUniqueInput
  }

  /**
   * StudentFee findFirst
   */
  export type StudentFeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentFee
     */
    select?: StudentFeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentFee
     */
    omit?: StudentFeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentFeeInclude<ExtArgs> | null
    /**
     * Filter, which StudentFee to fetch.
     */
    where?: StudentFeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentFees to fetch.
     */
    orderBy?: StudentFeeOrderByWithRelationInput | StudentFeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentFees.
     */
    cursor?: StudentFeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentFees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentFees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentFees.
     */
    distinct?: StudentFeeScalarFieldEnum | StudentFeeScalarFieldEnum[]
  }

  /**
   * StudentFee findFirstOrThrow
   */
  export type StudentFeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentFee
     */
    select?: StudentFeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentFee
     */
    omit?: StudentFeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentFeeInclude<ExtArgs> | null
    /**
     * Filter, which StudentFee to fetch.
     */
    where?: StudentFeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentFees to fetch.
     */
    orderBy?: StudentFeeOrderByWithRelationInput | StudentFeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentFees.
     */
    cursor?: StudentFeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentFees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentFees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentFees.
     */
    distinct?: StudentFeeScalarFieldEnum | StudentFeeScalarFieldEnum[]
  }

  /**
   * StudentFee findMany
   */
  export type StudentFeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentFee
     */
    select?: StudentFeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentFee
     */
    omit?: StudentFeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentFeeInclude<ExtArgs> | null
    /**
     * Filter, which StudentFees to fetch.
     */
    where?: StudentFeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentFees to fetch.
     */
    orderBy?: StudentFeeOrderByWithRelationInput | StudentFeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentFees.
     */
    cursor?: StudentFeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentFees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentFees.
     */
    skip?: number
    distinct?: StudentFeeScalarFieldEnum | StudentFeeScalarFieldEnum[]
  }

  /**
   * StudentFee create
   */
  export type StudentFeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentFee
     */
    select?: StudentFeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentFee
     */
    omit?: StudentFeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentFeeInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentFee.
     */
    data: XOR<StudentFeeCreateInput, StudentFeeUncheckedCreateInput>
  }

  /**
   * StudentFee createMany
   */
  export type StudentFeeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentFees.
     */
    data: StudentFeeCreateManyInput | StudentFeeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StudentFee createManyAndReturn
   */
  export type StudentFeeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentFee
     */
    select?: StudentFeeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StudentFee
     */
    omit?: StudentFeeOmit<ExtArgs> | null
    /**
     * The data used to create many StudentFees.
     */
    data: StudentFeeCreateManyInput | StudentFeeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentFeeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentFee update
   */
  export type StudentFeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentFee
     */
    select?: StudentFeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentFee
     */
    omit?: StudentFeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentFeeInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentFee.
     */
    data: XOR<StudentFeeUpdateInput, StudentFeeUncheckedUpdateInput>
    /**
     * Choose, which StudentFee to update.
     */
    where: StudentFeeWhereUniqueInput
  }

  /**
   * StudentFee updateMany
   */
  export type StudentFeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentFees.
     */
    data: XOR<StudentFeeUpdateManyMutationInput, StudentFeeUncheckedUpdateManyInput>
    /**
     * Filter which StudentFees to update
     */
    where?: StudentFeeWhereInput
    /**
     * Limit how many StudentFees to update.
     */
    limit?: number
  }

  /**
   * StudentFee updateManyAndReturn
   */
  export type StudentFeeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentFee
     */
    select?: StudentFeeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StudentFee
     */
    omit?: StudentFeeOmit<ExtArgs> | null
    /**
     * The data used to update StudentFees.
     */
    data: XOR<StudentFeeUpdateManyMutationInput, StudentFeeUncheckedUpdateManyInput>
    /**
     * Filter which StudentFees to update
     */
    where?: StudentFeeWhereInput
    /**
     * Limit how many StudentFees to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentFeeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentFee upsert
   */
  export type StudentFeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentFee
     */
    select?: StudentFeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentFee
     */
    omit?: StudentFeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentFeeInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentFee to update in case it exists.
     */
    where: StudentFeeWhereUniqueInput
    /**
     * In case the StudentFee found by the `where` argument doesn't exist, create a new StudentFee with this data.
     */
    create: XOR<StudentFeeCreateInput, StudentFeeUncheckedCreateInput>
    /**
     * In case the StudentFee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentFeeUpdateInput, StudentFeeUncheckedUpdateInput>
  }

  /**
   * StudentFee delete
   */
  export type StudentFeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentFee
     */
    select?: StudentFeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentFee
     */
    omit?: StudentFeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentFeeInclude<ExtArgs> | null
    /**
     * Filter which StudentFee to delete.
     */
    where: StudentFeeWhereUniqueInput
  }

  /**
   * StudentFee deleteMany
   */
  export type StudentFeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentFees to delete
     */
    where?: StudentFeeWhereInput
    /**
     * Limit how many StudentFees to delete.
     */
    limit?: number
  }

  /**
   * StudentFee.feeLogs
   */
  export type StudentFee$feeLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentFeeLog
     */
    select?: StudentFeeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentFeeLog
     */
    omit?: StudentFeeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentFeeLogInclude<ExtArgs> | null
    where?: StudentFeeLogWhereInput
    orderBy?: StudentFeeLogOrderByWithRelationInput | StudentFeeLogOrderByWithRelationInput[]
    cursor?: StudentFeeLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentFeeLogScalarFieldEnum | StudentFeeLogScalarFieldEnum[]
  }

  /**
   * StudentFee.feeStructure
   */
  export type StudentFee$feeStructureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeStructure
     */
    select?: FeeStructureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeStructure
     */
    omit?: FeeStructureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeStructureInclude<ExtArgs> | null
    where?: FeeStructureWhereInput
  }

  /**
   * StudentFee.notification
   */
  export type StudentFee$notificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
  }

  /**
   * StudentFee without action
   */
  export type StudentFeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentFee
     */
    select?: StudentFeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentFee
     */
    omit?: StudentFeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentFeeInclude<ExtArgs> | null
  }


  /**
   * Model StationeryItem
   */

  export type AggregateStationeryItem = {
    _count: StationeryItemCountAggregateOutputType | null
    _avg: StationeryItemAvgAggregateOutputType | null
    _sum: StationeryItemSumAggregateOutputType | null
    _min: StationeryItemMinAggregateOutputType | null
    _max: StationeryItemMaxAggregateOutputType | null
  }

  export type StationeryItemAvgAggregateOutputType = {
    id: number | null
    quantityAvailable: number | null
  }

  export type StationeryItemSumAggregateOutputType = {
    id: number | null
    quantityAvailable: number | null
  }

  export type StationeryItemMinAggregateOutputType = {
    id: number | null
    name: string | null
    quantityAvailable: number | null
  }

  export type StationeryItemMaxAggregateOutputType = {
    id: number | null
    name: string | null
    quantityAvailable: number | null
  }

  export type StationeryItemCountAggregateOutputType = {
    id: number
    name: number
    quantityAvailable: number
    _all: number
  }


  export type StationeryItemAvgAggregateInputType = {
    id?: true
    quantityAvailable?: true
  }

  export type StationeryItemSumAggregateInputType = {
    id?: true
    quantityAvailable?: true
  }

  export type StationeryItemMinAggregateInputType = {
    id?: true
    name?: true
    quantityAvailable?: true
  }

  export type StationeryItemMaxAggregateInputType = {
    id?: true
    name?: true
    quantityAvailable?: true
  }

  export type StationeryItemCountAggregateInputType = {
    id?: true
    name?: true
    quantityAvailable?: true
    _all?: true
  }

  export type StationeryItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StationeryItem to aggregate.
     */
    where?: StationeryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StationeryItems to fetch.
     */
    orderBy?: StationeryItemOrderByWithRelationInput | StationeryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StationeryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StationeryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StationeryItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StationeryItems
    **/
    _count?: true | StationeryItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StationeryItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StationeryItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StationeryItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StationeryItemMaxAggregateInputType
  }

  export type GetStationeryItemAggregateType<T extends StationeryItemAggregateArgs> = {
        [P in keyof T & keyof AggregateStationeryItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStationeryItem[P]>
      : GetScalarType<T[P], AggregateStationeryItem[P]>
  }




  export type StationeryItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StationeryItemWhereInput
    orderBy?: StationeryItemOrderByWithAggregationInput | StationeryItemOrderByWithAggregationInput[]
    by: StationeryItemScalarFieldEnum[] | StationeryItemScalarFieldEnum
    having?: StationeryItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StationeryItemCountAggregateInputType | true
    _avg?: StationeryItemAvgAggregateInputType
    _sum?: StationeryItemSumAggregateInputType
    _min?: StationeryItemMinAggregateInputType
    _max?: StationeryItemMaxAggregateInputType
  }

  export type StationeryItemGroupByOutputType = {
    id: number
    name: string
    quantityAvailable: number
    _count: StationeryItemCountAggregateOutputType | null
    _avg: StationeryItemAvgAggregateOutputType | null
    _sum: StationeryItemSumAggregateOutputType | null
    _min: StationeryItemMinAggregateOutputType | null
    _max: StationeryItemMaxAggregateOutputType | null
  }

  type GetStationeryItemGroupByPayload<T extends StationeryItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StationeryItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StationeryItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StationeryItemGroupByOutputType[P]>
            : GetScalarType<T[P], StationeryItemGroupByOutputType[P]>
        }
      >
    >


  export type StationeryItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    quantityAvailable?: boolean
    stationeryIssues?: boolean | StationeryItem$stationeryIssuesArgs<ExtArgs>
    _count?: boolean | StationeryItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stationeryItem"]>

  export type StationeryItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    quantityAvailable?: boolean
  }, ExtArgs["result"]["stationeryItem"]>

  export type StationeryItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    quantityAvailable?: boolean
  }, ExtArgs["result"]["stationeryItem"]>

  export type StationeryItemSelectScalar = {
    id?: boolean
    name?: boolean
    quantityAvailable?: boolean
  }

  export type StationeryItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "quantityAvailable", ExtArgs["result"]["stationeryItem"]>
  export type StationeryItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stationeryIssues?: boolean | StationeryItem$stationeryIssuesArgs<ExtArgs>
    _count?: boolean | StationeryItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StationeryItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type StationeryItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $StationeryItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StationeryItem"
    objects: {
      stationeryIssues: Prisma.$StationeryIssuePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      quantityAvailable: number
    }, ExtArgs["result"]["stationeryItem"]>
    composites: {}
  }

  type StationeryItemGetPayload<S extends boolean | null | undefined | StationeryItemDefaultArgs> = $Result.GetResult<Prisma.$StationeryItemPayload, S>

  type StationeryItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StationeryItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StationeryItemCountAggregateInputType | true
    }

  export interface StationeryItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StationeryItem'], meta: { name: 'StationeryItem' } }
    /**
     * Find zero or one StationeryItem that matches the filter.
     * @param {StationeryItemFindUniqueArgs} args - Arguments to find a StationeryItem
     * @example
     * // Get one StationeryItem
     * const stationeryItem = await prisma.stationeryItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StationeryItemFindUniqueArgs>(args: SelectSubset<T, StationeryItemFindUniqueArgs<ExtArgs>>): Prisma__StationeryItemClient<$Result.GetResult<Prisma.$StationeryItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StationeryItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StationeryItemFindUniqueOrThrowArgs} args - Arguments to find a StationeryItem
     * @example
     * // Get one StationeryItem
     * const stationeryItem = await prisma.stationeryItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StationeryItemFindUniqueOrThrowArgs>(args: SelectSubset<T, StationeryItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StationeryItemClient<$Result.GetResult<Prisma.$StationeryItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StationeryItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StationeryItemFindFirstArgs} args - Arguments to find a StationeryItem
     * @example
     * // Get one StationeryItem
     * const stationeryItem = await prisma.stationeryItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StationeryItemFindFirstArgs>(args?: SelectSubset<T, StationeryItemFindFirstArgs<ExtArgs>>): Prisma__StationeryItemClient<$Result.GetResult<Prisma.$StationeryItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StationeryItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StationeryItemFindFirstOrThrowArgs} args - Arguments to find a StationeryItem
     * @example
     * // Get one StationeryItem
     * const stationeryItem = await prisma.stationeryItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StationeryItemFindFirstOrThrowArgs>(args?: SelectSubset<T, StationeryItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__StationeryItemClient<$Result.GetResult<Prisma.$StationeryItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StationeryItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StationeryItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StationeryItems
     * const stationeryItems = await prisma.stationeryItem.findMany()
     * 
     * // Get first 10 StationeryItems
     * const stationeryItems = await prisma.stationeryItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stationeryItemWithIdOnly = await prisma.stationeryItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StationeryItemFindManyArgs>(args?: SelectSubset<T, StationeryItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StationeryItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StationeryItem.
     * @param {StationeryItemCreateArgs} args - Arguments to create a StationeryItem.
     * @example
     * // Create one StationeryItem
     * const StationeryItem = await prisma.stationeryItem.create({
     *   data: {
     *     // ... data to create a StationeryItem
     *   }
     * })
     * 
     */
    create<T extends StationeryItemCreateArgs>(args: SelectSubset<T, StationeryItemCreateArgs<ExtArgs>>): Prisma__StationeryItemClient<$Result.GetResult<Prisma.$StationeryItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StationeryItems.
     * @param {StationeryItemCreateManyArgs} args - Arguments to create many StationeryItems.
     * @example
     * // Create many StationeryItems
     * const stationeryItem = await prisma.stationeryItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StationeryItemCreateManyArgs>(args?: SelectSubset<T, StationeryItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StationeryItems and returns the data saved in the database.
     * @param {StationeryItemCreateManyAndReturnArgs} args - Arguments to create many StationeryItems.
     * @example
     * // Create many StationeryItems
     * const stationeryItem = await prisma.stationeryItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StationeryItems and only return the `id`
     * const stationeryItemWithIdOnly = await prisma.stationeryItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StationeryItemCreateManyAndReturnArgs>(args?: SelectSubset<T, StationeryItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StationeryItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StationeryItem.
     * @param {StationeryItemDeleteArgs} args - Arguments to delete one StationeryItem.
     * @example
     * // Delete one StationeryItem
     * const StationeryItem = await prisma.stationeryItem.delete({
     *   where: {
     *     // ... filter to delete one StationeryItem
     *   }
     * })
     * 
     */
    delete<T extends StationeryItemDeleteArgs>(args: SelectSubset<T, StationeryItemDeleteArgs<ExtArgs>>): Prisma__StationeryItemClient<$Result.GetResult<Prisma.$StationeryItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StationeryItem.
     * @param {StationeryItemUpdateArgs} args - Arguments to update one StationeryItem.
     * @example
     * // Update one StationeryItem
     * const stationeryItem = await prisma.stationeryItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StationeryItemUpdateArgs>(args: SelectSubset<T, StationeryItemUpdateArgs<ExtArgs>>): Prisma__StationeryItemClient<$Result.GetResult<Prisma.$StationeryItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StationeryItems.
     * @param {StationeryItemDeleteManyArgs} args - Arguments to filter StationeryItems to delete.
     * @example
     * // Delete a few StationeryItems
     * const { count } = await prisma.stationeryItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StationeryItemDeleteManyArgs>(args?: SelectSubset<T, StationeryItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StationeryItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StationeryItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StationeryItems
     * const stationeryItem = await prisma.stationeryItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StationeryItemUpdateManyArgs>(args: SelectSubset<T, StationeryItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StationeryItems and returns the data updated in the database.
     * @param {StationeryItemUpdateManyAndReturnArgs} args - Arguments to update many StationeryItems.
     * @example
     * // Update many StationeryItems
     * const stationeryItem = await prisma.stationeryItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StationeryItems and only return the `id`
     * const stationeryItemWithIdOnly = await prisma.stationeryItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StationeryItemUpdateManyAndReturnArgs>(args: SelectSubset<T, StationeryItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StationeryItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StationeryItem.
     * @param {StationeryItemUpsertArgs} args - Arguments to update or create a StationeryItem.
     * @example
     * // Update or create a StationeryItem
     * const stationeryItem = await prisma.stationeryItem.upsert({
     *   create: {
     *     // ... data to create a StationeryItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StationeryItem we want to update
     *   }
     * })
     */
    upsert<T extends StationeryItemUpsertArgs>(args: SelectSubset<T, StationeryItemUpsertArgs<ExtArgs>>): Prisma__StationeryItemClient<$Result.GetResult<Prisma.$StationeryItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StationeryItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StationeryItemCountArgs} args - Arguments to filter StationeryItems to count.
     * @example
     * // Count the number of StationeryItems
     * const count = await prisma.stationeryItem.count({
     *   where: {
     *     // ... the filter for the StationeryItems we want to count
     *   }
     * })
    **/
    count<T extends StationeryItemCountArgs>(
      args?: Subset<T, StationeryItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StationeryItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StationeryItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StationeryItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StationeryItemAggregateArgs>(args: Subset<T, StationeryItemAggregateArgs>): Prisma.PrismaPromise<GetStationeryItemAggregateType<T>>

    /**
     * Group by StationeryItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StationeryItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StationeryItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StationeryItemGroupByArgs['orderBy'] }
        : { orderBy?: StationeryItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StationeryItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStationeryItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StationeryItem model
   */
  readonly fields: StationeryItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StationeryItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StationeryItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    stationeryIssues<T extends StationeryItem$stationeryIssuesArgs<ExtArgs> = {}>(args?: Subset<T, StationeryItem$stationeryIssuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StationeryIssuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StationeryItem model
   */
  interface StationeryItemFieldRefs {
    readonly id: FieldRef<"StationeryItem", 'Int'>
    readonly name: FieldRef<"StationeryItem", 'String'>
    readonly quantityAvailable: FieldRef<"StationeryItem", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * StationeryItem findUnique
   */
  export type StationeryItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StationeryItem
     */
    select?: StationeryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StationeryItem
     */
    omit?: StationeryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StationeryItemInclude<ExtArgs> | null
    /**
     * Filter, which StationeryItem to fetch.
     */
    where: StationeryItemWhereUniqueInput
  }

  /**
   * StationeryItem findUniqueOrThrow
   */
  export type StationeryItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StationeryItem
     */
    select?: StationeryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StationeryItem
     */
    omit?: StationeryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StationeryItemInclude<ExtArgs> | null
    /**
     * Filter, which StationeryItem to fetch.
     */
    where: StationeryItemWhereUniqueInput
  }

  /**
   * StationeryItem findFirst
   */
  export type StationeryItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StationeryItem
     */
    select?: StationeryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StationeryItem
     */
    omit?: StationeryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StationeryItemInclude<ExtArgs> | null
    /**
     * Filter, which StationeryItem to fetch.
     */
    where?: StationeryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StationeryItems to fetch.
     */
    orderBy?: StationeryItemOrderByWithRelationInput | StationeryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StationeryItems.
     */
    cursor?: StationeryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StationeryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StationeryItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StationeryItems.
     */
    distinct?: StationeryItemScalarFieldEnum | StationeryItemScalarFieldEnum[]
  }

  /**
   * StationeryItem findFirstOrThrow
   */
  export type StationeryItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StationeryItem
     */
    select?: StationeryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StationeryItem
     */
    omit?: StationeryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StationeryItemInclude<ExtArgs> | null
    /**
     * Filter, which StationeryItem to fetch.
     */
    where?: StationeryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StationeryItems to fetch.
     */
    orderBy?: StationeryItemOrderByWithRelationInput | StationeryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StationeryItems.
     */
    cursor?: StationeryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StationeryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StationeryItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StationeryItems.
     */
    distinct?: StationeryItemScalarFieldEnum | StationeryItemScalarFieldEnum[]
  }

  /**
   * StationeryItem findMany
   */
  export type StationeryItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StationeryItem
     */
    select?: StationeryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StationeryItem
     */
    omit?: StationeryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StationeryItemInclude<ExtArgs> | null
    /**
     * Filter, which StationeryItems to fetch.
     */
    where?: StationeryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StationeryItems to fetch.
     */
    orderBy?: StationeryItemOrderByWithRelationInput | StationeryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StationeryItems.
     */
    cursor?: StationeryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StationeryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StationeryItems.
     */
    skip?: number
    distinct?: StationeryItemScalarFieldEnum | StationeryItemScalarFieldEnum[]
  }

  /**
   * StationeryItem create
   */
  export type StationeryItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StationeryItem
     */
    select?: StationeryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StationeryItem
     */
    omit?: StationeryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StationeryItemInclude<ExtArgs> | null
    /**
     * The data needed to create a StationeryItem.
     */
    data: XOR<StationeryItemCreateInput, StationeryItemUncheckedCreateInput>
  }

  /**
   * StationeryItem createMany
   */
  export type StationeryItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StationeryItems.
     */
    data: StationeryItemCreateManyInput | StationeryItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StationeryItem createManyAndReturn
   */
  export type StationeryItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StationeryItem
     */
    select?: StationeryItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StationeryItem
     */
    omit?: StationeryItemOmit<ExtArgs> | null
    /**
     * The data used to create many StationeryItems.
     */
    data: StationeryItemCreateManyInput | StationeryItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StationeryItem update
   */
  export type StationeryItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StationeryItem
     */
    select?: StationeryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StationeryItem
     */
    omit?: StationeryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StationeryItemInclude<ExtArgs> | null
    /**
     * The data needed to update a StationeryItem.
     */
    data: XOR<StationeryItemUpdateInput, StationeryItemUncheckedUpdateInput>
    /**
     * Choose, which StationeryItem to update.
     */
    where: StationeryItemWhereUniqueInput
  }

  /**
   * StationeryItem updateMany
   */
  export type StationeryItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StationeryItems.
     */
    data: XOR<StationeryItemUpdateManyMutationInput, StationeryItemUncheckedUpdateManyInput>
    /**
     * Filter which StationeryItems to update
     */
    where?: StationeryItemWhereInput
    /**
     * Limit how many StationeryItems to update.
     */
    limit?: number
  }

  /**
   * StationeryItem updateManyAndReturn
   */
  export type StationeryItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StationeryItem
     */
    select?: StationeryItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StationeryItem
     */
    omit?: StationeryItemOmit<ExtArgs> | null
    /**
     * The data used to update StationeryItems.
     */
    data: XOR<StationeryItemUpdateManyMutationInput, StationeryItemUncheckedUpdateManyInput>
    /**
     * Filter which StationeryItems to update
     */
    where?: StationeryItemWhereInput
    /**
     * Limit how many StationeryItems to update.
     */
    limit?: number
  }

  /**
   * StationeryItem upsert
   */
  export type StationeryItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StationeryItem
     */
    select?: StationeryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StationeryItem
     */
    omit?: StationeryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StationeryItemInclude<ExtArgs> | null
    /**
     * The filter to search for the StationeryItem to update in case it exists.
     */
    where: StationeryItemWhereUniqueInput
    /**
     * In case the StationeryItem found by the `where` argument doesn't exist, create a new StationeryItem with this data.
     */
    create: XOR<StationeryItemCreateInput, StationeryItemUncheckedCreateInput>
    /**
     * In case the StationeryItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StationeryItemUpdateInput, StationeryItemUncheckedUpdateInput>
  }

  /**
   * StationeryItem delete
   */
  export type StationeryItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StationeryItem
     */
    select?: StationeryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StationeryItem
     */
    omit?: StationeryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StationeryItemInclude<ExtArgs> | null
    /**
     * Filter which StationeryItem to delete.
     */
    where: StationeryItemWhereUniqueInput
  }

  /**
   * StationeryItem deleteMany
   */
  export type StationeryItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StationeryItems to delete
     */
    where?: StationeryItemWhereInput
    /**
     * Limit how many StationeryItems to delete.
     */
    limit?: number
  }

  /**
   * StationeryItem.stationeryIssues
   */
  export type StationeryItem$stationeryIssuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StationeryIssue
     */
    select?: StationeryIssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StationeryIssue
     */
    omit?: StationeryIssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StationeryIssueInclude<ExtArgs> | null
    where?: StationeryIssueWhereInput
    orderBy?: StationeryIssueOrderByWithRelationInput | StationeryIssueOrderByWithRelationInput[]
    cursor?: StationeryIssueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StationeryIssueScalarFieldEnum | StationeryIssueScalarFieldEnum[]
  }

  /**
   * StationeryItem without action
   */
  export type StationeryItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StationeryItem
     */
    select?: StationeryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StationeryItem
     */
    omit?: StationeryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StationeryItemInclude<ExtArgs> | null
  }


  /**
   * Model StationeryIssue
   */

  export type AggregateStationeryIssue = {
    _count: StationeryIssueCountAggregateOutputType | null
    _avg: StationeryIssueAvgAggregateOutputType | null
    _sum: StationeryIssueSumAggregateOutputType | null
    _min: StationeryIssueMinAggregateOutputType | null
    _max: StationeryIssueMaxAggregateOutputType | null
  }

  export type StationeryIssueAvgAggregateOutputType = {
    id: number | null
    studentId: number | null
    courseId: number | null
    itemId: number | null
    quantity: number | null
  }

  export type StationeryIssueSumAggregateOutputType = {
    id: number | null
    studentId: number | null
    courseId: number | null
    itemId: number | null
    quantity: number | null
  }

  export type StationeryIssueMinAggregateOutputType = {
    id: number | null
    studentId: number | null
    courseId: number | null
    itemId: number | null
    issueDate: Date | null
    quantity: number | null
    remarks: string | null
    clientAdminId: string | null
  }

  export type StationeryIssueMaxAggregateOutputType = {
    id: number | null
    studentId: number | null
    courseId: number | null
    itemId: number | null
    issueDate: Date | null
    quantity: number | null
    remarks: string | null
    clientAdminId: string | null
  }

  export type StationeryIssueCountAggregateOutputType = {
    id: number
    studentId: number
    courseId: number
    itemId: number
    issueDate: number
    quantity: number
    remarks: number
    clientAdminId: number
    _all: number
  }


  export type StationeryIssueAvgAggregateInputType = {
    id?: true
    studentId?: true
    courseId?: true
    itemId?: true
    quantity?: true
  }

  export type StationeryIssueSumAggregateInputType = {
    id?: true
    studentId?: true
    courseId?: true
    itemId?: true
    quantity?: true
  }

  export type StationeryIssueMinAggregateInputType = {
    id?: true
    studentId?: true
    courseId?: true
    itemId?: true
    issueDate?: true
    quantity?: true
    remarks?: true
    clientAdminId?: true
  }

  export type StationeryIssueMaxAggregateInputType = {
    id?: true
    studentId?: true
    courseId?: true
    itemId?: true
    issueDate?: true
    quantity?: true
    remarks?: true
    clientAdminId?: true
  }

  export type StationeryIssueCountAggregateInputType = {
    id?: true
    studentId?: true
    courseId?: true
    itemId?: true
    issueDate?: true
    quantity?: true
    remarks?: true
    clientAdminId?: true
    _all?: true
  }

  export type StationeryIssueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StationeryIssue to aggregate.
     */
    where?: StationeryIssueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StationeryIssues to fetch.
     */
    orderBy?: StationeryIssueOrderByWithRelationInput | StationeryIssueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StationeryIssueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StationeryIssues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StationeryIssues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StationeryIssues
    **/
    _count?: true | StationeryIssueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StationeryIssueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StationeryIssueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StationeryIssueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StationeryIssueMaxAggregateInputType
  }

  export type GetStationeryIssueAggregateType<T extends StationeryIssueAggregateArgs> = {
        [P in keyof T & keyof AggregateStationeryIssue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStationeryIssue[P]>
      : GetScalarType<T[P], AggregateStationeryIssue[P]>
  }




  export type StationeryIssueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StationeryIssueWhereInput
    orderBy?: StationeryIssueOrderByWithAggregationInput | StationeryIssueOrderByWithAggregationInput[]
    by: StationeryIssueScalarFieldEnum[] | StationeryIssueScalarFieldEnum
    having?: StationeryIssueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StationeryIssueCountAggregateInputType | true
    _avg?: StationeryIssueAvgAggregateInputType
    _sum?: StationeryIssueSumAggregateInputType
    _min?: StationeryIssueMinAggregateInputType
    _max?: StationeryIssueMaxAggregateInputType
  }

  export type StationeryIssueGroupByOutputType = {
    id: number
    studentId: number
    courseId: number
    itemId: number
    issueDate: Date
    quantity: number
    remarks: string | null
    clientAdminId: string
    _count: StationeryIssueCountAggregateOutputType | null
    _avg: StationeryIssueAvgAggregateOutputType | null
    _sum: StationeryIssueSumAggregateOutputType | null
    _min: StationeryIssueMinAggregateOutputType | null
    _max: StationeryIssueMaxAggregateOutputType | null
  }

  type GetStationeryIssueGroupByPayload<T extends StationeryIssueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StationeryIssueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StationeryIssueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StationeryIssueGroupByOutputType[P]>
            : GetScalarType<T[P], StationeryIssueGroupByOutputType[P]>
        }
      >
    >


  export type StationeryIssueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    courseId?: boolean
    itemId?: boolean
    issueDate?: boolean
    quantity?: boolean
    remarks?: boolean
    clientAdminId?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    item?: boolean | StationeryItemDefaultArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stationeryIssue"]>

  export type StationeryIssueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    courseId?: boolean
    itemId?: boolean
    issueDate?: boolean
    quantity?: boolean
    remarks?: boolean
    clientAdminId?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    item?: boolean | StationeryItemDefaultArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stationeryIssue"]>

  export type StationeryIssueSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    courseId?: boolean
    itemId?: boolean
    issueDate?: boolean
    quantity?: boolean
    remarks?: boolean
    clientAdminId?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    item?: boolean | StationeryItemDefaultArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stationeryIssue"]>

  export type StationeryIssueSelectScalar = {
    id?: boolean
    studentId?: boolean
    courseId?: boolean
    itemId?: boolean
    issueDate?: boolean
    quantity?: boolean
    remarks?: boolean
    clientAdminId?: boolean
  }

  export type StationeryIssueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "courseId" | "itemId" | "issueDate" | "quantity" | "remarks" | "clientAdminId", ExtArgs["result"]["stationeryIssue"]>
  export type StationeryIssueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    item?: boolean | StationeryItemDefaultArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }
  export type StationeryIssueIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    item?: boolean | StationeryItemDefaultArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }
  export type StationeryIssueIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    item?: boolean | StationeryItemDefaultArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }

  export type $StationeryIssuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StationeryIssue"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      course: Prisma.$CoursePayload<ExtArgs>
      item: Prisma.$StationeryItemPayload<ExtArgs>
      clientAdmin: Prisma.$ClientAdminPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      studentId: number
      courseId: number
      itemId: number
      issueDate: Date
      quantity: number
      remarks: string | null
      clientAdminId: string
    }, ExtArgs["result"]["stationeryIssue"]>
    composites: {}
  }

  type StationeryIssueGetPayload<S extends boolean | null | undefined | StationeryIssueDefaultArgs> = $Result.GetResult<Prisma.$StationeryIssuePayload, S>

  type StationeryIssueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StationeryIssueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StationeryIssueCountAggregateInputType | true
    }

  export interface StationeryIssueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StationeryIssue'], meta: { name: 'StationeryIssue' } }
    /**
     * Find zero or one StationeryIssue that matches the filter.
     * @param {StationeryIssueFindUniqueArgs} args - Arguments to find a StationeryIssue
     * @example
     * // Get one StationeryIssue
     * const stationeryIssue = await prisma.stationeryIssue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StationeryIssueFindUniqueArgs>(args: SelectSubset<T, StationeryIssueFindUniqueArgs<ExtArgs>>): Prisma__StationeryIssueClient<$Result.GetResult<Prisma.$StationeryIssuePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StationeryIssue that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StationeryIssueFindUniqueOrThrowArgs} args - Arguments to find a StationeryIssue
     * @example
     * // Get one StationeryIssue
     * const stationeryIssue = await prisma.stationeryIssue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StationeryIssueFindUniqueOrThrowArgs>(args: SelectSubset<T, StationeryIssueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StationeryIssueClient<$Result.GetResult<Prisma.$StationeryIssuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StationeryIssue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StationeryIssueFindFirstArgs} args - Arguments to find a StationeryIssue
     * @example
     * // Get one StationeryIssue
     * const stationeryIssue = await prisma.stationeryIssue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StationeryIssueFindFirstArgs>(args?: SelectSubset<T, StationeryIssueFindFirstArgs<ExtArgs>>): Prisma__StationeryIssueClient<$Result.GetResult<Prisma.$StationeryIssuePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StationeryIssue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StationeryIssueFindFirstOrThrowArgs} args - Arguments to find a StationeryIssue
     * @example
     * // Get one StationeryIssue
     * const stationeryIssue = await prisma.stationeryIssue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StationeryIssueFindFirstOrThrowArgs>(args?: SelectSubset<T, StationeryIssueFindFirstOrThrowArgs<ExtArgs>>): Prisma__StationeryIssueClient<$Result.GetResult<Prisma.$StationeryIssuePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StationeryIssues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StationeryIssueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StationeryIssues
     * const stationeryIssues = await prisma.stationeryIssue.findMany()
     * 
     * // Get first 10 StationeryIssues
     * const stationeryIssues = await prisma.stationeryIssue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stationeryIssueWithIdOnly = await prisma.stationeryIssue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StationeryIssueFindManyArgs>(args?: SelectSubset<T, StationeryIssueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StationeryIssuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StationeryIssue.
     * @param {StationeryIssueCreateArgs} args - Arguments to create a StationeryIssue.
     * @example
     * // Create one StationeryIssue
     * const StationeryIssue = await prisma.stationeryIssue.create({
     *   data: {
     *     // ... data to create a StationeryIssue
     *   }
     * })
     * 
     */
    create<T extends StationeryIssueCreateArgs>(args: SelectSubset<T, StationeryIssueCreateArgs<ExtArgs>>): Prisma__StationeryIssueClient<$Result.GetResult<Prisma.$StationeryIssuePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StationeryIssues.
     * @param {StationeryIssueCreateManyArgs} args - Arguments to create many StationeryIssues.
     * @example
     * // Create many StationeryIssues
     * const stationeryIssue = await prisma.stationeryIssue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StationeryIssueCreateManyArgs>(args?: SelectSubset<T, StationeryIssueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StationeryIssues and returns the data saved in the database.
     * @param {StationeryIssueCreateManyAndReturnArgs} args - Arguments to create many StationeryIssues.
     * @example
     * // Create many StationeryIssues
     * const stationeryIssue = await prisma.stationeryIssue.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StationeryIssues and only return the `id`
     * const stationeryIssueWithIdOnly = await prisma.stationeryIssue.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StationeryIssueCreateManyAndReturnArgs>(args?: SelectSubset<T, StationeryIssueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StationeryIssuePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StationeryIssue.
     * @param {StationeryIssueDeleteArgs} args - Arguments to delete one StationeryIssue.
     * @example
     * // Delete one StationeryIssue
     * const StationeryIssue = await prisma.stationeryIssue.delete({
     *   where: {
     *     // ... filter to delete one StationeryIssue
     *   }
     * })
     * 
     */
    delete<T extends StationeryIssueDeleteArgs>(args: SelectSubset<T, StationeryIssueDeleteArgs<ExtArgs>>): Prisma__StationeryIssueClient<$Result.GetResult<Prisma.$StationeryIssuePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StationeryIssue.
     * @param {StationeryIssueUpdateArgs} args - Arguments to update one StationeryIssue.
     * @example
     * // Update one StationeryIssue
     * const stationeryIssue = await prisma.stationeryIssue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StationeryIssueUpdateArgs>(args: SelectSubset<T, StationeryIssueUpdateArgs<ExtArgs>>): Prisma__StationeryIssueClient<$Result.GetResult<Prisma.$StationeryIssuePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StationeryIssues.
     * @param {StationeryIssueDeleteManyArgs} args - Arguments to filter StationeryIssues to delete.
     * @example
     * // Delete a few StationeryIssues
     * const { count } = await prisma.stationeryIssue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StationeryIssueDeleteManyArgs>(args?: SelectSubset<T, StationeryIssueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StationeryIssues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StationeryIssueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StationeryIssues
     * const stationeryIssue = await prisma.stationeryIssue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StationeryIssueUpdateManyArgs>(args: SelectSubset<T, StationeryIssueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StationeryIssues and returns the data updated in the database.
     * @param {StationeryIssueUpdateManyAndReturnArgs} args - Arguments to update many StationeryIssues.
     * @example
     * // Update many StationeryIssues
     * const stationeryIssue = await prisma.stationeryIssue.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StationeryIssues and only return the `id`
     * const stationeryIssueWithIdOnly = await prisma.stationeryIssue.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StationeryIssueUpdateManyAndReturnArgs>(args: SelectSubset<T, StationeryIssueUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StationeryIssuePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StationeryIssue.
     * @param {StationeryIssueUpsertArgs} args - Arguments to update or create a StationeryIssue.
     * @example
     * // Update or create a StationeryIssue
     * const stationeryIssue = await prisma.stationeryIssue.upsert({
     *   create: {
     *     // ... data to create a StationeryIssue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StationeryIssue we want to update
     *   }
     * })
     */
    upsert<T extends StationeryIssueUpsertArgs>(args: SelectSubset<T, StationeryIssueUpsertArgs<ExtArgs>>): Prisma__StationeryIssueClient<$Result.GetResult<Prisma.$StationeryIssuePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StationeryIssues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StationeryIssueCountArgs} args - Arguments to filter StationeryIssues to count.
     * @example
     * // Count the number of StationeryIssues
     * const count = await prisma.stationeryIssue.count({
     *   where: {
     *     // ... the filter for the StationeryIssues we want to count
     *   }
     * })
    **/
    count<T extends StationeryIssueCountArgs>(
      args?: Subset<T, StationeryIssueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StationeryIssueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StationeryIssue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StationeryIssueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StationeryIssueAggregateArgs>(args: Subset<T, StationeryIssueAggregateArgs>): Prisma.PrismaPromise<GetStationeryIssueAggregateType<T>>

    /**
     * Group by StationeryIssue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StationeryIssueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StationeryIssueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StationeryIssueGroupByArgs['orderBy'] }
        : { orderBy?: StationeryIssueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StationeryIssueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStationeryIssueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StationeryIssue model
   */
  readonly fields: StationeryIssueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StationeryIssue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StationeryIssueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    item<T extends StationeryItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StationeryItemDefaultArgs<ExtArgs>>): Prisma__StationeryItemClient<$Result.GetResult<Prisma.$StationeryItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    clientAdmin<T extends ClientAdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientAdminDefaultArgs<ExtArgs>>): Prisma__ClientAdminClient<$Result.GetResult<Prisma.$ClientAdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StationeryIssue model
   */
  interface StationeryIssueFieldRefs {
    readonly id: FieldRef<"StationeryIssue", 'Int'>
    readonly studentId: FieldRef<"StationeryIssue", 'Int'>
    readonly courseId: FieldRef<"StationeryIssue", 'Int'>
    readonly itemId: FieldRef<"StationeryIssue", 'Int'>
    readonly issueDate: FieldRef<"StationeryIssue", 'DateTime'>
    readonly quantity: FieldRef<"StationeryIssue", 'Int'>
    readonly remarks: FieldRef<"StationeryIssue", 'String'>
    readonly clientAdminId: FieldRef<"StationeryIssue", 'String'>
  }
    

  // Custom InputTypes
  /**
   * StationeryIssue findUnique
   */
  export type StationeryIssueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StationeryIssue
     */
    select?: StationeryIssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StationeryIssue
     */
    omit?: StationeryIssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StationeryIssueInclude<ExtArgs> | null
    /**
     * Filter, which StationeryIssue to fetch.
     */
    where: StationeryIssueWhereUniqueInput
  }

  /**
   * StationeryIssue findUniqueOrThrow
   */
  export type StationeryIssueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StationeryIssue
     */
    select?: StationeryIssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StationeryIssue
     */
    omit?: StationeryIssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StationeryIssueInclude<ExtArgs> | null
    /**
     * Filter, which StationeryIssue to fetch.
     */
    where: StationeryIssueWhereUniqueInput
  }

  /**
   * StationeryIssue findFirst
   */
  export type StationeryIssueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StationeryIssue
     */
    select?: StationeryIssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StationeryIssue
     */
    omit?: StationeryIssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StationeryIssueInclude<ExtArgs> | null
    /**
     * Filter, which StationeryIssue to fetch.
     */
    where?: StationeryIssueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StationeryIssues to fetch.
     */
    orderBy?: StationeryIssueOrderByWithRelationInput | StationeryIssueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StationeryIssues.
     */
    cursor?: StationeryIssueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StationeryIssues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StationeryIssues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StationeryIssues.
     */
    distinct?: StationeryIssueScalarFieldEnum | StationeryIssueScalarFieldEnum[]
  }

  /**
   * StationeryIssue findFirstOrThrow
   */
  export type StationeryIssueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StationeryIssue
     */
    select?: StationeryIssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StationeryIssue
     */
    omit?: StationeryIssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StationeryIssueInclude<ExtArgs> | null
    /**
     * Filter, which StationeryIssue to fetch.
     */
    where?: StationeryIssueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StationeryIssues to fetch.
     */
    orderBy?: StationeryIssueOrderByWithRelationInput | StationeryIssueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StationeryIssues.
     */
    cursor?: StationeryIssueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StationeryIssues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StationeryIssues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StationeryIssues.
     */
    distinct?: StationeryIssueScalarFieldEnum | StationeryIssueScalarFieldEnum[]
  }

  /**
   * StationeryIssue findMany
   */
  export type StationeryIssueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StationeryIssue
     */
    select?: StationeryIssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StationeryIssue
     */
    omit?: StationeryIssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StationeryIssueInclude<ExtArgs> | null
    /**
     * Filter, which StationeryIssues to fetch.
     */
    where?: StationeryIssueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StationeryIssues to fetch.
     */
    orderBy?: StationeryIssueOrderByWithRelationInput | StationeryIssueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StationeryIssues.
     */
    cursor?: StationeryIssueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StationeryIssues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StationeryIssues.
     */
    skip?: number
    distinct?: StationeryIssueScalarFieldEnum | StationeryIssueScalarFieldEnum[]
  }

  /**
   * StationeryIssue create
   */
  export type StationeryIssueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StationeryIssue
     */
    select?: StationeryIssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StationeryIssue
     */
    omit?: StationeryIssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StationeryIssueInclude<ExtArgs> | null
    /**
     * The data needed to create a StationeryIssue.
     */
    data: XOR<StationeryIssueCreateInput, StationeryIssueUncheckedCreateInput>
  }

  /**
   * StationeryIssue createMany
   */
  export type StationeryIssueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StationeryIssues.
     */
    data: StationeryIssueCreateManyInput | StationeryIssueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StationeryIssue createManyAndReturn
   */
  export type StationeryIssueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StationeryIssue
     */
    select?: StationeryIssueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StationeryIssue
     */
    omit?: StationeryIssueOmit<ExtArgs> | null
    /**
     * The data used to create many StationeryIssues.
     */
    data: StationeryIssueCreateManyInput | StationeryIssueCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StationeryIssueIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StationeryIssue update
   */
  export type StationeryIssueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StationeryIssue
     */
    select?: StationeryIssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StationeryIssue
     */
    omit?: StationeryIssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StationeryIssueInclude<ExtArgs> | null
    /**
     * The data needed to update a StationeryIssue.
     */
    data: XOR<StationeryIssueUpdateInput, StationeryIssueUncheckedUpdateInput>
    /**
     * Choose, which StationeryIssue to update.
     */
    where: StationeryIssueWhereUniqueInput
  }

  /**
   * StationeryIssue updateMany
   */
  export type StationeryIssueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StationeryIssues.
     */
    data: XOR<StationeryIssueUpdateManyMutationInput, StationeryIssueUncheckedUpdateManyInput>
    /**
     * Filter which StationeryIssues to update
     */
    where?: StationeryIssueWhereInput
    /**
     * Limit how many StationeryIssues to update.
     */
    limit?: number
  }

  /**
   * StationeryIssue updateManyAndReturn
   */
  export type StationeryIssueUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StationeryIssue
     */
    select?: StationeryIssueSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StationeryIssue
     */
    omit?: StationeryIssueOmit<ExtArgs> | null
    /**
     * The data used to update StationeryIssues.
     */
    data: XOR<StationeryIssueUpdateManyMutationInput, StationeryIssueUncheckedUpdateManyInput>
    /**
     * Filter which StationeryIssues to update
     */
    where?: StationeryIssueWhereInput
    /**
     * Limit how many StationeryIssues to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StationeryIssueIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StationeryIssue upsert
   */
  export type StationeryIssueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StationeryIssue
     */
    select?: StationeryIssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StationeryIssue
     */
    omit?: StationeryIssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StationeryIssueInclude<ExtArgs> | null
    /**
     * The filter to search for the StationeryIssue to update in case it exists.
     */
    where: StationeryIssueWhereUniqueInput
    /**
     * In case the StationeryIssue found by the `where` argument doesn't exist, create a new StationeryIssue with this data.
     */
    create: XOR<StationeryIssueCreateInput, StationeryIssueUncheckedCreateInput>
    /**
     * In case the StationeryIssue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StationeryIssueUpdateInput, StationeryIssueUncheckedUpdateInput>
  }

  /**
   * StationeryIssue delete
   */
  export type StationeryIssueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StationeryIssue
     */
    select?: StationeryIssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StationeryIssue
     */
    omit?: StationeryIssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StationeryIssueInclude<ExtArgs> | null
    /**
     * Filter which StationeryIssue to delete.
     */
    where: StationeryIssueWhereUniqueInput
  }

  /**
   * StationeryIssue deleteMany
   */
  export type StationeryIssueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StationeryIssues to delete
     */
    where?: StationeryIssueWhereInput
    /**
     * Limit how many StationeryIssues to delete.
     */
    limit?: number
  }

  /**
   * StationeryIssue without action
   */
  export type StationeryIssueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StationeryIssue
     */
    select?: StationeryIssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StationeryIssue
     */
    omit?: StationeryIssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StationeryIssueInclude<ExtArgs> | null
  }


  /**
   * Model AttendanceRecord
   */

  export type AggregateAttendanceRecord = {
    _count: AttendanceRecordCountAggregateOutputType | null
    _avg: AttendanceRecordAvgAggregateOutputType | null
    _sum: AttendanceRecordSumAggregateOutputType | null
    _min: AttendanceRecordMinAggregateOutputType | null
    _max: AttendanceRecordMaxAggregateOutputType | null
  }

  export type AttendanceRecordAvgAggregateOutputType = {
    id: number | null
    studentId: number | null
    courseId: number | null
    facultyId: number | null
    batchId: number | null
  }

  export type AttendanceRecordSumAggregateOutputType = {
    id: number | null
    studentId: number | null
    courseId: number | null
    facultyId: number | null
    batchId: number | null
  }

  export type AttendanceRecordMinAggregateOutputType = {
    id: number | null
    studentId: number | null
    courseId: number | null
    date: Date | null
    present: boolean | null
    facultyId: number | null
    batchId: number | null
    clientAdminId: string | null
  }

  export type AttendanceRecordMaxAggregateOutputType = {
    id: number | null
    studentId: number | null
    courseId: number | null
    date: Date | null
    present: boolean | null
    facultyId: number | null
    batchId: number | null
    clientAdminId: string | null
  }

  export type AttendanceRecordCountAggregateOutputType = {
    id: number
    studentId: number
    courseId: number
    date: number
    present: number
    facultyId: number
    batchId: number
    clientAdminId: number
    _all: number
  }


  export type AttendanceRecordAvgAggregateInputType = {
    id?: true
    studentId?: true
    courseId?: true
    facultyId?: true
    batchId?: true
  }

  export type AttendanceRecordSumAggregateInputType = {
    id?: true
    studentId?: true
    courseId?: true
    facultyId?: true
    batchId?: true
  }

  export type AttendanceRecordMinAggregateInputType = {
    id?: true
    studentId?: true
    courseId?: true
    date?: true
    present?: true
    facultyId?: true
    batchId?: true
    clientAdminId?: true
  }

  export type AttendanceRecordMaxAggregateInputType = {
    id?: true
    studentId?: true
    courseId?: true
    date?: true
    present?: true
    facultyId?: true
    batchId?: true
    clientAdminId?: true
  }

  export type AttendanceRecordCountAggregateInputType = {
    id?: true
    studentId?: true
    courseId?: true
    date?: true
    present?: true
    facultyId?: true
    batchId?: true
    clientAdminId?: true
    _all?: true
  }

  export type AttendanceRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AttendanceRecord to aggregate.
     */
    where?: AttendanceRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceRecords to fetch.
     */
    orderBy?: AttendanceRecordOrderByWithRelationInput | AttendanceRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttendanceRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AttendanceRecords
    **/
    _count?: true | AttendanceRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AttendanceRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AttendanceRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttendanceRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttendanceRecordMaxAggregateInputType
  }

  export type GetAttendanceRecordAggregateType<T extends AttendanceRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateAttendanceRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttendanceRecord[P]>
      : GetScalarType<T[P], AggregateAttendanceRecord[P]>
  }




  export type AttendanceRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceRecordWhereInput
    orderBy?: AttendanceRecordOrderByWithAggregationInput | AttendanceRecordOrderByWithAggregationInput[]
    by: AttendanceRecordScalarFieldEnum[] | AttendanceRecordScalarFieldEnum
    having?: AttendanceRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttendanceRecordCountAggregateInputType | true
    _avg?: AttendanceRecordAvgAggregateInputType
    _sum?: AttendanceRecordSumAggregateInputType
    _min?: AttendanceRecordMinAggregateInputType
    _max?: AttendanceRecordMaxAggregateInputType
  }

  export type AttendanceRecordGroupByOutputType = {
    id: number
    studentId: number
    courseId: number
    date: Date
    present: boolean
    facultyId: number
    batchId: number | null
    clientAdminId: string
    _count: AttendanceRecordCountAggregateOutputType | null
    _avg: AttendanceRecordAvgAggregateOutputType | null
    _sum: AttendanceRecordSumAggregateOutputType | null
    _min: AttendanceRecordMinAggregateOutputType | null
    _max: AttendanceRecordMaxAggregateOutputType | null
  }

  type GetAttendanceRecordGroupByPayload<T extends AttendanceRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttendanceRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttendanceRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttendanceRecordGroupByOutputType[P]>
            : GetScalarType<T[P], AttendanceRecordGroupByOutputType[P]>
        }
      >
    >


  export type AttendanceRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    courseId?: boolean
    date?: boolean
    present?: boolean
    facultyId?: boolean
    batchId?: boolean
    clientAdminId?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    markedBy?: boolean | FacultyDefaultArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendanceRecord"]>

  export type AttendanceRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    courseId?: boolean
    date?: boolean
    present?: boolean
    facultyId?: boolean
    batchId?: boolean
    clientAdminId?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    markedBy?: boolean | FacultyDefaultArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendanceRecord"]>

  export type AttendanceRecordSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    courseId?: boolean
    date?: boolean
    present?: boolean
    facultyId?: boolean
    batchId?: boolean
    clientAdminId?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    markedBy?: boolean | FacultyDefaultArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendanceRecord"]>

  export type AttendanceRecordSelectScalar = {
    id?: boolean
    studentId?: boolean
    courseId?: boolean
    date?: boolean
    present?: boolean
    facultyId?: boolean
    batchId?: boolean
    clientAdminId?: boolean
  }

  export type AttendanceRecordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "courseId" | "date" | "present" | "facultyId" | "batchId" | "clientAdminId", ExtArgs["result"]["attendanceRecord"]>
  export type AttendanceRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    markedBy?: boolean | FacultyDefaultArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }
  export type AttendanceRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    markedBy?: boolean | FacultyDefaultArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }
  export type AttendanceRecordIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    markedBy?: boolean | FacultyDefaultArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }

  export type $AttendanceRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AttendanceRecord"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      course: Prisma.$CoursePayload<ExtArgs>
      markedBy: Prisma.$FacultyPayload<ExtArgs>
      clientAdmin: Prisma.$ClientAdminPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      studentId: number
      courseId: number
      date: Date
      present: boolean
      facultyId: number
      batchId: number | null
      clientAdminId: string
    }, ExtArgs["result"]["attendanceRecord"]>
    composites: {}
  }

  type AttendanceRecordGetPayload<S extends boolean | null | undefined | AttendanceRecordDefaultArgs> = $Result.GetResult<Prisma.$AttendanceRecordPayload, S>

  type AttendanceRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AttendanceRecordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AttendanceRecordCountAggregateInputType | true
    }

  export interface AttendanceRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AttendanceRecord'], meta: { name: 'AttendanceRecord' } }
    /**
     * Find zero or one AttendanceRecord that matches the filter.
     * @param {AttendanceRecordFindUniqueArgs} args - Arguments to find a AttendanceRecord
     * @example
     * // Get one AttendanceRecord
     * const attendanceRecord = await prisma.attendanceRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttendanceRecordFindUniqueArgs>(args: SelectSubset<T, AttendanceRecordFindUniqueArgs<ExtArgs>>): Prisma__AttendanceRecordClient<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AttendanceRecord that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AttendanceRecordFindUniqueOrThrowArgs} args - Arguments to find a AttendanceRecord
     * @example
     * // Get one AttendanceRecord
     * const attendanceRecord = await prisma.attendanceRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttendanceRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, AttendanceRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttendanceRecordClient<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AttendanceRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceRecordFindFirstArgs} args - Arguments to find a AttendanceRecord
     * @example
     * // Get one AttendanceRecord
     * const attendanceRecord = await prisma.attendanceRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttendanceRecordFindFirstArgs>(args?: SelectSubset<T, AttendanceRecordFindFirstArgs<ExtArgs>>): Prisma__AttendanceRecordClient<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AttendanceRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceRecordFindFirstOrThrowArgs} args - Arguments to find a AttendanceRecord
     * @example
     * // Get one AttendanceRecord
     * const attendanceRecord = await prisma.attendanceRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttendanceRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, AttendanceRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttendanceRecordClient<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AttendanceRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AttendanceRecords
     * const attendanceRecords = await prisma.attendanceRecord.findMany()
     * 
     * // Get first 10 AttendanceRecords
     * const attendanceRecords = await prisma.attendanceRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attendanceRecordWithIdOnly = await prisma.attendanceRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AttendanceRecordFindManyArgs>(args?: SelectSubset<T, AttendanceRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AttendanceRecord.
     * @param {AttendanceRecordCreateArgs} args - Arguments to create a AttendanceRecord.
     * @example
     * // Create one AttendanceRecord
     * const AttendanceRecord = await prisma.attendanceRecord.create({
     *   data: {
     *     // ... data to create a AttendanceRecord
     *   }
     * })
     * 
     */
    create<T extends AttendanceRecordCreateArgs>(args: SelectSubset<T, AttendanceRecordCreateArgs<ExtArgs>>): Prisma__AttendanceRecordClient<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AttendanceRecords.
     * @param {AttendanceRecordCreateManyArgs} args - Arguments to create many AttendanceRecords.
     * @example
     * // Create many AttendanceRecords
     * const attendanceRecord = await prisma.attendanceRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttendanceRecordCreateManyArgs>(args?: SelectSubset<T, AttendanceRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AttendanceRecords and returns the data saved in the database.
     * @param {AttendanceRecordCreateManyAndReturnArgs} args - Arguments to create many AttendanceRecords.
     * @example
     * // Create many AttendanceRecords
     * const attendanceRecord = await prisma.attendanceRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AttendanceRecords and only return the `id`
     * const attendanceRecordWithIdOnly = await prisma.attendanceRecord.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AttendanceRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, AttendanceRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AttendanceRecord.
     * @param {AttendanceRecordDeleteArgs} args - Arguments to delete one AttendanceRecord.
     * @example
     * // Delete one AttendanceRecord
     * const AttendanceRecord = await prisma.attendanceRecord.delete({
     *   where: {
     *     // ... filter to delete one AttendanceRecord
     *   }
     * })
     * 
     */
    delete<T extends AttendanceRecordDeleteArgs>(args: SelectSubset<T, AttendanceRecordDeleteArgs<ExtArgs>>): Prisma__AttendanceRecordClient<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AttendanceRecord.
     * @param {AttendanceRecordUpdateArgs} args - Arguments to update one AttendanceRecord.
     * @example
     * // Update one AttendanceRecord
     * const attendanceRecord = await prisma.attendanceRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttendanceRecordUpdateArgs>(args: SelectSubset<T, AttendanceRecordUpdateArgs<ExtArgs>>): Prisma__AttendanceRecordClient<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AttendanceRecords.
     * @param {AttendanceRecordDeleteManyArgs} args - Arguments to filter AttendanceRecords to delete.
     * @example
     * // Delete a few AttendanceRecords
     * const { count } = await prisma.attendanceRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttendanceRecordDeleteManyArgs>(args?: SelectSubset<T, AttendanceRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AttendanceRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AttendanceRecords
     * const attendanceRecord = await prisma.attendanceRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttendanceRecordUpdateManyArgs>(args: SelectSubset<T, AttendanceRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AttendanceRecords and returns the data updated in the database.
     * @param {AttendanceRecordUpdateManyAndReturnArgs} args - Arguments to update many AttendanceRecords.
     * @example
     * // Update many AttendanceRecords
     * const attendanceRecord = await prisma.attendanceRecord.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AttendanceRecords and only return the `id`
     * const attendanceRecordWithIdOnly = await prisma.attendanceRecord.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AttendanceRecordUpdateManyAndReturnArgs>(args: SelectSubset<T, AttendanceRecordUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AttendanceRecord.
     * @param {AttendanceRecordUpsertArgs} args - Arguments to update or create a AttendanceRecord.
     * @example
     * // Update or create a AttendanceRecord
     * const attendanceRecord = await prisma.attendanceRecord.upsert({
     *   create: {
     *     // ... data to create a AttendanceRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AttendanceRecord we want to update
     *   }
     * })
     */
    upsert<T extends AttendanceRecordUpsertArgs>(args: SelectSubset<T, AttendanceRecordUpsertArgs<ExtArgs>>): Prisma__AttendanceRecordClient<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AttendanceRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceRecordCountArgs} args - Arguments to filter AttendanceRecords to count.
     * @example
     * // Count the number of AttendanceRecords
     * const count = await prisma.attendanceRecord.count({
     *   where: {
     *     // ... the filter for the AttendanceRecords we want to count
     *   }
     * })
    **/
    count<T extends AttendanceRecordCountArgs>(
      args?: Subset<T, AttendanceRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttendanceRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AttendanceRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttendanceRecordAggregateArgs>(args: Subset<T, AttendanceRecordAggregateArgs>): Prisma.PrismaPromise<GetAttendanceRecordAggregateType<T>>

    /**
     * Group by AttendanceRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttendanceRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttendanceRecordGroupByArgs['orderBy'] }
        : { orderBy?: AttendanceRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttendanceRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttendanceRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AttendanceRecord model
   */
  readonly fields: AttendanceRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AttendanceRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttendanceRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    markedBy<T extends FacultyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FacultyDefaultArgs<ExtArgs>>): Prisma__FacultyClient<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    clientAdmin<T extends ClientAdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientAdminDefaultArgs<ExtArgs>>): Prisma__ClientAdminClient<$Result.GetResult<Prisma.$ClientAdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AttendanceRecord model
   */
  interface AttendanceRecordFieldRefs {
    readonly id: FieldRef<"AttendanceRecord", 'Int'>
    readonly studentId: FieldRef<"AttendanceRecord", 'Int'>
    readonly courseId: FieldRef<"AttendanceRecord", 'Int'>
    readonly date: FieldRef<"AttendanceRecord", 'DateTime'>
    readonly present: FieldRef<"AttendanceRecord", 'Boolean'>
    readonly facultyId: FieldRef<"AttendanceRecord", 'Int'>
    readonly batchId: FieldRef<"AttendanceRecord", 'Int'>
    readonly clientAdminId: FieldRef<"AttendanceRecord", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AttendanceRecord findUnique
   */
  export type AttendanceRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceRecord
     */
    omit?: AttendanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceRecord to fetch.
     */
    where: AttendanceRecordWhereUniqueInput
  }

  /**
   * AttendanceRecord findUniqueOrThrow
   */
  export type AttendanceRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceRecord
     */
    omit?: AttendanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceRecord to fetch.
     */
    where: AttendanceRecordWhereUniqueInput
  }

  /**
   * AttendanceRecord findFirst
   */
  export type AttendanceRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceRecord
     */
    omit?: AttendanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceRecord to fetch.
     */
    where?: AttendanceRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceRecords to fetch.
     */
    orderBy?: AttendanceRecordOrderByWithRelationInput | AttendanceRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttendanceRecords.
     */
    cursor?: AttendanceRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttendanceRecords.
     */
    distinct?: AttendanceRecordScalarFieldEnum | AttendanceRecordScalarFieldEnum[]
  }

  /**
   * AttendanceRecord findFirstOrThrow
   */
  export type AttendanceRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceRecord
     */
    omit?: AttendanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceRecord to fetch.
     */
    where?: AttendanceRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceRecords to fetch.
     */
    orderBy?: AttendanceRecordOrderByWithRelationInput | AttendanceRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttendanceRecords.
     */
    cursor?: AttendanceRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttendanceRecords.
     */
    distinct?: AttendanceRecordScalarFieldEnum | AttendanceRecordScalarFieldEnum[]
  }

  /**
   * AttendanceRecord findMany
   */
  export type AttendanceRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceRecord
     */
    omit?: AttendanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceRecords to fetch.
     */
    where?: AttendanceRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceRecords to fetch.
     */
    orderBy?: AttendanceRecordOrderByWithRelationInput | AttendanceRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AttendanceRecords.
     */
    cursor?: AttendanceRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceRecords.
     */
    skip?: number
    distinct?: AttendanceRecordScalarFieldEnum | AttendanceRecordScalarFieldEnum[]
  }

  /**
   * AttendanceRecord create
   */
  export type AttendanceRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceRecord
     */
    omit?: AttendanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a AttendanceRecord.
     */
    data: XOR<AttendanceRecordCreateInput, AttendanceRecordUncheckedCreateInput>
  }

  /**
   * AttendanceRecord createMany
   */
  export type AttendanceRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AttendanceRecords.
     */
    data: AttendanceRecordCreateManyInput | AttendanceRecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AttendanceRecord createManyAndReturn
   */
  export type AttendanceRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceRecord
     */
    omit?: AttendanceRecordOmit<ExtArgs> | null
    /**
     * The data used to create many AttendanceRecords.
     */
    data: AttendanceRecordCreateManyInput | AttendanceRecordCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AttendanceRecord update
   */
  export type AttendanceRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceRecord
     */
    omit?: AttendanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a AttendanceRecord.
     */
    data: XOR<AttendanceRecordUpdateInput, AttendanceRecordUncheckedUpdateInput>
    /**
     * Choose, which AttendanceRecord to update.
     */
    where: AttendanceRecordWhereUniqueInput
  }

  /**
   * AttendanceRecord updateMany
   */
  export type AttendanceRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AttendanceRecords.
     */
    data: XOR<AttendanceRecordUpdateManyMutationInput, AttendanceRecordUncheckedUpdateManyInput>
    /**
     * Filter which AttendanceRecords to update
     */
    where?: AttendanceRecordWhereInput
    /**
     * Limit how many AttendanceRecords to update.
     */
    limit?: number
  }

  /**
   * AttendanceRecord updateManyAndReturn
   */
  export type AttendanceRecordUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceRecord
     */
    omit?: AttendanceRecordOmit<ExtArgs> | null
    /**
     * The data used to update AttendanceRecords.
     */
    data: XOR<AttendanceRecordUpdateManyMutationInput, AttendanceRecordUncheckedUpdateManyInput>
    /**
     * Filter which AttendanceRecords to update
     */
    where?: AttendanceRecordWhereInput
    /**
     * Limit how many AttendanceRecords to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AttendanceRecord upsert
   */
  export type AttendanceRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceRecord
     */
    omit?: AttendanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the AttendanceRecord to update in case it exists.
     */
    where: AttendanceRecordWhereUniqueInput
    /**
     * In case the AttendanceRecord found by the `where` argument doesn't exist, create a new AttendanceRecord with this data.
     */
    create: XOR<AttendanceRecordCreateInput, AttendanceRecordUncheckedCreateInput>
    /**
     * In case the AttendanceRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttendanceRecordUpdateInput, AttendanceRecordUncheckedUpdateInput>
  }

  /**
   * AttendanceRecord delete
   */
  export type AttendanceRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceRecord
     */
    omit?: AttendanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    /**
     * Filter which AttendanceRecord to delete.
     */
    where: AttendanceRecordWhereUniqueInput
  }

  /**
   * AttendanceRecord deleteMany
   */
  export type AttendanceRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AttendanceRecords to delete
     */
    where?: AttendanceRecordWhereInput
    /**
     * Limit how many AttendanceRecords to delete.
     */
    limit?: number
  }

  /**
   * AttendanceRecord without action
   */
  export type AttendanceRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceRecord
     */
    omit?: AttendanceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
  }


  /**
   * Model StudentTask
   */

  export type AggregateStudentTask = {
    _count: StudentTaskCountAggregateOutputType | null
    _avg: StudentTaskAvgAggregateOutputType | null
    _sum: StudentTaskSumAggregateOutputType | null
    _min: StudentTaskMinAggregateOutputType | null
    _max: StudentTaskMaxAggregateOutputType | null
  }

  export type StudentTaskAvgAggregateOutputType = {
    id: number | null
    studentId: number | null
    courseId: number | null
    facultyId: number | null
  }

  export type StudentTaskSumAggregateOutputType = {
    id: number | null
    studentId: number | null
    courseId: number | null
    facultyId: number | null
  }

  export type StudentTaskMinAggregateOutputType = {
    id: number | null
    studentId: number | null
    courseId: number | null
    assignedDate: Date | null
    dueDate: Date | null
    description: string | null
    status: string | null
    facultyRemarks: string | null
    grade: string | null
    facultyId: number | null
    clientAdminId: string | null
  }

  export type StudentTaskMaxAggregateOutputType = {
    id: number | null
    studentId: number | null
    courseId: number | null
    assignedDate: Date | null
    dueDate: Date | null
    description: string | null
    status: string | null
    facultyRemarks: string | null
    grade: string | null
    facultyId: number | null
    clientAdminId: string | null
  }

  export type StudentTaskCountAggregateOutputType = {
    id: number
    studentId: number
    courseId: number
    assignedDate: number
    dueDate: number
    description: number
    status: number
    facultyRemarks: number
    grade: number
    facultyId: number
    clientAdminId: number
    _all: number
  }


  export type StudentTaskAvgAggregateInputType = {
    id?: true
    studentId?: true
    courseId?: true
    facultyId?: true
  }

  export type StudentTaskSumAggregateInputType = {
    id?: true
    studentId?: true
    courseId?: true
    facultyId?: true
  }

  export type StudentTaskMinAggregateInputType = {
    id?: true
    studentId?: true
    courseId?: true
    assignedDate?: true
    dueDate?: true
    description?: true
    status?: true
    facultyRemarks?: true
    grade?: true
    facultyId?: true
    clientAdminId?: true
  }

  export type StudentTaskMaxAggregateInputType = {
    id?: true
    studentId?: true
    courseId?: true
    assignedDate?: true
    dueDate?: true
    description?: true
    status?: true
    facultyRemarks?: true
    grade?: true
    facultyId?: true
    clientAdminId?: true
  }

  export type StudentTaskCountAggregateInputType = {
    id?: true
    studentId?: true
    courseId?: true
    assignedDate?: true
    dueDate?: true
    description?: true
    status?: true
    facultyRemarks?: true
    grade?: true
    facultyId?: true
    clientAdminId?: true
    _all?: true
  }

  export type StudentTaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentTask to aggregate.
     */
    where?: StudentTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentTasks to fetch.
     */
    orderBy?: StudentTaskOrderByWithRelationInput | StudentTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentTasks
    **/
    _count?: true | StudentTaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentTaskAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentTaskSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentTaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentTaskMaxAggregateInputType
  }

  export type GetStudentTaskAggregateType<T extends StudentTaskAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentTask[P]>
      : GetScalarType<T[P], AggregateStudentTask[P]>
  }




  export type StudentTaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentTaskWhereInput
    orderBy?: StudentTaskOrderByWithAggregationInput | StudentTaskOrderByWithAggregationInput[]
    by: StudentTaskScalarFieldEnum[] | StudentTaskScalarFieldEnum
    having?: StudentTaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentTaskCountAggregateInputType | true
    _avg?: StudentTaskAvgAggregateInputType
    _sum?: StudentTaskSumAggregateInputType
    _min?: StudentTaskMinAggregateInputType
    _max?: StudentTaskMaxAggregateInputType
  }

  export type StudentTaskGroupByOutputType = {
    id: number
    studentId: number
    courseId: number
    assignedDate: Date
    dueDate: Date
    description: string
    status: string
    facultyRemarks: string | null
    grade: string | null
    facultyId: number | null
    clientAdminId: string
    _count: StudentTaskCountAggregateOutputType | null
    _avg: StudentTaskAvgAggregateOutputType | null
    _sum: StudentTaskSumAggregateOutputType | null
    _min: StudentTaskMinAggregateOutputType | null
    _max: StudentTaskMaxAggregateOutputType | null
  }

  type GetStudentTaskGroupByPayload<T extends StudentTaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentTaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentTaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentTaskGroupByOutputType[P]>
            : GetScalarType<T[P], StudentTaskGroupByOutputType[P]>
        }
      >
    >


  export type StudentTaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    courseId?: boolean
    assignedDate?: boolean
    dueDate?: boolean
    description?: boolean
    status?: boolean
    facultyRemarks?: boolean
    grade?: boolean
    facultyId?: boolean
    clientAdminId?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    faculty?: boolean | StudentTask$facultyArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentTask"]>

  export type StudentTaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    courseId?: boolean
    assignedDate?: boolean
    dueDate?: boolean
    description?: boolean
    status?: boolean
    facultyRemarks?: boolean
    grade?: boolean
    facultyId?: boolean
    clientAdminId?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    faculty?: boolean | StudentTask$facultyArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentTask"]>

  export type StudentTaskSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    courseId?: boolean
    assignedDate?: boolean
    dueDate?: boolean
    description?: boolean
    status?: boolean
    facultyRemarks?: boolean
    grade?: boolean
    facultyId?: boolean
    clientAdminId?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    faculty?: boolean | StudentTask$facultyArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentTask"]>

  export type StudentTaskSelectScalar = {
    id?: boolean
    studentId?: boolean
    courseId?: boolean
    assignedDate?: boolean
    dueDate?: boolean
    description?: boolean
    status?: boolean
    facultyRemarks?: boolean
    grade?: boolean
    facultyId?: boolean
    clientAdminId?: boolean
  }

  export type StudentTaskOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "courseId" | "assignedDate" | "dueDate" | "description" | "status" | "facultyRemarks" | "grade" | "facultyId" | "clientAdminId", ExtArgs["result"]["studentTask"]>
  export type StudentTaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    faculty?: boolean | StudentTask$facultyArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }
  export type StudentTaskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    faculty?: boolean | StudentTask$facultyArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }
  export type StudentTaskIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    faculty?: boolean | StudentTask$facultyArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }

  export type $StudentTaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentTask"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      course: Prisma.$CoursePayload<ExtArgs>
      faculty: Prisma.$FacultyPayload<ExtArgs> | null
      clientAdmin: Prisma.$ClientAdminPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      studentId: number
      courseId: number
      assignedDate: Date
      dueDate: Date
      description: string
      status: string
      facultyRemarks: string | null
      grade: string | null
      facultyId: number | null
      clientAdminId: string
    }, ExtArgs["result"]["studentTask"]>
    composites: {}
  }

  type StudentTaskGetPayload<S extends boolean | null | undefined | StudentTaskDefaultArgs> = $Result.GetResult<Prisma.$StudentTaskPayload, S>

  type StudentTaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudentTaskFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentTaskCountAggregateInputType | true
    }

  export interface StudentTaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentTask'], meta: { name: 'StudentTask' } }
    /**
     * Find zero or one StudentTask that matches the filter.
     * @param {StudentTaskFindUniqueArgs} args - Arguments to find a StudentTask
     * @example
     * // Get one StudentTask
     * const studentTask = await prisma.studentTask.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentTaskFindUniqueArgs>(args: SelectSubset<T, StudentTaskFindUniqueArgs<ExtArgs>>): Prisma__StudentTaskClient<$Result.GetResult<Prisma.$StudentTaskPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StudentTask that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudentTaskFindUniqueOrThrowArgs} args - Arguments to find a StudentTask
     * @example
     * // Get one StudentTask
     * const studentTask = await prisma.studentTask.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentTaskFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentTaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentTaskClient<$Result.GetResult<Prisma.$StudentTaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentTask that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentTaskFindFirstArgs} args - Arguments to find a StudentTask
     * @example
     * // Get one StudentTask
     * const studentTask = await prisma.studentTask.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentTaskFindFirstArgs>(args?: SelectSubset<T, StudentTaskFindFirstArgs<ExtArgs>>): Prisma__StudentTaskClient<$Result.GetResult<Prisma.$StudentTaskPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentTask that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentTaskFindFirstOrThrowArgs} args - Arguments to find a StudentTask
     * @example
     * // Get one StudentTask
     * const studentTask = await prisma.studentTask.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentTaskFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentTaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentTaskClient<$Result.GetResult<Prisma.$StudentTaskPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StudentTasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentTaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentTasks
     * const studentTasks = await prisma.studentTask.findMany()
     * 
     * // Get first 10 StudentTasks
     * const studentTasks = await prisma.studentTask.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentTaskWithIdOnly = await prisma.studentTask.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentTaskFindManyArgs>(args?: SelectSubset<T, StudentTaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StudentTask.
     * @param {StudentTaskCreateArgs} args - Arguments to create a StudentTask.
     * @example
     * // Create one StudentTask
     * const StudentTask = await prisma.studentTask.create({
     *   data: {
     *     // ... data to create a StudentTask
     *   }
     * })
     * 
     */
    create<T extends StudentTaskCreateArgs>(args: SelectSubset<T, StudentTaskCreateArgs<ExtArgs>>): Prisma__StudentTaskClient<$Result.GetResult<Prisma.$StudentTaskPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StudentTasks.
     * @param {StudentTaskCreateManyArgs} args - Arguments to create many StudentTasks.
     * @example
     * // Create many StudentTasks
     * const studentTask = await prisma.studentTask.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentTaskCreateManyArgs>(args?: SelectSubset<T, StudentTaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StudentTasks and returns the data saved in the database.
     * @param {StudentTaskCreateManyAndReturnArgs} args - Arguments to create many StudentTasks.
     * @example
     * // Create many StudentTasks
     * const studentTask = await prisma.studentTask.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StudentTasks and only return the `id`
     * const studentTaskWithIdOnly = await prisma.studentTask.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentTaskCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentTaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentTaskPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StudentTask.
     * @param {StudentTaskDeleteArgs} args - Arguments to delete one StudentTask.
     * @example
     * // Delete one StudentTask
     * const StudentTask = await prisma.studentTask.delete({
     *   where: {
     *     // ... filter to delete one StudentTask
     *   }
     * })
     * 
     */
    delete<T extends StudentTaskDeleteArgs>(args: SelectSubset<T, StudentTaskDeleteArgs<ExtArgs>>): Prisma__StudentTaskClient<$Result.GetResult<Prisma.$StudentTaskPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StudentTask.
     * @param {StudentTaskUpdateArgs} args - Arguments to update one StudentTask.
     * @example
     * // Update one StudentTask
     * const studentTask = await prisma.studentTask.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentTaskUpdateArgs>(args: SelectSubset<T, StudentTaskUpdateArgs<ExtArgs>>): Prisma__StudentTaskClient<$Result.GetResult<Prisma.$StudentTaskPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StudentTasks.
     * @param {StudentTaskDeleteManyArgs} args - Arguments to filter StudentTasks to delete.
     * @example
     * // Delete a few StudentTasks
     * const { count } = await prisma.studentTask.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentTaskDeleteManyArgs>(args?: SelectSubset<T, StudentTaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentTaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentTasks
     * const studentTask = await prisma.studentTask.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentTaskUpdateManyArgs>(args: SelectSubset<T, StudentTaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentTasks and returns the data updated in the database.
     * @param {StudentTaskUpdateManyAndReturnArgs} args - Arguments to update many StudentTasks.
     * @example
     * // Update many StudentTasks
     * const studentTask = await prisma.studentTask.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StudentTasks and only return the `id`
     * const studentTaskWithIdOnly = await prisma.studentTask.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StudentTaskUpdateManyAndReturnArgs>(args: SelectSubset<T, StudentTaskUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentTaskPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StudentTask.
     * @param {StudentTaskUpsertArgs} args - Arguments to update or create a StudentTask.
     * @example
     * // Update or create a StudentTask
     * const studentTask = await prisma.studentTask.upsert({
     *   create: {
     *     // ... data to create a StudentTask
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentTask we want to update
     *   }
     * })
     */
    upsert<T extends StudentTaskUpsertArgs>(args: SelectSubset<T, StudentTaskUpsertArgs<ExtArgs>>): Prisma__StudentTaskClient<$Result.GetResult<Prisma.$StudentTaskPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StudentTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentTaskCountArgs} args - Arguments to filter StudentTasks to count.
     * @example
     * // Count the number of StudentTasks
     * const count = await prisma.studentTask.count({
     *   where: {
     *     // ... the filter for the StudentTasks we want to count
     *   }
     * })
    **/
    count<T extends StudentTaskCountArgs>(
      args?: Subset<T, StudentTaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentTaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentTaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentTaskAggregateArgs>(args: Subset<T, StudentTaskAggregateArgs>): Prisma.PrismaPromise<GetStudentTaskAggregateType<T>>

    /**
     * Group by StudentTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentTaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentTaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentTaskGroupByArgs['orderBy'] }
        : { orderBy?: StudentTaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentTaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentTask model
   */
  readonly fields: StudentTaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentTask.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentTaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    faculty<T extends StudentTask$facultyArgs<ExtArgs> = {}>(args?: Subset<T, StudentTask$facultyArgs<ExtArgs>>): Prisma__FacultyClient<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    clientAdmin<T extends ClientAdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientAdminDefaultArgs<ExtArgs>>): Prisma__ClientAdminClient<$Result.GetResult<Prisma.$ClientAdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudentTask model
   */
  interface StudentTaskFieldRefs {
    readonly id: FieldRef<"StudentTask", 'Int'>
    readonly studentId: FieldRef<"StudentTask", 'Int'>
    readonly courseId: FieldRef<"StudentTask", 'Int'>
    readonly assignedDate: FieldRef<"StudentTask", 'DateTime'>
    readonly dueDate: FieldRef<"StudentTask", 'DateTime'>
    readonly description: FieldRef<"StudentTask", 'String'>
    readonly status: FieldRef<"StudentTask", 'String'>
    readonly facultyRemarks: FieldRef<"StudentTask", 'String'>
    readonly grade: FieldRef<"StudentTask", 'String'>
    readonly facultyId: FieldRef<"StudentTask", 'Int'>
    readonly clientAdminId: FieldRef<"StudentTask", 'String'>
  }
    

  // Custom InputTypes
  /**
   * StudentTask findUnique
   */
  export type StudentTaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTask
     */
    select?: StudentTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentTask
     */
    omit?: StudentTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTaskInclude<ExtArgs> | null
    /**
     * Filter, which StudentTask to fetch.
     */
    where: StudentTaskWhereUniqueInput
  }

  /**
   * StudentTask findUniqueOrThrow
   */
  export type StudentTaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTask
     */
    select?: StudentTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentTask
     */
    omit?: StudentTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTaskInclude<ExtArgs> | null
    /**
     * Filter, which StudentTask to fetch.
     */
    where: StudentTaskWhereUniqueInput
  }

  /**
   * StudentTask findFirst
   */
  export type StudentTaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTask
     */
    select?: StudentTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentTask
     */
    omit?: StudentTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTaskInclude<ExtArgs> | null
    /**
     * Filter, which StudentTask to fetch.
     */
    where?: StudentTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentTasks to fetch.
     */
    orderBy?: StudentTaskOrderByWithRelationInput | StudentTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentTasks.
     */
    cursor?: StudentTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentTasks.
     */
    distinct?: StudentTaskScalarFieldEnum | StudentTaskScalarFieldEnum[]
  }

  /**
   * StudentTask findFirstOrThrow
   */
  export type StudentTaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTask
     */
    select?: StudentTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentTask
     */
    omit?: StudentTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTaskInclude<ExtArgs> | null
    /**
     * Filter, which StudentTask to fetch.
     */
    where?: StudentTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentTasks to fetch.
     */
    orderBy?: StudentTaskOrderByWithRelationInput | StudentTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentTasks.
     */
    cursor?: StudentTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentTasks.
     */
    distinct?: StudentTaskScalarFieldEnum | StudentTaskScalarFieldEnum[]
  }

  /**
   * StudentTask findMany
   */
  export type StudentTaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTask
     */
    select?: StudentTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentTask
     */
    omit?: StudentTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTaskInclude<ExtArgs> | null
    /**
     * Filter, which StudentTasks to fetch.
     */
    where?: StudentTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentTasks to fetch.
     */
    orderBy?: StudentTaskOrderByWithRelationInput | StudentTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentTasks.
     */
    cursor?: StudentTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentTasks.
     */
    skip?: number
    distinct?: StudentTaskScalarFieldEnum | StudentTaskScalarFieldEnum[]
  }

  /**
   * StudentTask create
   */
  export type StudentTaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTask
     */
    select?: StudentTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentTask
     */
    omit?: StudentTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTaskInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentTask.
     */
    data: XOR<StudentTaskCreateInput, StudentTaskUncheckedCreateInput>
  }

  /**
   * StudentTask createMany
   */
  export type StudentTaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentTasks.
     */
    data: StudentTaskCreateManyInput | StudentTaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StudentTask createManyAndReturn
   */
  export type StudentTaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTask
     */
    select?: StudentTaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StudentTask
     */
    omit?: StudentTaskOmit<ExtArgs> | null
    /**
     * The data used to create many StudentTasks.
     */
    data: StudentTaskCreateManyInput | StudentTaskCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTaskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentTask update
   */
  export type StudentTaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTask
     */
    select?: StudentTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentTask
     */
    omit?: StudentTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTaskInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentTask.
     */
    data: XOR<StudentTaskUpdateInput, StudentTaskUncheckedUpdateInput>
    /**
     * Choose, which StudentTask to update.
     */
    where: StudentTaskWhereUniqueInput
  }

  /**
   * StudentTask updateMany
   */
  export type StudentTaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentTasks.
     */
    data: XOR<StudentTaskUpdateManyMutationInput, StudentTaskUncheckedUpdateManyInput>
    /**
     * Filter which StudentTasks to update
     */
    where?: StudentTaskWhereInput
    /**
     * Limit how many StudentTasks to update.
     */
    limit?: number
  }

  /**
   * StudentTask updateManyAndReturn
   */
  export type StudentTaskUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTask
     */
    select?: StudentTaskSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StudentTask
     */
    omit?: StudentTaskOmit<ExtArgs> | null
    /**
     * The data used to update StudentTasks.
     */
    data: XOR<StudentTaskUpdateManyMutationInput, StudentTaskUncheckedUpdateManyInput>
    /**
     * Filter which StudentTasks to update
     */
    where?: StudentTaskWhereInput
    /**
     * Limit how many StudentTasks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTaskIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentTask upsert
   */
  export type StudentTaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTask
     */
    select?: StudentTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentTask
     */
    omit?: StudentTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTaskInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentTask to update in case it exists.
     */
    where: StudentTaskWhereUniqueInput
    /**
     * In case the StudentTask found by the `where` argument doesn't exist, create a new StudentTask with this data.
     */
    create: XOR<StudentTaskCreateInput, StudentTaskUncheckedCreateInput>
    /**
     * In case the StudentTask was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentTaskUpdateInput, StudentTaskUncheckedUpdateInput>
  }

  /**
   * StudentTask delete
   */
  export type StudentTaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTask
     */
    select?: StudentTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentTask
     */
    omit?: StudentTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTaskInclude<ExtArgs> | null
    /**
     * Filter which StudentTask to delete.
     */
    where: StudentTaskWhereUniqueInput
  }

  /**
   * StudentTask deleteMany
   */
  export type StudentTaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentTasks to delete
     */
    where?: StudentTaskWhereInput
    /**
     * Limit how many StudentTasks to delete.
     */
    limit?: number
  }

  /**
   * StudentTask.faculty
   */
  export type StudentTask$facultyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faculty
     */
    omit?: FacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyInclude<ExtArgs> | null
    where?: FacultyWhereInput
  }

  /**
   * StudentTask without action
   */
  export type StudentTaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTask
     */
    select?: StudentTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentTask
     */
    omit?: StudentTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTaskInclude<ExtArgs> | null
  }


  /**
   * Model StudentTest
   */

  export type AggregateStudentTest = {
    _count: StudentTestCountAggregateOutputType | null
    _avg: StudentTestAvgAggregateOutputType | null
    _sum: StudentTestSumAggregateOutputType | null
    _min: StudentTestMinAggregateOutputType | null
    _max: StudentTestMaxAggregateOutputType | null
  }

  export type StudentTestAvgAggregateOutputType = {
    id: number | null
    studentId: number | null
    courseId: number | null
    totalMarks: number | null
    marksObtained: number | null
  }

  export type StudentTestSumAggregateOutputType = {
    id: number | null
    studentId: number | null
    courseId: number | null
    totalMarks: number | null
    marksObtained: number | null
  }

  export type StudentTestMinAggregateOutputType = {
    id: number | null
    studentId: number | null
    courseId: number | null
    testName: string | null
    testDate: Date | null
    totalMarks: number | null
    marksObtained: number | null
    grade: string | null
    clientAdminId: string | null
  }

  export type StudentTestMaxAggregateOutputType = {
    id: number | null
    studentId: number | null
    courseId: number | null
    testName: string | null
    testDate: Date | null
    totalMarks: number | null
    marksObtained: number | null
    grade: string | null
    clientAdminId: string | null
  }

  export type StudentTestCountAggregateOutputType = {
    id: number
    studentId: number
    courseId: number
    testName: number
    testDate: number
    totalMarks: number
    marksObtained: number
    grade: number
    clientAdminId: number
    _all: number
  }


  export type StudentTestAvgAggregateInputType = {
    id?: true
    studentId?: true
    courseId?: true
    totalMarks?: true
    marksObtained?: true
  }

  export type StudentTestSumAggregateInputType = {
    id?: true
    studentId?: true
    courseId?: true
    totalMarks?: true
    marksObtained?: true
  }

  export type StudentTestMinAggregateInputType = {
    id?: true
    studentId?: true
    courseId?: true
    testName?: true
    testDate?: true
    totalMarks?: true
    marksObtained?: true
    grade?: true
    clientAdminId?: true
  }

  export type StudentTestMaxAggregateInputType = {
    id?: true
    studentId?: true
    courseId?: true
    testName?: true
    testDate?: true
    totalMarks?: true
    marksObtained?: true
    grade?: true
    clientAdminId?: true
  }

  export type StudentTestCountAggregateInputType = {
    id?: true
    studentId?: true
    courseId?: true
    testName?: true
    testDate?: true
    totalMarks?: true
    marksObtained?: true
    grade?: true
    clientAdminId?: true
    _all?: true
  }

  export type StudentTestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentTest to aggregate.
     */
    where?: StudentTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentTests to fetch.
     */
    orderBy?: StudentTestOrderByWithRelationInput | StudentTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentTests
    **/
    _count?: true | StudentTestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentTestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentTestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentTestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentTestMaxAggregateInputType
  }

  export type GetStudentTestAggregateType<T extends StudentTestAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentTest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentTest[P]>
      : GetScalarType<T[P], AggregateStudentTest[P]>
  }




  export type StudentTestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentTestWhereInput
    orderBy?: StudentTestOrderByWithAggregationInput | StudentTestOrderByWithAggregationInput[]
    by: StudentTestScalarFieldEnum[] | StudentTestScalarFieldEnum
    having?: StudentTestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentTestCountAggregateInputType | true
    _avg?: StudentTestAvgAggregateInputType
    _sum?: StudentTestSumAggregateInputType
    _min?: StudentTestMinAggregateInputType
    _max?: StudentTestMaxAggregateInputType
  }

  export type StudentTestGroupByOutputType = {
    id: number
    studentId: number
    courseId: number
    testName: string
    testDate: Date
    totalMarks: number
    marksObtained: number
    grade: string
    clientAdminId: string
    _count: StudentTestCountAggregateOutputType | null
    _avg: StudentTestAvgAggregateOutputType | null
    _sum: StudentTestSumAggregateOutputType | null
    _min: StudentTestMinAggregateOutputType | null
    _max: StudentTestMaxAggregateOutputType | null
  }

  type GetStudentTestGroupByPayload<T extends StudentTestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentTestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentTestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentTestGroupByOutputType[P]>
            : GetScalarType<T[P], StudentTestGroupByOutputType[P]>
        }
      >
    >


  export type StudentTestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    courseId?: boolean
    testName?: boolean
    testDate?: boolean
    totalMarks?: boolean
    marksObtained?: boolean
    grade?: boolean
    clientAdminId?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentTest"]>

  export type StudentTestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    courseId?: boolean
    testName?: boolean
    testDate?: boolean
    totalMarks?: boolean
    marksObtained?: boolean
    grade?: boolean
    clientAdminId?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentTest"]>

  export type StudentTestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    courseId?: boolean
    testName?: boolean
    testDate?: boolean
    totalMarks?: boolean
    marksObtained?: boolean
    grade?: boolean
    clientAdminId?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentTest"]>

  export type StudentTestSelectScalar = {
    id?: boolean
    studentId?: boolean
    courseId?: boolean
    testName?: boolean
    testDate?: boolean
    totalMarks?: boolean
    marksObtained?: boolean
    grade?: boolean
    clientAdminId?: boolean
  }

  export type StudentTestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "courseId" | "testName" | "testDate" | "totalMarks" | "marksObtained" | "grade" | "clientAdminId", ExtArgs["result"]["studentTest"]>
  export type StudentTestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }
  export type StudentTestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }
  export type StudentTestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }

  export type $StudentTestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentTest"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      course: Prisma.$CoursePayload<ExtArgs>
      clientAdmin: Prisma.$ClientAdminPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      studentId: number
      courseId: number
      testName: string
      testDate: Date
      totalMarks: number
      marksObtained: number
      grade: string
      clientAdminId: string
    }, ExtArgs["result"]["studentTest"]>
    composites: {}
  }

  type StudentTestGetPayload<S extends boolean | null | undefined | StudentTestDefaultArgs> = $Result.GetResult<Prisma.$StudentTestPayload, S>

  type StudentTestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudentTestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentTestCountAggregateInputType | true
    }

  export interface StudentTestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentTest'], meta: { name: 'StudentTest' } }
    /**
     * Find zero or one StudentTest that matches the filter.
     * @param {StudentTestFindUniqueArgs} args - Arguments to find a StudentTest
     * @example
     * // Get one StudentTest
     * const studentTest = await prisma.studentTest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentTestFindUniqueArgs>(args: SelectSubset<T, StudentTestFindUniqueArgs<ExtArgs>>): Prisma__StudentTestClient<$Result.GetResult<Prisma.$StudentTestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StudentTest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudentTestFindUniqueOrThrowArgs} args - Arguments to find a StudentTest
     * @example
     * // Get one StudentTest
     * const studentTest = await prisma.studentTest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentTestFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentTestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentTestClient<$Result.GetResult<Prisma.$StudentTestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentTest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentTestFindFirstArgs} args - Arguments to find a StudentTest
     * @example
     * // Get one StudentTest
     * const studentTest = await prisma.studentTest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentTestFindFirstArgs>(args?: SelectSubset<T, StudentTestFindFirstArgs<ExtArgs>>): Prisma__StudentTestClient<$Result.GetResult<Prisma.$StudentTestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentTest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentTestFindFirstOrThrowArgs} args - Arguments to find a StudentTest
     * @example
     * // Get one StudentTest
     * const studentTest = await prisma.studentTest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentTestFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentTestFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentTestClient<$Result.GetResult<Prisma.$StudentTestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StudentTests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentTestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentTests
     * const studentTests = await prisma.studentTest.findMany()
     * 
     * // Get first 10 StudentTests
     * const studentTests = await prisma.studentTest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentTestWithIdOnly = await prisma.studentTest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentTestFindManyArgs>(args?: SelectSubset<T, StudentTestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentTestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StudentTest.
     * @param {StudentTestCreateArgs} args - Arguments to create a StudentTest.
     * @example
     * // Create one StudentTest
     * const StudentTest = await prisma.studentTest.create({
     *   data: {
     *     // ... data to create a StudentTest
     *   }
     * })
     * 
     */
    create<T extends StudentTestCreateArgs>(args: SelectSubset<T, StudentTestCreateArgs<ExtArgs>>): Prisma__StudentTestClient<$Result.GetResult<Prisma.$StudentTestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StudentTests.
     * @param {StudentTestCreateManyArgs} args - Arguments to create many StudentTests.
     * @example
     * // Create many StudentTests
     * const studentTest = await prisma.studentTest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentTestCreateManyArgs>(args?: SelectSubset<T, StudentTestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StudentTests and returns the data saved in the database.
     * @param {StudentTestCreateManyAndReturnArgs} args - Arguments to create many StudentTests.
     * @example
     * // Create many StudentTests
     * const studentTest = await prisma.studentTest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StudentTests and only return the `id`
     * const studentTestWithIdOnly = await prisma.studentTest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentTestCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentTestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentTestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StudentTest.
     * @param {StudentTestDeleteArgs} args - Arguments to delete one StudentTest.
     * @example
     * // Delete one StudentTest
     * const StudentTest = await prisma.studentTest.delete({
     *   where: {
     *     // ... filter to delete one StudentTest
     *   }
     * })
     * 
     */
    delete<T extends StudentTestDeleteArgs>(args: SelectSubset<T, StudentTestDeleteArgs<ExtArgs>>): Prisma__StudentTestClient<$Result.GetResult<Prisma.$StudentTestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StudentTest.
     * @param {StudentTestUpdateArgs} args - Arguments to update one StudentTest.
     * @example
     * // Update one StudentTest
     * const studentTest = await prisma.studentTest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentTestUpdateArgs>(args: SelectSubset<T, StudentTestUpdateArgs<ExtArgs>>): Prisma__StudentTestClient<$Result.GetResult<Prisma.$StudentTestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StudentTests.
     * @param {StudentTestDeleteManyArgs} args - Arguments to filter StudentTests to delete.
     * @example
     * // Delete a few StudentTests
     * const { count } = await prisma.studentTest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentTestDeleteManyArgs>(args?: SelectSubset<T, StudentTestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentTests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentTestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentTests
     * const studentTest = await prisma.studentTest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentTestUpdateManyArgs>(args: SelectSubset<T, StudentTestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentTests and returns the data updated in the database.
     * @param {StudentTestUpdateManyAndReturnArgs} args - Arguments to update many StudentTests.
     * @example
     * // Update many StudentTests
     * const studentTest = await prisma.studentTest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StudentTests and only return the `id`
     * const studentTestWithIdOnly = await prisma.studentTest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StudentTestUpdateManyAndReturnArgs>(args: SelectSubset<T, StudentTestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentTestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StudentTest.
     * @param {StudentTestUpsertArgs} args - Arguments to update or create a StudentTest.
     * @example
     * // Update or create a StudentTest
     * const studentTest = await prisma.studentTest.upsert({
     *   create: {
     *     // ... data to create a StudentTest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentTest we want to update
     *   }
     * })
     */
    upsert<T extends StudentTestUpsertArgs>(args: SelectSubset<T, StudentTestUpsertArgs<ExtArgs>>): Prisma__StudentTestClient<$Result.GetResult<Prisma.$StudentTestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StudentTests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentTestCountArgs} args - Arguments to filter StudentTests to count.
     * @example
     * // Count the number of StudentTests
     * const count = await prisma.studentTest.count({
     *   where: {
     *     // ... the filter for the StudentTests we want to count
     *   }
     * })
    **/
    count<T extends StudentTestCountArgs>(
      args?: Subset<T, StudentTestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentTestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentTest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentTestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentTestAggregateArgs>(args: Subset<T, StudentTestAggregateArgs>): Prisma.PrismaPromise<GetStudentTestAggregateType<T>>

    /**
     * Group by StudentTest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentTestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentTestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentTestGroupByArgs['orderBy'] }
        : { orderBy?: StudentTestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentTestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentTestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentTest model
   */
  readonly fields: StudentTestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentTest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentTestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    clientAdmin<T extends ClientAdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientAdminDefaultArgs<ExtArgs>>): Prisma__ClientAdminClient<$Result.GetResult<Prisma.$ClientAdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudentTest model
   */
  interface StudentTestFieldRefs {
    readonly id: FieldRef<"StudentTest", 'Int'>
    readonly studentId: FieldRef<"StudentTest", 'Int'>
    readonly courseId: FieldRef<"StudentTest", 'Int'>
    readonly testName: FieldRef<"StudentTest", 'String'>
    readonly testDate: FieldRef<"StudentTest", 'DateTime'>
    readonly totalMarks: FieldRef<"StudentTest", 'Int'>
    readonly marksObtained: FieldRef<"StudentTest", 'Int'>
    readonly grade: FieldRef<"StudentTest", 'String'>
    readonly clientAdminId: FieldRef<"StudentTest", 'String'>
  }
    

  // Custom InputTypes
  /**
   * StudentTest findUnique
   */
  export type StudentTestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTest
     */
    select?: StudentTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentTest
     */
    omit?: StudentTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTestInclude<ExtArgs> | null
    /**
     * Filter, which StudentTest to fetch.
     */
    where: StudentTestWhereUniqueInput
  }

  /**
   * StudentTest findUniqueOrThrow
   */
  export type StudentTestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTest
     */
    select?: StudentTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentTest
     */
    omit?: StudentTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTestInclude<ExtArgs> | null
    /**
     * Filter, which StudentTest to fetch.
     */
    where: StudentTestWhereUniqueInput
  }

  /**
   * StudentTest findFirst
   */
  export type StudentTestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTest
     */
    select?: StudentTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentTest
     */
    omit?: StudentTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTestInclude<ExtArgs> | null
    /**
     * Filter, which StudentTest to fetch.
     */
    where?: StudentTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentTests to fetch.
     */
    orderBy?: StudentTestOrderByWithRelationInput | StudentTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentTests.
     */
    cursor?: StudentTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentTests.
     */
    distinct?: StudentTestScalarFieldEnum | StudentTestScalarFieldEnum[]
  }

  /**
   * StudentTest findFirstOrThrow
   */
  export type StudentTestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTest
     */
    select?: StudentTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentTest
     */
    omit?: StudentTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTestInclude<ExtArgs> | null
    /**
     * Filter, which StudentTest to fetch.
     */
    where?: StudentTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentTests to fetch.
     */
    orderBy?: StudentTestOrderByWithRelationInput | StudentTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentTests.
     */
    cursor?: StudentTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentTests.
     */
    distinct?: StudentTestScalarFieldEnum | StudentTestScalarFieldEnum[]
  }

  /**
   * StudentTest findMany
   */
  export type StudentTestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTest
     */
    select?: StudentTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentTest
     */
    omit?: StudentTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTestInclude<ExtArgs> | null
    /**
     * Filter, which StudentTests to fetch.
     */
    where?: StudentTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentTests to fetch.
     */
    orderBy?: StudentTestOrderByWithRelationInput | StudentTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentTests.
     */
    cursor?: StudentTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentTests.
     */
    skip?: number
    distinct?: StudentTestScalarFieldEnum | StudentTestScalarFieldEnum[]
  }

  /**
   * StudentTest create
   */
  export type StudentTestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTest
     */
    select?: StudentTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentTest
     */
    omit?: StudentTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTestInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentTest.
     */
    data: XOR<StudentTestCreateInput, StudentTestUncheckedCreateInput>
  }

  /**
   * StudentTest createMany
   */
  export type StudentTestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentTests.
     */
    data: StudentTestCreateManyInput | StudentTestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StudentTest createManyAndReturn
   */
  export type StudentTestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTest
     */
    select?: StudentTestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StudentTest
     */
    omit?: StudentTestOmit<ExtArgs> | null
    /**
     * The data used to create many StudentTests.
     */
    data: StudentTestCreateManyInput | StudentTestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentTest update
   */
  export type StudentTestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTest
     */
    select?: StudentTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentTest
     */
    omit?: StudentTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTestInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentTest.
     */
    data: XOR<StudentTestUpdateInput, StudentTestUncheckedUpdateInput>
    /**
     * Choose, which StudentTest to update.
     */
    where: StudentTestWhereUniqueInput
  }

  /**
   * StudentTest updateMany
   */
  export type StudentTestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentTests.
     */
    data: XOR<StudentTestUpdateManyMutationInput, StudentTestUncheckedUpdateManyInput>
    /**
     * Filter which StudentTests to update
     */
    where?: StudentTestWhereInput
    /**
     * Limit how many StudentTests to update.
     */
    limit?: number
  }

  /**
   * StudentTest updateManyAndReturn
   */
  export type StudentTestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTest
     */
    select?: StudentTestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StudentTest
     */
    omit?: StudentTestOmit<ExtArgs> | null
    /**
     * The data used to update StudentTests.
     */
    data: XOR<StudentTestUpdateManyMutationInput, StudentTestUncheckedUpdateManyInput>
    /**
     * Filter which StudentTests to update
     */
    where?: StudentTestWhereInput
    /**
     * Limit how many StudentTests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentTest upsert
   */
  export type StudentTestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTest
     */
    select?: StudentTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentTest
     */
    omit?: StudentTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTestInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentTest to update in case it exists.
     */
    where: StudentTestWhereUniqueInput
    /**
     * In case the StudentTest found by the `where` argument doesn't exist, create a new StudentTest with this data.
     */
    create: XOR<StudentTestCreateInput, StudentTestUncheckedCreateInput>
    /**
     * In case the StudentTest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentTestUpdateInput, StudentTestUncheckedUpdateInput>
  }

  /**
   * StudentTest delete
   */
  export type StudentTestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTest
     */
    select?: StudentTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentTest
     */
    omit?: StudentTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTestInclude<ExtArgs> | null
    /**
     * Filter which StudentTest to delete.
     */
    where: StudentTestWhereUniqueInput
  }

  /**
   * StudentTest deleteMany
   */
  export type StudentTestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentTests to delete
     */
    where?: StudentTestWhereInput
    /**
     * Limit how many StudentTests to delete.
     */
    limit?: number
  }

  /**
   * StudentTest without action
   */
  export type StudentTestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTest
     */
    select?: StudentTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentTest
     */
    omit?: StudentTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTestInclude<ExtArgs> | null
  }


  /**
   * Model CourseCompletion
   */

  export type AggregateCourseCompletion = {
    _count: CourseCompletionCountAggregateOutputType | null
    _avg: CourseCompletionAvgAggregateOutputType | null
    _sum: CourseCompletionSumAggregateOutputType | null
    _min: CourseCompletionMinAggregateOutputType | null
    _max: CourseCompletionMaxAggregateOutputType | null
  }

  export type CourseCompletionAvgAggregateOutputType = {
    id: number | null
    studentCourseId: number | null
    studentId: number | null
  }

  export type CourseCompletionSumAggregateOutputType = {
    id: number | null
    studentCourseId: number | null
    studentId: number | null
  }

  export type CourseCompletionMinAggregateOutputType = {
    id: number | null
    studentCourseId: number | null
    studentId: number | null
    completionDate: Date | null
    feedback: string | null
    remarks: string | null
    clientAdminId: string | null
  }

  export type CourseCompletionMaxAggregateOutputType = {
    id: number | null
    studentCourseId: number | null
    studentId: number | null
    completionDate: Date | null
    feedback: string | null
    remarks: string | null
    clientAdminId: string | null
  }

  export type CourseCompletionCountAggregateOutputType = {
    id: number
    studentCourseId: number
    studentId: number
    completionDate: number
    feedback: number
    remarks: number
    clientAdminId: number
    _all: number
  }


  export type CourseCompletionAvgAggregateInputType = {
    id?: true
    studentCourseId?: true
    studentId?: true
  }

  export type CourseCompletionSumAggregateInputType = {
    id?: true
    studentCourseId?: true
    studentId?: true
  }

  export type CourseCompletionMinAggregateInputType = {
    id?: true
    studentCourseId?: true
    studentId?: true
    completionDate?: true
    feedback?: true
    remarks?: true
    clientAdminId?: true
  }

  export type CourseCompletionMaxAggregateInputType = {
    id?: true
    studentCourseId?: true
    studentId?: true
    completionDate?: true
    feedback?: true
    remarks?: true
    clientAdminId?: true
  }

  export type CourseCompletionCountAggregateInputType = {
    id?: true
    studentCourseId?: true
    studentId?: true
    completionDate?: true
    feedback?: true
    remarks?: true
    clientAdminId?: true
    _all?: true
  }

  export type CourseCompletionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseCompletion to aggregate.
     */
    where?: CourseCompletionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseCompletions to fetch.
     */
    orderBy?: CourseCompletionOrderByWithRelationInput | CourseCompletionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseCompletionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseCompletions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseCompletions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CourseCompletions
    **/
    _count?: true | CourseCompletionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CourseCompletionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CourseCompletionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseCompletionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseCompletionMaxAggregateInputType
  }

  export type GetCourseCompletionAggregateType<T extends CourseCompletionAggregateArgs> = {
        [P in keyof T & keyof AggregateCourseCompletion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourseCompletion[P]>
      : GetScalarType<T[P], AggregateCourseCompletion[P]>
  }




  export type CourseCompletionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseCompletionWhereInput
    orderBy?: CourseCompletionOrderByWithAggregationInput | CourseCompletionOrderByWithAggregationInput[]
    by: CourseCompletionScalarFieldEnum[] | CourseCompletionScalarFieldEnum
    having?: CourseCompletionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseCompletionCountAggregateInputType | true
    _avg?: CourseCompletionAvgAggregateInputType
    _sum?: CourseCompletionSumAggregateInputType
    _min?: CourseCompletionMinAggregateInputType
    _max?: CourseCompletionMaxAggregateInputType
  }

  export type CourseCompletionGroupByOutputType = {
    id: number
    studentCourseId: number
    studentId: number
    completionDate: Date
    feedback: string | null
    remarks: string | null
    clientAdminId: string
    _count: CourseCompletionCountAggregateOutputType | null
    _avg: CourseCompletionAvgAggregateOutputType | null
    _sum: CourseCompletionSumAggregateOutputType | null
    _min: CourseCompletionMinAggregateOutputType | null
    _max: CourseCompletionMaxAggregateOutputType | null
  }

  type GetCourseCompletionGroupByPayload<T extends CourseCompletionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseCompletionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseCompletionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseCompletionGroupByOutputType[P]>
            : GetScalarType<T[P], CourseCompletionGroupByOutputType[P]>
        }
      >
    >


  export type CourseCompletionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentCourseId?: boolean
    studentId?: boolean
    completionDate?: boolean
    feedback?: boolean
    remarks?: boolean
    clientAdminId?: boolean
    studentCourse?: boolean | StudentCourseDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseCompletion"]>

  export type CourseCompletionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentCourseId?: boolean
    studentId?: boolean
    completionDate?: boolean
    feedback?: boolean
    remarks?: boolean
    clientAdminId?: boolean
    studentCourse?: boolean | StudentCourseDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseCompletion"]>

  export type CourseCompletionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentCourseId?: boolean
    studentId?: boolean
    completionDate?: boolean
    feedback?: boolean
    remarks?: boolean
    clientAdminId?: boolean
    studentCourse?: boolean | StudentCourseDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseCompletion"]>

  export type CourseCompletionSelectScalar = {
    id?: boolean
    studentCourseId?: boolean
    studentId?: boolean
    completionDate?: boolean
    feedback?: boolean
    remarks?: boolean
    clientAdminId?: boolean
  }

  export type CourseCompletionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentCourseId" | "studentId" | "completionDate" | "feedback" | "remarks" | "clientAdminId", ExtArgs["result"]["courseCompletion"]>
  export type CourseCompletionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    studentCourse?: boolean | StudentCourseDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }
  export type CourseCompletionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    studentCourse?: boolean | StudentCourseDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }
  export type CourseCompletionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    studentCourse?: boolean | StudentCourseDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }

  export type $CourseCompletionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CourseCompletion"
    objects: {
      studentCourse: Prisma.$StudentCoursePayload<ExtArgs>
      student: Prisma.$StudentPayload<ExtArgs>
      clientAdmin: Prisma.$ClientAdminPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      studentCourseId: number
      studentId: number
      completionDate: Date
      feedback: string | null
      remarks: string | null
      clientAdminId: string
    }, ExtArgs["result"]["courseCompletion"]>
    composites: {}
  }

  type CourseCompletionGetPayload<S extends boolean | null | undefined | CourseCompletionDefaultArgs> = $Result.GetResult<Prisma.$CourseCompletionPayload, S>

  type CourseCompletionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CourseCompletionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CourseCompletionCountAggregateInputType | true
    }

  export interface CourseCompletionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CourseCompletion'], meta: { name: 'CourseCompletion' } }
    /**
     * Find zero or one CourseCompletion that matches the filter.
     * @param {CourseCompletionFindUniqueArgs} args - Arguments to find a CourseCompletion
     * @example
     * // Get one CourseCompletion
     * const courseCompletion = await prisma.courseCompletion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseCompletionFindUniqueArgs>(args: SelectSubset<T, CourseCompletionFindUniqueArgs<ExtArgs>>): Prisma__CourseCompletionClient<$Result.GetResult<Prisma.$CourseCompletionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CourseCompletion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CourseCompletionFindUniqueOrThrowArgs} args - Arguments to find a CourseCompletion
     * @example
     * // Get one CourseCompletion
     * const courseCompletion = await prisma.courseCompletion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseCompletionFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseCompletionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseCompletionClient<$Result.GetResult<Prisma.$CourseCompletionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CourseCompletion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseCompletionFindFirstArgs} args - Arguments to find a CourseCompletion
     * @example
     * // Get one CourseCompletion
     * const courseCompletion = await prisma.courseCompletion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseCompletionFindFirstArgs>(args?: SelectSubset<T, CourseCompletionFindFirstArgs<ExtArgs>>): Prisma__CourseCompletionClient<$Result.GetResult<Prisma.$CourseCompletionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CourseCompletion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseCompletionFindFirstOrThrowArgs} args - Arguments to find a CourseCompletion
     * @example
     * // Get one CourseCompletion
     * const courseCompletion = await prisma.courseCompletion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseCompletionFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseCompletionFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseCompletionClient<$Result.GetResult<Prisma.$CourseCompletionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CourseCompletions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseCompletionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CourseCompletions
     * const courseCompletions = await prisma.courseCompletion.findMany()
     * 
     * // Get first 10 CourseCompletions
     * const courseCompletions = await prisma.courseCompletion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courseCompletionWithIdOnly = await prisma.courseCompletion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CourseCompletionFindManyArgs>(args?: SelectSubset<T, CourseCompletionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseCompletionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CourseCompletion.
     * @param {CourseCompletionCreateArgs} args - Arguments to create a CourseCompletion.
     * @example
     * // Create one CourseCompletion
     * const CourseCompletion = await prisma.courseCompletion.create({
     *   data: {
     *     // ... data to create a CourseCompletion
     *   }
     * })
     * 
     */
    create<T extends CourseCompletionCreateArgs>(args: SelectSubset<T, CourseCompletionCreateArgs<ExtArgs>>): Prisma__CourseCompletionClient<$Result.GetResult<Prisma.$CourseCompletionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CourseCompletions.
     * @param {CourseCompletionCreateManyArgs} args - Arguments to create many CourseCompletions.
     * @example
     * // Create many CourseCompletions
     * const courseCompletion = await prisma.courseCompletion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseCompletionCreateManyArgs>(args?: SelectSubset<T, CourseCompletionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CourseCompletions and returns the data saved in the database.
     * @param {CourseCompletionCreateManyAndReturnArgs} args - Arguments to create many CourseCompletions.
     * @example
     * // Create many CourseCompletions
     * const courseCompletion = await prisma.courseCompletion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CourseCompletions and only return the `id`
     * const courseCompletionWithIdOnly = await prisma.courseCompletion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CourseCompletionCreateManyAndReturnArgs>(args?: SelectSubset<T, CourseCompletionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseCompletionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CourseCompletion.
     * @param {CourseCompletionDeleteArgs} args - Arguments to delete one CourseCompletion.
     * @example
     * // Delete one CourseCompletion
     * const CourseCompletion = await prisma.courseCompletion.delete({
     *   where: {
     *     // ... filter to delete one CourseCompletion
     *   }
     * })
     * 
     */
    delete<T extends CourseCompletionDeleteArgs>(args: SelectSubset<T, CourseCompletionDeleteArgs<ExtArgs>>): Prisma__CourseCompletionClient<$Result.GetResult<Prisma.$CourseCompletionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CourseCompletion.
     * @param {CourseCompletionUpdateArgs} args - Arguments to update one CourseCompletion.
     * @example
     * // Update one CourseCompletion
     * const courseCompletion = await prisma.courseCompletion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseCompletionUpdateArgs>(args: SelectSubset<T, CourseCompletionUpdateArgs<ExtArgs>>): Prisma__CourseCompletionClient<$Result.GetResult<Prisma.$CourseCompletionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CourseCompletions.
     * @param {CourseCompletionDeleteManyArgs} args - Arguments to filter CourseCompletions to delete.
     * @example
     * // Delete a few CourseCompletions
     * const { count } = await prisma.courseCompletion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseCompletionDeleteManyArgs>(args?: SelectSubset<T, CourseCompletionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseCompletions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseCompletionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CourseCompletions
     * const courseCompletion = await prisma.courseCompletion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseCompletionUpdateManyArgs>(args: SelectSubset<T, CourseCompletionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseCompletions and returns the data updated in the database.
     * @param {CourseCompletionUpdateManyAndReturnArgs} args - Arguments to update many CourseCompletions.
     * @example
     * // Update many CourseCompletions
     * const courseCompletion = await prisma.courseCompletion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CourseCompletions and only return the `id`
     * const courseCompletionWithIdOnly = await prisma.courseCompletion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CourseCompletionUpdateManyAndReturnArgs>(args: SelectSubset<T, CourseCompletionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseCompletionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CourseCompletion.
     * @param {CourseCompletionUpsertArgs} args - Arguments to update or create a CourseCompletion.
     * @example
     * // Update or create a CourseCompletion
     * const courseCompletion = await prisma.courseCompletion.upsert({
     *   create: {
     *     // ... data to create a CourseCompletion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CourseCompletion we want to update
     *   }
     * })
     */
    upsert<T extends CourseCompletionUpsertArgs>(args: SelectSubset<T, CourseCompletionUpsertArgs<ExtArgs>>): Prisma__CourseCompletionClient<$Result.GetResult<Prisma.$CourseCompletionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CourseCompletions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseCompletionCountArgs} args - Arguments to filter CourseCompletions to count.
     * @example
     * // Count the number of CourseCompletions
     * const count = await prisma.courseCompletion.count({
     *   where: {
     *     // ... the filter for the CourseCompletions we want to count
     *   }
     * })
    **/
    count<T extends CourseCompletionCountArgs>(
      args?: Subset<T, CourseCompletionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseCompletionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CourseCompletion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseCompletionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseCompletionAggregateArgs>(args: Subset<T, CourseCompletionAggregateArgs>): Prisma.PrismaPromise<GetCourseCompletionAggregateType<T>>

    /**
     * Group by CourseCompletion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseCompletionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseCompletionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseCompletionGroupByArgs['orderBy'] }
        : { orderBy?: CourseCompletionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseCompletionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseCompletionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CourseCompletion model
   */
  readonly fields: CourseCompletionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CourseCompletion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseCompletionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    studentCourse<T extends StudentCourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentCourseDefaultArgs<ExtArgs>>): Prisma__StudentCourseClient<$Result.GetResult<Prisma.$StudentCoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    clientAdmin<T extends ClientAdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientAdminDefaultArgs<ExtArgs>>): Prisma__ClientAdminClient<$Result.GetResult<Prisma.$ClientAdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CourseCompletion model
   */
  interface CourseCompletionFieldRefs {
    readonly id: FieldRef<"CourseCompletion", 'Int'>
    readonly studentCourseId: FieldRef<"CourseCompletion", 'Int'>
    readonly studentId: FieldRef<"CourseCompletion", 'Int'>
    readonly completionDate: FieldRef<"CourseCompletion", 'DateTime'>
    readonly feedback: FieldRef<"CourseCompletion", 'String'>
    readonly remarks: FieldRef<"CourseCompletion", 'String'>
    readonly clientAdminId: FieldRef<"CourseCompletion", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CourseCompletion findUnique
   */
  export type CourseCompletionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseCompletion
     */
    select?: CourseCompletionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseCompletion
     */
    omit?: CourseCompletionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseCompletionInclude<ExtArgs> | null
    /**
     * Filter, which CourseCompletion to fetch.
     */
    where: CourseCompletionWhereUniqueInput
  }

  /**
   * CourseCompletion findUniqueOrThrow
   */
  export type CourseCompletionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseCompletion
     */
    select?: CourseCompletionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseCompletion
     */
    omit?: CourseCompletionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseCompletionInclude<ExtArgs> | null
    /**
     * Filter, which CourseCompletion to fetch.
     */
    where: CourseCompletionWhereUniqueInput
  }

  /**
   * CourseCompletion findFirst
   */
  export type CourseCompletionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseCompletion
     */
    select?: CourseCompletionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseCompletion
     */
    omit?: CourseCompletionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseCompletionInclude<ExtArgs> | null
    /**
     * Filter, which CourseCompletion to fetch.
     */
    where?: CourseCompletionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseCompletions to fetch.
     */
    orderBy?: CourseCompletionOrderByWithRelationInput | CourseCompletionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseCompletions.
     */
    cursor?: CourseCompletionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseCompletions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseCompletions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseCompletions.
     */
    distinct?: CourseCompletionScalarFieldEnum | CourseCompletionScalarFieldEnum[]
  }

  /**
   * CourseCompletion findFirstOrThrow
   */
  export type CourseCompletionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseCompletion
     */
    select?: CourseCompletionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseCompletion
     */
    omit?: CourseCompletionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseCompletionInclude<ExtArgs> | null
    /**
     * Filter, which CourseCompletion to fetch.
     */
    where?: CourseCompletionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseCompletions to fetch.
     */
    orderBy?: CourseCompletionOrderByWithRelationInput | CourseCompletionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseCompletions.
     */
    cursor?: CourseCompletionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseCompletions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseCompletions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseCompletions.
     */
    distinct?: CourseCompletionScalarFieldEnum | CourseCompletionScalarFieldEnum[]
  }

  /**
   * CourseCompletion findMany
   */
  export type CourseCompletionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseCompletion
     */
    select?: CourseCompletionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseCompletion
     */
    omit?: CourseCompletionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseCompletionInclude<ExtArgs> | null
    /**
     * Filter, which CourseCompletions to fetch.
     */
    where?: CourseCompletionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseCompletions to fetch.
     */
    orderBy?: CourseCompletionOrderByWithRelationInput | CourseCompletionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CourseCompletions.
     */
    cursor?: CourseCompletionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseCompletions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseCompletions.
     */
    skip?: number
    distinct?: CourseCompletionScalarFieldEnum | CourseCompletionScalarFieldEnum[]
  }

  /**
   * CourseCompletion create
   */
  export type CourseCompletionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseCompletion
     */
    select?: CourseCompletionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseCompletion
     */
    omit?: CourseCompletionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseCompletionInclude<ExtArgs> | null
    /**
     * The data needed to create a CourseCompletion.
     */
    data: XOR<CourseCompletionCreateInput, CourseCompletionUncheckedCreateInput>
  }

  /**
   * CourseCompletion createMany
   */
  export type CourseCompletionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CourseCompletions.
     */
    data: CourseCompletionCreateManyInput | CourseCompletionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CourseCompletion createManyAndReturn
   */
  export type CourseCompletionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseCompletion
     */
    select?: CourseCompletionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CourseCompletion
     */
    omit?: CourseCompletionOmit<ExtArgs> | null
    /**
     * The data used to create many CourseCompletions.
     */
    data: CourseCompletionCreateManyInput | CourseCompletionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseCompletionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CourseCompletion update
   */
  export type CourseCompletionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseCompletion
     */
    select?: CourseCompletionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseCompletion
     */
    omit?: CourseCompletionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseCompletionInclude<ExtArgs> | null
    /**
     * The data needed to update a CourseCompletion.
     */
    data: XOR<CourseCompletionUpdateInput, CourseCompletionUncheckedUpdateInput>
    /**
     * Choose, which CourseCompletion to update.
     */
    where: CourseCompletionWhereUniqueInput
  }

  /**
   * CourseCompletion updateMany
   */
  export type CourseCompletionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CourseCompletions.
     */
    data: XOR<CourseCompletionUpdateManyMutationInput, CourseCompletionUncheckedUpdateManyInput>
    /**
     * Filter which CourseCompletions to update
     */
    where?: CourseCompletionWhereInput
    /**
     * Limit how many CourseCompletions to update.
     */
    limit?: number
  }

  /**
   * CourseCompletion updateManyAndReturn
   */
  export type CourseCompletionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseCompletion
     */
    select?: CourseCompletionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CourseCompletion
     */
    omit?: CourseCompletionOmit<ExtArgs> | null
    /**
     * The data used to update CourseCompletions.
     */
    data: XOR<CourseCompletionUpdateManyMutationInput, CourseCompletionUncheckedUpdateManyInput>
    /**
     * Filter which CourseCompletions to update
     */
    where?: CourseCompletionWhereInput
    /**
     * Limit how many CourseCompletions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseCompletionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CourseCompletion upsert
   */
  export type CourseCompletionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseCompletion
     */
    select?: CourseCompletionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseCompletion
     */
    omit?: CourseCompletionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseCompletionInclude<ExtArgs> | null
    /**
     * The filter to search for the CourseCompletion to update in case it exists.
     */
    where: CourseCompletionWhereUniqueInput
    /**
     * In case the CourseCompletion found by the `where` argument doesn't exist, create a new CourseCompletion with this data.
     */
    create: XOR<CourseCompletionCreateInput, CourseCompletionUncheckedCreateInput>
    /**
     * In case the CourseCompletion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseCompletionUpdateInput, CourseCompletionUncheckedUpdateInput>
  }

  /**
   * CourseCompletion delete
   */
  export type CourseCompletionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseCompletion
     */
    select?: CourseCompletionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseCompletion
     */
    omit?: CourseCompletionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseCompletionInclude<ExtArgs> | null
    /**
     * Filter which CourseCompletion to delete.
     */
    where: CourseCompletionWhereUniqueInput
  }

  /**
   * CourseCompletion deleteMany
   */
  export type CourseCompletionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseCompletions to delete
     */
    where?: CourseCompletionWhereInput
    /**
     * Limit how many CourseCompletions to delete.
     */
    limit?: number
  }

  /**
   * CourseCompletion without action
   */
  export type CourseCompletionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseCompletion
     */
    select?: CourseCompletionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourseCompletion
     */
    omit?: CourseCompletionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseCompletionInclude<ExtArgs> | null
  }


  /**
   * Model Certificate
   */

  export type AggregateCertificate = {
    _count: CertificateCountAggregateOutputType | null
    _avg: CertificateAvgAggregateOutputType | null
    _sum: CertificateSumAggregateOutputType | null
    _min: CertificateMinAggregateOutputType | null
    _max: CertificateMaxAggregateOutputType | null
  }

  export type CertificateAvgAggregateOutputType = {
    id: number | null
    studentId: number | null
    courseId: number | null
    studentCourseId: number | null
  }

  export type CertificateSumAggregateOutputType = {
    id: number | null
    studentId: number | null
    courseId: number | null
    studentCourseId: number | null
  }

  export type CertificateMinAggregateOutputType = {
    id: number | null
    studentId: number | null
    courseId: number | null
    studentCourseId: number | null
    issueDate: Date | null
    certificateUrl: string | null
    clientAdminId: string | null
  }

  export type CertificateMaxAggregateOutputType = {
    id: number | null
    studentId: number | null
    courseId: number | null
    studentCourseId: number | null
    issueDate: Date | null
    certificateUrl: string | null
    clientAdminId: string | null
  }

  export type CertificateCountAggregateOutputType = {
    id: number
    studentId: number
    courseId: number
    studentCourseId: number
    issueDate: number
    certificateUrl: number
    clientAdminId: number
    _all: number
  }


  export type CertificateAvgAggregateInputType = {
    id?: true
    studentId?: true
    courseId?: true
    studentCourseId?: true
  }

  export type CertificateSumAggregateInputType = {
    id?: true
    studentId?: true
    courseId?: true
    studentCourseId?: true
  }

  export type CertificateMinAggregateInputType = {
    id?: true
    studentId?: true
    courseId?: true
    studentCourseId?: true
    issueDate?: true
    certificateUrl?: true
    clientAdminId?: true
  }

  export type CertificateMaxAggregateInputType = {
    id?: true
    studentId?: true
    courseId?: true
    studentCourseId?: true
    issueDate?: true
    certificateUrl?: true
    clientAdminId?: true
  }

  export type CertificateCountAggregateInputType = {
    id?: true
    studentId?: true
    courseId?: true
    studentCourseId?: true
    issueDate?: true
    certificateUrl?: true
    clientAdminId?: true
    _all?: true
  }

  export type CertificateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Certificate to aggregate.
     */
    where?: CertificateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certificates to fetch.
     */
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CertificateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certificates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Certificates
    **/
    _count?: true | CertificateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CertificateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CertificateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CertificateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CertificateMaxAggregateInputType
  }

  export type GetCertificateAggregateType<T extends CertificateAggregateArgs> = {
        [P in keyof T & keyof AggregateCertificate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCertificate[P]>
      : GetScalarType<T[P], AggregateCertificate[P]>
  }




  export type CertificateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CertificateWhereInput
    orderBy?: CertificateOrderByWithAggregationInput | CertificateOrderByWithAggregationInput[]
    by: CertificateScalarFieldEnum[] | CertificateScalarFieldEnum
    having?: CertificateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CertificateCountAggregateInputType | true
    _avg?: CertificateAvgAggregateInputType
    _sum?: CertificateSumAggregateInputType
    _min?: CertificateMinAggregateInputType
    _max?: CertificateMaxAggregateInputType
  }

  export type CertificateGroupByOutputType = {
    id: number
    studentId: number
    courseId: number
    studentCourseId: number
    issueDate: Date
    certificateUrl: string
    clientAdminId: string
    _count: CertificateCountAggregateOutputType | null
    _avg: CertificateAvgAggregateOutputType | null
    _sum: CertificateSumAggregateOutputType | null
    _min: CertificateMinAggregateOutputType | null
    _max: CertificateMaxAggregateOutputType | null
  }

  type GetCertificateGroupByPayload<T extends CertificateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CertificateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CertificateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CertificateGroupByOutputType[P]>
            : GetScalarType<T[P], CertificateGroupByOutputType[P]>
        }
      >
    >


  export type CertificateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    courseId?: boolean
    studentCourseId?: boolean
    issueDate?: boolean
    certificateUrl?: boolean
    clientAdminId?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    studentCourse?: boolean | StudentCourseDefaultArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["certificate"]>

  export type CertificateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    courseId?: boolean
    studentCourseId?: boolean
    issueDate?: boolean
    certificateUrl?: boolean
    clientAdminId?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    studentCourse?: boolean | StudentCourseDefaultArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["certificate"]>

  export type CertificateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    courseId?: boolean
    studentCourseId?: boolean
    issueDate?: boolean
    certificateUrl?: boolean
    clientAdminId?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    studentCourse?: boolean | StudentCourseDefaultArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["certificate"]>

  export type CertificateSelectScalar = {
    id?: boolean
    studentId?: boolean
    courseId?: boolean
    studentCourseId?: boolean
    issueDate?: boolean
    certificateUrl?: boolean
    clientAdminId?: boolean
  }

  export type CertificateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "courseId" | "studentCourseId" | "issueDate" | "certificateUrl" | "clientAdminId", ExtArgs["result"]["certificate"]>
  export type CertificateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    studentCourse?: boolean | StudentCourseDefaultArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }
  export type CertificateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    studentCourse?: boolean | StudentCourseDefaultArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }
  export type CertificateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    studentCourse?: boolean | StudentCourseDefaultArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }

  export type $CertificatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Certificate"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      course: Prisma.$CoursePayload<ExtArgs>
      studentCourse: Prisma.$StudentCoursePayload<ExtArgs>
      clientAdmin: Prisma.$ClientAdminPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      studentId: number
      courseId: number
      studentCourseId: number
      issueDate: Date
      certificateUrl: string
      clientAdminId: string
    }, ExtArgs["result"]["certificate"]>
    composites: {}
  }

  type CertificateGetPayload<S extends boolean | null | undefined | CertificateDefaultArgs> = $Result.GetResult<Prisma.$CertificatePayload, S>

  type CertificateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CertificateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CertificateCountAggregateInputType | true
    }

  export interface CertificateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Certificate'], meta: { name: 'Certificate' } }
    /**
     * Find zero or one Certificate that matches the filter.
     * @param {CertificateFindUniqueArgs} args - Arguments to find a Certificate
     * @example
     * // Get one Certificate
     * const certificate = await prisma.certificate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CertificateFindUniqueArgs>(args: SelectSubset<T, CertificateFindUniqueArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Certificate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CertificateFindUniqueOrThrowArgs} args - Arguments to find a Certificate
     * @example
     * // Get one Certificate
     * const certificate = await prisma.certificate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CertificateFindUniqueOrThrowArgs>(args: SelectSubset<T, CertificateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Certificate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateFindFirstArgs} args - Arguments to find a Certificate
     * @example
     * // Get one Certificate
     * const certificate = await prisma.certificate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CertificateFindFirstArgs>(args?: SelectSubset<T, CertificateFindFirstArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Certificate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateFindFirstOrThrowArgs} args - Arguments to find a Certificate
     * @example
     * // Get one Certificate
     * const certificate = await prisma.certificate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CertificateFindFirstOrThrowArgs>(args?: SelectSubset<T, CertificateFindFirstOrThrowArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Certificates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Certificates
     * const certificates = await prisma.certificate.findMany()
     * 
     * // Get first 10 Certificates
     * const certificates = await prisma.certificate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const certificateWithIdOnly = await prisma.certificate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CertificateFindManyArgs>(args?: SelectSubset<T, CertificateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Certificate.
     * @param {CertificateCreateArgs} args - Arguments to create a Certificate.
     * @example
     * // Create one Certificate
     * const Certificate = await prisma.certificate.create({
     *   data: {
     *     // ... data to create a Certificate
     *   }
     * })
     * 
     */
    create<T extends CertificateCreateArgs>(args: SelectSubset<T, CertificateCreateArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Certificates.
     * @param {CertificateCreateManyArgs} args - Arguments to create many Certificates.
     * @example
     * // Create many Certificates
     * const certificate = await prisma.certificate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CertificateCreateManyArgs>(args?: SelectSubset<T, CertificateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Certificates and returns the data saved in the database.
     * @param {CertificateCreateManyAndReturnArgs} args - Arguments to create many Certificates.
     * @example
     * // Create many Certificates
     * const certificate = await prisma.certificate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Certificates and only return the `id`
     * const certificateWithIdOnly = await prisma.certificate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CertificateCreateManyAndReturnArgs>(args?: SelectSubset<T, CertificateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Certificate.
     * @param {CertificateDeleteArgs} args - Arguments to delete one Certificate.
     * @example
     * // Delete one Certificate
     * const Certificate = await prisma.certificate.delete({
     *   where: {
     *     // ... filter to delete one Certificate
     *   }
     * })
     * 
     */
    delete<T extends CertificateDeleteArgs>(args: SelectSubset<T, CertificateDeleteArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Certificate.
     * @param {CertificateUpdateArgs} args - Arguments to update one Certificate.
     * @example
     * // Update one Certificate
     * const certificate = await prisma.certificate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CertificateUpdateArgs>(args: SelectSubset<T, CertificateUpdateArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Certificates.
     * @param {CertificateDeleteManyArgs} args - Arguments to filter Certificates to delete.
     * @example
     * // Delete a few Certificates
     * const { count } = await prisma.certificate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CertificateDeleteManyArgs>(args?: SelectSubset<T, CertificateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Certificates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Certificates
     * const certificate = await prisma.certificate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CertificateUpdateManyArgs>(args: SelectSubset<T, CertificateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Certificates and returns the data updated in the database.
     * @param {CertificateUpdateManyAndReturnArgs} args - Arguments to update many Certificates.
     * @example
     * // Update many Certificates
     * const certificate = await prisma.certificate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Certificates and only return the `id`
     * const certificateWithIdOnly = await prisma.certificate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CertificateUpdateManyAndReturnArgs>(args: SelectSubset<T, CertificateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Certificate.
     * @param {CertificateUpsertArgs} args - Arguments to update or create a Certificate.
     * @example
     * // Update or create a Certificate
     * const certificate = await prisma.certificate.upsert({
     *   create: {
     *     // ... data to create a Certificate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Certificate we want to update
     *   }
     * })
     */
    upsert<T extends CertificateUpsertArgs>(args: SelectSubset<T, CertificateUpsertArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Certificates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateCountArgs} args - Arguments to filter Certificates to count.
     * @example
     * // Count the number of Certificates
     * const count = await prisma.certificate.count({
     *   where: {
     *     // ... the filter for the Certificates we want to count
     *   }
     * })
    **/
    count<T extends CertificateCountArgs>(
      args?: Subset<T, CertificateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CertificateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Certificate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CertificateAggregateArgs>(args: Subset<T, CertificateAggregateArgs>): Prisma.PrismaPromise<GetCertificateAggregateType<T>>

    /**
     * Group by Certificate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CertificateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CertificateGroupByArgs['orderBy'] }
        : { orderBy?: CertificateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CertificateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCertificateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Certificate model
   */
  readonly fields: CertificateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Certificate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CertificateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    studentCourse<T extends StudentCourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentCourseDefaultArgs<ExtArgs>>): Prisma__StudentCourseClient<$Result.GetResult<Prisma.$StudentCoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    clientAdmin<T extends ClientAdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientAdminDefaultArgs<ExtArgs>>): Prisma__ClientAdminClient<$Result.GetResult<Prisma.$ClientAdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Certificate model
   */
  interface CertificateFieldRefs {
    readonly id: FieldRef<"Certificate", 'Int'>
    readonly studentId: FieldRef<"Certificate", 'Int'>
    readonly courseId: FieldRef<"Certificate", 'Int'>
    readonly studentCourseId: FieldRef<"Certificate", 'Int'>
    readonly issueDate: FieldRef<"Certificate", 'DateTime'>
    readonly certificateUrl: FieldRef<"Certificate", 'String'>
    readonly clientAdminId: FieldRef<"Certificate", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Certificate findUnique
   */
  export type CertificateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter, which Certificate to fetch.
     */
    where: CertificateWhereUniqueInput
  }

  /**
   * Certificate findUniqueOrThrow
   */
  export type CertificateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter, which Certificate to fetch.
     */
    where: CertificateWhereUniqueInput
  }

  /**
   * Certificate findFirst
   */
  export type CertificateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter, which Certificate to fetch.
     */
    where?: CertificateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certificates to fetch.
     */
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Certificates.
     */
    cursor?: CertificateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certificates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Certificates.
     */
    distinct?: CertificateScalarFieldEnum | CertificateScalarFieldEnum[]
  }

  /**
   * Certificate findFirstOrThrow
   */
  export type CertificateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter, which Certificate to fetch.
     */
    where?: CertificateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certificates to fetch.
     */
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Certificates.
     */
    cursor?: CertificateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certificates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Certificates.
     */
    distinct?: CertificateScalarFieldEnum | CertificateScalarFieldEnum[]
  }

  /**
   * Certificate findMany
   */
  export type CertificateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter, which Certificates to fetch.
     */
    where?: CertificateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certificates to fetch.
     */
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Certificates.
     */
    cursor?: CertificateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certificates.
     */
    skip?: number
    distinct?: CertificateScalarFieldEnum | CertificateScalarFieldEnum[]
  }

  /**
   * Certificate create
   */
  export type CertificateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * The data needed to create a Certificate.
     */
    data: XOR<CertificateCreateInput, CertificateUncheckedCreateInput>
  }

  /**
   * Certificate createMany
   */
  export type CertificateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Certificates.
     */
    data: CertificateCreateManyInput | CertificateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Certificate createManyAndReturn
   */
  export type CertificateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * The data used to create many Certificates.
     */
    data: CertificateCreateManyInput | CertificateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Certificate update
   */
  export type CertificateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * The data needed to update a Certificate.
     */
    data: XOR<CertificateUpdateInput, CertificateUncheckedUpdateInput>
    /**
     * Choose, which Certificate to update.
     */
    where: CertificateWhereUniqueInput
  }

  /**
   * Certificate updateMany
   */
  export type CertificateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Certificates.
     */
    data: XOR<CertificateUpdateManyMutationInput, CertificateUncheckedUpdateManyInput>
    /**
     * Filter which Certificates to update
     */
    where?: CertificateWhereInput
    /**
     * Limit how many Certificates to update.
     */
    limit?: number
  }

  /**
   * Certificate updateManyAndReturn
   */
  export type CertificateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * The data used to update Certificates.
     */
    data: XOR<CertificateUpdateManyMutationInput, CertificateUncheckedUpdateManyInput>
    /**
     * Filter which Certificates to update
     */
    where?: CertificateWhereInput
    /**
     * Limit how many Certificates to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Certificate upsert
   */
  export type CertificateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * The filter to search for the Certificate to update in case it exists.
     */
    where: CertificateWhereUniqueInput
    /**
     * In case the Certificate found by the `where` argument doesn't exist, create a new Certificate with this data.
     */
    create: XOR<CertificateCreateInput, CertificateUncheckedCreateInput>
    /**
     * In case the Certificate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CertificateUpdateInput, CertificateUncheckedUpdateInput>
  }

  /**
   * Certificate delete
   */
  export type CertificateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter which Certificate to delete.
     */
    where: CertificateWhereUniqueInput
  }

  /**
   * Certificate deleteMany
   */
  export type CertificateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Certificates to delete
     */
    where?: CertificateWhereInput
    /**
     * Limit how many Certificates to delete.
     */
    limit?: number
  }

  /**
   * Certificate without action
   */
  export type CertificateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
  }


  /**
   * Model FinancialRecord
   */

  export type AggregateFinancialRecord = {
    _count: FinancialRecordCountAggregateOutputType | null
    _avg: FinancialRecordAvgAggregateOutputType | null
    _sum: FinancialRecordSumAggregateOutputType | null
    _min: FinancialRecordMinAggregateOutputType | null
    _max: FinancialRecordMaxAggregateOutputType | null
  }

  export type FinancialRecordAvgAggregateOutputType = {
    amount: number | null
    studentId: number | null
    courseId: number | null
    facultyId: number | null
    labId: number | null
  }

  export type FinancialRecordSumAggregateOutputType = {
    amount: number | null
    studentId: number | null
    courseId: number | null
    facultyId: number | null
    labId: number | null
  }

  export type FinancialRecordMinAggregateOutputType = {
    id: string | null
    clientAdminId: string | null
    recordType: $Enums.RecordType | null
    amount: number | null
    description: string | null
    date: Date | null
    paymentMode: $Enums.PaymentMode | null
    studentId: number | null
    courseId: number | null
    facultyId: number | null
    labId: number | null
  }

  export type FinancialRecordMaxAggregateOutputType = {
    id: string | null
    clientAdminId: string | null
    recordType: $Enums.RecordType | null
    amount: number | null
    description: string | null
    date: Date | null
    paymentMode: $Enums.PaymentMode | null
    studentId: number | null
    courseId: number | null
    facultyId: number | null
    labId: number | null
  }

  export type FinancialRecordCountAggregateOutputType = {
    id: number
    clientAdminId: number
    recordType: number
    amount: number
    description: number
    date: number
    paymentMode: number
    studentId: number
    courseId: number
    facultyId: number
    labId: number
    _all: number
  }


  export type FinancialRecordAvgAggregateInputType = {
    amount?: true
    studentId?: true
    courseId?: true
    facultyId?: true
    labId?: true
  }

  export type FinancialRecordSumAggregateInputType = {
    amount?: true
    studentId?: true
    courseId?: true
    facultyId?: true
    labId?: true
  }

  export type FinancialRecordMinAggregateInputType = {
    id?: true
    clientAdminId?: true
    recordType?: true
    amount?: true
    description?: true
    date?: true
    paymentMode?: true
    studentId?: true
    courseId?: true
    facultyId?: true
    labId?: true
  }

  export type FinancialRecordMaxAggregateInputType = {
    id?: true
    clientAdminId?: true
    recordType?: true
    amount?: true
    description?: true
    date?: true
    paymentMode?: true
    studentId?: true
    courseId?: true
    facultyId?: true
    labId?: true
  }

  export type FinancialRecordCountAggregateInputType = {
    id?: true
    clientAdminId?: true
    recordType?: true
    amount?: true
    description?: true
    date?: true
    paymentMode?: true
    studentId?: true
    courseId?: true
    facultyId?: true
    labId?: true
    _all?: true
  }

  export type FinancialRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FinancialRecord to aggregate.
     */
    where?: FinancialRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinancialRecords to fetch.
     */
    orderBy?: FinancialRecordOrderByWithRelationInput | FinancialRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FinancialRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinancialRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinancialRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FinancialRecords
    **/
    _count?: true | FinancialRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FinancialRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FinancialRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FinancialRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FinancialRecordMaxAggregateInputType
  }

  export type GetFinancialRecordAggregateType<T extends FinancialRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateFinancialRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFinancialRecord[P]>
      : GetScalarType<T[P], AggregateFinancialRecord[P]>
  }




  export type FinancialRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FinancialRecordWhereInput
    orderBy?: FinancialRecordOrderByWithAggregationInput | FinancialRecordOrderByWithAggregationInput[]
    by: FinancialRecordScalarFieldEnum[] | FinancialRecordScalarFieldEnum
    having?: FinancialRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FinancialRecordCountAggregateInputType | true
    _avg?: FinancialRecordAvgAggregateInputType
    _sum?: FinancialRecordSumAggregateInputType
    _min?: FinancialRecordMinAggregateInputType
    _max?: FinancialRecordMaxAggregateInputType
  }

  export type FinancialRecordGroupByOutputType = {
    id: string
    clientAdminId: string
    recordType: $Enums.RecordType
    amount: number
    description: string | null
    date: Date
    paymentMode: $Enums.PaymentMode | null
    studentId: number | null
    courseId: number | null
    facultyId: number | null
    labId: number | null
    _count: FinancialRecordCountAggregateOutputType | null
    _avg: FinancialRecordAvgAggregateOutputType | null
    _sum: FinancialRecordSumAggregateOutputType | null
    _min: FinancialRecordMinAggregateOutputType | null
    _max: FinancialRecordMaxAggregateOutputType | null
  }

  type GetFinancialRecordGroupByPayload<T extends FinancialRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FinancialRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FinancialRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FinancialRecordGroupByOutputType[P]>
            : GetScalarType<T[P], FinancialRecordGroupByOutputType[P]>
        }
      >
    >


  export type FinancialRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientAdminId?: boolean
    recordType?: boolean
    amount?: boolean
    description?: boolean
    date?: boolean
    paymentMode?: boolean
    studentId?: boolean
    courseId?: boolean
    facultyId?: boolean
    labId?: boolean
    student?: boolean | FinancialRecord$studentArgs<ExtArgs>
    course?: boolean | FinancialRecord$courseArgs<ExtArgs>
    faculty?: boolean | FinancialRecord$facultyArgs<ExtArgs>
    lab?: boolean | FinancialRecord$labArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["financialRecord"]>

  export type FinancialRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientAdminId?: boolean
    recordType?: boolean
    amount?: boolean
    description?: boolean
    date?: boolean
    paymentMode?: boolean
    studentId?: boolean
    courseId?: boolean
    facultyId?: boolean
    labId?: boolean
    student?: boolean | FinancialRecord$studentArgs<ExtArgs>
    course?: boolean | FinancialRecord$courseArgs<ExtArgs>
    faculty?: boolean | FinancialRecord$facultyArgs<ExtArgs>
    lab?: boolean | FinancialRecord$labArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["financialRecord"]>

  export type FinancialRecordSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientAdminId?: boolean
    recordType?: boolean
    amount?: boolean
    description?: boolean
    date?: boolean
    paymentMode?: boolean
    studentId?: boolean
    courseId?: boolean
    facultyId?: boolean
    labId?: boolean
    student?: boolean | FinancialRecord$studentArgs<ExtArgs>
    course?: boolean | FinancialRecord$courseArgs<ExtArgs>
    faculty?: boolean | FinancialRecord$facultyArgs<ExtArgs>
    lab?: boolean | FinancialRecord$labArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["financialRecord"]>

  export type FinancialRecordSelectScalar = {
    id?: boolean
    clientAdminId?: boolean
    recordType?: boolean
    amount?: boolean
    description?: boolean
    date?: boolean
    paymentMode?: boolean
    studentId?: boolean
    courseId?: boolean
    facultyId?: boolean
    labId?: boolean
  }

  export type FinancialRecordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clientAdminId" | "recordType" | "amount" | "description" | "date" | "paymentMode" | "studentId" | "courseId" | "facultyId" | "labId", ExtArgs["result"]["financialRecord"]>
  export type FinancialRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | FinancialRecord$studentArgs<ExtArgs>
    course?: boolean | FinancialRecord$courseArgs<ExtArgs>
    faculty?: boolean | FinancialRecord$facultyArgs<ExtArgs>
    lab?: boolean | FinancialRecord$labArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }
  export type FinancialRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | FinancialRecord$studentArgs<ExtArgs>
    course?: boolean | FinancialRecord$courseArgs<ExtArgs>
    faculty?: boolean | FinancialRecord$facultyArgs<ExtArgs>
    lab?: boolean | FinancialRecord$labArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }
  export type FinancialRecordIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | FinancialRecord$studentArgs<ExtArgs>
    course?: boolean | FinancialRecord$courseArgs<ExtArgs>
    faculty?: boolean | FinancialRecord$facultyArgs<ExtArgs>
    lab?: boolean | FinancialRecord$labArgs<ExtArgs>
    clientAdmin?: boolean | ClientAdminDefaultArgs<ExtArgs>
  }

  export type $FinancialRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FinancialRecord"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs> | null
      course: Prisma.$CoursePayload<ExtArgs> | null
      faculty: Prisma.$FacultyPayload<ExtArgs> | null
      lab: Prisma.$LabPayload<ExtArgs> | null
      clientAdmin: Prisma.$ClientAdminPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clientAdminId: string
      recordType: $Enums.RecordType
      amount: number
      description: string | null
      date: Date
      paymentMode: $Enums.PaymentMode | null
      studentId: number | null
      courseId: number | null
      facultyId: number | null
      labId: number | null
    }, ExtArgs["result"]["financialRecord"]>
    composites: {}
  }

  type FinancialRecordGetPayload<S extends boolean | null | undefined | FinancialRecordDefaultArgs> = $Result.GetResult<Prisma.$FinancialRecordPayload, S>

  type FinancialRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FinancialRecordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FinancialRecordCountAggregateInputType | true
    }

  export interface FinancialRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FinancialRecord'], meta: { name: 'FinancialRecord' } }
    /**
     * Find zero or one FinancialRecord that matches the filter.
     * @param {FinancialRecordFindUniqueArgs} args - Arguments to find a FinancialRecord
     * @example
     * // Get one FinancialRecord
     * const financialRecord = await prisma.financialRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FinancialRecordFindUniqueArgs>(args: SelectSubset<T, FinancialRecordFindUniqueArgs<ExtArgs>>): Prisma__FinancialRecordClient<$Result.GetResult<Prisma.$FinancialRecordPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FinancialRecord that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FinancialRecordFindUniqueOrThrowArgs} args - Arguments to find a FinancialRecord
     * @example
     * // Get one FinancialRecord
     * const financialRecord = await prisma.financialRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FinancialRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, FinancialRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FinancialRecordClient<$Result.GetResult<Prisma.$FinancialRecordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FinancialRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialRecordFindFirstArgs} args - Arguments to find a FinancialRecord
     * @example
     * // Get one FinancialRecord
     * const financialRecord = await prisma.financialRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FinancialRecordFindFirstArgs>(args?: SelectSubset<T, FinancialRecordFindFirstArgs<ExtArgs>>): Prisma__FinancialRecordClient<$Result.GetResult<Prisma.$FinancialRecordPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FinancialRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialRecordFindFirstOrThrowArgs} args - Arguments to find a FinancialRecord
     * @example
     * // Get one FinancialRecord
     * const financialRecord = await prisma.financialRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FinancialRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, FinancialRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__FinancialRecordClient<$Result.GetResult<Prisma.$FinancialRecordPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FinancialRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FinancialRecords
     * const financialRecords = await prisma.financialRecord.findMany()
     * 
     * // Get first 10 FinancialRecords
     * const financialRecords = await prisma.financialRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const financialRecordWithIdOnly = await prisma.financialRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FinancialRecordFindManyArgs>(args?: SelectSubset<T, FinancialRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinancialRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FinancialRecord.
     * @param {FinancialRecordCreateArgs} args - Arguments to create a FinancialRecord.
     * @example
     * // Create one FinancialRecord
     * const FinancialRecord = await prisma.financialRecord.create({
     *   data: {
     *     // ... data to create a FinancialRecord
     *   }
     * })
     * 
     */
    create<T extends FinancialRecordCreateArgs>(args: SelectSubset<T, FinancialRecordCreateArgs<ExtArgs>>): Prisma__FinancialRecordClient<$Result.GetResult<Prisma.$FinancialRecordPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FinancialRecords.
     * @param {FinancialRecordCreateManyArgs} args - Arguments to create many FinancialRecords.
     * @example
     * // Create many FinancialRecords
     * const financialRecord = await prisma.financialRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FinancialRecordCreateManyArgs>(args?: SelectSubset<T, FinancialRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FinancialRecords and returns the data saved in the database.
     * @param {FinancialRecordCreateManyAndReturnArgs} args - Arguments to create many FinancialRecords.
     * @example
     * // Create many FinancialRecords
     * const financialRecord = await prisma.financialRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FinancialRecords and only return the `id`
     * const financialRecordWithIdOnly = await prisma.financialRecord.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FinancialRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, FinancialRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinancialRecordPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FinancialRecord.
     * @param {FinancialRecordDeleteArgs} args - Arguments to delete one FinancialRecord.
     * @example
     * // Delete one FinancialRecord
     * const FinancialRecord = await prisma.financialRecord.delete({
     *   where: {
     *     // ... filter to delete one FinancialRecord
     *   }
     * })
     * 
     */
    delete<T extends FinancialRecordDeleteArgs>(args: SelectSubset<T, FinancialRecordDeleteArgs<ExtArgs>>): Prisma__FinancialRecordClient<$Result.GetResult<Prisma.$FinancialRecordPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FinancialRecord.
     * @param {FinancialRecordUpdateArgs} args - Arguments to update one FinancialRecord.
     * @example
     * // Update one FinancialRecord
     * const financialRecord = await prisma.financialRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FinancialRecordUpdateArgs>(args: SelectSubset<T, FinancialRecordUpdateArgs<ExtArgs>>): Prisma__FinancialRecordClient<$Result.GetResult<Prisma.$FinancialRecordPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FinancialRecords.
     * @param {FinancialRecordDeleteManyArgs} args - Arguments to filter FinancialRecords to delete.
     * @example
     * // Delete a few FinancialRecords
     * const { count } = await prisma.financialRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FinancialRecordDeleteManyArgs>(args?: SelectSubset<T, FinancialRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FinancialRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FinancialRecords
     * const financialRecord = await prisma.financialRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FinancialRecordUpdateManyArgs>(args: SelectSubset<T, FinancialRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FinancialRecords and returns the data updated in the database.
     * @param {FinancialRecordUpdateManyAndReturnArgs} args - Arguments to update many FinancialRecords.
     * @example
     * // Update many FinancialRecords
     * const financialRecord = await prisma.financialRecord.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FinancialRecords and only return the `id`
     * const financialRecordWithIdOnly = await prisma.financialRecord.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FinancialRecordUpdateManyAndReturnArgs>(args: SelectSubset<T, FinancialRecordUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinancialRecordPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FinancialRecord.
     * @param {FinancialRecordUpsertArgs} args - Arguments to update or create a FinancialRecord.
     * @example
     * // Update or create a FinancialRecord
     * const financialRecord = await prisma.financialRecord.upsert({
     *   create: {
     *     // ... data to create a FinancialRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FinancialRecord we want to update
     *   }
     * })
     */
    upsert<T extends FinancialRecordUpsertArgs>(args: SelectSubset<T, FinancialRecordUpsertArgs<ExtArgs>>): Prisma__FinancialRecordClient<$Result.GetResult<Prisma.$FinancialRecordPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FinancialRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialRecordCountArgs} args - Arguments to filter FinancialRecords to count.
     * @example
     * // Count the number of FinancialRecords
     * const count = await prisma.financialRecord.count({
     *   where: {
     *     // ... the filter for the FinancialRecords we want to count
     *   }
     * })
    **/
    count<T extends FinancialRecordCountArgs>(
      args?: Subset<T, FinancialRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FinancialRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FinancialRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FinancialRecordAggregateArgs>(args: Subset<T, FinancialRecordAggregateArgs>): Prisma.PrismaPromise<GetFinancialRecordAggregateType<T>>

    /**
     * Group by FinancialRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FinancialRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FinancialRecordGroupByArgs['orderBy'] }
        : { orderBy?: FinancialRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FinancialRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFinancialRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FinancialRecord model
   */
  readonly fields: FinancialRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FinancialRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FinancialRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends FinancialRecord$studentArgs<ExtArgs> = {}>(args?: Subset<T, FinancialRecord$studentArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    course<T extends FinancialRecord$courseArgs<ExtArgs> = {}>(args?: Subset<T, FinancialRecord$courseArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    faculty<T extends FinancialRecord$facultyArgs<ExtArgs> = {}>(args?: Subset<T, FinancialRecord$facultyArgs<ExtArgs>>): Prisma__FacultyClient<$Result.GetResult<Prisma.$FacultyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    lab<T extends FinancialRecord$labArgs<ExtArgs> = {}>(args?: Subset<T, FinancialRecord$labArgs<ExtArgs>>): Prisma__LabClient<$Result.GetResult<Prisma.$LabPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    clientAdmin<T extends ClientAdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientAdminDefaultArgs<ExtArgs>>): Prisma__ClientAdminClient<$Result.GetResult<Prisma.$ClientAdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FinancialRecord model
   */
  interface FinancialRecordFieldRefs {
    readonly id: FieldRef<"FinancialRecord", 'String'>
    readonly clientAdminId: FieldRef<"FinancialRecord", 'String'>
    readonly recordType: FieldRef<"FinancialRecord", 'RecordType'>
    readonly amount: FieldRef<"FinancialRecord", 'Float'>
    readonly description: FieldRef<"FinancialRecord", 'String'>
    readonly date: FieldRef<"FinancialRecord", 'DateTime'>
    readonly paymentMode: FieldRef<"FinancialRecord", 'PaymentMode'>
    readonly studentId: FieldRef<"FinancialRecord", 'Int'>
    readonly courseId: FieldRef<"FinancialRecord", 'Int'>
    readonly facultyId: FieldRef<"FinancialRecord", 'Int'>
    readonly labId: FieldRef<"FinancialRecord", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * FinancialRecord findUnique
   */
  export type FinancialRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialRecord
     */
    select?: FinancialRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialRecord
     */
    omit?: FinancialRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialRecordInclude<ExtArgs> | null
    /**
     * Filter, which FinancialRecord to fetch.
     */
    where: FinancialRecordWhereUniqueInput
  }

  /**
   * FinancialRecord findUniqueOrThrow
   */
  export type FinancialRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialRecord
     */
    select?: FinancialRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialRecord
     */
    omit?: FinancialRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialRecordInclude<ExtArgs> | null
    /**
     * Filter, which FinancialRecord to fetch.
     */
    where: FinancialRecordWhereUniqueInput
  }

  /**
   * FinancialRecord findFirst
   */
  export type FinancialRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialRecord
     */
    select?: FinancialRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialRecord
     */
    omit?: FinancialRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialRecordInclude<ExtArgs> | null
    /**
     * Filter, which FinancialRecord to fetch.
     */
    where?: FinancialRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinancialRecords to fetch.
     */
    orderBy?: FinancialRecordOrderByWithRelationInput | FinancialRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FinancialRecords.
     */
    cursor?: FinancialRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinancialRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinancialRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FinancialRecords.
     */
    distinct?: FinancialRecordScalarFieldEnum | FinancialRecordScalarFieldEnum[]
  }

  /**
   * FinancialRecord findFirstOrThrow
   */
  export type FinancialRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialRecord
     */
    select?: FinancialRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialRecord
     */
    omit?: FinancialRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialRecordInclude<ExtArgs> | null
    /**
     * Filter, which FinancialRecord to fetch.
     */
    where?: FinancialRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinancialRecords to fetch.
     */
    orderBy?: FinancialRecordOrderByWithRelationInput | FinancialRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FinancialRecords.
     */
    cursor?: FinancialRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinancialRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinancialRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FinancialRecords.
     */
    distinct?: FinancialRecordScalarFieldEnum | FinancialRecordScalarFieldEnum[]
  }

  /**
   * FinancialRecord findMany
   */
  export type FinancialRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialRecord
     */
    select?: FinancialRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialRecord
     */
    omit?: FinancialRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialRecordInclude<ExtArgs> | null
    /**
     * Filter, which FinancialRecords to fetch.
     */
    where?: FinancialRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinancialRecords to fetch.
     */
    orderBy?: FinancialRecordOrderByWithRelationInput | FinancialRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FinancialRecords.
     */
    cursor?: FinancialRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinancialRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinancialRecords.
     */
    skip?: number
    distinct?: FinancialRecordScalarFieldEnum | FinancialRecordScalarFieldEnum[]
  }

  /**
   * FinancialRecord create
   */
  export type FinancialRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialRecord
     */
    select?: FinancialRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialRecord
     */
    omit?: FinancialRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a FinancialRecord.
     */
    data: XOR<FinancialRecordCreateInput, FinancialRecordUncheckedCreateInput>
  }

  /**
   * FinancialRecord createMany
   */
  export type FinancialRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FinancialRecords.
     */
    data: FinancialRecordCreateManyInput | FinancialRecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FinancialRecord createManyAndReturn
   */
  export type FinancialRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialRecord
     */
    select?: FinancialRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialRecord
     */
    omit?: FinancialRecordOmit<ExtArgs> | null
    /**
     * The data used to create many FinancialRecords.
     */
    data: FinancialRecordCreateManyInput | FinancialRecordCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialRecordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FinancialRecord update
   */
  export type FinancialRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialRecord
     */
    select?: FinancialRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialRecord
     */
    omit?: FinancialRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a FinancialRecord.
     */
    data: XOR<FinancialRecordUpdateInput, FinancialRecordUncheckedUpdateInput>
    /**
     * Choose, which FinancialRecord to update.
     */
    where: FinancialRecordWhereUniqueInput
  }

  /**
   * FinancialRecord updateMany
   */
  export type FinancialRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FinancialRecords.
     */
    data: XOR<FinancialRecordUpdateManyMutationInput, FinancialRecordUncheckedUpdateManyInput>
    /**
     * Filter which FinancialRecords to update
     */
    where?: FinancialRecordWhereInput
    /**
     * Limit how many FinancialRecords to update.
     */
    limit?: number
  }

  /**
   * FinancialRecord updateManyAndReturn
   */
  export type FinancialRecordUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialRecord
     */
    select?: FinancialRecordSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialRecord
     */
    omit?: FinancialRecordOmit<ExtArgs> | null
    /**
     * The data used to update FinancialRecords.
     */
    data: XOR<FinancialRecordUpdateManyMutationInput, FinancialRecordUncheckedUpdateManyInput>
    /**
     * Filter which FinancialRecords to update
     */
    where?: FinancialRecordWhereInput
    /**
     * Limit how many FinancialRecords to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialRecordIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FinancialRecord upsert
   */
  export type FinancialRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialRecord
     */
    select?: FinancialRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialRecord
     */
    omit?: FinancialRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the FinancialRecord to update in case it exists.
     */
    where: FinancialRecordWhereUniqueInput
    /**
     * In case the FinancialRecord found by the `where` argument doesn't exist, create a new FinancialRecord with this data.
     */
    create: XOR<FinancialRecordCreateInput, FinancialRecordUncheckedCreateInput>
    /**
     * In case the FinancialRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FinancialRecordUpdateInput, FinancialRecordUncheckedUpdateInput>
  }

  /**
   * FinancialRecord delete
   */
  export type FinancialRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialRecord
     */
    select?: FinancialRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialRecord
     */
    omit?: FinancialRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialRecordInclude<ExtArgs> | null
    /**
     * Filter which FinancialRecord to delete.
     */
    where: FinancialRecordWhereUniqueInput
  }

  /**
   * FinancialRecord deleteMany
   */
  export type FinancialRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FinancialRecords to delete
     */
    where?: FinancialRecordWhereInput
    /**
     * Limit how many FinancialRecords to delete.
     */
    limit?: number
  }

  /**
   * FinancialRecord.student
   */
  export type FinancialRecord$studentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
  }

  /**
   * FinancialRecord.course
   */
  export type FinancialRecord$courseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Course
     */
    omit?: CourseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    where?: CourseWhereInput
  }

  /**
   * FinancialRecord.faculty
   */
  export type FinancialRecord$facultyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faculty
     */
    select?: FacultySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faculty
     */
    omit?: FacultyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacultyInclude<ExtArgs> | null
    where?: FacultyWhereInput
  }

  /**
   * FinancialRecord.lab
   */
  export type FinancialRecord$labArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lab
     */
    select?: LabSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lab
     */
    omit?: LabOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabInclude<ExtArgs> | null
    where?: LabWhereInput
  }

  /**
   * FinancialRecord without action
   */
  export type FinancialRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialRecord
     */
    select?: FinancialRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinancialRecord
     */
    omit?: FinancialRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialRecordInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const ClientAdminScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    password: 'password',
    instituteName: 'instituteName',
    slug: 'slug',
    fullAddress: 'fullAddress',
    logo: 'logo',
    certificateName: 'certificateName',
    stamp: 'stamp',
    sign: 'sign',
    contact: 'contact',
    position: 'position',
    country: 'country',
    state: 'state',
    city: 'city',
    zipCode: 'zipCode',
    createdAt: 'createdAt',
    role: 'role',
    currentSessionToken: 'currentSessionToken',
    lastLoginAt: 'lastLoginAt'
  };

  export type ClientAdminScalarFieldEnum = (typeof ClientAdminScalarFieldEnum)[keyof typeof ClientAdminScalarFieldEnum]


  export const RoleUserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    password: 'password',
    role: 'role',
    createdAt: 'createdAt',
    country: 'country',
    state: 'state',
    city: 'city',
    zipCode: 'zipCode',
    currentSessionToken: 'currentSessionToken',
    lastLoginAt: 'lastLoginAt',
    clientAdminId: 'clientAdminId'
  };

  export type RoleUserScalarFieldEnum = (typeof RoleUserScalarFieldEnum)[keyof typeof RoleUserScalarFieldEnum]


  export const ActivityLogScalarFieldEnum: {
    id: 'id',
    entity: 'entity',
    entityId: 'entityId',
    action: 'action',
    message: 'message',
    createdAt: 'createdAt',
    clientAdminId: 'clientAdminId'
  };

  export type ActivityLogScalarFieldEnum = (typeof ActivityLogScalarFieldEnum)[keyof typeof ActivityLogScalarFieldEnum]


  export const EnquiryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    contact: 'contact',
    email: 'email',
    course: 'course',
    source: 'source',
    leadStatus: 'leadStatus',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isConverted: 'isConverted',
    studentId: 'studentId',
    clientAdminId: 'clientAdminId'
  };

  export type EnquiryScalarFieldEnum = (typeof EnquiryScalarFieldEnum)[keyof typeof EnquiryScalarFieldEnum]


  export const EnquiryCourseScalarFieldEnum: {
    id: 'id',
    enquiryId: 'enquiryId',
    courseId: 'courseId',
    clientAdminId: 'clientAdminId'
  };

  export type EnquiryCourseScalarFieldEnum = (typeof EnquiryCourseScalarFieldEnum)[keyof typeof EnquiryCourseScalarFieldEnum]


  export const FollowUpScalarFieldEnum: {
    id: 'id',
    enquiryId: 'enquiryId',
    scheduledAt: 'scheduledAt',
    doneAt: 'doneAt',
    remark: 'remark',
    createdAt: 'createdAt',
    followUpStatus: 'followUpStatus'
  };

  export type FollowUpScalarFieldEnum = (typeof FollowUpScalarFieldEnum)[keyof typeof FollowUpScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    message: 'message',
    seen: 'seen',
    createdAt: 'createdAt',
    followUpId: 'followUpId',
    enquiryId: 'enquiryId',
    paymentId: 'paymentId',
    clientAdminId: 'clientAdminId'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const StudentScalarFieldEnum: {
    id: 'id',
    serialNumber: 'serialNumber',
    studentCode: 'studentCode',
    fullName: 'fullName',
    fatherName: 'fatherName',
    motherName: 'motherName',
    photoUrl: 'photoUrl',
    contact: 'contact',
    parentsContact: 'parentsContact',
    email: 'email',
    residentialAddress: 'residentialAddress',
    permenantAddress: 'permenantAddress',
    dob: 'dob',
    gender: 'gender',
    religion: 'religion',
    idProofType: 'idProofType',
    idProofNumber: 'idProofNumber',
    admissionDate: 'admissionDate',
    clientAdminId: 'clientAdminId'
  };

  export type StudentScalarFieldEnum = (typeof StudentScalarFieldEnum)[keyof typeof StudentScalarFieldEnum]


  export const CourseScalarFieldEnum: {
    id: 'id',
    name: 'name',
    durationWeeks: 'durationWeeks',
    description: 'description',
    clientAdminId: 'clientAdminId'
  };

  export type CourseScalarFieldEnum = (typeof CourseScalarFieldEnum)[keyof typeof CourseScalarFieldEnum]


  export const CourseFeeStructureScalarFieldEnum: {
    id: 'id',
    courseId: 'courseId',
    totalAmount: 'totalAmount',
    paymentType: 'paymentType',
    clientAdminId: 'clientAdminId'
  };

  export type CourseFeeStructureScalarFieldEnum = (typeof CourseFeeStructureScalarFieldEnum)[keyof typeof CourseFeeStructureScalarFieldEnum]


  export const BatchScalarFieldEnum: {
    id: 'id',
    name: 'name',
    facultyId: 'facultyId',
    labTimeSlotId: 'labTimeSlotId',
    clientAdminId: 'clientAdminId'
  };

  export type BatchScalarFieldEnum = (typeof BatchScalarFieldEnum)[keyof typeof BatchScalarFieldEnum]


  export const BatchCourseScalarFieldEnum: {
    id: 'id',
    batchId: 'batchId',
    courseId: 'courseId',
    pcsReserved: 'pcsReserved'
  };

  export type BatchCourseScalarFieldEnum = (typeof BatchCourseScalarFieldEnum)[keyof typeof BatchCourseScalarFieldEnum]


  export const FacultyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    password: 'password',
    contact: 'contact',
    joiningDate: 'joiningDate',
    specialization: 'specialization',
    role: 'role',
    country: 'country',
    state: 'state',
    city: 'city',
    zipCode: 'zipCode',
    currentSessionToken: 'currentSessionToken',
    lastLoginAt: 'lastLoginAt',
    clientAdminId: 'clientAdminId'
  };

  export type FacultyScalarFieldEnum = (typeof FacultyScalarFieldEnum)[keyof typeof FacultyScalarFieldEnum]


  export const LabScalarFieldEnum: {
    id: 'id',
    name: 'name',
    location: 'location',
    totalPCs: 'totalPCs',
    isActive: 'isActive',
    clientAdminId: 'clientAdminId'
  };

  export type LabScalarFieldEnum = (typeof LabScalarFieldEnum)[keyof typeof LabScalarFieldEnum]


  export const LabTimeSlotScalarFieldEnum: {
    id: 'id',
    startTime: 'startTime',
    endTime: 'endTime',
    day: 'day',
    labId: 'labId',
    availablePCs: 'availablePCs',
    clientAdminId: 'clientAdminId'
  };

  export type LabTimeSlotScalarFieldEnum = (typeof LabTimeSlotScalarFieldEnum)[keyof typeof LabTimeSlotScalarFieldEnum]


  export const PaymentStructureTypeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    installmentCount: 'installmentCount'
  };

  export type PaymentStructureTypeScalarFieldEnum = (typeof PaymentStructureTypeScalarFieldEnum)[keyof typeof PaymentStructureTypeScalarFieldEnum]


  export const InstallmentDetailScalarFieldEnum: {
    id: 'id',
    CourseFeeStructureId: 'CourseFeeStructureId',
    number: 'number',
    amount: 'amount'
  };

  export type InstallmentDetailScalarFieldEnum = (typeof InstallmentDetailScalarFieldEnum)[keyof typeof InstallmentDetailScalarFieldEnum]


  export const LabAllocationScalarFieldEnum: {
    id: 'id',
    labTimeSlotId: 'labTimeSlotId',
    studentId: 'studentId',
    pcNumber: 'pcNumber',
    assignedAt: 'assignedAt',
    clientAdminId: 'clientAdminId'
  };

  export type LabAllocationScalarFieldEnum = (typeof LabAllocationScalarFieldEnum)[keyof typeof LabAllocationScalarFieldEnum]


  export const StudentCourseScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    courseId: 'courseId',
    startDate: 'startDate',
    endDate: 'endDate',
    studentCode: 'studentCode',
    batchId: 'batchId',
    internalNotes: 'internalNotes',
    status: 'status',
    clientAdminId: 'clientAdminId'
  };

  export type StudentCourseScalarFieldEnum = (typeof StudentCourseScalarFieldEnum)[keyof typeof StudentCourseScalarFieldEnum]


  export const FeeStructureScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    courseId: 'courseId',
    totalAmount: 'totalAmount',
    paymentType: 'paymentType',
    installmentCount: 'installmentCount',
    installmentTypeId: 'installmentTypeId',
    clientAdminId: 'clientAdminId'
  };

  export type FeeStructureScalarFieldEnum = (typeof FeeStructureScalarFieldEnum)[keyof typeof FeeStructureScalarFieldEnum]


  export const StudentFeeLogScalarFieldEnum: {
    id: 'id',
    studentFeeId: 'studentFeeId',
    amountPaid: 'amountPaid',
    paymentDate: 'paymentDate',
    paymentMode: 'paymentMode',
    receiptNo: 'receiptNo'
  };

  export type StudentFeeLogScalarFieldEnum = (typeof StudentFeeLogScalarFieldEnum)[keyof typeof StudentFeeLogScalarFieldEnum]


  export const StudentFeeScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    courseId: 'courseId',
    dueDate: 'dueDate',
    amountDue: 'amountDue',
    amountPaid: 'amountPaid',
    paymentDate: 'paymentDate',
    paymentMode: 'paymentMode',
    receiptNo: 'receiptNo',
    paymentStatus: 'paymentStatus',
    clientAdminId: 'clientAdminId'
  };

  export type StudentFeeScalarFieldEnum = (typeof StudentFeeScalarFieldEnum)[keyof typeof StudentFeeScalarFieldEnum]


  export const StationeryItemScalarFieldEnum: {
    id: 'id',
    name: 'name',
    quantityAvailable: 'quantityAvailable'
  };

  export type StationeryItemScalarFieldEnum = (typeof StationeryItemScalarFieldEnum)[keyof typeof StationeryItemScalarFieldEnum]


  export const StationeryIssueScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    courseId: 'courseId',
    itemId: 'itemId',
    issueDate: 'issueDate',
    quantity: 'quantity',
    remarks: 'remarks',
    clientAdminId: 'clientAdminId'
  };

  export type StationeryIssueScalarFieldEnum = (typeof StationeryIssueScalarFieldEnum)[keyof typeof StationeryIssueScalarFieldEnum]


  export const AttendanceRecordScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    courseId: 'courseId',
    date: 'date',
    present: 'present',
    facultyId: 'facultyId',
    batchId: 'batchId',
    clientAdminId: 'clientAdminId'
  };

  export type AttendanceRecordScalarFieldEnum = (typeof AttendanceRecordScalarFieldEnum)[keyof typeof AttendanceRecordScalarFieldEnum]


  export const StudentTaskScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    courseId: 'courseId',
    assignedDate: 'assignedDate',
    dueDate: 'dueDate',
    description: 'description',
    status: 'status',
    facultyRemarks: 'facultyRemarks',
    grade: 'grade',
    facultyId: 'facultyId',
    clientAdminId: 'clientAdminId'
  };

  export type StudentTaskScalarFieldEnum = (typeof StudentTaskScalarFieldEnum)[keyof typeof StudentTaskScalarFieldEnum]


  export const StudentTestScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    courseId: 'courseId',
    testName: 'testName',
    testDate: 'testDate',
    totalMarks: 'totalMarks',
    marksObtained: 'marksObtained',
    grade: 'grade',
    clientAdminId: 'clientAdminId'
  };

  export type StudentTestScalarFieldEnum = (typeof StudentTestScalarFieldEnum)[keyof typeof StudentTestScalarFieldEnum]


  export const CourseCompletionScalarFieldEnum: {
    id: 'id',
    studentCourseId: 'studentCourseId',
    studentId: 'studentId',
    completionDate: 'completionDate',
    feedback: 'feedback',
    remarks: 'remarks',
    clientAdminId: 'clientAdminId'
  };

  export type CourseCompletionScalarFieldEnum = (typeof CourseCompletionScalarFieldEnum)[keyof typeof CourseCompletionScalarFieldEnum]


  export const CertificateScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    courseId: 'courseId',
    studentCourseId: 'studentCourseId',
    issueDate: 'issueDate',
    certificateUrl: 'certificateUrl',
    clientAdminId: 'clientAdminId'
  };

  export type CertificateScalarFieldEnum = (typeof CertificateScalarFieldEnum)[keyof typeof CertificateScalarFieldEnum]


  export const FinancialRecordScalarFieldEnum: {
    id: 'id',
    clientAdminId: 'clientAdminId',
    recordType: 'recordType',
    amount: 'amount',
    description: 'description',
    date: 'date',
    paymentMode: 'paymentMode',
    studentId: 'studentId',
    courseId: 'courseId',
    facultyId: 'facultyId',
    labId: 'labId'
  };

  export type FinancialRecordScalarFieldEnum = (typeof FinancialRecordScalarFieldEnum)[keyof typeof FinancialRecordScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'LeadStatus'
   */
  export type EnumLeadStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeadStatus'>
    


  /**
   * Reference to a field of type 'LeadStatus[]'
   */
  export type ListEnumLeadStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeadStatus[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'FollowUpStatus'
   */
  export type EnumFollowUpStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FollowUpStatus'>
    


  /**
   * Reference to a field of type 'FollowUpStatus[]'
   */
  export type ListEnumFollowUpStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FollowUpStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'PaymentType'
   */
  export type EnumPaymentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentType'>
    


  /**
   * Reference to a field of type 'PaymentType[]'
   */
  export type ListEnumPaymentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentType[]'>
    


  /**
   * Reference to a field of type 'PaymentMode'
   */
  export type EnumPaymentModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMode'>
    


  /**
   * Reference to a field of type 'PaymentMode[]'
   */
  export type ListEnumPaymentModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMode[]'>
    


  /**
   * Reference to a field of type 'PaymentStatus'
   */
  export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus'>
    


  /**
   * Reference to a field of type 'PaymentStatus[]'
   */
  export type ListEnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus[]'>
    


  /**
   * Reference to a field of type 'RecordType'
   */
  export type EnumRecordTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RecordType'>
    


  /**
   * Reference to a field of type 'RecordType[]'
   */
  export type ListEnumRecordTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RecordType[]'>
    
  /**
   * Deep Input Types
   */


  export type ClientAdminWhereInput = {
    AND?: ClientAdminWhereInput | ClientAdminWhereInput[]
    OR?: ClientAdminWhereInput[]
    NOT?: ClientAdminWhereInput | ClientAdminWhereInput[]
    id?: StringFilter<"ClientAdmin"> | string
    name?: StringFilter<"ClientAdmin"> | string
    email?: StringFilter<"ClientAdmin"> | string
    password?: StringFilter<"ClientAdmin"> | string
    instituteName?: StringFilter<"ClientAdmin"> | string
    slug?: StringFilter<"ClientAdmin"> | string
    fullAddress?: StringFilter<"ClientAdmin"> | string
    logo?: StringNullableFilter<"ClientAdmin"> | string | null
    certificateName?: StringNullableFilter<"ClientAdmin"> | string | null
    stamp?: StringNullableFilter<"ClientAdmin"> | string | null
    sign?: StringNullableFilter<"ClientAdmin"> | string | null
    contact?: StringFilter<"ClientAdmin"> | string
    position?: StringFilter<"ClientAdmin"> | string
    country?: StringFilter<"ClientAdmin"> | string
    state?: StringFilter<"ClientAdmin"> | string
    city?: StringFilter<"ClientAdmin"> | string
    zipCode?: StringFilter<"ClientAdmin"> | string
    createdAt?: DateTimeFilter<"ClientAdmin"> | Date | string
    role?: EnumUserRoleFilter<"ClientAdmin"> | $Enums.UserRole
    currentSessionToken?: StringNullableFilter<"ClientAdmin"> | string | null
    lastLoginAt?: DateTimeNullableFilter<"ClientAdmin"> | Date | string | null
    roleUsers?: RoleUserListRelationFilter
    faculties?: FacultyListRelationFilter
    batches?: BatchListRelationFilter
    courses?: CourseListRelationFilter
    enquiryCourse?: EnquiryCourseListRelationFilter
    labs?: LabListRelationFilter
    labTimeSlots?: LabTimeSlotListRelationFilter
    labAllocations?: LabAllocationListRelationFilter
    students?: StudentListRelationFilter
    activities?: ActivityLogListRelationFilter
    studentCourses?: StudentCourseListRelationFilter
    feeStructures?: FeeStructureListRelationFilter
    studentFees?: StudentFeeListRelationFilter
    stationeryIssues?: StationeryIssueListRelationFilter
    attendanceRecords?: AttendanceRecordListRelationFilter
    studentTasks?: StudentTaskListRelationFilter
    studentTests?: StudentTestListRelationFilter
    courseCompletions?: CourseCompletionListRelationFilter
    certificates?: CertificateListRelationFilter
    financialRecords?: FinancialRecordListRelationFilter
    enquiries?: EnquiryListRelationFilter
    notifications?: NotificationListRelationFilter
    courseFeeStructures?: CourseFeeStructureListRelationFilter
  }

  export type ClientAdminOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    instituteName?: SortOrder
    slug?: SortOrder
    fullAddress?: SortOrder
    logo?: SortOrderInput | SortOrder
    certificateName?: SortOrderInput | SortOrder
    stamp?: SortOrderInput | SortOrder
    sign?: SortOrderInput | SortOrder
    contact?: SortOrder
    position?: SortOrder
    country?: SortOrder
    state?: SortOrder
    city?: SortOrder
    zipCode?: SortOrder
    createdAt?: SortOrder
    role?: SortOrder
    currentSessionToken?: SortOrderInput | SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    roleUsers?: RoleUserOrderByRelationAggregateInput
    faculties?: FacultyOrderByRelationAggregateInput
    batches?: BatchOrderByRelationAggregateInput
    courses?: CourseOrderByRelationAggregateInput
    enquiryCourse?: EnquiryCourseOrderByRelationAggregateInput
    labs?: LabOrderByRelationAggregateInput
    labTimeSlots?: LabTimeSlotOrderByRelationAggregateInput
    labAllocations?: LabAllocationOrderByRelationAggregateInput
    students?: StudentOrderByRelationAggregateInput
    activities?: ActivityLogOrderByRelationAggregateInput
    studentCourses?: StudentCourseOrderByRelationAggregateInput
    feeStructures?: FeeStructureOrderByRelationAggregateInput
    studentFees?: StudentFeeOrderByRelationAggregateInput
    stationeryIssues?: StationeryIssueOrderByRelationAggregateInput
    attendanceRecords?: AttendanceRecordOrderByRelationAggregateInput
    studentTasks?: StudentTaskOrderByRelationAggregateInput
    studentTests?: StudentTestOrderByRelationAggregateInput
    courseCompletions?: CourseCompletionOrderByRelationAggregateInput
    certificates?: CertificateOrderByRelationAggregateInput
    financialRecords?: FinancialRecordOrderByRelationAggregateInput
    enquiries?: EnquiryOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    courseFeeStructures?: CourseFeeStructureOrderByRelationAggregateInput
  }

  export type ClientAdminWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    slug?: string
    AND?: ClientAdminWhereInput | ClientAdminWhereInput[]
    OR?: ClientAdminWhereInput[]
    NOT?: ClientAdminWhereInput | ClientAdminWhereInput[]
    name?: StringFilter<"ClientAdmin"> | string
    password?: StringFilter<"ClientAdmin"> | string
    instituteName?: StringFilter<"ClientAdmin"> | string
    fullAddress?: StringFilter<"ClientAdmin"> | string
    logo?: StringNullableFilter<"ClientAdmin"> | string | null
    certificateName?: StringNullableFilter<"ClientAdmin"> | string | null
    stamp?: StringNullableFilter<"ClientAdmin"> | string | null
    sign?: StringNullableFilter<"ClientAdmin"> | string | null
    contact?: StringFilter<"ClientAdmin"> | string
    position?: StringFilter<"ClientAdmin"> | string
    country?: StringFilter<"ClientAdmin"> | string
    state?: StringFilter<"ClientAdmin"> | string
    city?: StringFilter<"ClientAdmin"> | string
    zipCode?: StringFilter<"ClientAdmin"> | string
    createdAt?: DateTimeFilter<"ClientAdmin"> | Date | string
    role?: EnumUserRoleFilter<"ClientAdmin"> | $Enums.UserRole
    currentSessionToken?: StringNullableFilter<"ClientAdmin"> | string | null
    lastLoginAt?: DateTimeNullableFilter<"ClientAdmin"> | Date | string | null
    roleUsers?: RoleUserListRelationFilter
    faculties?: FacultyListRelationFilter
    batches?: BatchListRelationFilter
    courses?: CourseListRelationFilter
    enquiryCourse?: EnquiryCourseListRelationFilter
    labs?: LabListRelationFilter
    labTimeSlots?: LabTimeSlotListRelationFilter
    labAllocations?: LabAllocationListRelationFilter
    students?: StudentListRelationFilter
    activities?: ActivityLogListRelationFilter
    studentCourses?: StudentCourseListRelationFilter
    feeStructures?: FeeStructureListRelationFilter
    studentFees?: StudentFeeListRelationFilter
    stationeryIssues?: StationeryIssueListRelationFilter
    attendanceRecords?: AttendanceRecordListRelationFilter
    studentTasks?: StudentTaskListRelationFilter
    studentTests?: StudentTestListRelationFilter
    courseCompletions?: CourseCompletionListRelationFilter
    certificates?: CertificateListRelationFilter
    financialRecords?: FinancialRecordListRelationFilter
    enquiries?: EnquiryListRelationFilter
    notifications?: NotificationListRelationFilter
    courseFeeStructures?: CourseFeeStructureListRelationFilter
  }, "id" | "email" | "slug">

  export type ClientAdminOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    instituteName?: SortOrder
    slug?: SortOrder
    fullAddress?: SortOrder
    logo?: SortOrderInput | SortOrder
    certificateName?: SortOrderInput | SortOrder
    stamp?: SortOrderInput | SortOrder
    sign?: SortOrderInput | SortOrder
    contact?: SortOrder
    position?: SortOrder
    country?: SortOrder
    state?: SortOrder
    city?: SortOrder
    zipCode?: SortOrder
    createdAt?: SortOrder
    role?: SortOrder
    currentSessionToken?: SortOrderInput | SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    _count?: ClientAdminCountOrderByAggregateInput
    _max?: ClientAdminMaxOrderByAggregateInput
    _min?: ClientAdminMinOrderByAggregateInput
  }

  export type ClientAdminScalarWhereWithAggregatesInput = {
    AND?: ClientAdminScalarWhereWithAggregatesInput | ClientAdminScalarWhereWithAggregatesInput[]
    OR?: ClientAdminScalarWhereWithAggregatesInput[]
    NOT?: ClientAdminScalarWhereWithAggregatesInput | ClientAdminScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ClientAdmin"> | string
    name?: StringWithAggregatesFilter<"ClientAdmin"> | string
    email?: StringWithAggregatesFilter<"ClientAdmin"> | string
    password?: StringWithAggregatesFilter<"ClientAdmin"> | string
    instituteName?: StringWithAggregatesFilter<"ClientAdmin"> | string
    slug?: StringWithAggregatesFilter<"ClientAdmin"> | string
    fullAddress?: StringWithAggregatesFilter<"ClientAdmin"> | string
    logo?: StringNullableWithAggregatesFilter<"ClientAdmin"> | string | null
    certificateName?: StringNullableWithAggregatesFilter<"ClientAdmin"> | string | null
    stamp?: StringNullableWithAggregatesFilter<"ClientAdmin"> | string | null
    sign?: StringNullableWithAggregatesFilter<"ClientAdmin"> | string | null
    contact?: StringWithAggregatesFilter<"ClientAdmin"> | string
    position?: StringWithAggregatesFilter<"ClientAdmin"> | string
    country?: StringWithAggregatesFilter<"ClientAdmin"> | string
    state?: StringWithAggregatesFilter<"ClientAdmin"> | string
    city?: StringWithAggregatesFilter<"ClientAdmin"> | string
    zipCode?: StringWithAggregatesFilter<"ClientAdmin"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ClientAdmin"> | Date | string
    role?: EnumUserRoleWithAggregatesFilter<"ClientAdmin"> | $Enums.UserRole
    currentSessionToken?: StringNullableWithAggregatesFilter<"ClientAdmin"> | string | null
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"ClientAdmin"> | Date | string | null
  }

  export type RoleUserWhereInput = {
    AND?: RoleUserWhereInput | RoleUserWhereInput[]
    OR?: RoleUserWhereInput[]
    NOT?: RoleUserWhereInput | RoleUserWhereInput[]
    id?: StringFilter<"RoleUser"> | string
    name?: StringFilter<"RoleUser"> | string
    email?: StringFilter<"RoleUser"> | string
    password?: StringFilter<"RoleUser"> | string
    role?: EnumUserRoleFilter<"RoleUser"> | $Enums.UserRole
    createdAt?: DateTimeFilter<"RoleUser"> | Date | string
    country?: StringFilter<"RoleUser"> | string
    state?: StringFilter<"RoleUser"> | string
    city?: StringFilter<"RoleUser"> | string
    zipCode?: StringFilter<"RoleUser"> | string
    currentSessionToken?: StringNullableFilter<"RoleUser"> | string | null
    lastLoginAt?: DateTimeNullableFilter<"RoleUser"> | Date | string | null
    clientAdminId?: StringFilter<"RoleUser"> | string
    clientAdmin?: XOR<ClientAdminScalarRelationFilter, ClientAdminWhereInput>
  }

  export type RoleUserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    country?: SortOrder
    state?: SortOrder
    city?: SortOrder
    zipCode?: SortOrder
    currentSessionToken?: SortOrderInput | SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    clientAdminId?: SortOrder
    clientAdmin?: ClientAdminOrderByWithRelationInput
  }

  export type RoleUserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: RoleUserWhereInput | RoleUserWhereInput[]
    OR?: RoleUserWhereInput[]
    NOT?: RoleUserWhereInput | RoleUserWhereInput[]
    name?: StringFilter<"RoleUser"> | string
    password?: StringFilter<"RoleUser"> | string
    role?: EnumUserRoleFilter<"RoleUser"> | $Enums.UserRole
    createdAt?: DateTimeFilter<"RoleUser"> | Date | string
    country?: StringFilter<"RoleUser"> | string
    state?: StringFilter<"RoleUser"> | string
    city?: StringFilter<"RoleUser"> | string
    zipCode?: StringFilter<"RoleUser"> | string
    currentSessionToken?: StringNullableFilter<"RoleUser"> | string | null
    lastLoginAt?: DateTimeNullableFilter<"RoleUser"> | Date | string | null
    clientAdminId?: StringFilter<"RoleUser"> | string
    clientAdmin?: XOR<ClientAdminScalarRelationFilter, ClientAdminWhereInput>
  }, "id" | "email">

  export type RoleUserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    country?: SortOrder
    state?: SortOrder
    city?: SortOrder
    zipCode?: SortOrder
    currentSessionToken?: SortOrderInput | SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    clientAdminId?: SortOrder
    _count?: RoleUserCountOrderByAggregateInput
    _max?: RoleUserMaxOrderByAggregateInput
    _min?: RoleUserMinOrderByAggregateInput
  }

  export type RoleUserScalarWhereWithAggregatesInput = {
    AND?: RoleUserScalarWhereWithAggregatesInput | RoleUserScalarWhereWithAggregatesInput[]
    OR?: RoleUserScalarWhereWithAggregatesInput[]
    NOT?: RoleUserScalarWhereWithAggregatesInput | RoleUserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RoleUser"> | string
    name?: StringWithAggregatesFilter<"RoleUser"> | string
    email?: StringWithAggregatesFilter<"RoleUser"> | string
    password?: StringWithAggregatesFilter<"RoleUser"> | string
    role?: EnumUserRoleWithAggregatesFilter<"RoleUser"> | $Enums.UserRole
    createdAt?: DateTimeWithAggregatesFilter<"RoleUser"> | Date | string
    country?: StringWithAggregatesFilter<"RoleUser"> | string
    state?: StringWithAggregatesFilter<"RoleUser"> | string
    city?: StringWithAggregatesFilter<"RoleUser"> | string
    zipCode?: StringWithAggregatesFilter<"RoleUser"> | string
    currentSessionToken?: StringNullableWithAggregatesFilter<"RoleUser"> | string | null
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"RoleUser"> | Date | string | null
    clientAdminId?: StringWithAggregatesFilter<"RoleUser"> | string
  }

  export type ActivityLogWhereInput = {
    AND?: ActivityLogWhereInput | ActivityLogWhereInput[]
    OR?: ActivityLogWhereInput[]
    NOT?: ActivityLogWhereInput | ActivityLogWhereInput[]
    id?: StringFilter<"ActivityLog"> | string
    entity?: StringFilter<"ActivityLog"> | string
    entityId?: StringFilter<"ActivityLog"> | string
    action?: StringFilter<"ActivityLog"> | string
    message?: StringNullableFilter<"ActivityLog"> | string | null
    createdAt?: DateTimeFilter<"ActivityLog"> | Date | string
    clientAdminId?: StringFilter<"ActivityLog"> | string
    clientAdmin?: XOR<ClientAdminScalarRelationFilter, ClientAdminWhereInput>
  }

  export type ActivityLogOrderByWithRelationInput = {
    id?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    message?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    clientAdminId?: SortOrder
    clientAdmin?: ClientAdminOrderByWithRelationInput
  }

  export type ActivityLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ActivityLogWhereInput | ActivityLogWhereInput[]
    OR?: ActivityLogWhereInput[]
    NOT?: ActivityLogWhereInput | ActivityLogWhereInput[]
    entity?: StringFilter<"ActivityLog"> | string
    entityId?: StringFilter<"ActivityLog"> | string
    action?: StringFilter<"ActivityLog"> | string
    message?: StringNullableFilter<"ActivityLog"> | string | null
    createdAt?: DateTimeFilter<"ActivityLog"> | Date | string
    clientAdminId?: StringFilter<"ActivityLog"> | string
    clientAdmin?: XOR<ClientAdminScalarRelationFilter, ClientAdminWhereInput>
  }, "id">

  export type ActivityLogOrderByWithAggregationInput = {
    id?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    message?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    clientAdminId?: SortOrder
    _count?: ActivityLogCountOrderByAggregateInput
    _max?: ActivityLogMaxOrderByAggregateInput
    _min?: ActivityLogMinOrderByAggregateInput
  }

  export type ActivityLogScalarWhereWithAggregatesInput = {
    AND?: ActivityLogScalarWhereWithAggregatesInput | ActivityLogScalarWhereWithAggregatesInput[]
    OR?: ActivityLogScalarWhereWithAggregatesInput[]
    NOT?: ActivityLogScalarWhereWithAggregatesInput | ActivityLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ActivityLog"> | string
    entity?: StringWithAggregatesFilter<"ActivityLog"> | string
    entityId?: StringWithAggregatesFilter<"ActivityLog"> | string
    action?: StringWithAggregatesFilter<"ActivityLog"> | string
    message?: StringNullableWithAggregatesFilter<"ActivityLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ActivityLog"> | Date | string
    clientAdminId?: StringWithAggregatesFilter<"ActivityLog"> | string
  }

  export type EnquiryWhereInput = {
    AND?: EnquiryWhereInput | EnquiryWhereInput[]
    OR?: EnquiryWhereInput[]
    NOT?: EnquiryWhereInput | EnquiryWhereInput[]
    id?: StringFilter<"Enquiry"> | string
    name?: StringFilter<"Enquiry"> | string
    contact?: StringFilter<"Enquiry"> | string
    email?: StringNullableFilter<"Enquiry"> | string | null
    course?: StringNullableFilter<"Enquiry"> | string | null
    source?: StringNullableFilter<"Enquiry"> | string | null
    leadStatus?: EnumLeadStatusFilter<"Enquiry"> | $Enums.LeadStatus
    createdAt?: DateTimeFilter<"Enquiry"> | Date | string
    updatedAt?: DateTimeFilter<"Enquiry"> | Date | string
    isConverted?: BoolFilter<"Enquiry"> | boolean
    studentId?: IntNullableFilter<"Enquiry"> | number | null
    clientAdminId?: StringFilter<"Enquiry"> | string
    followUps?: FollowUpListRelationFilter
    student?: XOR<StudentNullableScalarRelationFilter, StudentWhereInput> | null
    enquiryCourse?: EnquiryCourseListRelationFilter
    notification?: XOR<NotificationNullableScalarRelationFilter, NotificationWhereInput> | null
    clientAdmin?: XOR<ClientAdminScalarRelationFilter, ClientAdminWhereInput>
  }

  export type EnquiryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    contact?: SortOrder
    email?: SortOrderInput | SortOrder
    course?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    leadStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isConverted?: SortOrder
    studentId?: SortOrderInput | SortOrder
    clientAdminId?: SortOrder
    followUps?: FollowUpOrderByRelationAggregateInput
    student?: StudentOrderByWithRelationInput
    enquiryCourse?: EnquiryCourseOrderByRelationAggregateInput
    notification?: NotificationOrderByWithRelationInput
    clientAdmin?: ClientAdminOrderByWithRelationInput
  }

  export type EnquiryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    studentId?: number
    AND?: EnquiryWhereInput | EnquiryWhereInput[]
    OR?: EnquiryWhereInput[]
    NOT?: EnquiryWhereInput | EnquiryWhereInput[]
    name?: StringFilter<"Enquiry"> | string
    contact?: StringFilter<"Enquiry"> | string
    email?: StringNullableFilter<"Enquiry"> | string | null
    course?: StringNullableFilter<"Enquiry"> | string | null
    source?: StringNullableFilter<"Enquiry"> | string | null
    leadStatus?: EnumLeadStatusFilter<"Enquiry"> | $Enums.LeadStatus
    createdAt?: DateTimeFilter<"Enquiry"> | Date | string
    updatedAt?: DateTimeFilter<"Enquiry"> | Date | string
    isConverted?: BoolFilter<"Enquiry"> | boolean
    clientAdminId?: StringFilter<"Enquiry"> | string
    followUps?: FollowUpListRelationFilter
    student?: XOR<StudentNullableScalarRelationFilter, StudentWhereInput> | null
    enquiryCourse?: EnquiryCourseListRelationFilter
    notification?: XOR<NotificationNullableScalarRelationFilter, NotificationWhereInput> | null
    clientAdmin?: XOR<ClientAdminScalarRelationFilter, ClientAdminWhereInput>
  }, "id" | "studentId">

  export type EnquiryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    contact?: SortOrder
    email?: SortOrderInput | SortOrder
    course?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    leadStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isConverted?: SortOrder
    studentId?: SortOrderInput | SortOrder
    clientAdminId?: SortOrder
    _count?: EnquiryCountOrderByAggregateInput
    _avg?: EnquiryAvgOrderByAggregateInput
    _max?: EnquiryMaxOrderByAggregateInput
    _min?: EnquiryMinOrderByAggregateInput
    _sum?: EnquirySumOrderByAggregateInput
  }

  export type EnquiryScalarWhereWithAggregatesInput = {
    AND?: EnquiryScalarWhereWithAggregatesInput | EnquiryScalarWhereWithAggregatesInput[]
    OR?: EnquiryScalarWhereWithAggregatesInput[]
    NOT?: EnquiryScalarWhereWithAggregatesInput | EnquiryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Enquiry"> | string
    name?: StringWithAggregatesFilter<"Enquiry"> | string
    contact?: StringWithAggregatesFilter<"Enquiry"> | string
    email?: StringNullableWithAggregatesFilter<"Enquiry"> | string | null
    course?: StringNullableWithAggregatesFilter<"Enquiry"> | string | null
    source?: StringNullableWithAggregatesFilter<"Enquiry"> | string | null
    leadStatus?: EnumLeadStatusWithAggregatesFilter<"Enquiry"> | $Enums.LeadStatus
    createdAt?: DateTimeWithAggregatesFilter<"Enquiry"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Enquiry"> | Date | string
    isConverted?: BoolWithAggregatesFilter<"Enquiry"> | boolean
    studentId?: IntNullableWithAggregatesFilter<"Enquiry"> | number | null
    clientAdminId?: StringWithAggregatesFilter<"Enquiry"> | string
  }

  export type EnquiryCourseWhereInput = {
    AND?: EnquiryCourseWhereInput | EnquiryCourseWhereInput[]
    OR?: EnquiryCourseWhereInput[]
    NOT?: EnquiryCourseWhereInput | EnquiryCourseWhereInput[]
    id?: IntFilter<"EnquiryCourse"> | number
    enquiryId?: StringFilter<"EnquiryCourse"> | string
    courseId?: IntFilter<"EnquiryCourse"> | number
    clientAdminId?: StringFilter<"EnquiryCourse"> | string
    enquiry?: XOR<EnquiryScalarRelationFilter, EnquiryWhereInput>
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    clientAdmin?: XOR<ClientAdminScalarRelationFilter, ClientAdminWhereInput>
  }

  export type EnquiryCourseOrderByWithRelationInput = {
    id?: SortOrder
    enquiryId?: SortOrder
    courseId?: SortOrder
    clientAdminId?: SortOrder
    enquiry?: EnquiryOrderByWithRelationInput
    course?: CourseOrderByWithRelationInput
    clientAdmin?: ClientAdminOrderByWithRelationInput
  }

  export type EnquiryCourseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    enquiryId_courseId?: EnquiryCourseEnquiryIdCourseIdCompoundUniqueInput
    AND?: EnquiryCourseWhereInput | EnquiryCourseWhereInput[]
    OR?: EnquiryCourseWhereInput[]
    NOT?: EnquiryCourseWhereInput | EnquiryCourseWhereInput[]
    enquiryId?: StringFilter<"EnquiryCourse"> | string
    courseId?: IntFilter<"EnquiryCourse"> | number
    clientAdminId?: StringFilter<"EnquiryCourse"> | string
    enquiry?: XOR<EnquiryScalarRelationFilter, EnquiryWhereInput>
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    clientAdmin?: XOR<ClientAdminScalarRelationFilter, ClientAdminWhereInput>
  }, "id" | "enquiryId_courseId">

  export type EnquiryCourseOrderByWithAggregationInput = {
    id?: SortOrder
    enquiryId?: SortOrder
    courseId?: SortOrder
    clientAdminId?: SortOrder
    _count?: EnquiryCourseCountOrderByAggregateInput
    _avg?: EnquiryCourseAvgOrderByAggregateInput
    _max?: EnquiryCourseMaxOrderByAggregateInput
    _min?: EnquiryCourseMinOrderByAggregateInput
    _sum?: EnquiryCourseSumOrderByAggregateInput
  }

  export type EnquiryCourseScalarWhereWithAggregatesInput = {
    AND?: EnquiryCourseScalarWhereWithAggregatesInput | EnquiryCourseScalarWhereWithAggregatesInput[]
    OR?: EnquiryCourseScalarWhereWithAggregatesInput[]
    NOT?: EnquiryCourseScalarWhereWithAggregatesInput | EnquiryCourseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EnquiryCourse"> | number
    enquiryId?: StringWithAggregatesFilter<"EnquiryCourse"> | string
    courseId?: IntWithAggregatesFilter<"EnquiryCourse"> | number
    clientAdminId?: StringWithAggregatesFilter<"EnquiryCourse"> | string
  }

  export type FollowUpWhereInput = {
    AND?: FollowUpWhereInput | FollowUpWhereInput[]
    OR?: FollowUpWhereInput[]
    NOT?: FollowUpWhereInput | FollowUpWhereInput[]
    id?: StringFilter<"FollowUp"> | string
    enquiryId?: StringFilter<"FollowUp"> | string
    scheduledAt?: DateTimeNullableFilter<"FollowUp"> | Date | string | null
    doneAt?: DateTimeNullableFilter<"FollowUp"> | Date | string | null
    remark?: StringFilter<"FollowUp"> | string
    createdAt?: DateTimeFilter<"FollowUp"> | Date | string
    followUpStatus?: EnumFollowUpStatusFilter<"FollowUp"> | $Enums.FollowUpStatus
    enquiry?: XOR<EnquiryScalarRelationFilter, EnquiryWhereInput>
    notification?: XOR<NotificationNullableScalarRelationFilter, NotificationWhereInput> | null
  }

  export type FollowUpOrderByWithRelationInput = {
    id?: SortOrder
    enquiryId?: SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    doneAt?: SortOrderInput | SortOrder
    remark?: SortOrder
    createdAt?: SortOrder
    followUpStatus?: SortOrder
    enquiry?: EnquiryOrderByWithRelationInput
    notification?: NotificationOrderByWithRelationInput
  }

  export type FollowUpWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FollowUpWhereInput | FollowUpWhereInput[]
    OR?: FollowUpWhereInput[]
    NOT?: FollowUpWhereInput | FollowUpWhereInput[]
    enquiryId?: StringFilter<"FollowUp"> | string
    scheduledAt?: DateTimeNullableFilter<"FollowUp"> | Date | string | null
    doneAt?: DateTimeNullableFilter<"FollowUp"> | Date | string | null
    remark?: StringFilter<"FollowUp"> | string
    createdAt?: DateTimeFilter<"FollowUp"> | Date | string
    followUpStatus?: EnumFollowUpStatusFilter<"FollowUp"> | $Enums.FollowUpStatus
    enquiry?: XOR<EnquiryScalarRelationFilter, EnquiryWhereInput>
    notification?: XOR<NotificationNullableScalarRelationFilter, NotificationWhereInput> | null
  }, "id">

  export type FollowUpOrderByWithAggregationInput = {
    id?: SortOrder
    enquiryId?: SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    doneAt?: SortOrderInput | SortOrder
    remark?: SortOrder
    createdAt?: SortOrder
    followUpStatus?: SortOrder
    _count?: FollowUpCountOrderByAggregateInput
    _max?: FollowUpMaxOrderByAggregateInput
    _min?: FollowUpMinOrderByAggregateInput
  }

  export type FollowUpScalarWhereWithAggregatesInput = {
    AND?: FollowUpScalarWhereWithAggregatesInput | FollowUpScalarWhereWithAggregatesInput[]
    OR?: FollowUpScalarWhereWithAggregatesInput[]
    NOT?: FollowUpScalarWhereWithAggregatesInput | FollowUpScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FollowUp"> | string
    enquiryId?: StringWithAggregatesFilter<"FollowUp"> | string
    scheduledAt?: DateTimeNullableWithAggregatesFilter<"FollowUp"> | Date | string | null
    doneAt?: DateTimeNullableWithAggregatesFilter<"FollowUp"> | Date | string | null
    remark?: StringWithAggregatesFilter<"FollowUp"> | string
    createdAt?: DateTimeWithAggregatesFilter<"FollowUp"> | Date | string
    followUpStatus?: EnumFollowUpStatusWithAggregatesFilter<"FollowUp"> | $Enums.FollowUpStatus
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    seen?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    followUpId?: StringNullableFilter<"Notification"> | string | null
    enquiryId?: StringNullableFilter<"Notification"> | string | null
    paymentId?: IntNullableFilter<"Notification"> | number | null
    clientAdminId?: StringFilter<"Notification"> | string
    followUp?: XOR<FollowUpNullableScalarRelationFilter, FollowUpWhereInput> | null
    enquiry?: XOR<EnquiryNullableScalarRelationFilter, EnquiryWhereInput> | null
    payment?: XOR<StudentFeeNullableScalarRelationFilter, StudentFeeWhereInput> | null
    clientAdmin?: XOR<ClientAdminScalarRelationFilter, ClientAdminWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    message?: SortOrder
    seen?: SortOrder
    createdAt?: SortOrder
    followUpId?: SortOrderInput | SortOrder
    enquiryId?: SortOrderInput | SortOrder
    paymentId?: SortOrderInput | SortOrder
    clientAdminId?: SortOrder
    followUp?: FollowUpOrderByWithRelationInput
    enquiry?: EnquiryOrderByWithRelationInput
    payment?: StudentFeeOrderByWithRelationInput
    clientAdmin?: ClientAdminOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    followUpId?: string
    enquiryId?: string
    paymentId?: number
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    message?: StringFilter<"Notification"> | string
    seen?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    clientAdminId?: StringFilter<"Notification"> | string
    followUp?: XOR<FollowUpNullableScalarRelationFilter, FollowUpWhereInput> | null
    enquiry?: XOR<EnquiryNullableScalarRelationFilter, EnquiryWhereInput> | null
    payment?: XOR<StudentFeeNullableScalarRelationFilter, StudentFeeWhereInput> | null
    clientAdmin?: XOR<ClientAdminScalarRelationFilter, ClientAdminWhereInput>
  }, "id" | "followUpId" | "enquiryId" | "paymentId">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    message?: SortOrder
    seen?: SortOrder
    createdAt?: SortOrder
    followUpId?: SortOrderInput | SortOrder
    enquiryId?: SortOrderInput | SortOrder
    paymentId?: SortOrderInput | SortOrder
    clientAdminId?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _avg?: NotificationAvgOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
    _sum?: NotificationSumOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    seen?: BoolWithAggregatesFilter<"Notification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    followUpId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    enquiryId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    paymentId?: IntNullableWithAggregatesFilter<"Notification"> | number | null
    clientAdminId?: StringWithAggregatesFilter<"Notification"> | string
  }

  export type StudentWhereInput = {
    AND?: StudentWhereInput | StudentWhereInput[]
    OR?: StudentWhereInput[]
    NOT?: StudentWhereInput | StudentWhereInput[]
    id?: IntFilter<"Student"> | number
    serialNumber?: IntFilter<"Student"> | number
    studentCode?: StringFilter<"Student"> | string
    fullName?: StringFilter<"Student"> | string
    fatherName?: StringFilter<"Student"> | string
    motherName?: StringFilter<"Student"> | string
    photoUrl?: StringNullableFilter<"Student"> | string | null
    contact?: StringFilter<"Student"> | string
    parentsContact?: StringFilter<"Student"> | string
    email?: StringNullableFilter<"Student"> | string | null
    residentialAddress?: StringNullableFilter<"Student"> | string | null
    permenantAddress?: StringNullableFilter<"Student"> | string | null
    dob?: StringFilter<"Student"> | string
    gender?: StringFilter<"Student"> | string
    religion?: StringNullableFilter<"Student"> | string | null
    idProofType?: StringNullableFilter<"Student"> | string | null
    idProofNumber?: StringNullableFilter<"Student"> | string | null
    admissionDate?: DateTimeFilter<"Student"> | Date | string
    clientAdminId?: StringFilter<"Student"> | string
    enquiry?: XOR<EnquiryNullableScalarRelationFilter, EnquiryWhereInput> | null
    labAllocations?: LabAllocationListRelationFilter
    studentCourses?: StudentCourseListRelationFilter
    feeStructures?: FeeStructureListRelationFilter
    feeRecords?: StudentFeeListRelationFilter
    attendance?: AttendanceRecordListRelationFilter
    tasks?: StudentTaskListRelationFilter
    tests?: StudentTestListRelationFilter
    completions?: CourseCompletionListRelationFilter
    stationery?: StationeryIssueListRelationFilter
    certificates?: CertificateListRelationFilter
    financialRecords?: FinancialRecordListRelationFilter
    clientAdmin?: XOR<ClientAdminScalarRelationFilter, ClientAdminWhereInput>
  }

  export type StudentOrderByWithRelationInput = {
    id?: SortOrder
    serialNumber?: SortOrder
    studentCode?: SortOrder
    fullName?: SortOrder
    fatherName?: SortOrder
    motherName?: SortOrder
    photoUrl?: SortOrderInput | SortOrder
    contact?: SortOrder
    parentsContact?: SortOrder
    email?: SortOrderInput | SortOrder
    residentialAddress?: SortOrderInput | SortOrder
    permenantAddress?: SortOrderInput | SortOrder
    dob?: SortOrder
    gender?: SortOrder
    religion?: SortOrderInput | SortOrder
    idProofType?: SortOrderInput | SortOrder
    idProofNumber?: SortOrderInput | SortOrder
    admissionDate?: SortOrder
    clientAdminId?: SortOrder
    enquiry?: EnquiryOrderByWithRelationInput
    labAllocations?: LabAllocationOrderByRelationAggregateInput
    studentCourses?: StudentCourseOrderByRelationAggregateInput
    feeStructures?: FeeStructureOrderByRelationAggregateInput
    feeRecords?: StudentFeeOrderByRelationAggregateInput
    attendance?: AttendanceRecordOrderByRelationAggregateInput
    tasks?: StudentTaskOrderByRelationAggregateInput
    tests?: StudentTestOrderByRelationAggregateInput
    completions?: CourseCompletionOrderByRelationAggregateInput
    stationery?: StationeryIssueOrderByRelationAggregateInput
    certificates?: CertificateOrderByRelationAggregateInput
    financialRecords?: FinancialRecordOrderByRelationAggregateInput
    clientAdmin?: ClientAdminOrderByWithRelationInput
  }

  export type StudentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    serialNumber?: number
    studentCode?: string
    AND?: StudentWhereInput | StudentWhereInput[]
    OR?: StudentWhereInput[]
    NOT?: StudentWhereInput | StudentWhereInput[]
    fullName?: StringFilter<"Student"> | string
    fatherName?: StringFilter<"Student"> | string
    motherName?: StringFilter<"Student"> | string
    photoUrl?: StringNullableFilter<"Student"> | string | null
    contact?: StringFilter<"Student"> | string
    parentsContact?: StringFilter<"Student"> | string
    email?: StringNullableFilter<"Student"> | string | null
    residentialAddress?: StringNullableFilter<"Student"> | string | null
    permenantAddress?: StringNullableFilter<"Student"> | string | null
    dob?: StringFilter<"Student"> | string
    gender?: StringFilter<"Student"> | string
    religion?: StringNullableFilter<"Student"> | string | null
    idProofType?: StringNullableFilter<"Student"> | string | null
    idProofNumber?: StringNullableFilter<"Student"> | string | null
    admissionDate?: DateTimeFilter<"Student"> | Date | string
    clientAdminId?: StringFilter<"Student"> | string
    enquiry?: XOR<EnquiryNullableScalarRelationFilter, EnquiryWhereInput> | null
    labAllocations?: LabAllocationListRelationFilter
    studentCourses?: StudentCourseListRelationFilter
    feeStructures?: FeeStructureListRelationFilter
    feeRecords?: StudentFeeListRelationFilter
    attendance?: AttendanceRecordListRelationFilter
    tasks?: StudentTaskListRelationFilter
    tests?: StudentTestListRelationFilter
    completions?: CourseCompletionListRelationFilter
    stationery?: StationeryIssueListRelationFilter
    certificates?: CertificateListRelationFilter
    financialRecords?: FinancialRecordListRelationFilter
    clientAdmin?: XOR<ClientAdminScalarRelationFilter, ClientAdminWhereInput>
  }, "id" | "serialNumber" | "studentCode">

  export type StudentOrderByWithAggregationInput = {
    id?: SortOrder
    serialNumber?: SortOrder
    studentCode?: SortOrder
    fullName?: SortOrder
    fatherName?: SortOrder
    motherName?: SortOrder
    photoUrl?: SortOrderInput | SortOrder
    contact?: SortOrder
    parentsContact?: SortOrder
    email?: SortOrderInput | SortOrder
    residentialAddress?: SortOrderInput | SortOrder
    permenantAddress?: SortOrderInput | SortOrder
    dob?: SortOrder
    gender?: SortOrder
    religion?: SortOrderInput | SortOrder
    idProofType?: SortOrderInput | SortOrder
    idProofNumber?: SortOrderInput | SortOrder
    admissionDate?: SortOrder
    clientAdminId?: SortOrder
    _count?: StudentCountOrderByAggregateInput
    _avg?: StudentAvgOrderByAggregateInput
    _max?: StudentMaxOrderByAggregateInput
    _min?: StudentMinOrderByAggregateInput
    _sum?: StudentSumOrderByAggregateInput
  }

  export type StudentScalarWhereWithAggregatesInput = {
    AND?: StudentScalarWhereWithAggregatesInput | StudentScalarWhereWithAggregatesInput[]
    OR?: StudentScalarWhereWithAggregatesInput[]
    NOT?: StudentScalarWhereWithAggregatesInput | StudentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Student"> | number
    serialNumber?: IntWithAggregatesFilter<"Student"> | number
    studentCode?: StringWithAggregatesFilter<"Student"> | string
    fullName?: StringWithAggregatesFilter<"Student"> | string
    fatherName?: StringWithAggregatesFilter<"Student"> | string
    motherName?: StringWithAggregatesFilter<"Student"> | string
    photoUrl?: StringNullableWithAggregatesFilter<"Student"> | string | null
    contact?: StringWithAggregatesFilter<"Student"> | string
    parentsContact?: StringWithAggregatesFilter<"Student"> | string
    email?: StringNullableWithAggregatesFilter<"Student"> | string | null
    residentialAddress?: StringNullableWithAggregatesFilter<"Student"> | string | null
    permenantAddress?: StringNullableWithAggregatesFilter<"Student"> | string | null
    dob?: StringWithAggregatesFilter<"Student"> | string
    gender?: StringWithAggregatesFilter<"Student"> | string
    religion?: StringNullableWithAggregatesFilter<"Student"> | string | null
    idProofType?: StringNullableWithAggregatesFilter<"Student"> | string | null
    idProofNumber?: StringNullableWithAggregatesFilter<"Student"> | string | null
    admissionDate?: DateTimeWithAggregatesFilter<"Student"> | Date | string
    clientAdminId?: StringWithAggregatesFilter<"Student"> | string
  }

  export type CourseWhereInput = {
    AND?: CourseWhereInput | CourseWhereInput[]
    OR?: CourseWhereInput[]
    NOT?: CourseWhereInput | CourseWhereInput[]
    id?: IntFilter<"Course"> | number
    name?: StringFilter<"Course"> | string
    durationWeeks?: IntFilter<"Course"> | number
    description?: StringNullableFilter<"Course"> | string | null
    clientAdminId?: StringFilter<"Course"> | string
    courseFeeStructure?: XOR<CourseFeeStructureNullableScalarRelationFilter, CourseFeeStructureWhereInput> | null
    studentCourses?: StudentCourseListRelationFilter
    enquiryCourse?: EnquiryCourseListRelationFilter
    feeStructures?: FeeStructureListRelationFilter
    stationery?: StationeryIssueListRelationFilter
    studentFees?: StudentFeeListRelationFilter
    attendanceRecords?: AttendanceRecordListRelationFilter
    studentTasks?: StudentTaskListRelationFilter
    studentTests?: StudentTestListRelationFilter
    certificates?: CertificateListRelationFilter
    financialRecords?: FinancialRecordListRelationFilter
    batchCourses?: BatchCourseListRelationFilter
    clientAdmin?: XOR<ClientAdminScalarRelationFilter, ClientAdminWhereInput>
  }

  export type CourseOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    durationWeeks?: SortOrder
    description?: SortOrderInput | SortOrder
    clientAdminId?: SortOrder
    courseFeeStructure?: CourseFeeStructureOrderByWithRelationInput
    studentCourses?: StudentCourseOrderByRelationAggregateInput
    enquiryCourse?: EnquiryCourseOrderByRelationAggregateInput
    feeStructures?: FeeStructureOrderByRelationAggregateInput
    stationery?: StationeryIssueOrderByRelationAggregateInput
    studentFees?: StudentFeeOrderByRelationAggregateInput
    attendanceRecords?: AttendanceRecordOrderByRelationAggregateInput
    studentTasks?: StudentTaskOrderByRelationAggregateInput
    studentTests?: StudentTestOrderByRelationAggregateInput
    certificates?: CertificateOrderByRelationAggregateInput
    financialRecords?: FinancialRecordOrderByRelationAggregateInput
    batchCourses?: BatchCourseOrderByRelationAggregateInput
    clientAdmin?: ClientAdminOrderByWithRelationInput
  }

  export type CourseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CourseWhereInput | CourseWhereInput[]
    OR?: CourseWhereInput[]
    NOT?: CourseWhereInput | CourseWhereInput[]
    name?: StringFilter<"Course"> | string
    durationWeeks?: IntFilter<"Course"> | number
    description?: StringNullableFilter<"Course"> | string | null
    clientAdminId?: StringFilter<"Course"> | string
    courseFeeStructure?: XOR<CourseFeeStructureNullableScalarRelationFilter, CourseFeeStructureWhereInput> | null
    studentCourses?: StudentCourseListRelationFilter
    enquiryCourse?: EnquiryCourseListRelationFilter
    feeStructures?: FeeStructureListRelationFilter
    stationery?: StationeryIssueListRelationFilter
    studentFees?: StudentFeeListRelationFilter
    attendanceRecords?: AttendanceRecordListRelationFilter
    studentTasks?: StudentTaskListRelationFilter
    studentTests?: StudentTestListRelationFilter
    certificates?: CertificateListRelationFilter
    financialRecords?: FinancialRecordListRelationFilter
    batchCourses?: BatchCourseListRelationFilter
    clientAdmin?: XOR<ClientAdminScalarRelationFilter, ClientAdminWhereInput>
  }, "id">

  export type CourseOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    durationWeeks?: SortOrder
    description?: SortOrderInput | SortOrder
    clientAdminId?: SortOrder
    _count?: CourseCountOrderByAggregateInput
    _avg?: CourseAvgOrderByAggregateInput
    _max?: CourseMaxOrderByAggregateInput
    _min?: CourseMinOrderByAggregateInput
    _sum?: CourseSumOrderByAggregateInput
  }

  export type CourseScalarWhereWithAggregatesInput = {
    AND?: CourseScalarWhereWithAggregatesInput | CourseScalarWhereWithAggregatesInput[]
    OR?: CourseScalarWhereWithAggregatesInput[]
    NOT?: CourseScalarWhereWithAggregatesInput | CourseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Course"> | number
    name?: StringWithAggregatesFilter<"Course"> | string
    durationWeeks?: IntWithAggregatesFilter<"Course"> | number
    description?: StringNullableWithAggregatesFilter<"Course"> | string | null
    clientAdminId?: StringWithAggregatesFilter<"Course"> | string
  }

  export type CourseFeeStructureWhereInput = {
    AND?: CourseFeeStructureWhereInput | CourseFeeStructureWhereInput[]
    OR?: CourseFeeStructureWhereInput[]
    NOT?: CourseFeeStructureWhereInput | CourseFeeStructureWhereInput[]
    id?: IntFilter<"CourseFeeStructure"> | number
    courseId?: IntFilter<"CourseFeeStructure"> | number
    totalAmount?: FloatFilter<"CourseFeeStructure"> | number
    paymentType?: StringNullableListFilter<"CourseFeeStructure">
    clientAdminId?: StringFilter<"CourseFeeStructure"> | string
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    installments?: InstallmentDetailListRelationFilter
    clientAdmin?: XOR<ClientAdminScalarRelationFilter, ClientAdminWhereInput>
  }

  export type CourseFeeStructureOrderByWithRelationInput = {
    id?: SortOrder
    courseId?: SortOrder
    totalAmount?: SortOrder
    paymentType?: SortOrder
    clientAdminId?: SortOrder
    course?: CourseOrderByWithRelationInput
    installments?: InstallmentDetailOrderByRelationAggregateInput
    clientAdmin?: ClientAdminOrderByWithRelationInput
  }

  export type CourseFeeStructureWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    courseId?: number
    AND?: CourseFeeStructureWhereInput | CourseFeeStructureWhereInput[]
    OR?: CourseFeeStructureWhereInput[]
    NOT?: CourseFeeStructureWhereInput | CourseFeeStructureWhereInput[]
    totalAmount?: FloatFilter<"CourseFeeStructure"> | number
    paymentType?: StringNullableListFilter<"CourseFeeStructure">
    clientAdminId?: StringFilter<"CourseFeeStructure"> | string
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    installments?: InstallmentDetailListRelationFilter
    clientAdmin?: XOR<ClientAdminScalarRelationFilter, ClientAdminWhereInput>
  }, "id" | "courseId">

  export type CourseFeeStructureOrderByWithAggregationInput = {
    id?: SortOrder
    courseId?: SortOrder
    totalAmount?: SortOrder
    paymentType?: SortOrder
    clientAdminId?: SortOrder
    _count?: CourseFeeStructureCountOrderByAggregateInput
    _avg?: CourseFeeStructureAvgOrderByAggregateInput
    _max?: CourseFeeStructureMaxOrderByAggregateInput
    _min?: CourseFeeStructureMinOrderByAggregateInput
    _sum?: CourseFeeStructureSumOrderByAggregateInput
  }

  export type CourseFeeStructureScalarWhereWithAggregatesInput = {
    AND?: CourseFeeStructureScalarWhereWithAggregatesInput | CourseFeeStructureScalarWhereWithAggregatesInput[]
    OR?: CourseFeeStructureScalarWhereWithAggregatesInput[]
    NOT?: CourseFeeStructureScalarWhereWithAggregatesInput | CourseFeeStructureScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CourseFeeStructure"> | number
    courseId?: IntWithAggregatesFilter<"CourseFeeStructure"> | number
    totalAmount?: FloatWithAggregatesFilter<"CourseFeeStructure"> | number
    paymentType?: StringNullableListFilter<"CourseFeeStructure">
    clientAdminId?: StringWithAggregatesFilter<"CourseFeeStructure"> | string
  }

  export type BatchWhereInput = {
    AND?: BatchWhereInput | BatchWhereInput[]
    OR?: BatchWhereInput[]
    NOT?: BatchWhereInput | BatchWhereInput[]
    id?: IntFilter<"Batch"> | number
    name?: StringFilter<"Batch"> | string
    facultyId?: IntNullableFilter<"Batch"> | number | null
    labTimeSlotId?: IntFilter<"Batch"> | number
    clientAdminId?: StringFilter<"Batch"> | string
    faculty?: XOR<FacultyNullableScalarRelationFilter, FacultyWhereInput> | null
    labTimeSlot?: XOR<LabTimeSlotScalarRelationFilter, LabTimeSlotWhereInput>
    studentCourses?: StudentCourseListRelationFilter
    batchCourses?: BatchCourseListRelationFilter
    clientAdmin?: XOR<ClientAdminScalarRelationFilter, ClientAdminWhereInput>
  }

  export type BatchOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    facultyId?: SortOrderInput | SortOrder
    labTimeSlotId?: SortOrder
    clientAdminId?: SortOrder
    faculty?: FacultyOrderByWithRelationInput
    labTimeSlot?: LabTimeSlotOrderByWithRelationInput
    studentCourses?: StudentCourseOrderByRelationAggregateInput
    batchCourses?: BatchCourseOrderByRelationAggregateInput
    clientAdmin?: ClientAdminOrderByWithRelationInput
  }

  export type BatchWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    labTimeSlotId_clientAdminId?: BatchLabTimeSlotIdClientAdminIdCompoundUniqueInput
    AND?: BatchWhereInput | BatchWhereInput[]
    OR?: BatchWhereInput[]
    NOT?: BatchWhereInput | BatchWhereInput[]
    name?: StringFilter<"Batch"> | string
    facultyId?: IntNullableFilter<"Batch"> | number | null
    labTimeSlotId?: IntFilter<"Batch"> | number
    clientAdminId?: StringFilter<"Batch"> | string
    faculty?: XOR<FacultyNullableScalarRelationFilter, FacultyWhereInput> | null
    labTimeSlot?: XOR<LabTimeSlotScalarRelationFilter, LabTimeSlotWhereInput>
    studentCourses?: StudentCourseListRelationFilter
    batchCourses?: BatchCourseListRelationFilter
    clientAdmin?: XOR<ClientAdminScalarRelationFilter, ClientAdminWhereInput>
  }, "id" | "labTimeSlotId_clientAdminId">

  export type BatchOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    facultyId?: SortOrderInput | SortOrder
    labTimeSlotId?: SortOrder
    clientAdminId?: SortOrder
    _count?: BatchCountOrderByAggregateInput
    _avg?: BatchAvgOrderByAggregateInput
    _max?: BatchMaxOrderByAggregateInput
    _min?: BatchMinOrderByAggregateInput
    _sum?: BatchSumOrderByAggregateInput
  }

  export type BatchScalarWhereWithAggregatesInput = {
    AND?: BatchScalarWhereWithAggregatesInput | BatchScalarWhereWithAggregatesInput[]
    OR?: BatchScalarWhereWithAggregatesInput[]
    NOT?: BatchScalarWhereWithAggregatesInput | BatchScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Batch"> | number
    name?: StringWithAggregatesFilter<"Batch"> | string
    facultyId?: IntNullableWithAggregatesFilter<"Batch"> | number | null
    labTimeSlotId?: IntWithAggregatesFilter<"Batch"> | number
    clientAdminId?: StringWithAggregatesFilter<"Batch"> | string
  }

  export type BatchCourseWhereInput = {
    AND?: BatchCourseWhereInput | BatchCourseWhereInput[]
    OR?: BatchCourseWhereInput[]
    NOT?: BatchCourseWhereInput | BatchCourseWhereInput[]
    id?: IntFilter<"BatchCourse"> | number
    batchId?: IntFilter<"BatchCourse"> | number
    courseId?: IntFilter<"BatchCourse"> | number
    pcsReserved?: IntNullableFilter<"BatchCourse"> | number | null
    batch?: XOR<BatchScalarRelationFilter, BatchWhereInput>
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
  }

  export type BatchCourseOrderByWithRelationInput = {
    id?: SortOrder
    batchId?: SortOrder
    courseId?: SortOrder
    pcsReserved?: SortOrderInput | SortOrder
    batch?: BatchOrderByWithRelationInput
    course?: CourseOrderByWithRelationInput
  }

  export type BatchCourseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    batchId_courseId?: BatchCourseBatchIdCourseIdCompoundUniqueInput
    AND?: BatchCourseWhereInput | BatchCourseWhereInput[]
    OR?: BatchCourseWhereInput[]
    NOT?: BatchCourseWhereInput | BatchCourseWhereInput[]
    batchId?: IntFilter<"BatchCourse"> | number
    courseId?: IntFilter<"BatchCourse"> | number
    pcsReserved?: IntNullableFilter<"BatchCourse"> | number | null
    batch?: XOR<BatchScalarRelationFilter, BatchWhereInput>
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
  }, "id" | "batchId_courseId">

  export type BatchCourseOrderByWithAggregationInput = {
    id?: SortOrder
    batchId?: SortOrder
    courseId?: SortOrder
    pcsReserved?: SortOrderInput | SortOrder
    _count?: BatchCourseCountOrderByAggregateInput
    _avg?: BatchCourseAvgOrderByAggregateInput
    _max?: BatchCourseMaxOrderByAggregateInput
    _min?: BatchCourseMinOrderByAggregateInput
    _sum?: BatchCourseSumOrderByAggregateInput
  }

  export type BatchCourseScalarWhereWithAggregatesInput = {
    AND?: BatchCourseScalarWhereWithAggregatesInput | BatchCourseScalarWhereWithAggregatesInput[]
    OR?: BatchCourseScalarWhereWithAggregatesInput[]
    NOT?: BatchCourseScalarWhereWithAggregatesInput | BatchCourseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BatchCourse"> | number
    batchId?: IntWithAggregatesFilter<"BatchCourse"> | number
    courseId?: IntWithAggregatesFilter<"BatchCourse"> | number
    pcsReserved?: IntNullableWithAggregatesFilter<"BatchCourse"> | number | null
  }

  export type FacultyWhereInput = {
    AND?: FacultyWhereInput | FacultyWhereInput[]
    OR?: FacultyWhereInput[]
    NOT?: FacultyWhereInput | FacultyWhereInput[]
    id?: IntFilter<"Faculty"> | number
    name?: StringFilter<"Faculty"> | string
    email?: StringFilter<"Faculty"> | string
    password?: StringFilter<"Faculty"> | string
    contact?: StringFilter<"Faculty"> | string
    joiningDate?: DateTimeFilter<"Faculty"> | Date | string
    specialization?: StringNullableFilter<"Faculty"> | string | null
    role?: EnumUserRoleFilter<"Faculty"> | $Enums.UserRole
    country?: StringFilter<"Faculty"> | string
    state?: StringFilter<"Faculty"> | string
    city?: StringFilter<"Faculty"> | string
    zipCode?: StringFilter<"Faculty"> | string
    currentSessionToken?: StringNullableFilter<"Faculty"> | string | null
    lastLoginAt?: DateTimeNullableFilter<"Faculty"> | Date | string | null
    clientAdminId?: StringFilter<"Faculty"> | string
    batches?: BatchListRelationFilter
    attendance?: AttendanceRecordListRelationFilter
    tasks?: StudentTaskListRelationFilter
    financialRecords?: FinancialRecordListRelationFilter
    clientAdmin?: XOR<ClientAdminScalarRelationFilter, ClientAdminWhereInput>
  }

  export type FacultyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    contact?: SortOrder
    joiningDate?: SortOrder
    specialization?: SortOrderInput | SortOrder
    role?: SortOrder
    country?: SortOrder
    state?: SortOrder
    city?: SortOrder
    zipCode?: SortOrder
    currentSessionToken?: SortOrderInput | SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    clientAdminId?: SortOrder
    batches?: BatchOrderByRelationAggregateInput
    attendance?: AttendanceRecordOrderByRelationAggregateInput
    tasks?: StudentTaskOrderByRelationAggregateInput
    financialRecords?: FinancialRecordOrderByRelationAggregateInput
    clientAdmin?: ClientAdminOrderByWithRelationInput
  }

  export type FacultyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: FacultyWhereInput | FacultyWhereInput[]
    OR?: FacultyWhereInput[]
    NOT?: FacultyWhereInput | FacultyWhereInput[]
    name?: StringFilter<"Faculty"> | string
    password?: StringFilter<"Faculty"> | string
    contact?: StringFilter<"Faculty"> | string
    joiningDate?: DateTimeFilter<"Faculty"> | Date | string
    specialization?: StringNullableFilter<"Faculty"> | string | null
    role?: EnumUserRoleFilter<"Faculty"> | $Enums.UserRole
    country?: StringFilter<"Faculty"> | string
    state?: StringFilter<"Faculty"> | string
    city?: StringFilter<"Faculty"> | string
    zipCode?: StringFilter<"Faculty"> | string
    currentSessionToken?: StringNullableFilter<"Faculty"> | string | null
    lastLoginAt?: DateTimeNullableFilter<"Faculty"> | Date | string | null
    clientAdminId?: StringFilter<"Faculty"> | string
    batches?: BatchListRelationFilter
    attendance?: AttendanceRecordListRelationFilter
    tasks?: StudentTaskListRelationFilter
    financialRecords?: FinancialRecordListRelationFilter
    clientAdmin?: XOR<ClientAdminScalarRelationFilter, ClientAdminWhereInput>
  }, "id" | "email">

  export type FacultyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    contact?: SortOrder
    joiningDate?: SortOrder
    specialization?: SortOrderInput | SortOrder
    role?: SortOrder
    country?: SortOrder
    state?: SortOrder
    city?: SortOrder
    zipCode?: SortOrder
    currentSessionToken?: SortOrderInput | SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    clientAdminId?: SortOrder
    _count?: FacultyCountOrderByAggregateInput
    _avg?: FacultyAvgOrderByAggregateInput
    _max?: FacultyMaxOrderByAggregateInput
    _min?: FacultyMinOrderByAggregateInput
    _sum?: FacultySumOrderByAggregateInput
  }

  export type FacultyScalarWhereWithAggregatesInput = {
    AND?: FacultyScalarWhereWithAggregatesInput | FacultyScalarWhereWithAggregatesInput[]
    OR?: FacultyScalarWhereWithAggregatesInput[]
    NOT?: FacultyScalarWhereWithAggregatesInput | FacultyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Faculty"> | number
    name?: StringWithAggregatesFilter<"Faculty"> | string
    email?: StringWithAggregatesFilter<"Faculty"> | string
    password?: StringWithAggregatesFilter<"Faculty"> | string
    contact?: StringWithAggregatesFilter<"Faculty"> | string
    joiningDate?: DateTimeWithAggregatesFilter<"Faculty"> | Date | string
    specialization?: StringNullableWithAggregatesFilter<"Faculty"> | string | null
    role?: EnumUserRoleWithAggregatesFilter<"Faculty"> | $Enums.UserRole
    country?: StringWithAggregatesFilter<"Faculty"> | string
    state?: StringWithAggregatesFilter<"Faculty"> | string
    city?: StringWithAggregatesFilter<"Faculty"> | string
    zipCode?: StringWithAggregatesFilter<"Faculty"> | string
    currentSessionToken?: StringNullableWithAggregatesFilter<"Faculty"> | string | null
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"Faculty"> | Date | string | null
    clientAdminId?: StringWithAggregatesFilter<"Faculty"> | string
  }

  export type LabWhereInput = {
    AND?: LabWhereInput | LabWhereInput[]
    OR?: LabWhereInput[]
    NOT?: LabWhereInput | LabWhereInput[]
    id?: IntFilter<"Lab"> | number
    name?: StringFilter<"Lab"> | string
    location?: StringNullableFilter<"Lab"> | string | null
    totalPCs?: IntFilter<"Lab"> | number
    isActive?: BoolFilter<"Lab"> | boolean
    clientAdminId?: StringFilter<"Lab"> | string
    timeSlots?: LabTimeSlotListRelationFilter
    financialRecords?: FinancialRecordListRelationFilter
    clientAdmin?: XOR<ClientAdminScalarRelationFilter, ClientAdminWhereInput>
  }

  export type LabOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrderInput | SortOrder
    totalPCs?: SortOrder
    isActive?: SortOrder
    clientAdminId?: SortOrder
    timeSlots?: LabTimeSlotOrderByRelationAggregateInput
    financialRecords?: FinancialRecordOrderByRelationAggregateInput
    clientAdmin?: ClientAdminOrderByWithRelationInput
  }

  export type LabWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LabWhereInput | LabWhereInput[]
    OR?: LabWhereInput[]
    NOT?: LabWhereInput | LabWhereInput[]
    name?: StringFilter<"Lab"> | string
    location?: StringNullableFilter<"Lab"> | string | null
    totalPCs?: IntFilter<"Lab"> | number
    isActive?: BoolFilter<"Lab"> | boolean
    clientAdminId?: StringFilter<"Lab"> | string
    timeSlots?: LabTimeSlotListRelationFilter
    financialRecords?: FinancialRecordListRelationFilter
    clientAdmin?: XOR<ClientAdminScalarRelationFilter, ClientAdminWhereInput>
  }, "id">

  export type LabOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrderInput | SortOrder
    totalPCs?: SortOrder
    isActive?: SortOrder
    clientAdminId?: SortOrder
    _count?: LabCountOrderByAggregateInput
    _avg?: LabAvgOrderByAggregateInput
    _max?: LabMaxOrderByAggregateInput
    _min?: LabMinOrderByAggregateInput
    _sum?: LabSumOrderByAggregateInput
  }

  export type LabScalarWhereWithAggregatesInput = {
    AND?: LabScalarWhereWithAggregatesInput | LabScalarWhereWithAggregatesInput[]
    OR?: LabScalarWhereWithAggregatesInput[]
    NOT?: LabScalarWhereWithAggregatesInput | LabScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Lab"> | number
    name?: StringWithAggregatesFilter<"Lab"> | string
    location?: StringNullableWithAggregatesFilter<"Lab"> | string | null
    totalPCs?: IntWithAggregatesFilter<"Lab"> | number
    isActive?: BoolWithAggregatesFilter<"Lab"> | boolean
    clientAdminId?: StringWithAggregatesFilter<"Lab"> | string
  }

  export type LabTimeSlotWhereInput = {
    AND?: LabTimeSlotWhereInput | LabTimeSlotWhereInput[]
    OR?: LabTimeSlotWhereInput[]
    NOT?: LabTimeSlotWhereInput | LabTimeSlotWhereInput[]
    id?: IntFilter<"LabTimeSlot"> | number
    startTime?: StringFilter<"LabTimeSlot"> | string
    endTime?: StringFilter<"LabTimeSlot"> | string
    day?: StringFilter<"LabTimeSlot"> | string
    labId?: IntFilter<"LabTimeSlot"> | number
    availablePCs?: IntFilter<"LabTimeSlot"> | number
    clientAdminId?: StringFilter<"LabTimeSlot"> | string
    lab?: XOR<LabScalarRelationFilter, LabWhereInput>
    batches?: BatchListRelationFilter
    allocations?: LabAllocationListRelationFilter
    clientAdmin?: XOR<ClientAdminScalarRelationFilter, ClientAdminWhereInput>
  }

  export type LabTimeSlotOrderByWithRelationInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    day?: SortOrder
    labId?: SortOrder
    availablePCs?: SortOrder
    clientAdminId?: SortOrder
    lab?: LabOrderByWithRelationInput
    batches?: BatchOrderByRelationAggregateInput
    allocations?: LabAllocationOrderByRelationAggregateInput
    clientAdmin?: ClientAdminOrderByWithRelationInput
  }

  export type LabTimeSlotWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LabTimeSlotWhereInput | LabTimeSlotWhereInput[]
    OR?: LabTimeSlotWhereInput[]
    NOT?: LabTimeSlotWhereInput | LabTimeSlotWhereInput[]
    startTime?: StringFilter<"LabTimeSlot"> | string
    endTime?: StringFilter<"LabTimeSlot"> | string
    day?: StringFilter<"LabTimeSlot"> | string
    labId?: IntFilter<"LabTimeSlot"> | number
    availablePCs?: IntFilter<"LabTimeSlot"> | number
    clientAdminId?: StringFilter<"LabTimeSlot"> | string
    lab?: XOR<LabScalarRelationFilter, LabWhereInput>
    batches?: BatchListRelationFilter
    allocations?: LabAllocationListRelationFilter
    clientAdmin?: XOR<ClientAdminScalarRelationFilter, ClientAdminWhereInput>
  }, "id">

  export type LabTimeSlotOrderByWithAggregationInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    day?: SortOrder
    labId?: SortOrder
    availablePCs?: SortOrder
    clientAdminId?: SortOrder
    _count?: LabTimeSlotCountOrderByAggregateInput
    _avg?: LabTimeSlotAvgOrderByAggregateInput
    _max?: LabTimeSlotMaxOrderByAggregateInput
    _min?: LabTimeSlotMinOrderByAggregateInput
    _sum?: LabTimeSlotSumOrderByAggregateInput
  }

  export type LabTimeSlotScalarWhereWithAggregatesInput = {
    AND?: LabTimeSlotScalarWhereWithAggregatesInput | LabTimeSlotScalarWhereWithAggregatesInput[]
    OR?: LabTimeSlotScalarWhereWithAggregatesInput[]
    NOT?: LabTimeSlotScalarWhereWithAggregatesInput | LabTimeSlotScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LabTimeSlot"> | number
    startTime?: StringWithAggregatesFilter<"LabTimeSlot"> | string
    endTime?: StringWithAggregatesFilter<"LabTimeSlot"> | string
    day?: StringWithAggregatesFilter<"LabTimeSlot"> | string
    labId?: IntWithAggregatesFilter<"LabTimeSlot"> | number
    availablePCs?: IntWithAggregatesFilter<"LabTimeSlot"> | number
    clientAdminId?: StringWithAggregatesFilter<"LabTimeSlot"> | string
  }

  export type PaymentStructureTypeWhereInput = {
    AND?: PaymentStructureTypeWhereInput | PaymentStructureTypeWhereInput[]
    OR?: PaymentStructureTypeWhereInput[]
    NOT?: PaymentStructureTypeWhereInput | PaymentStructureTypeWhereInput[]
    id?: IntFilter<"PaymentStructureType"> | number
    name?: EnumPaymentTypeFilter<"PaymentStructureType"> | $Enums.PaymentType
    installmentCount?: IntNullableFilter<"PaymentStructureType"> | number | null
  }

  export type PaymentStructureTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    installmentCount?: SortOrderInput | SortOrder
  }

  export type PaymentStructureTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PaymentStructureTypeWhereInput | PaymentStructureTypeWhereInput[]
    OR?: PaymentStructureTypeWhereInput[]
    NOT?: PaymentStructureTypeWhereInput | PaymentStructureTypeWhereInput[]
    name?: EnumPaymentTypeFilter<"PaymentStructureType"> | $Enums.PaymentType
    installmentCount?: IntNullableFilter<"PaymentStructureType"> | number | null
  }, "id">

  export type PaymentStructureTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    installmentCount?: SortOrderInput | SortOrder
    _count?: PaymentStructureTypeCountOrderByAggregateInput
    _avg?: PaymentStructureTypeAvgOrderByAggregateInput
    _max?: PaymentStructureTypeMaxOrderByAggregateInput
    _min?: PaymentStructureTypeMinOrderByAggregateInput
    _sum?: PaymentStructureTypeSumOrderByAggregateInput
  }

  export type PaymentStructureTypeScalarWhereWithAggregatesInput = {
    AND?: PaymentStructureTypeScalarWhereWithAggregatesInput | PaymentStructureTypeScalarWhereWithAggregatesInput[]
    OR?: PaymentStructureTypeScalarWhereWithAggregatesInput[]
    NOT?: PaymentStructureTypeScalarWhereWithAggregatesInput | PaymentStructureTypeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PaymentStructureType"> | number
    name?: EnumPaymentTypeWithAggregatesFilter<"PaymentStructureType"> | $Enums.PaymentType
    installmentCount?: IntNullableWithAggregatesFilter<"PaymentStructureType"> | number | null
  }

  export type InstallmentDetailWhereInput = {
    AND?: InstallmentDetailWhereInput | InstallmentDetailWhereInput[]
    OR?: InstallmentDetailWhereInput[]
    NOT?: InstallmentDetailWhereInput | InstallmentDetailWhereInput[]
    id?: IntFilter<"InstallmentDetail"> | number
    CourseFeeStructureId?: IntFilter<"InstallmentDetail"> | number
    number?: IntFilter<"InstallmentDetail"> | number
    amount?: FloatFilter<"InstallmentDetail"> | number
    feeStructures?: FeeStructureListRelationFilter
    CourseFeeStructure?: XOR<CourseFeeStructureScalarRelationFilter, CourseFeeStructureWhereInput>
  }

  export type InstallmentDetailOrderByWithRelationInput = {
    id?: SortOrder
    CourseFeeStructureId?: SortOrder
    number?: SortOrder
    amount?: SortOrder
    feeStructures?: FeeStructureOrderByRelationAggregateInput
    CourseFeeStructure?: CourseFeeStructureOrderByWithRelationInput
  }

  export type InstallmentDetailWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: InstallmentDetailWhereInput | InstallmentDetailWhereInput[]
    OR?: InstallmentDetailWhereInput[]
    NOT?: InstallmentDetailWhereInput | InstallmentDetailWhereInput[]
    CourseFeeStructureId?: IntFilter<"InstallmentDetail"> | number
    number?: IntFilter<"InstallmentDetail"> | number
    amount?: FloatFilter<"InstallmentDetail"> | number
    feeStructures?: FeeStructureListRelationFilter
    CourseFeeStructure?: XOR<CourseFeeStructureScalarRelationFilter, CourseFeeStructureWhereInput>
  }, "id">

  export type InstallmentDetailOrderByWithAggregationInput = {
    id?: SortOrder
    CourseFeeStructureId?: SortOrder
    number?: SortOrder
    amount?: SortOrder
    _count?: InstallmentDetailCountOrderByAggregateInput
    _avg?: InstallmentDetailAvgOrderByAggregateInput
    _max?: InstallmentDetailMaxOrderByAggregateInput
    _min?: InstallmentDetailMinOrderByAggregateInput
    _sum?: InstallmentDetailSumOrderByAggregateInput
  }

  export type InstallmentDetailScalarWhereWithAggregatesInput = {
    AND?: InstallmentDetailScalarWhereWithAggregatesInput | InstallmentDetailScalarWhereWithAggregatesInput[]
    OR?: InstallmentDetailScalarWhereWithAggregatesInput[]
    NOT?: InstallmentDetailScalarWhereWithAggregatesInput | InstallmentDetailScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"InstallmentDetail"> | number
    CourseFeeStructureId?: IntWithAggregatesFilter<"InstallmentDetail"> | number
    number?: IntWithAggregatesFilter<"InstallmentDetail"> | number
    amount?: FloatWithAggregatesFilter<"InstallmentDetail"> | number
  }

  export type LabAllocationWhereInput = {
    AND?: LabAllocationWhereInput | LabAllocationWhereInput[]
    OR?: LabAllocationWhereInput[]
    NOT?: LabAllocationWhereInput | LabAllocationWhereInput[]
    id?: IntFilter<"LabAllocation"> | number
    labTimeSlotId?: IntFilter<"LabAllocation"> | number
    studentId?: IntFilter<"LabAllocation"> | number
    pcNumber?: IntFilter<"LabAllocation"> | number
    assignedAt?: DateTimeFilter<"LabAllocation"> | Date | string
    clientAdminId?: StringFilter<"LabAllocation"> | string
    labTimeSlot?: XOR<LabTimeSlotScalarRelationFilter, LabTimeSlotWhereInput>
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    clientAdmin?: XOR<ClientAdminScalarRelationFilter, ClientAdminWhereInput>
  }

  export type LabAllocationOrderByWithRelationInput = {
    id?: SortOrder
    labTimeSlotId?: SortOrder
    studentId?: SortOrder
    pcNumber?: SortOrder
    assignedAt?: SortOrder
    clientAdminId?: SortOrder
    labTimeSlot?: LabTimeSlotOrderByWithRelationInput
    student?: StudentOrderByWithRelationInput
    clientAdmin?: ClientAdminOrderByWithRelationInput
  }

  export type LabAllocationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    labTimeSlotId_pcNumber?: LabAllocationLabTimeSlotIdPcNumberCompoundUniqueInput
    labTimeSlotId_studentId?: LabAllocationLabTimeSlotIdStudentIdCompoundUniqueInput
    AND?: LabAllocationWhereInput | LabAllocationWhereInput[]
    OR?: LabAllocationWhereInput[]
    NOT?: LabAllocationWhereInput | LabAllocationWhereInput[]
    labTimeSlotId?: IntFilter<"LabAllocation"> | number
    studentId?: IntFilter<"LabAllocation"> | number
    pcNumber?: IntFilter<"LabAllocation"> | number
    assignedAt?: DateTimeFilter<"LabAllocation"> | Date | string
    clientAdminId?: StringFilter<"LabAllocation"> | string
    labTimeSlot?: XOR<LabTimeSlotScalarRelationFilter, LabTimeSlotWhereInput>
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    clientAdmin?: XOR<ClientAdminScalarRelationFilter, ClientAdminWhereInput>
  }, "id" | "labTimeSlotId_pcNumber" | "labTimeSlotId_studentId">

  export type LabAllocationOrderByWithAggregationInput = {
    id?: SortOrder
    labTimeSlotId?: SortOrder
    studentId?: SortOrder
    pcNumber?: SortOrder
    assignedAt?: SortOrder
    clientAdminId?: SortOrder
    _count?: LabAllocationCountOrderByAggregateInput
    _avg?: LabAllocationAvgOrderByAggregateInput
    _max?: LabAllocationMaxOrderByAggregateInput
    _min?: LabAllocationMinOrderByAggregateInput
    _sum?: LabAllocationSumOrderByAggregateInput
  }

  export type LabAllocationScalarWhereWithAggregatesInput = {
    AND?: LabAllocationScalarWhereWithAggregatesInput | LabAllocationScalarWhereWithAggregatesInput[]
    OR?: LabAllocationScalarWhereWithAggregatesInput[]
    NOT?: LabAllocationScalarWhereWithAggregatesInput | LabAllocationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LabAllocation"> | number
    labTimeSlotId?: IntWithAggregatesFilter<"LabAllocation"> | number
    studentId?: IntWithAggregatesFilter<"LabAllocation"> | number
    pcNumber?: IntWithAggregatesFilter<"LabAllocation"> | number
    assignedAt?: DateTimeWithAggregatesFilter<"LabAllocation"> | Date | string
    clientAdminId?: StringWithAggregatesFilter<"LabAllocation"> | string
  }

  export type StudentCourseWhereInput = {
    AND?: StudentCourseWhereInput | StudentCourseWhereInput[]
    OR?: StudentCourseWhereInput[]
    NOT?: StudentCourseWhereInput | StudentCourseWhereInput[]
    id?: IntFilter<"StudentCourse"> | number
    studentId?: IntFilter<"StudentCourse"> | number
    courseId?: IntFilter<"StudentCourse"> | number
    startDate?: DateTimeFilter<"StudentCourse"> | Date | string
    endDate?: DateTimeFilter<"StudentCourse"> | Date | string
    studentCode?: StringFilter<"StudentCourse"> | string
    batchId?: IntNullableFilter<"StudentCourse"> | number | null
    internalNotes?: StringNullableFilter<"StudentCourse"> | string | null
    status?: StringFilter<"StudentCourse"> | string
    clientAdminId?: StringFilter<"StudentCourse"> | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    batch?: XOR<BatchNullableScalarRelationFilter, BatchWhereInput> | null
    certificate?: XOR<CertificateNullableScalarRelationFilter, CertificateWhereInput> | null
    completions?: CourseCompletionListRelationFilter
    clientAdmin?: XOR<ClientAdminScalarRelationFilter, ClientAdminWhereInput>
  }

  export type StudentCourseOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    courseId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    studentCode?: SortOrder
    batchId?: SortOrderInput | SortOrder
    internalNotes?: SortOrderInput | SortOrder
    status?: SortOrder
    clientAdminId?: SortOrder
    student?: StudentOrderByWithRelationInput
    course?: CourseOrderByWithRelationInput
    batch?: BatchOrderByWithRelationInput
    certificate?: CertificateOrderByWithRelationInput
    completions?: CourseCompletionOrderByRelationAggregateInput
    clientAdmin?: ClientAdminOrderByWithRelationInput
  }

  export type StudentCourseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: StudentCourseWhereInput | StudentCourseWhereInput[]
    OR?: StudentCourseWhereInput[]
    NOT?: StudentCourseWhereInput | StudentCourseWhereInput[]
    studentId?: IntFilter<"StudentCourse"> | number
    courseId?: IntFilter<"StudentCourse"> | number
    startDate?: DateTimeFilter<"StudentCourse"> | Date | string
    endDate?: DateTimeFilter<"StudentCourse"> | Date | string
    studentCode?: StringFilter<"StudentCourse"> | string
    batchId?: IntNullableFilter<"StudentCourse"> | number | null
    internalNotes?: StringNullableFilter<"StudentCourse"> | string | null
    status?: StringFilter<"StudentCourse"> | string
    clientAdminId?: StringFilter<"StudentCourse"> | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    batch?: XOR<BatchNullableScalarRelationFilter, BatchWhereInput> | null
    certificate?: XOR<CertificateNullableScalarRelationFilter, CertificateWhereInput> | null
    completions?: CourseCompletionListRelationFilter
    clientAdmin?: XOR<ClientAdminScalarRelationFilter, ClientAdminWhereInput>
  }, "id">

  export type StudentCourseOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    courseId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    studentCode?: SortOrder
    batchId?: SortOrderInput | SortOrder
    internalNotes?: SortOrderInput | SortOrder
    status?: SortOrder
    clientAdminId?: SortOrder
    _count?: StudentCourseCountOrderByAggregateInput
    _avg?: StudentCourseAvgOrderByAggregateInput
    _max?: StudentCourseMaxOrderByAggregateInput
    _min?: StudentCourseMinOrderByAggregateInput
    _sum?: StudentCourseSumOrderByAggregateInput
  }

  export type StudentCourseScalarWhereWithAggregatesInput = {
    AND?: StudentCourseScalarWhereWithAggregatesInput | StudentCourseScalarWhereWithAggregatesInput[]
    OR?: StudentCourseScalarWhereWithAggregatesInput[]
    NOT?: StudentCourseScalarWhereWithAggregatesInput | StudentCourseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"StudentCourse"> | number
    studentId?: IntWithAggregatesFilter<"StudentCourse"> | number
    courseId?: IntWithAggregatesFilter<"StudentCourse"> | number
    startDate?: DateTimeWithAggregatesFilter<"StudentCourse"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"StudentCourse"> | Date | string
    studentCode?: StringWithAggregatesFilter<"StudentCourse"> | string
    batchId?: IntNullableWithAggregatesFilter<"StudentCourse"> | number | null
    internalNotes?: StringNullableWithAggregatesFilter<"StudentCourse"> | string | null
    status?: StringWithAggregatesFilter<"StudentCourse"> | string
    clientAdminId?: StringWithAggregatesFilter<"StudentCourse"> | string
  }

  export type FeeStructureWhereInput = {
    AND?: FeeStructureWhereInput | FeeStructureWhereInput[]
    OR?: FeeStructureWhereInput[]
    NOT?: FeeStructureWhereInput | FeeStructureWhereInput[]
    id?: IntFilter<"FeeStructure"> | number
    studentId?: IntFilter<"FeeStructure"> | number
    courseId?: IntFilter<"FeeStructure"> | number
    totalAmount?: FloatFilter<"FeeStructure"> | number
    paymentType?: EnumPaymentTypeFilter<"FeeStructure"> | $Enums.PaymentType
    installmentCount?: IntNullableFilter<"FeeStructure"> | number | null
    installmentTypeId?: IntNullableFilter<"FeeStructure"> | number | null
    clientAdminId?: StringFilter<"FeeStructure"> | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    installment?: XOR<InstallmentDetailNullableScalarRelationFilter, InstallmentDetailWhereInput> | null
    studentFees?: StudentFeeListRelationFilter
    clientAdmin?: XOR<ClientAdminScalarRelationFilter, ClientAdminWhereInput>
  }

  export type FeeStructureOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    courseId?: SortOrder
    totalAmount?: SortOrder
    paymentType?: SortOrder
    installmentCount?: SortOrderInput | SortOrder
    installmentTypeId?: SortOrderInput | SortOrder
    clientAdminId?: SortOrder
    student?: StudentOrderByWithRelationInput
    course?: CourseOrderByWithRelationInput
    installment?: InstallmentDetailOrderByWithRelationInput
    studentFees?: StudentFeeOrderByRelationAggregateInput
    clientAdmin?: ClientAdminOrderByWithRelationInput
  }

  export type FeeStructureWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    studentId_courseId?: FeeStructureStudentIdCourseIdCompoundUniqueInput
    AND?: FeeStructureWhereInput | FeeStructureWhereInput[]
    OR?: FeeStructureWhereInput[]
    NOT?: FeeStructureWhereInput | FeeStructureWhereInput[]
    studentId?: IntFilter<"FeeStructure"> | number
    courseId?: IntFilter<"FeeStructure"> | number
    totalAmount?: FloatFilter<"FeeStructure"> | number
    paymentType?: EnumPaymentTypeFilter<"FeeStructure"> | $Enums.PaymentType
    installmentCount?: IntNullableFilter<"FeeStructure"> | number | null
    installmentTypeId?: IntNullableFilter<"FeeStructure"> | number | null
    clientAdminId?: StringFilter<"FeeStructure"> | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    installment?: XOR<InstallmentDetailNullableScalarRelationFilter, InstallmentDetailWhereInput> | null
    studentFees?: StudentFeeListRelationFilter
    clientAdmin?: XOR<ClientAdminScalarRelationFilter, ClientAdminWhereInput>
  }, "id" | "studentId_courseId">

  export type FeeStructureOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    courseId?: SortOrder
    totalAmount?: SortOrder
    paymentType?: SortOrder
    installmentCount?: SortOrderInput | SortOrder
    installmentTypeId?: SortOrderInput | SortOrder
    clientAdminId?: SortOrder
    _count?: FeeStructureCountOrderByAggregateInput
    _avg?: FeeStructureAvgOrderByAggregateInput
    _max?: FeeStructureMaxOrderByAggregateInput
    _min?: FeeStructureMinOrderByAggregateInput
    _sum?: FeeStructureSumOrderByAggregateInput
  }

  export type FeeStructureScalarWhereWithAggregatesInput = {
    AND?: FeeStructureScalarWhereWithAggregatesInput | FeeStructureScalarWhereWithAggregatesInput[]
    OR?: FeeStructureScalarWhereWithAggregatesInput[]
    NOT?: FeeStructureScalarWhereWithAggregatesInput | FeeStructureScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FeeStructure"> | number
    studentId?: IntWithAggregatesFilter<"FeeStructure"> | number
    courseId?: IntWithAggregatesFilter<"FeeStructure"> | number
    totalAmount?: FloatWithAggregatesFilter<"FeeStructure"> | number
    paymentType?: EnumPaymentTypeWithAggregatesFilter<"FeeStructure"> | $Enums.PaymentType
    installmentCount?: IntNullableWithAggregatesFilter<"FeeStructure"> | number | null
    installmentTypeId?: IntNullableWithAggregatesFilter<"FeeStructure"> | number | null
    clientAdminId?: StringWithAggregatesFilter<"FeeStructure"> | string
  }

  export type StudentFeeLogWhereInput = {
    AND?: StudentFeeLogWhereInput | StudentFeeLogWhereInput[]
    OR?: StudentFeeLogWhereInput[]
    NOT?: StudentFeeLogWhereInput | StudentFeeLogWhereInput[]
    id?: IntFilter<"StudentFeeLog"> | number
    studentFeeId?: IntFilter<"StudentFeeLog"> | number
    amountPaid?: FloatFilter<"StudentFeeLog"> | number
    paymentDate?: DateTimeFilter<"StudentFeeLog"> | Date | string
    paymentMode?: EnumPaymentModeFilter<"StudentFeeLog"> | $Enums.PaymentMode
    receiptNo?: StringFilter<"StudentFeeLog"> | string
    studentFee?: XOR<StudentFeeScalarRelationFilter, StudentFeeWhereInput>
  }

  export type StudentFeeLogOrderByWithRelationInput = {
    id?: SortOrder
    studentFeeId?: SortOrder
    amountPaid?: SortOrder
    paymentDate?: SortOrder
    paymentMode?: SortOrder
    receiptNo?: SortOrder
    studentFee?: StudentFeeOrderByWithRelationInput
  }

  export type StudentFeeLogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    receiptNo?: string
    AND?: StudentFeeLogWhereInput | StudentFeeLogWhereInput[]
    OR?: StudentFeeLogWhereInput[]
    NOT?: StudentFeeLogWhereInput | StudentFeeLogWhereInput[]
    studentFeeId?: IntFilter<"StudentFeeLog"> | number
    amountPaid?: FloatFilter<"StudentFeeLog"> | number
    paymentDate?: DateTimeFilter<"StudentFeeLog"> | Date | string
    paymentMode?: EnumPaymentModeFilter<"StudentFeeLog"> | $Enums.PaymentMode
    studentFee?: XOR<StudentFeeScalarRelationFilter, StudentFeeWhereInput>
  }, "id" | "receiptNo">

  export type StudentFeeLogOrderByWithAggregationInput = {
    id?: SortOrder
    studentFeeId?: SortOrder
    amountPaid?: SortOrder
    paymentDate?: SortOrder
    paymentMode?: SortOrder
    receiptNo?: SortOrder
    _count?: StudentFeeLogCountOrderByAggregateInput
    _avg?: StudentFeeLogAvgOrderByAggregateInput
    _max?: StudentFeeLogMaxOrderByAggregateInput
    _min?: StudentFeeLogMinOrderByAggregateInput
    _sum?: StudentFeeLogSumOrderByAggregateInput
  }

  export type StudentFeeLogScalarWhereWithAggregatesInput = {
    AND?: StudentFeeLogScalarWhereWithAggregatesInput | StudentFeeLogScalarWhereWithAggregatesInput[]
    OR?: StudentFeeLogScalarWhereWithAggregatesInput[]
    NOT?: StudentFeeLogScalarWhereWithAggregatesInput | StudentFeeLogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"StudentFeeLog"> | number
    studentFeeId?: IntWithAggregatesFilter<"StudentFeeLog"> | number
    amountPaid?: FloatWithAggregatesFilter<"StudentFeeLog"> | number
    paymentDate?: DateTimeWithAggregatesFilter<"StudentFeeLog"> | Date | string
    paymentMode?: EnumPaymentModeWithAggregatesFilter<"StudentFeeLog"> | $Enums.PaymentMode
    receiptNo?: StringWithAggregatesFilter<"StudentFeeLog"> | string
  }

  export type StudentFeeWhereInput = {
    AND?: StudentFeeWhereInput | StudentFeeWhereInput[]
    OR?: StudentFeeWhereInput[]
    NOT?: StudentFeeWhereInput | StudentFeeWhereInput[]
    id?: IntFilter<"StudentFee"> | number
    studentId?: IntFilter<"StudentFee"> | number
    courseId?: IntFilter<"StudentFee"> | number
    dueDate?: DateTimeFilter<"StudentFee"> | Date | string
    amountDue?: FloatFilter<"StudentFee"> | number
    amountPaid?: FloatFilter<"StudentFee"> | number
    paymentDate?: DateTimeNullableFilter<"StudentFee"> | Date | string | null
    paymentMode?: EnumPaymentModeFilter<"StudentFee"> | $Enums.PaymentMode
    receiptNo?: StringFilter<"StudentFee"> | string
    paymentStatus?: EnumPaymentStatusFilter<"StudentFee"> | $Enums.PaymentStatus
    clientAdminId?: StringFilter<"StudentFee"> | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    feeLogs?: StudentFeeLogListRelationFilter
    feeStructure?: XOR<FeeStructureNullableScalarRelationFilter, FeeStructureWhereInput> | null
    notification?: XOR<NotificationNullableScalarRelationFilter, NotificationWhereInput> | null
    clientAdmin?: XOR<ClientAdminScalarRelationFilter, ClientAdminWhereInput>
  }

  export type StudentFeeOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    courseId?: SortOrder
    dueDate?: SortOrder
    amountDue?: SortOrder
    amountPaid?: SortOrder
    paymentDate?: SortOrderInput | SortOrder
    paymentMode?: SortOrder
    receiptNo?: SortOrder
    paymentStatus?: SortOrder
    clientAdminId?: SortOrder
    student?: StudentOrderByWithRelationInput
    course?: CourseOrderByWithRelationInput
    feeLogs?: StudentFeeLogOrderByRelationAggregateInput
    feeStructure?: FeeStructureOrderByWithRelationInput
    notification?: NotificationOrderByWithRelationInput
    clientAdmin?: ClientAdminOrderByWithRelationInput
  }

  export type StudentFeeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    receiptNo?: string
    AND?: StudentFeeWhereInput | StudentFeeWhereInput[]
    OR?: StudentFeeWhereInput[]
    NOT?: StudentFeeWhereInput | StudentFeeWhereInput[]
    studentId?: IntFilter<"StudentFee"> | number
    courseId?: IntFilter<"StudentFee"> | number
    dueDate?: DateTimeFilter<"StudentFee"> | Date | string
    amountDue?: FloatFilter<"StudentFee"> | number
    amountPaid?: FloatFilter<"StudentFee"> | number
    paymentDate?: DateTimeNullableFilter<"StudentFee"> | Date | string | null
    paymentMode?: EnumPaymentModeFilter<"StudentFee"> | $Enums.PaymentMode
    paymentStatus?: EnumPaymentStatusFilter<"StudentFee"> | $Enums.PaymentStatus
    clientAdminId?: StringFilter<"StudentFee"> | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    feeLogs?: StudentFeeLogListRelationFilter
    feeStructure?: XOR<FeeStructureNullableScalarRelationFilter, FeeStructureWhereInput> | null
    notification?: XOR<NotificationNullableScalarRelationFilter, NotificationWhereInput> | null
    clientAdmin?: XOR<ClientAdminScalarRelationFilter, ClientAdminWhereInput>
  }, "id" | "receiptNo">

  export type StudentFeeOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    courseId?: SortOrder
    dueDate?: SortOrder
    amountDue?: SortOrder
    amountPaid?: SortOrder
    paymentDate?: SortOrderInput | SortOrder
    paymentMode?: SortOrder
    receiptNo?: SortOrder
    paymentStatus?: SortOrder
    clientAdminId?: SortOrder
    _count?: StudentFeeCountOrderByAggregateInput
    _avg?: StudentFeeAvgOrderByAggregateInput
    _max?: StudentFeeMaxOrderByAggregateInput
    _min?: StudentFeeMinOrderByAggregateInput
    _sum?: StudentFeeSumOrderByAggregateInput
  }

  export type StudentFeeScalarWhereWithAggregatesInput = {
    AND?: StudentFeeScalarWhereWithAggregatesInput | StudentFeeScalarWhereWithAggregatesInput[]
    OR?: StudentFeeScalarWhereWithAggregatesInput[]
    NOT?: StudentFeeScalarWhereWithAggregatesInput | StudentFeeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"StudentFee"> | number
    studentId?: IntWithAggregatesFilter<"StudentFee"> | number
    courseId?: IntWithAggregatesFilter<"StudentFee"> | number
    dueDate?: DateTimeWithAggregatesFilter<"StudentFee"> | Date | string
    amountDue?: FloatWithAggregatesFilter<"StudentFee"> | number
    amountPaid?: FloatWithAggregatesFilter<"StudentFee"> | number
    paymentDate?: DateTimeNullableWithAggregatesFilter<"StudentFee"> | Date | string | null
    paymentMode?: EnumPaymentModeWithAggregatesFilter<"StudentFee"> | $Enums.PaymentMode
    receiptNo?: StringWithAggregatesFilter<"StudentFee"> | string
    paymentStatus?: EnumPaymentStatusWithAggregatesFilter<"StudentFee"> | $Enums.PaymentStatus
    clientAdminId?: StringWithAggregatesFilter<"StudentFee"> | string
  }

  export type StationeryItemWhereInput = {
    AND?: StationeryItemWhereInput | StationeryItemWhereInput[]
    OR?: StationeryItemWhereInput[]
    NOT?: StationeryItemWhereInput | StationeryItemWhereInput[]
    id?: IntFilter<"StationeryItem"> | number
    name?: StringFilter<"StationeryItem"> | string
    quantityAvailable?: IntFilter<"StationeryItem"> | number
    stationeryIssues?: StationeryIssueListRelationFilter
  }

  export type StationeryItemOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    quantityAvailable?: SortOrder
    stationeryIssues?: StationeryIssueOrderByRelationAggregateInput
  }

  export type StationeryItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: StationeryItemWhereInput | StationeryItemWhereInput[]
    OR?: StationeryItemWhereInput[]
    NOT?: StationeryItemWhereInput | StationeryItemWhereInput[]
    name?: StringFilter<"StationeryItem"> | string
    quantityAvailable?: IntFilter<"StationeryItem"> | number
    stationeryIssues?: StationeryIssueListRelationFilter
  }, "id">

  export type StationeryItemOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    quantityAvailable?: SortOrder
    _count?: StationeryItemCountOrderByAggregateInput
    _avg?: StationeryItemAvgOrderByAggregateInput
    _max?: StationeryItemMaxOrderByAggregateInput
    _min?: StationeryItemMinOrderByAggregateInput
    _sum?: StationeryItemSumOrderByAggregateInput
  }

  export type StationeryItemScalarWhereWithAggregatesInput = {
    AND?: StationeryItemScalarWhereWithAggregatesInput | StationeryItemScalarWhereWithAggregatesInput[]
    OR?: StationeryItemScalarWhereWithAggregatesInput[]
    NOT?: StationeryItemScalarWhereWithAggregatesInput | StationeryItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"StationeryItem"> | number
    name?: StringWithAggregatesFilter<"StationeryItem"> | string
    quantityAvailable?: IntWithAggregatesFilter<"StationeryItem"> | number
  }

  export type StationeryIssueWhereInput = {
    AND?: StationeryIssueWhereInput | StationeryIssueWhereInput[]
    OR?: StationeryIssueWhereInput[]
    NOT?: StationeryIssueWhereInput | StationeryIssueWhereInput[]
    id?: IntFilter<"StationeryIssue"> | number
    studentId?: IntFilter<"StationeryIssue"> | number
    courseId?: IntFilter<"StationeryIssue"> | number
    itemId?: IntFilter<"StationeryIssue"> | number
    issueDate?: DateTimeFilter<"StationeryIssue"> | Date | string
    quantity?: IntFilter<"StationeryIssue"> | number
    remarks?: StringNullableFilter<"StationeryIssue"> | string | null
    clientAdminId?: StringFilter<"StationeryIssue"> | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    item?: XOR<StationeryItemScalarRelationFilter, StationeryItemWhereInput>
    clientAdmin?: XOR<ClientAdminScalarRelationFilter, ClientAdminWhereInput>
  }

  export type StationeryIssueOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    courseId?: SortOrder
    itemId?: SortOrder
    issueDate?: SortOrder
    quantity?: SortOrder
    remarks?: SortOrderInput | SortOrder
    clientAdminId?: SortOrder
    student?: StudentOrderByWithRelationInput
    course?: CourseOrderByWithRelationInput
    item?: StationeryItemOrderByWithRelationInput
    clientAdmin?: ClientAdminOrderByWithRelationInput
  }

  export type StationeryIssueWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: StationeryIssueWhereInput | StationeryIssueWhereInput[]
    OR?: StationeryIssueWhereInput[]
    NOT?: StationeryIssueWhereInput | StationeryIssueWhereInput[]
    studentId?: IntFilter<"StationeryIssue"> | number
    courseId?: IntFilter<"StationeryIssue"> | number
    itemId?: IntFilter<"StationeryIssue"> | number
    issueDate?: DateTimeFilter<"StationeryIssue"> | Date | string
    quantity?: IntFilter<"StationeryIssue"> | number
    remarks?: StringNullableFilter<"StationeryIssue"> | string | null
    clientAdminId?: StringFilter<"StationeryIssue"> | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    item?: XOR<StationeryItemScalarRelationFilter, StationeryItemWhereInput>
    clientAdmin?: XOR<ClientAdminScalarRelationFilter, ClientAdminWhereInput>
  }, "id">

  export type StationeryIssueOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    courseId?: SortOrder
    itemId?: SortOrder
    issueDate?: SortOrder
    quantity?: SortOrder
    remarks?: SortOrderInput | SortOrder
    clientAdminId?: SortOrder
    _count?: StationeryIssueCountOrderByAggregateInput
    _avg?: StationeryIssueAvgOrderByAggregateInput
    _max?: StationeryIssueMaxOrderByAggregateInput
    _min?: StationeryIssueMinOrderByAggregateInput
    _sum?: StationeryIssueSumOrderByAggregateInput
  }

  export type StationeryIssueScalarWhereWithAggregatesInput = {
    AND?: StationeryIssueScalarWhereWithAggregatesInput | StationeryIssueScalarWhereWithAggregatesInput[]
    OR?: StationeryIssueScalarWhereWithAggregatesInput[]
    NOT?: StationeryIssueScalarWhereWithAggregatesInput | StationeryIssueScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"StationeryIssue"> | number
    studentId?: IntWithAggregatesFilter<"StationeryIssue"> | number
    courseId?: IntWithAggregatesFilter<"StationeryIssue"> | number
    itemId?: IntWithAggregatesFilter<"StationeryIssue"> | number
    issueDate?: DateTimeWithAggregatesFilter<"StationeryIssue"> | Date | string
    quantity?: IntWithAggregatesFilter<"StationeryIssue"> | number
    remarks?: StringNullableWithAggregatesFilter<"StationeryIssue"> | string | null
    clientAdminId?: StringWithAggregatesFilter<"StationeryIssue"> | string
  }

  export type AttendanceRecordWhereInput = {
    AND?: AttendanceRecordWhereInput | AttendanceRecordWhereInput[]
    OR?: AttendanceRecordWhereInput[]
    NOT?: AttendanceRecordWhereInput | AttendanceRecordWhereInput[]
    id?: IntFilter<"AttendanceRecord"> | number
    studentId?: IntFilter<"AttendanceRecord"> | number
    courseId?: IntFilter<"AttendanceRecord"> | number
    date?: DateTimeFilter<"AttendanceRecord"> | Date | string
    present?: BoolFilter<"AttendanceRecord"> | boolean
    facultyId?: IntFilter<"AttendanceRecord"> | number
    batchId?: IntNullableFilter<"AttendanceRecord"> | number | null
    clientAdminId?: StringFilter<"AttendanceRecord"> | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    markedBy?: XOR<FacultyScalarRelationFilter, FacultyWhereInput>
    clientAdmin?: XOR<ClientAdminScalarRelationFilter, ClientAdminWhereInput>
  }

  export type AttendanceRecordOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    courseId?: SortOrder
    date?: SortOrder
    present?: SortOrder
    facultyId?: SortOrder
    batchId?: SortOrderInput | SortOrder
    clientAdminId?: SortOrder
    student?: StudentOrderByWithRelationInput
    course?: CourseOrderByWithRelationInput
    markedBy?: FacultyOrderByWithRelationInput
    clientAdmin?: ClientAdminOrderByWithRelationInput
  }

  export type AttendanceRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AttendanceRecordWhereInput | AttendanceRecordWhereInput[]
    OR?: AttendanceRecordWhereInput[]
    NOT?: AttendanceRecordWhereInput | AttendanceRecordWhereInput[]
    studentId?: IntFilter<"AttendanceRecord"> | number
    courseId?: IntFilter<"AttendanceRecord"> | number
    date?: DateTimeFilter<"AttendanceRecord"> | Date | string
    present?: BoolFilter<"AttendanceRecord"> | boolean
    facultyId?: IntFilter<"AttendanceRecord"> | number
    batchId?: IntNullableFilter<"AttendanceRecord"> | number | null
    clientAdminId?: StringFilter<"AttendanceRecord"> | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    markedBy?: XOR<FacultyScalarRelationFilter, FacultyWhereInput>
    clientAdmin?: XOR<ClientAdminScalarRelationFilter, ClientAdminWhereInput>
  }, "id">

  export type AttendanceRecordOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    courseId?: SortOrder
    date?: SortOrder
    present?: SortOrder
    facultyId?: SortOrder
    batchId?: SortOrderInput | SortOrder
    clientAdminId?: SortOrder
    _count?: AttendanceRecordCountOrderByAggregateInput
    _avg?: AttendanceRecordAvgOrderByAggregateInput
    _max?: AttendanceRecordMaxOrderByAggregateInput
    _min?: AttendanceRecordMinOrderByAggregateInput
    _sum?: AttendanceRecordSumOrderByAggregateInput
  }

  export type AttendanceRecordScalarWhereWithAggregatesInput = {
    AND?: AttendanceRecordScalarWhereWithAggregatesInput | AttendanceRecordScalarWhereWithAggregatesInput[]
    OR?: AttendanceRecordScalarWhereWithAggregatesInput[]
    NOT?: AttendanceRecordScalarWhereWithAggregatesInput | AttendanceRecordScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AttendanceRecord"> | number
    studentId?: IntWithAggregatesFilter<"AttendanceRecord"> | number
    courseId?: IntWithAggregatesFilter<"AttendanceRecord"> | number
    date?: DateTimeWithAggregatesFilter<"AttendanceRecord"> | Date | string
    present?: BoolWithAggregatesFilter<"AttendanceRecord"> | boolean
    facultyId?: IntWithAggregatesFilter<"AttendanceRecord"> | number
    batchId?: IntNullableWithAggregatesFilter<"AttendanceRecord"> | number | null
    clientAdminId?: StringWithAggregatesFilter<"AttendanceRecord"> | string
  }

  export type StudentTaskWhereInput = {
    AND?: StudentTaskWhereInput | StudentTaskWhereInput[]
    OR?: StudentTaskWhereInput[]
    NOT?: StudentTaskWhereInput | StudentTaskWhereInput[]
    id?: IntFilter<"StudentTask"> | number
    studentId?: IntFilter<"StudentTask"> | number
    courseId?: IntFilter<"StudentTask"> | number
    assignedDate?: DateTimeFilter<"StudentTask"> | Date | string
    dueDate?: DateTimeFilter<"StudentTask"> | Date | string
    description?: StringFilter<"StudentTask"> | string
    status?: StringFilter<"StudentTask"> | string
    facultyRemarks?: StringNullableFilter<"StudentTask"> | string | null
    grade?: StringNullableFilter<"StudentTask"> | string | null
    facultyId?: IntNullableFilter<"StudentTask"> | number | null
    clientAdminId?: StringFilter<"StudentTask"> | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    faculty?: XOR<FacultyNullableScalarRelationFilter, FacultyWhereInput> | null
    clientAdmin?: XOR<ClientAdminScalarRelationFilter, ClientAdminWhereInput>
  }

  export type StudentTaskOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    courseId?: SortOrder
    assignedDate?: SortOrder
    dueDate?: SortOrder
    description?: SortOrder
    status?: SortOrder
    facultyRemarks?: SortOrderInput | SortOrder
    grade?: SortOrderInput | SortOrder
    facultyId?: SortOrderInput | SortOrder
    clientAdminId?: SortOrder
    student?: StudentOrderByWithRelationInput
    course?: CourseOrderByWithRelationInput
    faculty?: FacultyOrderByWithRelationInput
    clientAdmin?: ClientAdminOrderByWithRelationInput
  }

  export type StudentTaskWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: StudentTaskWhereInput | StudentTaskWhereInput[]
    OR?: StudentTaskWhereInput[]
    NOT?: StudentTaskWhereInput | StudentTaskWhereInput[]
    studentId?: IntFilter<"StudentTask"> | number
    courseId?: IntFilter<"StudentTask"> | number
    assignedDate?: DateTimeFilter<"StudentTask"> | Date | string
    dueDate?: DateTimeFilter<"StudentTask"> | Date | string
    description?: StringFilter<"StudentTask"> | string
    status?: StringFilter<"StudentTask"> | string
    facultyRemarks?: StringNullableFilter<"StudentTask"> | string | null
    grade?: StringNullableFilter<"StudentTask"> | string | null
    facultyId?: IntNullableFilter<"StudentTask"> | number | null
    clientAdminId?: StringFilter<"StudentTask"> | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    faculty?: XOR<FacultyNullableScalarRelationFilter, FacultyWhereInput> | null
    clientAdmin?: XOR<ClientAdminScalarRelationFilter, ClientAdminWhereInput>
  }, "id">

  export type StudentTaskOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    courseId?: SortOrder
    assignedDate?: SortOrder
    dueDate?: SortOrder
    description?: SortOrder
    status?: SortOrder
    facultyRemarks?: SortOrderInput | SortOrder
    grade?: SortOrderInput | SortOrder
    facultyId?: SortOrderInput | SortOrder
    clientAdminId?: SortOrder
    _count?: StudentTaskCountOrderByAggregateInput
    _avg?: StudentTaskAvgOrderByAggregateInput
    _max?: StudentTaskMaxOrderByAggregateInput
    _min?: StudentTaskMinOrderByAggregateInput
    _sum?: StudentTaskSumOrderByAggregateInput
  }

  export type StudentTaskScalarWhereWithAggregatesInput = {
    AND?: StudentTaskScalarWhereWithAggregatesInput | StudentTaskScalarWhereWithAggregatesInput[]
    OR?: StudentTaskScalarWhereWithAggregatesInput[]
    NOT?: StudentTaskScalarWhereWithAggregatesInput | StudentTaskScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"StudentTask"> | number
    studentId?: IntWithAggregatesFilter<"StudentTask"> | number
    courseId?: IntWithAggregatesFilter<"StudentTask"> | number
    assignedDate?: DateTimeWithAggregatesFilter<"StudentTask"> | Date | string
    dueDate?: DateTimeWithAggregatesFilter<"StudentTask"> | Date | string
    description?: StringWithAggregatesFilter<"StudentTask"> | string
    status?: StringWithAggregatesFilter<"StudentTask"> | string
    facultyRemarks?: StringNullableWithAggregatesFilter<"StudentTask"> | string | null
    grade?: StringNullableWithAggregatesFilter<"StudentTask"> | string | null
    facultyId?: IntNullableWithAggregatesFilter<"StudentTask"> | number | null
    clientAdminId?: StringWithAggregatesFilter<"StudentTask"> | string
  }

  export type StudentTestWhereInput = {
    AND?: StudentTestWhereInput | StudentTestWhereInput[]
    OR?: StudentTestWhereInput[]
    NOT?: StudentTestWhereInput | StudentTestWhereInput[]
    id?: IntFilter<"StudentTest"> | number
    studentId?: IntFilter<"StudentTest"> | number
    courseId?: IntFilter<"StudentTest"> | number
    testName?: StringFilter<"StudentTest"> | string
    testDate?: DateTimeFilter<"StudentTest"> | Date | string
    totalMarks?: IntFilter<"StudentTest"> | number
    marksObtained?: IntFilter<"StudentTest"> | number
    grade?: StringFilter<"StudentTest"> | string
    clientAdminId?: StringFilter<"StudentTest"> | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    clientAdmin?: XOR<ClientAdminScalarRelationFilter, ClientAdminWhereInput>
  }

  export type StudentTestOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    courseId?: SortOrder
    testName?: SortOrder
    testDate?: SortOrder
    totalMarks?: SortOrder
    marksObtained?: SortOrder
    grade?: SortOrder
    clientAdminId?: SortOrder
    student?: StudentOrderByWithRelationInput
    course?: CourseOrderByWithRelationInput
    clientAdmin?: ClientAdminOrderByWithRelationInput
  }

  export type StudentTestWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: StudentTestWhereInput | StudentTestWhereInput[]
    OR?: StudentTestWhereInput[]
    NOT?: StudentTestWhereInput | StudentTestWhereInput[]
    studentId?: IntFilter<"StudentTest"> | number
    courseId?: IntFilter<"StudentTest"> | number
    testName?: StringFilter<"StudentTest"> | string
    testDate?: DateTimeFilter<"StudentTest"> | Date | string
    totalMarks?: IntFilter<"StudentTest"> | number
    marksObtained?: IntFilter<"StudentTest"> | number
    grade?: StringFilter<"StudentTest"> | string
    clientAdminId?: StringFilter<"StudentTest"> | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    clientAdmin?: XOR<ClientAdminScalarRelationFilter, ClientAdminWhereInput>
  }, "id">

  export type StudentTestOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    courseId?: SortOrder
    testName?: SortOrder
    testDate?: SortOrder
    totalMarks?: SortOrder
    marksObtained?: SortOrder
    grade?: SortOrder
    clientAdminId?: SortOrder
    _count?: StudentTestCountOrderByAggregateInput
    _avg?: StudentTestAvgOrderByAggregateInput
    _max?: StudentTestMaxOrderByAggregateInput
    _min?: StudentTestMinOrderByAggregateInput
    _sum?: StudentTestSumOrderByAggregateInput
  }

  export type StudentTestScalarWhereWithAggregatesInput = {
    AND?: StudentTestScalarWhereWithAggregatesInput | StudentTestScalarWhereWithAggregatesInput[]
    OR?: StudentTestScalarWhereWithAggregatesInput[]
    NOT?: StudentTestScalarWhereWithAggregatesInput | StudentTestScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"StudentTest"> | number
    studentId?: IntWithAggregatesFilter<"StudentTest"> | number
    courseId?: IntWithAggregatesFilter<"StudentTest"> | number
    testName?: StringWithAggregatesFilter<"StudentTest"> | string
    testDate?: DateTimeWithAggregatesFilter<"StudentTest"> | Date | string
    totalMarks?: IntWithAggregatesFilter<"StudentTest"> | number
    marksObtained?: IntWithAggregatesFilter<"StudentTest"> | number
    grade?: StringWithAggregatesFilter<"StudentTest"> | string
    clientAdminId?: StringWithAggregatesFilter<"StudentTest"> | string
  }

  export type CourseCompletionWhereInput = {
    AND?: CourseCompletionWhereInput | CourseCompletionWhereInput[]
    OR?: CourseCompletionWhereInput[]
    NOT?: CourseCompletionWhereInput | CourseCompletionWhereInput[]
    id?: IntFilter<"CourseCompletion"> | number
    studentCourseId?: IntFilter<"CourseCompletion"> | number
    studentId?: IntFilter<"CourseCompletion"> | number
    completionDate?: DateTimeFilter<"CourseCompletion"> | Date | string
    feedback?: StringNullableFilter<"CourseCompletion"> | string | null
    remarks?: StringNullableFilter<"CourseCompletion"> | string | null
    clientAdminId?: StringFilter<"CourseCompletion"> | string
    studentCourse?: XOR<StudentCourseScalarRelationFilter, StudentCourseWhereInput>
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    clientAdmin?: XOR<ClientAdminScalarRelationFilter, ClientAdminWhereInput>
  }

  export type CourseCompletionOrderByWithRelationInput = {
    id?: SortOrder
    studentCourseId?: SortOrder
    studentId?: SortOrder
    completionDate?: SortOrder
    feedback?: SortOrderInput | SortOrder
    remarks?: SortOrderInput | SortOrder
    clientAdminId?: SortOrder
    studentCourse?: StudentCourseOrderByWithRelationInput
    student?: StudentOrderByWithRelationInput
    clientAdmin?: ClientAdminOrderByWithRelationInput
  }

  export type CourseCompletionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CourseCompletionWhereInput | CourseCompletionWhereInput[]
    OR?: CourseCompletionWhereInput[]
    NOT?: CourseCompletionWhereInput | CourseCompletionWhereInput[]
    studentCourseId?: IntFilter<"CourseCompletion"> | number
    studentId?: IntFilter<"CourseCompletion"> | number
    completionDate?: DateTimeFilter<"CourseCompletion"> | Date | string
    feedback?: StringNullableFilter<"CourseCompletion"> | string | null
    remarks?: StringNullableFilter<"CourseCompletion"> | string | null
    clientAdminId?: StringFilter<"CourseCompletion"> | string
    studentCourse?: XOR<StudentCourseScalarRelationFilter, StudentCourseWhereInput>
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    clientAdmin?: XOR<ClientAdminScalarRelationFilter, ClientAdminWhereInput>
  }, "id">

  export type CourseCompletionOrderByWithAggregationInput = {
    id?: SortOrder
    studentCourseId?: SortOrder
    studentId?: SortOrder
    completionDate?: SortOrder
    feedback?: SortOrderInput | SortOrder
    remarks?: SortOrderInput | SortOrder
    clientAdminId?: SortOrder
    _count?: CourseCompletionCountOrderByAggregateInput
    _avg?: CourseCompletionAvgOrderByAggregateInput
    _max?: CourseCompletionMaxOrderByAggregateInput
    _min?: CourseCompletionMinOrderByAggregateInput
    _sum?: CourseCompletionSumOrderByAggregateInput
  }

  export type CourseCompletionScalarWhereWithAggregatesInput = {
    AND?: CourseCompletionScalarWhereWithAggregatesInput | CourseCompletionScalarWhereWithAggregatesInput[]
    OR?: CourseCompletionScalarWhereWithAggregatesInput[]
    NOT?: CourseCompletionScalarWhereWithAggregatesInput | CourseCompletionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CourseCompletion"> | number
    studentCourseId?: IntWithAggregatesFilter<"CourseCompletion"> | number
    studentId?: IntWithAggregatesFilter<"CourseCompletion"> | number
    completionDate?: DateTimeWithAggregatesFilter<"CourseCompletion"> | Date | string
    feedback?: StringNullableWithAggregatesFilter<"CourseCompletion"> | string | null
    remarks?: StringNullableWithAggregatesFilter<"CourseCompletion"> | string | null
    clientAdminId?: StringWithAggregatesFilter<"CourseCompletion"> | string
  }

  export type CertificateWhereInput = {
    AND?: CertificateWhereInput | CertificateWhereInput[]
    OR?: CertificateWhereInput[]
    NOT?: CertificateWhereInput | CertificateWhereInput[]
    id?: IntFilter<"Certificate"> | number
    studentId?: IntFilter<"Certificate"> | number
    courseId?: IntFilter<"Certificate"> | number
    studentCourseId?: IntFilter<"Certificate"> | number
    issueDate?: DateTimeFilter<"Certificate"> | Date | string
    certificateUrl?: StringFilter<"Certificate"> | string
    clientAdminId?: StringFilter<"Certificate"> | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    studentCourse?: XOR<StudentCourseScalarRelationFilter, StudentCourseWhereInput>
    clientAdmin?: XOR<ClientAdminScalarRelationFilter, ClientAdminWhereInput>
  }

  export type CertificateOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    courseId?: SortOrder
    studentCourseId?: SortOrder
    issueDate?: SortOrder
    certificateUrl?: SortOrder
    clientAdminId?: SortOrder
    student?: StudentOrderByWithRelationInput
    course?: CourseOrderByWithRelationInput
    studentCourse?: StudentCourseOrderByWithRelationInput
    clientAdmin?: ClientAdminOrderByWithRelationInput
  }

  export type CertificateWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    studentCourseId?: number
    AND?: CertificateWhereInput | CertificateWhereInput[]
    OR?: CertificateWhereInput[]
    NOT?: CertificateWhereInput | CertificateWhereInput[]
    studentId?: IntFilter<"Certificate"> | number
    courseId?: IntFilter<"Certificate"> | number
    issueDate?: DateTimeFilter<"Certificate"> | Date | string
    certificateUrl?: StringFilter<"Certificate"> | string
    clientAdminId?: StringFilter<"Certificate"> | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    course?: XOR<CourseScalarRelationFilter, CourseWhereInput>
    studentCourse?: XOR<StudentCourseScalarRelationFilter, StudentCourseWhereInput>
    clientAdmin?: XOR<ClientAdminScalarRelationFilter, ClientAdminWhereInput>
  }, "id" | "studentCourseId">

  export type CertificateOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    courseId?: SortOrder
    studentCourseId?: SortOrder
    issueDate?: SortOrder
    certificateUrl?: SortOrder
    clientAdminId?: SortOrder
    _count?: CertificateCountOrderByAggregateInput
    _avg?: CertificateAvgOrderByAggregateInput
    _max?: CertificateMaxOrderByAggregateInput
    _min?: CertificateMinOrderByAggregateInput
    _sum?: CertificateSumOrderByAggregateInput
  }

  export type CertificateScalarWhereWithAggregatesInput = {
    AND?: CertificateScalarWhereWithAggregatesInput | CertificateScalarWhereWithAggregatesInput[]
    OR?: CertificateScalarWhereWithAggregatesInput[]
    NOT?: CertificateScalarWhereWithAggregatesInput | CertificateScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Certificate"> | number
    studentId?: IntWithAggregatesFilter<"Certificate"> | number
    courseId?: IntWithAggregatesFilter<"Certificate"> | number
    studentCourseId?: IntWithAggregatesFilter<"Certificate"> | number
    issueDate?: DateTimeWithAggregatesFilter<"Certificate"> | Date | string
    certificateUrl?: StringWithAggregatesFilter<"Certificate"> | string
    clientAdminId?: StringWithAggregatesFilter<"Certificate"> | string
  }

  export type FinancialRecordWhereInput = {
    AND?: FinancialRecordWhereInput | FinancialRecordWhereInput[]
    OR?: FinancialRecordWhereInput[]
    NOT?: FinancialRecordWhereInput | FinancialRecordWhereInput[]
    id?: StringFilter<"FinancialRecord"> | string
    clientAdminId?: StringFilter<"FinancialRecord"> | string
    recordType?: EnumRecordTypeFilter<"FinancialRecord"> | $Enums.RecordType
    amount?: FloatFilter<"FinancialRecord"> | number
    description?: StringNullableFilter<"FinancialRecord"> | string | null
    date?: DateTimeFilter<"FinancialRecord"> | Date | string
    paymentMode?: EnumPaymentModeNullableFilter<"FinancialRecord"> | $Enums.PaymentMode | null
    studentId?: IntNullableFilter<"FinancialRecord"> | number | null
    courseId?: IntNullableFilter<"FinancialRecord"> | number | null
    facultyId?: IntNullableFilter<"FinancialRecord"> | number | null
    labId?: IntNullableFilter<"FinancialRecord"> | number | null
    student?: XOR<StudentNullableScalarRelationFilter, StudentWhereInput> | null
    course?: XOR<CourseNullableScalarRelationFilter, CourseWhereInput> | null
    faculty?: XOR<FacultyNullableScalarRelationFilter, FacultyWhereInput> | null
    lab?: XOR<LabNullableScalarRelationFilter, LabWhereInput> | null
    clientAdmin?: XOR<ClientAdminScalarRelationFilter, ClientAdminWhereInput>
  }

  export type FinancialRecordOrderByWithRelationInput = {
    id?: SortOrder
    clientAdminId?: SortOrder
    recordType?: SortOrder
    amount?: SortOrder
    description?: SortOrderInput | SortOrder
    date?: SortOrder
    paymentMode?: SortOrderInput | SortOrder
    studentId?: SortOrderInput | SortOrder
    courseId?: SortOrderInput | SortOrder
    facultyId?: SortOrderInput | SortOrder
    labId?: SortOrderInput | SortOrder
    student?: StudentOrderByWithRelationInput
    course?: CourseOrderByWithRelationInput
    faculty?: FacultyOrderByWithRelationInput
    lab?: LabOrderByWithRelationInput
    clientAdmin?: ClientAdminOrderByWithRelationInput
  }

  export type FinancialRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FinancialRecordWhereInput | FinancialRecordWhereInput[]
    OR?: FinancialRecordWhereInput[]
    NOT?: FinancialRecordWhereInput | FinancialRecordWhereInput[]
    clientAdminId?: StringFilter<"FinancialRecord"> | string
    recordType?: EnumRecordTypeFilter<"FinancialRecord"> | $Enums.RecordType
    amount?: FloatFilter<"FinancialRecord"> | number
    description?: StringNullableFilter<"FinancialRecord"> | string | null
    date?: DateTimeFilter<"FinancialRecord"> | Date | string
    paymentMode?: EnumPaymentModeNullableFilter<"FinancialRecord"> | $Enums.PaymentMode | null
    studentId?: IntNullableFilter<"FinancialRecord"> | number | null
    courseId?: IntNullableFilter<"FinancialRecord"> | number | null
    facultyId?: IntNullableFilter<"FinancialRecord"> | number | null
    labId?: IntNullableFilter<"FinancialRecord"> | number | null
    student?: XOR<StudentNullableScalarRelationFilter, StudentWhereInput> | null
    course?: XOR<CourseNullableScalarRelationFilter, CourseWhereInput> | null
    faculty?: XOR<FacultyNullableScalarRelationFilter, FacultyWhereInput> | null
    lab?: XOR<LabNullableScalarRelationFilter, LabWhereInput> | null
    clientAdmin?: XOR<ClientAdminScalarRelationFilter, ClientAdminWhereInput>
  }, "id">

  export type FinancialRecordOrderByWithAggregationInput = {
    id?: SortOrder
    clientAdminId?: SortOrder
    recordType?: SortOrder
    amount?: SortOrder
    description?: SortOrderInput | SortOrder
    date?: SortOrder
    paymentMode?: SortOrderInput | SortOrder
    studentId?: SortOrderInput | SortOrder
    courseId?: SortOrderInput | SortOrder
    facultyId?: SortOrderInput | SortOrder
    labId?: SortOrderInput | SortOrder
    _count?: FinancialRecordCountOrderByAggregateInput
    _avg?: FinancialRecordAvgOrderByAggregateInput
    _max?: FinancialRecordMaxOrderByAggregateInput
    _min?: FinancialRecordMinOrderByAggregateInput
    _sum?: FinancialRecordSumOrderByAggregateInput
  }

  export type FinancialRecordScalarWhereWithAggregatesInput = {
    AND?: FinancialRecordScalarWhereWithAggregatesInput | FinancialRecordScalarWhereWithAggregatesInput[]
    OR?: FinancialRecordScalarWhereWithAggregatesInput[]
    NOT?: FinancialRecordScalarWhereWithAggregatesInput | FinancialRecordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FinancialRecord"> | string
    clientAdminId?: StringWithAggregatesFilter<"FinancialRecord"> | string
    recordType?: EnumRecordTypeWithAggregatesFilter<"FinancialRecord"> | $Enums.RecordType
    amount?: FloatWithAggregatesFilter<"FinancialRecord"> | number
    description?: StringNullableWithAggregatesFilter<"FinancialRecord"> | string | null
    date?: DateTimeWithAggregatesFilter<"FinancialRecord"> | Date | string
    paymentMode?: EnumPaymentModeNullableWithAggregatesFilter<"FinancialRecord"> | $Enums.PaymentMode | null
    studentId?: IntNullableWithAggregatesFilter<"FinancialRecord"> | number | null
    courseId?: IntNullableWithAggregatesFilter<"FinancialRecord"> | number | null
    facultyId?: IntNullableWithAggregatesFilter<"FinancialRecord"> | number | null
    labId?: IntNullableWithAggregatesFilter<"FinancialRecord"> | number | null
  }

  export type ClientAdminCreateInput = {
    id?: string
    name: string
    email: string
    password: string
    instituteName: string
    slug: string
    fullAddress: string
    logo?: string | null
    certificateName?: string | null
    stamp?: string | null
    sign?: string | null
    contact: string
    position: string
    country: string
    state: string
    city: string
    zipCode: string
    createdAt?: Date | string
    role?: $Enums.UserRole
    currentSessionToken?: string | null
    lastLoginAt?: Date | string | null
    roleUsers?: RoleUserCreateNestedManyWithoutClientAdminInput
    faculties?: FacultyCreateNestedManyWithoutClientAdminInput
    batches?: BatchCreateNestedManyWithoutClientAdminInput
    courses?: CourseCreateNestedManyWithoutClientAdminInput
    enquiryCourse?: EnquiryCourseCreateNestedManyWithoutClientAdminInput
    labs?: LabCreateNestedManyWithoutClientAdminInput
    labTimeSlots?: LabTimeSlotCreateNestedManyWithoutClientAdminInput
    labAllocations?: LabAllocationCreateNestedManyWithoutClientAdminInput
    students?: StudentCreateNestedManyWithoutClientAdminInput
    activities?: ActivityLogCreateNestedManyWithoutClientAdminInput
    studentCourses?: StudentCourseCreateNestedManyWithoutClientAdminInput
    feeStructures?: FeeStructureCreateNestedManyWithoutClientAdminInput
    studentFees?: StudentFeeCreateNestedManyWithoutClientAdminInput
    stationeryIssues?: StationeryIssueCreateNestedManyWithoutClientAdminInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutClientAdminInput
    studentTasks?: StudentTaskCreateNestedManyWithoutClientAdminInput
    studentTests?: StudentTestCreateNestedManyWithoutClientAdminInput
    courseCompletions?: CourseCompletionCreateNestedManyWithoutClientAdminInput
    certificates?: CertificateCreateNestedManyWithoutClientAdminInput
    financialRecords?: FinancialRecordCreateNestedManyWithoutClientAdminInput
    enquiries?: EnquiryCreateNestedManyWithoutClientAdminInput
    notifications?: NotificationCreateNestedManyWithoutClientAdminInput
    courseFeeStructures?: CourseFeeStructureCreateNestedManyWithoutClientAdminInput
  }

  export type ClientAdminUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    password: string
    instituteName: string
    slug: string
    fullAddress: string
    logo?: string | null
    certificateName?: string | null
    stamp?: string | null
    sign?: string | null
    contact: string
    position: string
    country: string
    state: string
    city: string
    zipCode: string
    createdAt?: Date | string
    role?: $Enums.UserRole
    currentSessionToken?: string | null
    lastLoginAt?: Date | string | null
    roleUsers?: RoleUserUncheckedCreateNestedManyWithoutClientAdminInput
    faculties?: FacultyUncheckedCreateNestedManyWithoutClientAdminInput
    batches?: BatchUncheckedCreateNestedManyWithoutClientAdminInput
    courses?: CourseUncheckedCreateNestedManyWithoutClientAdminInput
    enquiryCourse?: EnquiryCourseUncheckedCreateNestedManyWithoutClientAdminInput
    labs?: LabUncheckedCreateNestedManyWithoutClientAdminInput
    labTimeSlots?: LabTimeSlotUncheckedCreateNestedManyWithoutClientAdminInput
    labAllocations?: LabAllocationUncheckedCreateNestedManyWithoutClientAdminInput
    students?: StudentUncheckedCreateNestedManyWithoutClientAdminInput
    activities?: ActivityLogUncheckedCreateNestedManyWithoutClientAdminInput
    studentCourses?: StudentCourseUncheckedCreateNestedManyWithoutClientAdminInput
    feeStructures?: FeeStructureUncheckedCreateNestedManyWithoutClientAdminInput
    studentFees?: StudentFeeUncheckedCreateNestedManyWithoutClientAdminInput
    stationeryIssues?: StationeryIssueUncheckedCreateNestedManyWithoutClientAdminInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutClientAdminInput
    studentTasks?: StudentTaskUncheckedCreateNestedManyWithoutClientAdminInput
    studentTests?: StudentTestUncheckedCreateNestedManyWithoutClientAdminInput
    courseCompletions?: CourseCompletionUncheckedCreateNestedManyWithoutClientAdminInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutClientAdminInput
    financialRecords?: FinancialRecordUncheckedCreateNestedManyWithoutClientAdminInput
    enquiries?: EnquiryUncheckedCreateNestedManyWithoutClientAdminInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutClientAdminInput
    courseFeeStructures?: CourseFeeStructureUncheckedCreateNestedManyWithoutClientAdminInput
  }

  export type ClientAdminUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    instituteName?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    fullAddress?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    certificateName?: NullableStringFieldUpdateOperationsInput | string | null
    stamp?: NullableStringFieldUpdateOperationsInput | string | null
    sign?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    currentSessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleUsers?: RoleUserUpdateManyWithoutClientAdminNestedInput
    faculties?: FacultyUpdateManyWithoutClientAdminNestedInput
    batches?: BatchUpdateManyWithoutClientAdminNestedInput
    courses?: CourseUpdateManyWithoutClientAdminNestedInput
    enquiryCourse?: EnquiryCourseUpdateManyWithoutClientAdminNestedInput
    labs?: LabUpdateManyWithoutClientAdminNestedInput
    labTimeSlots?: LabTimeSlotUpdateManyWithoutClientAdminNestedInput
    labAllocations?: LabAllocationUpdateManyWithoutClientAdminNestedInput
    students?: StudentUpdateManyWithoutClientAdminNestedInput
    activities?: ActivityLogUpdateManyWithoutClientAdminNestedInput
    studentCourses?: StudentCourseUpdateManyWithoutClientAdminNestedInput
    feeStructures?: FeeStructureUpdateManyWithoutClientAdminNestedInput
    studentFees?: StudentFeeUpdateManyWithoutClientAdminNestedInput
    stationeryIssues?: StationeryIssueUpdateManyWithoutClientAdminNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutClientAdminNestedInput
    studentTasks?: StudentTaskUpdateManyWithoutClientAdminNestedInput
    studentTests?: StudentTestUpdateManyWithoutClientAdminNestedInput
    courseCompletions?: CourseCompletionUpdateManyWithoutClientAdminNestedInput
    certificates?: CertificateUpdateManyWithoutClientAdminNestedInput
    financialRecords?: FinancialRecordUpdateManyWithoutClientAdminNestedInput
    enquiries?: EnquiryUpdateManyWithoutClientAdminNestedInput
    notifications?: NotificationUpdateManyWithoutClientAdminNestedInput
    courseFeeStructures?: CourseFeeStructureUpdateManyWithoutClientAdminNestedInput
  }

  export type ClientAdminUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    instituteName?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    fullAddress?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    certificateName?: NullableStringFieldUpdateOperationsInput | string | null
    stamp?: NullableStringFieldUpdateOperationsInput | string | null
    sign?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    currentSessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleUsers?: RoleUserUncheckedUpdateManyWithoutClientAdminNestedInput
    faculties?: FacultyUncheckedUpdateManyWithoutClientAdminNestedInput
    batches?: BatchUncheckedUpdateManyWithoutClientAdminNestedInput
    courses?: CourseUncheckedUpdateManyWithoutClientAdminNestedInput
    enquiryCourse?: EnquiryCourseUncheckedUpdateManyWithoutClientAdminNestedInput
    labs?: LabUncheckedUpdateManyWithoutClientAdminNestedInput
    labTimeSlots?: LabTimeSlotUncheckedUpdateManyWithoutClientAdminNestedInput
    labAllocations?: LabAllocationUncheckedUpdateManyWithoutClientAdminNestedInput
    students?: StudentUncheckedUpdateManyWithoutClientAdminNestedInput
    activities?: ActivityLogUncheckedUpdateManyWithoutClientAdminNestedInput
    studentCourses?: StudentCourseUncheckedUpdateManyWithoutClientAdminNestedInput
    feeStructures?: FeeStructureUncheckedUpdateManyWithoutClientAdminNestedInput
    studentFees?: StudentFeeUncheckedUpdateManyWithoutClientAdminNestedInput
    stationeryIssues?: StationeryIssueUncheckedUpdateManyWithoutClientAdminNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutClientAdminNestedInput
    studentTasks?: StudentTaskUncheckedUpdateManyWithoutClientAdminNestedInput
    studentTests?: StudentTestUncheckedUpdateManyWithoutClientAdminNestedInput
    courseCompletions?: CourseCompletionUncheckedUpdateManyWithoutClientAdminNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutClientAdminNestedInput
    financialRecords?: FinancialRecordUncheckedUpdateManyWithoutClientAdminNestedInput
    enquiries?: EnquiryUncheckedUpdateManyWithoutClientAdminNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutClientAdminNestedInput
    courseFeeStructures?: CourseFeeStructureUncheckedUpdateManyWithoutClientAdminNestedInput
  }

  export type ClientAdminCreateManyInput = {
    id?: string
    name: string
    email: string
    password: string
    instituteName: string
    slug: string
    fullAddress: string
    logo?: string | null
    certificateName?: string | null
    stamp?: string | null
    sign?: string | null
    contact: string
    position: string
    country: string
    state: string
    city: string
    zipCode: string
    createdAt?: Date | string
    role?: $Enums.UserRole
    currentSessionToken?: string | null
    lastLoginAt?: Date | string | null
  }

  export type ClientAdminUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    instituteName?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    fullAddress?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    certificateName?: NullableStringFieldUpdateOperationsInput | string | null
    stamp?: NullableStringFieldUpdateOperationsInput | string | null
    sign?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    currentSessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ClientAdminUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    instituteName?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    fullAddress?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    certificateName?: NullableStringFieldUpdateOperationsInput | string | null
    stamp?: NullableStringFieldUpdateOperationsInput | string | null
    sign?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    currentSessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RoleUserCreateInput = {
    id?: string
    name: string
    email: string
    password: string
    role: $Enums.UserRole
    createdAt?: Date | string
    country: string
    state: string
    city: string
    zipCode: string
    currentSessionToken?: string | null
    lastLoginAt?: Date | string | null
    clientAdmin: ClientAdminCreateNestedOneWithoutRoleUsersInput
  }

  export type RoleUserUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    password: string
    role: $Enums.UserRole
    createdAt?: Date | string
    country: string
    state: string
    city: string
    zipCode: string
    currentSessionToken?: string | null
    lastLoginAt?: Date | string | null
    clientAdminId: string
  }

  export type RoleUserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    currentSessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutRoleUsersNestedInput
  }

  export type RoleUserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    currentSessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type RoleUserCreateManyInput = {
    id?: string
    name: string
    email: string
    password: string
    role: $Enums.UserRole
    createdAt?: Date | string
    country: string
    state: string
    city: string
    zipCode: string
    currentSessionToken?: string | null
    lastLoginAt?: Date | string | null
    clientAdminId: string
  }

  export type RoleUserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    currentSessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RoleUserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    currentSessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type ActivityLogCreateInput = {
    id?: string
    entity: string
    entityId: string
    action: string
    message?: string | null
    createdAt?: Date | string
    clientAdmin: ClientAdminCreateNestedOneWithoutActivitiesInput
  }

  export type ActivityLogUncheckedCreateInput = {
    id?: string
    entity: string
    entityId: string
    action: string
    message?: string | null
    createdAt?: Date | string
    clientAdminId: string
  }

  export type ActivityLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutActivitiesNestedInput
  }

  export type ActivityLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type ActivityLogCreateManyInput = {
    id?: string
    entity: string
    entityId: string
    action: string
    message?: string | null
    createdAt?: Date | string
    clientAdminId: string
  }

  export type ActivityLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type EnquiryCreateInput = {
    id?: string
    name: string
    contact: string
    email?: string | null
    course?: string | null
    source?: string | null
    leadStatus?: $Enums.LeadStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    isConverted?: boolean
    followUps?: FollowUpCreateNestedManyWithoutEnquiryInput
    student?: StudentCreateNestedOneWithoutEnquiryInput
    enquiryCourse?: EnquiryCourseCreateNestedManyWithoutEnquiryInput
    notification?: NotificationCreateNestedOneWithoutEnquiryInput
    clientAdmin: ClientAdminCreateNestedOneWithoutEnquiriesInput
  }

  export type EnquiryUncheckedCreateInput = {
    id?: string
    name: string
    contact: string
    email?: string | null
    course?: string | null
    source?: string | null
    leadStatus?: $Enums.LeadStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    isConverted?: boolean
    studentId?: number | null
    clientAdminId: string
    followUps?: FollowUpUncheckedCreateNestedManyWithoutEnquiryInput
    enquiryCourse?: EnquiryCourseUncheckedCreateNestedManyWithoutEnquiryInput
    notification?: NotificationUncheckedCreateNestedOneWithoutEnquiryInput
  }

  export type EnquiryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    course?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    leadStatus?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isConverted?: BoolFieldUpdateOperationsInput | boolean
    followUps?: FollowUpUpdateManyWithoutEnquiryNestedInput
    student?: StudentUpdateOneWithoutEnquiryNestedInput
    enquiryCourse?: EnquiryCourseUpdateManyWithoutEnquiryNestedInput
    notification?: NotificationUpdateOneWithoutEnquiryNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutEnquiriesNestedInput
  }

  export type EnquiryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    course?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    leadStatus?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isConverted?: BoolFieldUpdateOperationsInput | boolean
    studentId?: NullableIntFieldUpdateOperationsInput | number | null
    clientAdminId?: StringFieldUpdateOperationsInput | string
    followUps?: FollowUpUncheckedUpdateManyWithoutEnquiryNestedInput
    enquiryCourse?: EnquiryCourseUncheckedUpdateManyWithoutEnquiryNestedInput
    notification?: NotificationUncheckedUpdateOneWithoutEnquiryNestedInput
  }

  export type EnquiryCreateManyInput = {
    id?: string
    name: string
    contact: string
    email?: string | null
    course?: string | null
    source?: string | null
    leadStatus?: $Enums.LeadStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    isConverted?: boolean
    studentId?: number | null
    clientAdminId: string
  }

  export type EnquiryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    course?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    leadStatus?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isConverted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EnquiryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    course?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    leadStatus?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isConverted?: BoolFieldUpdateOperationsInput | boolean
    studentId?: NullableIntFieldUpdateOperationsInput | number | null
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type EnquiryCourseCreateInput = {
    enquiry: EnquiryCreateNestedOneWithoutEnquiryCourseInput
    course: CourseCreateNestedOneWithoutEnquiryCourseInput
    clientAdmin: ClientAdminCreateNestedOneWithoutEnquiryCourseInput
  }

  export type EnquiryCourseUncheckedCreateInput = {
    id?: number
    enquiryId: string
    courseId: number
    clientAdminId: string
  }

  export type EnquiryCourseUpdateInput = {
    enquiry?: EnquiryUpdateOneRequiredWithoutEnquiryCourseNestedInput
    course?: CourseUpdateOneRequiredWithoutEnquiryCourseNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutEnquiryCourseNestedInput
  }

  export type EnquiryCourseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    enquiryId?: StringFieldUpdateOperationsInput | string
    courseId?: IntFieldUpdateOperationsInput | number
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type EnquiryCourseCreateManyInput = {
    id?: number
    enquiryId: string
    courseId: number
    clientAdminId: string
  }

  export type EnquiryCourseUpdateManyMutationInput = {

  }

  export type EnquiryCourseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    enquiryId?: StringFieldUpdateOperationsInput | string
    courseId?: IntFieldUpdateOperationsInput | number
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type FollowUpCreateInput = {
    id?: string
    scheduledAt?: Date | string | null
    doneAt?: Date | string | null
    remark: string
    createdAt?: Date | string
    followUpStatus?: $Enums.FollowUpStatus
    enquiry: EnquiryCreateNestedOneWithoutFollowUpsInput
    notification?: NotificationCreateNestedOneWithoutFollowUpInput
  }

  export type FollowUpUncheckedCreateInput = {
    id?: string
    enquiryId: string
    scheduledAt?: Date | string | null
    doneAt?: Date | string | null
    remark: string
    createdAt?: Date | string
    followUpStatus?: $Enums.FollowUpStatus
    notification?: NotificationUncheckedCreateNestedOneWithoutFollowUpInput
  }

  export type FollowUpUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doneAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remark?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    followUpStatus?: EnumFollowUpStatusFieldUpdateOperationsInput | $Enums.FollowUpStatus
    enquiry?: EnquiryUpdateOneRequiredWithoutFollowUpsNestedInput
    notification?: NotificationUpdateOneWithoutFollowUpNestedInput
  }

  export type FollowUpUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    enquiryId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doneAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remark?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    followUpStatus?: EnumFollowUpStatusFieldUpdateOperationsInput | $Enums.FollowUpStatus
    notification?: NotificationUncheckedUpdateOneWithoutFollowUpNestedInput
  }

  export type FollowUpCreateManyInput = {
    id?: string
    enquiryId: string
    scheduledAt?: Date | string | null
    doneAt?: Date | string | null
    remark: string
    createdAt?: Date | string
    followUpStatus?: $Enums.FollowUpStatus
  }

  export type FollowUpUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doneAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remark?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    followUpStatus?: EnumFollowUpStatusFieldUpdateOperationsInput | $Enums.FollowUpStatus
  }

  export type FollowUpUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    enquiryId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doneAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remark?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    followUpStatus?: EnumFollowUpStatusFieldUpdateOperationsInput | $Enums.FollowUpStatus
  }

  export type NotificationCreateInput = {
    id?: string
    message: string
    seen?: boolean
    createdAt?: Date | string
    followUp?: FollowUpCreateNestedOneWithoutNotificationInput
    enquiry?: EnquiryCreateNestedOneWithoutNotificationInput
    payment?: StudentFeeCreateNestedOneWithoutNotificationInput
    clientAdmin: ClientAdminCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    message: string
    seen?: boolean
    createdAt?: Date | string
    followUpId?: string | null
    enquiryId?: string | null
    paymentId?: number | null
    clientAdminId: string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    seen?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    followUp?: FollowUpUpdateOneWithoutNotificationNestedInput
    enquiry?: EnquiryUpdateOneWithoutNotificationNestedInput
    payment?: StudentFeeUpdateOneWithoutNotificationNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    seen?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    followUpId?: NullableStringFieldUpdateOperationsInput | string | null
    enquiryId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableIntFieldUpdateOperationsInput | number | null
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    message: string
    seen?: boolean
    createdAt?: Date | string
    followUpId?: string | null
    enquiryId?: string | null
    paymentId?: number | null
    clientAdminId: string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    seen?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    seen?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    followUpId?: NullableStringFieldUpdateOperationsInput | string | null
    enquiryId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableIntFieldUpdateOperationsInput | number | null
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentCreateInput = {
    serialNumber: number
    studentCode: string
    fullName: string
    fatherName: string
    motherName: string
    photoUrl?: string | null
    contact: string
    parentsContact: string
    email?: string | null
    residentialAddress?: string | null
    permenantAddress?: string | null
    dob: string
    gender: string
    religion?: string | null
    idProofType?: string | null
    idProofNumber?: string | null
    admissionDate: Date | string
    enquiry?: EnquiryCreateNestedOneWithoutStudentInput
    labAllocations?: LabAllocationCreateNestedManyWithoutStudentInput
    studentCourses?: StudentCourseCreateNestedManyWithoutStudentInput
    feeStructures?: FeeStructureCreateNestedManyWithoutStudentInput
    feeRecords?: StudentFeeCreateNestedManyWithoutStudentInput
    attendance?: AttendanceRecordCreateNestedManyWithoutStudentInput
    tasks?: StudentTaskCreateNestedManyWithoutStudentInput
    tests?: StudentTestCreateNestedManyWithoutStudentInput
    completions?: CourseCompletionCreateNestedManyWithoutStudentInput
    stationery?: StationeryIssueCreateNestedManyWithoutStudentInput
    certificates?: CertificateCreateNestedManyWithoutStudentInput
    financialRecords?: FinancialRecordCreateNestedManyWithoutStudentInput
    clientAdmin: ClientAdminCreateNestedOneWithoutStudentsInput
  }

  export type StudentUncheckedCreateInput = {
    id?: number
    serialNumber: number
    studentCode: string
    fullName: string
    fatherName: string
    motherName: string
    photoUrl?: string | null
    contact: string
    parentsContact: string
    email?: string | null
    residentialAddress?: string | null
    permenantAddress?: string | null
    dob: string
    gender: string
    religion?: string | null
    idProofType?: string | null
    idProofNumber?: string | null
    admissionDate: Date | string
    clientAdminId: string
    enquiry?: EnquiryUncheckedCreateNestedOneWithoutStudentInput
    labAllocations?: LabAllocationUncheckedCreateNestedManyWithoutStudentInput
    studentCourses?: StudentCourseUncheckedCreateNestedManyWithoutStudentInput
    feeStructures?: FeeStructureUncheckedCreateNestedManyWithoutStudentInput
    feeRecords?: StudentFeeUncheckedCreateNestedManyWithoutStudentInput
    attendance?: AttendanceRecordUncheckedCreateNestedManyWithoutStudentInput
    tasks?: StudentTaskUncheckedCreateNestedManyWithoutStudentInput
    tests?: StudentTestUncheckedCreateNestedManyWithoutStudentInput
    completions?: CourseCompletionUncheckedCreateNestedManyWithoutStudentInput
    stationery?: StationeryIssueUncheckedCreateNestedManyWithoutStudentInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutStudentInput
    financialRecords?: FinancialRecordUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentUpdateInput = {
    serialNumber?: IntFieldUpdateOperationsInput | number
    studentCode?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    fatherName?: StringFieldUpdateOperationsInput | string
    motherName?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: StringFieldUpdateOperationsInput | string
    parentsContact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: NullableStringFieldUpdateOperationsInput | string | null
    permenantAddress?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    idProofType?: NullableStringFieldUpdateOperationsInput | string | null
    idProofNumber?: NullableStringFieldUpdateOperationsInput | string | null
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    enquiry?: EnquiryUpdateOneWithoutStudentNestedInput
    labAllocations?: LabAllocationUpdateManyWithoutStudentNestedInput
    studentCourses?: StudentCourseUpdateManyWithoutStudentNestedInput
    feeStructures?: FeeStructureUpdateManyWithoutStudentNestedInput
    feeRecords?: StudentFeeUpdateManyWithoutStudentNestedInput
    attendance?: AttendanceRecordUpdateManyWithoutStudentNestedInput
    tasks?: StudentTaskUpdateManyWithoutStudentNestedInput
    tests?: StudentTestUpdateManyWithoutStudentNestedInput
    completions?: CourseCompletionUpdateManyWithoutStudentNestedInput
    stationery?: StationeryIssueUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUpdateManyWithoutStudentNestedInput
    financialRecords?: FinancialRecordUpdateManyWithoutStudentNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutStudentsNestedInput
  }

  export type StudentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    serialNumber?: IntFieldUpdateOperationsInput | number
    studentCode?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    fatherName?: StringFieldUpdateOperationsInput | string
    motherName?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: StringFieldUpdateOperationsInput | string
    parentsContact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: NullableStringFieldUpdateOperationsInput | string | null
    permenantAddress?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    idProofType?: NullableStringFieldUpdateOperationsInput | string | null
    idProofNumber?: NullableStringFieldUpdateOperationsInput | string | null
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    clientAdminId?: StringFieldUpdateOperationsInput | string
    enquiry?: EnquiryUncheckedUpdateOneWithoutStudentNestedInput
    labAllocations?: LabAllocationUncheckedUpdateManyWithoutStudentNestedInput
    studentCourses?: StudentCourseUncheckedUpdateManyWithoutStudentNestedInput
    feeStructures?: FeeStructureUncheckedUpdateManyWithoutStudentNestedInput
    feeRecords?: StudentFeeUncheckedUpdateManyWithoutStudentNestedInput
    attendance?: AttendanceRecordUncheckedUpdateManyWithoutStudentNestedInput
    tasks?: StudentTaskUncheckedUpdateManyWithoutStudentNestedInput
    tests?: StudentTestUncheckedUpdateManyWithoutStudentNestedInput
    completions?: CourseCompletionUncheckedUpdateManyWithoutStudentNestedInput
    stationery?: StationeryIssueUncheckedUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutStudentNestedInput
    financialRecords?: FinancialRecordUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentCreateManyInput = {
    id?: number
    serialNumber: number
    studentCode: string
    fullName: string
    fatherName: string
    motherName: string
    photoUrl?: string | null
    contact: string
    parentsContact: string
    email?: string | null
    residentialAddress?: string | null
    permenantAddress?: string | null
    dob: string
    gender: string
    religion?: string | null
    idProofType?: string | null
    idProofNumber?: string | null
    admissionDate: Date | string
    clientAdminId: string
  }

  export type StudentUpdateManyMutationInput = {
    serialNumber?: IntFieldUpdateOperationsInput | number
    studentCode?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    fatherName?: StringFieldUpdateOperationsInput | string
    motherName?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: StringFieldUpdateOperationsInput | string
    parentsContact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: NullableStringFieldUpdateOperationsInput | string | null
    permenantAddress?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    idProofType?: NullableStringFieldUpdateOperationsInput | string | null
    idProofNumber?: NullableStringFieldUpdateOperationsInput | string | null
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    serialNumber?: IntFieldUpdateOperationsInput | number
    studentCode?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    fatherName?: StringFieldUpdateOperationsInput | string
    motherName?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: StringFieldUpdateOperationsInput | string
    parentsContact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: NullableStringFieldUpdateOperationsInput | string | null
    permenantAddress?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    idProofType?: NullableStringFieldUpdateOperationsInput | string | null
    idProofNumber?: NullableStringFieldUpdateOperationsInput | string | null
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type CourseCreateInput = {
    name: string
    durationWeeks: number
    description?: string | null
    courseFeeStructure?: CourseFeeStructureCreateNestedOneWithoutCourseInput
    studentCourses?: StudentCourseCreateNestedManyWithoutCourseInput
    enquiryCourse?: EnquiryCourseCreateNestedManyWithoutCourseInput
    feeStructures?: FeeStructureCreateNestedManyWithoutCourseInput
    stationery?: StationeryIssueCreateNestedManyWithoutCourseInput
    studentFees?: StudentFeeCreateNestedManyWithoutCourseInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutCourseInput
    studentTasks?: StudentTaskCreateNestedManyWithoutCourseInput
    studentTests?: StudentTestCreateNestedManyWithoutCourseInput
    certificates?: CertificateCreateNestedManyWithoutCourseInput
    financialRecords?: FinancialRecordCreateNestedManyWithoutCourseInput
    batchCourses?: BatchCourseCreateNestedManyWithoutCourseInput
    clientAdmin: ClientAdminCreateNestedOneWithoutCoursesInput
  }

  export type CourseUncheckedCreateInput = {
    id?: number
    name: string
    durationWeeks: number
    description?: string | null
    clientAdminId: string
    courseFeeStructure?: CourseFeeStructureUncheckedCreateNestedOneWithoutCourseInput
    studentCourses?: StudentCourseUncheckedCreateNestedManyWithoutCourseInput
    enquiryCourse?: EnquiryCourseUncheckedCreateNestedManyWithoutCourseInput
    feeStructures?: FeeStructureUncheckedCreateNestedManyWithoutCourseInput
    stationery?: StationeryIssueUncheckedCreateNestedManyWithoutCourseInput
    studentFees?: StudentFeeUncheckedCreateNestedManyWithoutCourseInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutCourseInput
    studentTasks?: StudentTaskUncheckedCreateNestedManyWithoutCourseInput
    studentTests?: StudentTestUncheckedCreateNestedManyWithoutCourseInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutCourseInput
    financialRecords?: FinancialRecordUncheckedCreateNestedManyWithoutCourseInput
    batchCourses?: BatchCourseUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    durationWeeks?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    courseFeeStructure?: CourseFeeStructureUpdateOneWithoutCourseNestedInput
    studentCourses?: StudentCourseUpdateManyWithoutCourseNestedInput
    enquiryCourse?: EnquiryCourseUpdateManyWithoutCourseNestedInput
    feeStructures?: FeeStructureUpdateManyWithoutCourseNestedInput
    stationery?: StationeryIssueUpdateManyWithoutCourseNestedInput
    studentFees?: StudentFeeUpdateManyWithoutCourseNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutCourseNestedInput
    studentTasks?: StudentTaskUpdateManyWithoutCourseNestedInput
    studentTests?: StudentTestUpdateManyWithoutCourseNestedInput
    certificates?: CertificateUpdateManyWithoutCourseNestedInput
    financialRecords?: FinancialRecordUpdateManyWithoutCourseNestedInput
    batchCourses?: BatchCourseUpdateManyWithoutCourseNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutCoursesNestedInput
  }

  export type CourseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    durationWeeks?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    clientAdminId?: StringFieldUpdateOperationsInput | string
    courseFeeStructure?: CourseFeeStructureUncheckedUpdateOneWithoutCourseNestedInput
    studentCourses?: StudentCourseUncheckedUpdateManyWithoutCourseNestedInput
    enquiryCourse?: EnquiryCourseUncheckedUpdateManyWithoutCourseNestedInput
    feeStructures?: FeeStructureUncheckedUpdateManyWithoutCourseNestedInput
    stationery?: StationeryIssueUncheckedUpdateManyWithoutCourseNestedInput
    studentFees?: StudentFeeUncheckedUpdateManyWithoutCourseNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutCourseNestedInput
    studentTasks?: StudentTaskUncheckedUpdateManyWithoutCourseNestedInput
    studentTests?: StudentTestUncheckedUpdateManyWithoutCourseNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutCourseNestedInput
    financialRecords?: FinancialRecordUncheckedUpdateManyWithoutCourseNestedInput
    batchCourses?: BatchCourseUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CourseCreateManyInput = {
    id?: number
    name: string
    durationWeeks: number
    description?: string | null
    clientAdminId: string
  }

  export type CourseUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    durationWeeks?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CourseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    durationWeeks?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type CourseFeeStructureCreateInput = {
    totalAmount: number
    paymentType?: CourseFeeStructureCreatepaymentTypeInput | string[]
    course: CourseCreateNestedOneWithoutCourseFeeStructureInput
    installments?: InstallmentDetailCreateNestedManyWithoutCourseFeeStructureInput
    clientAdmin: ClientAdminCreateNestedOneWithoutCourseFeeStructuresInput
  }

  export type CourseFeeStructureUncheckedCreateInput = {
    id?: number
    courseId: number
    totalAmount: number
    paymentType?: CourseFeeStructureCreatepaymentTypeInput | string[]
    clientAdminId: string
    installments?: InstallmentDetailUncheckedCreateNestedManyWithoutCourseFeeStructureInput
  }

  export type CourseFeeStructureUpdateInput = {
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paymentType?: CourseFeeStructureUpdatepaymentTypeInput | string[]
    course?: CourseUpdateOneRequiredWithoutCourseFeeStructureNestedInput
    installments?: InstallmentDetailUpdateManyWithoutCourseFeeStructureNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutCourseFeeStructuresNestedInput
  }

  export type CourseFeeStructureUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paymentType?: CourseFeeStructureUpdatepaymentTypeInput | string[]
    clientAdminId?: StringFieldUpdateOperationsInput | string
    installments?: InstallmentDetailUncheckedUpdateManyWithoutCourseFeeStructureNestedInput
  }

  export type CourseFeeStructureCreateManyInput = {
    id?: number
    courseId: number
    totalAmount: number
    paymentType?: CourseFeeStructureCreatepaymentTypeInput | string[]
    clientAdminId: string
  }

  export type CourseFeeStructureUpdateManyMutationInput = {
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paymentType?: CourseFeeStructureUpdatepaymentTypeInput | string[]
  }

  export type CourseFeeStructureUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paymentType?: CourseFeeStructureUpdatepaymentTypeInput | string[]
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type BatchCreateInput = {
    name: string
    faculty?: FacultyCreateNestedOneWithoutBatchesInput
    labTimeSlot: LabTimeSlotCreateNestedOneWithoutBatchesInput
    studentCourses?: StudentCourseCreateNestedManyWithoutBatchInput
    batchCourses?: BatchCourseCreateNestedManyWithoutBatchInput
    clientAdmin: ClientAdminCreateNestedOneWithoutBatchesInput
  }

  export type BatchUncheckedCreateInput = {
    id?: number
    name: string
    facultyId?: number | null
    labTimeSlotId: number
    clientAdminId: string
    studentCourses?: StudentCourseUncheckedCreateNestedManyWithoutBatchInput
    batchCourses?: BatchCourseUncheckedCreateNestedManyWithoutBatchInput
  }

  export type BatchUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    faculty?: FacultyUpdateOneWithoutBatchesNestedInput
    labTimeSlot?: LabTimeSlotUpdateOneRequiredWithoutBatchesNestedInput
    studentCourses?: StudentCourseUpdateManyWithoutBatchNestedInput
    batchCourses?: BatchCourseUpdateManyWithoutBatchNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutBatchesNestedInput
  }

  export type BatchUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    facultyId?: NullableIntFieldUpdateOperationsInput | number | null
    labTimeSlotId?: IntFieldUpdateOperationsInput | number
    clientAdminId?: StringFieldUpdateOperationsInput | string
    studentCourses?: StudentCourseUncheckedUpdateManyWithoutBatchNestedInput
    batchCourses?: BatchCourseUncheckedUpdateManyWithoutBatchNestedInput
  }

  export type BatchCreateManyInput = {
    id?: number
    name: string
    facultyId?: number | null
    labTimeSlotId: number
    clientAdminId: string
  }

  export type BatchUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type BatchUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    facultyId?: NullableIntFieldUpdateOperationsInput | number | null
    labTimeSlotId?: IntFieldUpdateOperationsInput | number
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type BatchCourseCreateInput = {
    pcsReserved?: number | null
    batch: BatchCreateNestedOneWithoutBatchCoursesInput
    course: CourseCreateNestedOneWithoutBatchCoursesInput
  }

  export type BatchCourseUncheckedCreateInput = {
    id?: number
    batchId: number
    courseId: number
    pcsReserved?: number | null
  }

  export type BatchCourseUpdateInput = {
    pcsReserved?: NullableIntFieldUpdateOperationsInput | number | null
    batch?: BatchUpdateOneRequiredWithoutBatchCoursesNestedInput
    course?: CourseUpdateOneRequiredWithoutBatchCoursesNestedInput
  }

  export type BatchCourseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    batchId?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    pcsReserved?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BatchCourseCreateManyInput = {
    id?: number
    batchId: number
    courseId: number
    pcsReserved?: number | null
  }

  export type BatchCourseUpdateManyMutationInput = {
    pcsReserved?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BatchCourseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    batchId?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    pcsReserved?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FacultyCreateInput = {
    name: string
    email: string
    password: string
    contact: string
    joiningDate: Date | string
    specialization?: string | null
    role?: $Enums.UserRole
    country: string
    state: string
    city: string
    zipCode: string
    currentSessionToken?: string | null
    lastLoginAt?: Date | string | null
    batches?: BatchCreateNestedManyWithoutFacultyInput
    attendance?: AttendanceRecordCreateNestedManyWithoutMarkedByInput
    tasks?: StudentTaskCreateNestedManyWithoutFacultyInput
    financialRecords?: FinancialRecordCreateNestedManyWithoutFacultyInput
    clientAdmin: ClientAdminCreateNestedOneWithoutFacultiesInput
  }

  export type FacultyUncheckedCreateInput = {
    id?: number
    name: string
    email: string
    password: string
    contact: string
    joiningDate: Date | string
    specialization?: string | null
    role?: $Enums.UserRole
    country: string
    state: string
    city: string
    zipCode: string
    currentSessionToken?: string | null
    lastLoginAt?: Date | string | null
    clientAdminId: string
    batches?: BatchUncheckedCreateNestedManyWithoutFacultyInput
    attendance?: AttendanceRecordUncheckedCreateNestedManyWithoutMarkedByInput
    tasks?: StudentTaskUncheckedCreateNestedManyWithoutFacultyInput
    financialRecords?: FinancialRecordUncheckedCreateNestedManyWithoutFacultyInput
  }

  export type FacultyUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    joiningDate?: DateTimeFieldUpdateOperationsInput | Date | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    currentSessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    batches?: BatchUpdateManyWithoutFacultyNestedInput
    attendance?: AttendanceRecordUpdateManyWithoutMarkedByNestedInput
    tasks?: StudentTaskUpdateManyWithoutFacultyNestedInput
    financialRecords?: FinancialRecordUpdateManyWithoutFacultyNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutFacultiesNestedInput
  }

  export type FacultyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    joiningDate?: DateTimeFieldUpdateOperationsInput | Date | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    currentSessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clientAdminId?: StringFieldUpdateOperationsInput | string
    batches?: BatchUncheckedUpdateManyWithoutFacultyNestedInput
    attendance?: AttendanceRecordUncheckedUpdateManyWithoutMarkedByNestedInput
    tasks?: StudentTaskUncheckedUpdateManyWithoutFacultyNestedInput
    financialRecords?: FinancialRecordUncheckedUpdateManyWithoutFacultyNestedInput
  }

  export type FacultyCreateManyInput = {
    id?: number
    name: string
    email: string
    password: string
    contact: string
    joiningDate: Date | string
    specialization?: string | null
    role?: $Enums.UserRole
    country: string
    state: string
    city: string
    zipCode: string
    currentSessionToken?: string | null
    lastLoginAt?: Date | string | null
    clientAdminId: string
  }

  export type FacultyUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    joiningDate?: DateTimeFieldUpdateOperationsInput | Date | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    currentSessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FacultyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    joiningDate?: DateTimeFieldUpdateOperationsInput | Date | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    currentSessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type LabCreateInput = {
    name: string
    location?: string | null
    totalPCs: number
    isActive?: boolean
    timeSlots?: LabTimeSlotCreateNestedManyWithoutLabInput
    financialRecords?: FinancialRecordCreateNestedManyWithoutLabInput
    clientAdmin: ClientAdminCreateNestedOneWithoutLabsInput
  }

  export type LabUncheckedCreateInput = {
    id?: number
    name: string
    location?: string | null
    totalPCs: number
    isActive?: boolean
    clientAdminId: string
    timeSlots?: LabTimeSlotUncheckedCreateNestedManyWithoutLabInput
    financialRecords?: FinancialRecordUncheckedCreateNestedManyWithoutLabInput
  }

  export type LabUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    totalPCs?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    timeSlots?: LabTimeSlotUpdateManyWithoutLabNestedInput
    financialRecords?: FinancialRecordUpdateManyWithoutLabNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutLabsNestedInput
  }

  export type LabUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    totalPCs?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    clientAdminId?: StringFieldUpdateOperationsInput | string
    timeSlots?: LabTimeSlotUncheckedUpdateManyWithoutLabNestedInput
    financialRecords?: FinancialRecordUncheckedUpdateManyWithoutLabNestedInput
  }

  export type LabCreateManyInput = {
    id?: number
    name: string
    location?: string | null
    totalPCs: number
    isActive?: boolean
    clientAdminId: string
  }

  export type LabUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    totalPCs?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LabUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    totalPCs?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type LabTimeSlotCreateInput = {
    startTime: string
    endTime: string
    day: string
    availablePCs: number
    lab: LabCreateNestedOneWithoutTimeSlotsInput
    batches?: BatchCreateNestedManyWithoutLabTimeSlotInput
    allocations?: LabAllocationCreateNestedManyWithoutLabTimeSlotInput
    clientAdmin: ClientAdminCreateNestedOneWithoutLabTimeSlotsInput
  }

  export type LabTimeSlotUncheckedCreateInput = {
    id?: number
    startTime: string
    endTime: string
    day: string
    labId: number
    availablePCs: number
    clientAdminId: string
    batches?: BatchUncheckedCreateNestedManyWithoutLabTimeSlotInput
    allocations?: LabAllocationUncheckedCreateNestedManyWithoutLabTimeSlotInput
  }

  export type LabTimeSlotUpdateInput = {
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    day?: StringFieldUpdateOperationsInput | string
    availablePCs?: IntFieldUpdateOperationsInput | number
    lab?: LabUpdateOneRequiredWithoutTimeSlotsNestedInput
    batches?: BatchUpdateManyWithoutLabTimeSlotNestedInput
    allocations?: LabAllocationUpdateManyWithoutLabTimeSlotNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutLabTimeSlotsNestedInput
  }

  export type LabTimeSlotUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    day?: StringFieldUpdateOperationsInput | string
    labId?: IntFieldUpdateOperationsInput | number
    availablePCs?: IntFieldUpdateOperationsInput | number
    clientAdminId?: StringFieldUpdateOperationsInput | string
    batches?: BatchUncheckedUpdateManyWithoutLabTimeSlotNestedInput
    allocations?: LabAllocationUncheckedUpdateManyWithoutLabTimeSlotNestedInput
  }

  export type LabTimeSlotCreateManyInput = {
    id?: number
    startTime: string
    endTime: string
    day: string
    labId: number
    availablePCs: number
    clientAdminId: string
  }

  export type LabTimeSlotUpdateManyMutationInput = {
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    day?: StringFieldUpdateOperationsInput | string
    availablePCs?: IntFieldUpdateOperationsInput | number
  }

  export type LabTimeSlotUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    day?: StringFieldUpdateOperationsInput | string
    labId?: IntFieldUpdateOperationsInput | number
    availablePCs?: IntFieldUpdateOperationsInput | number
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type PaymentStructureTypeCreateInput = {
    name: $Enums.PaymentType
    installmentCount?: number | null
  }

  export type PaymentStructureTypeUncheckedCreateInput = {
    id?: number
    name: $Enums.PaymentType
    installmentCount?: number | null
  }

  export type PaymentStructureTypeUpdateInput = {
    name?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    installmentCount?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PaymentStructureTypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    installmentCount?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PaymentStructureTypeCreateManyInput = {
    id?: number
    name: $Enums.PaymentType
    installmentCount?: number | null
  }

  export type PaymentStructureTypeUpdateManyMutationInput = {
    name?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    installmentCount?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PaymentStructureTypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    installmentCount?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type InstallmentDetailCreateInput = {
    number: number
    amount: number
    feeStructures?: FeeStructureCreateNestedManyWithoutInstallmentInput
    CourseFeeStructure: CourseFeeStructureCreateNestedOneWithoutInstallmentsInput
  }

  export type InstallmentDetailUncheckedCreateInput = {
    id?: number
    CourseFeeStructureId: number
    number: number
    amount: number
    feeStructures?: FeeStructureUncheckedCreateNestedManyWithoutInstallmentInput
  }

  export type InstallmentDetailUpdateInput = {
    number?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    feeStructures?: FeeStructureUpdateManyWithoutInstallmentNestedInput
    CourseFeeStructure?: CourseFeeStructureUpdateOneRequiredWithoutInstallmentsNestedInput
  }

  export type InstallmentDetailUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    CourseFeeStructureId?: IntFieldUpdateOperationsInput | number
    number?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    feeStructures?: FeeStructureUncheckedUpdateManyWithoutInstallmentNestedInput
  }

  export type InstallmentDetailCreateManyInput = {
    id?: number
    CourseFeeStructureId: number
    number: number
    amount: number
  }

  export type InstallmentDetailUpdateManyMutationInput = {
    number?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
  }

  export type InstallmentDetailUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    CourseFeeStructureId?: IntFieldUpdateOperationsInput | number
    number?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
  }

  export type LabAllocationCreateInput = {
    pcNumber: number
    assignedAt?: Date | string
    labTimeSlot: LabTimeSlotCreateNestedOneWithoutAllocationsInput
    student: StudentCreateNestedOneWithoutLabAllocationsInput
    clientAdmin: ClientAdminCreateNestedOneWithoutLabAllocationsInput
  }

  export type LabAllocationUncheckedCreateInput = {
    id?: number
    labTimeSlotId: number
    studentId: number
    pcNumber: number
    assignedAt?: Date | string
    clientAdminId: string
  }

  export type LabAllocationUpdateInput = {
    pcNumber?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    labTimeSlot?: LabTimeSlotUpdateOneRequiredWithoutAllocationsNestedInput
    student?: StudentUpdateOneRequiredWithoutLabAllocationsNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutLabAllocationsNestedInput
  }

  export type LabAllocationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    labTimeSlotId?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    pcNumber?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type LabAllocationCreateManyInput = {
    id?: number
    labTimeSlotId: number
    studentId: number
    pcNumber: number
    assignedAt?: Date | string
    clientAdminId: string
  }

  export type LabAllocationUpdateManyMutationInput = {
    pcNumber?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabAllocationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    labTimeSlotId?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    pcNumber?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentCourseCreateInput = {
    startDate: Date | string
    endDate: Date | string
    studentCode: string
    internalNotes?: string | null
    status: string
    student: StudentCreateNestedOneWithoutStudentCoursesInput
    course: CourseCreateNestedOneWithoutStudentCoursesInput
    batch?: BatchCreateNestedOneWithoutStudentCoursesInput
    certificate?: CertificateCreateNestedOneWithoutStudentCourseInput
    completions?: CourseCompletionCreateNestedManyWithoutStudentCourseInput
    clientAdmin: ClientAdminCreateNestedOneWithoutStudentCoursesInput
  }

  export type StudentCourseUncheckedCreateInput = {
    id?: number
    studentId: number
    courseId: number
    startDate: Date | string
    endDate: Date | string
    studentCode: string
    batchId?: number | null
    internalNotes?: string | null
    status: string
    clientAdminId: string
    certificate?: CertificateUncheckedCreateNestedOneWithoutStudentCourseInput
    completions?: CourseCompletionUncheckedCreateNestedManyWithoutStudentCourseInput
  }

  export type StudentCourseUpdateInput = {
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    studentCode?: StringFieldUpdateOperationsInput | string
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    student?: StudentUpdateOneRequiredWithoutStudentCoursesNestedInput
    course?: CourseUpdateOneRequiredWithoutStudentCoursesNestedInput
    batch?: BatchUpdateOneWithoutStudentCoursesNestedInput
    certificate?: CertificateUpdateOneWithoutStudentCourseNestedInput
    completions?: CourseCompletionUpdateManyWithoutStudentCourseNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutStudentCoursesNestedInput
  }

  export type StudentCourseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    studentCode?: StringFieldUpdateOperationsInput | string
    batchId?: NullableIntFieldUpdateOperationsInput | number | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    clientAdminId?: StringFieldUpdateOperationsInput | string
    certificate?: CertificateUncheckedUpdateOneWithoutStudentCourseNestedInput
    completions?: CourseCompletionUncheckedUpdateManyWithoutStudentCourseNestedInput
  }

  export type StudentCourseCreateManyInput = {
    id?: number
    studentId: number
    courseId: number
    startDate: Date | string
    endDate: Date | string
    studentCode: string
    batchId?: number | null
    internalNotes?: string | null
    status: string
    clientAdminId: string
  }

  export type StudentCourseUpdateManyMutationInput = {
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    studentCode?: StringFieldUpdateOperationsInput | string
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type StudentCourseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    studentCode?: StringFieldUpdateOperationsInput | string
    batchId?: NullableIntFieldUpdateOperationsInput | number | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type FeeStructureCreateInput = {
    totalAmount: number
    paymentType: $Enums.PaymentType
    installmentCount?: number | null
    student: StudentCreateNestedOneWithoutFeeStructuresInput
    course: CourseCreateNestedOneWithoutFeeStructuresInput
    installment?: InstallmentDetailCreateNestedOneWithoutFeeStructuresInput
    studentFees?: StudentFeeCreateNestedManyWithoutFeeStructureInput
    clientAdmin: ClientAdminCreateNestedOneWithoutFeeStructuresInput
  }

  export type FeeStructureUncheckedCreateInput = {
    id?: number
    studentId: number
    courseId: number
    totalAmount: number
    paymentType: $Enums.PaymentType
    installmentCount?: number | null
    installmentTypeId?: number | null
    clientAdminId: string
    studentFees?: StudentFeeUncheckedCreateNestedManyWithoutFeeStructureInput
  }

  export type FeeStructureUpdateInput = {
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paymentType?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    installmentCount?: NullableIntFieldUpdateOperationsInput | number | null
    student?: StudentUpdateOneRequiredWithoutFeeStructuresNestedInput
    course?: CourseUpdateOneRequiredWithoutFeeStructuresNestedInput
    installment?: InstallmentDetailUpdateOneWithoutFeeStructuresNestedInput
    studentFees?: StudentFeeUpdateManyWithoutFeeStructureNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutFeeStructuresNestedInput
  }

  export type FeeStructureUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paymentType?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    installmentCount?: NullableIntFieldUpdateOperationsInput | number | null
    installmentTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    clientAdminId?: StringFieldUpdateOperationsInput | string
    studentFees?: StudentFeeUncheckedUpdateManyWithoutFeeStructureNestedInput
  }

  export type FeeStructureCreateManyInput = {
    id?: number
    studentId: number
    courseId: number
    totalAmount: number
    paymentType: $Enums.PaymentType
    installmentCount?: number | null
    installmentTypeId?: number | null
    clientAdminId: string
  }

  export type FeeStructureUpdateManyMutationInput = {
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paymentType?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    installmentCount?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FeeStructureUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paymentType?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    installmentCount?: NullableIntFieldUpdateOperationsInput | number | null
    installmentTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentFeeLogCreateInput = {
    amountPaid: number
    paymentDate: Date | string
    paymentMode: $Enums.PaymentMode
    receiptNo: string
    studentFee: StudentFeeCreateNestedOneWithoutFeeLogsInput
  }

  export type StudentFeeLogUncheckedCreateInput = {
    id?: number
    studentFeeId: number
    amountPaid: number
    paymentDate: Date | string
    paymentMode: $Enums.PaymentMode
    receiptNo: string
  }

  export type StudentFeeLogUpdateInput = {
    amountPaid?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMode?: EnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode
    receiptNo?: StringFieldUpdateOperationsInput | string
    studentFee?: StudentFeeUpdateOneRequiredWithoutFeeLogsNestedInput
  }

  export type StudentFeeLogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentFeeId?: IntFieldUpdateOperationsInput | number
    amountPaid?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMode?: EnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode
    receiptNo?: StringFieldUpdateOperationsInput | string
  }

  export type StudentFeeLogCreateManyInput = {
    id?: number
    studentFeeId: number
    amountPaid: number
    paymentDate: Date | string
    paymentMode: $Enums.PaymentMode
    receiptNo: string
  }

  export type StudentFeeLogUpdateManyMutationInput = {
    amountPaid?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMode?: EnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode
    receiptNo?: StringFieldUpdateOperationsInput | string
  }

  export type StudentFeeLogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentFeeId?: IntFieldUpdateOperationsInput | number
    amountPaid?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMode?: EnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode
    receiptNo?: StringFieldUpdateOperationsInput | string
  }

  export type StudentFeeCreateInput = {
    dueDate: Date | string
    amountDue: number
    amountPaid: number
    paymentDate?: Date | string | null
    paymentMode: $Enums.PaymentMode
    receiptNo: string
    paymentStatus?: $Enums.PaymentStatus
    student: StudentCreateNestedOneWithoutFeeRecordsInput
    course: CourseCreateNestedOneWithoutStudentFeesInput
    feeLogs?: StudentFeeLogCreateNestedManyWithoutStudentFeeInput
    feeStructure?: FeeStructureCreateNestedOneWithoutStudentFeesInput
    notification?: NotificationCreateNestedOneWithoutPaymentInput
    clientAdmin: ClientAdminCreateNestedOneWithoutStudentFeesInput
  }

  export type StudentFeeUncheckedCreateInput = {
    id?: number
    studentId: number
    courseId: number
    dueDate: Date | string
    amountDue: number
    amountPaid: number
    paymentDate?: Date | string | null
    paymentMode: $Enums.PaymentMode
    receiptNo: string
    paymentStatus?: $Enums.PaymentStatus
    clientAdminId: string
    feeLogs?: StudentFeeLogUncheckedCreateNestedManyWithoutStudentFeeInput
    notification?: NotificationUncheckedCreateNestedOneWithoutPaymentInput
  }

  export type StudentFeeUpdateInput = {
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amountDue?: FloatFieldUpdateOperationsInput | number
    amountPaid?: FloatFieldUpdateOperationsInput | number
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMode?: EnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode
    receiptNo?: StringFieldUpdateOperationsInput | string
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    student?: StudentUpdateOneRequiredWithoutFeeRecordsNestedInput
    course?: CourseUpdateOneRequiredWithoutStudentFeesNestedInput
    feeLogs?: StudentFeeLogUpdateManyWithoutStudentFeeNestedInput
    feeStructure?: FeeStructureUpdateOneWithoutStudentFeesNestedInput
    notification?: NotificationUpdateOneWithoutPaymentNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutStudentFeesNestedInput
  }

  export type StudentFeeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amountDue?: FloatFieldUpdateOperationsInput | number
    amountPaid?: FloatFieldUpdateOperationsInput | number
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMode?: EnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode
    receiptNo?: StringFieldUpdateOperationsInput | string
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    clientAdminId?: StringFieldUpdateOperationsInput | string
    feeLogs?: StudentFeeLogUncheckedUpdateManyWithoutStudentFeeNestedInput
    notification?: NotificationUncheckedUpdateOneWithoutPaymentNestedInput
  }

  export type StudentFeeCreateManyInput = {
    id?: number
    studentId: number
    courseId: number
    dueDate: Date | string
    amountDue: number
    amountPaid: number
    paymentDate?: Date | string | null
    paymentMode: $Enums.PaymentMode
    receiptNo: string
    paymentStatus?: $Enums.PaymentStatus
    clientAdminId: string
  }

  export type StudentFeeUpdateManyMutationInput = {
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amountDue?: FloatFieldUpdateOperationsInput | number
    amountPaid?: FloatFieldUpdateOperationsInput | number
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMode?: EnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode
    receiptNo?: StringFieldUpdateOperationsInput | string
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
  }

  export type StudentFeeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amountDue?: FloatFieldUpdateOperationsInput | number
    amountPaid?: FloatFieldUpdateOperationsInput | number
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMode?: EnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode
    receiptNo?: StringFieldUpdateOperationsInput | string
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type StationeryItemCreateInput = {
    name: string
    quantityAvailable: number
    stationeryIssues?: StationeryIssueCreateNestedManyWithoutItemInput
  }

  export type StationeryItemUncheckedCreateInput = {
    id?: number
    name: string
    quantityAvailable: number
    stationeryIssues?: StationeryIssueUncheckedCreateNestedManyWithoutItemInput
  }

  export type StationeryItemUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    quantityAvailable?: IntFieldUpdateOperationsInput | number
    stationeryIssues?: StationeryIssueUpdateManyWithoutItemNestedInput
  }

  export type StationeryItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    quantityAvailable?: IntFieldUpdateOperationsInput | number
    stationeryIssues?: StationeryIssueUncheckedUpdateManyWithoutItemNestedInput
  }

  export type StationeryItemCreateManyInput = {
    id?: number
    name: string
    quantityAvailable: number
  }

  export type StationeryItemUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    quantityAvailable?: IntFieldUpdateOperationsInput | number
  }

  export type StationeryItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    quantityAvailable?: IntFieldUpdateOperationsInput | number
  }

  export type StationeryIssueCreateInput = {
    issueDate: Date | string
    quantity: number
    remarks?: string | null
    student: StudentCreateNestedOneWithoutStationeryInput
    course: CourseCreateNestedOneWithoutStationeryInput
    item: StationeryItemCreateNestedOneWithoutStationeryIssuesInput
    clientAdmin: ClientAdminCreateNestedOneWithoutStationeryIssuesInput
  }

  export type StationeryIssueUncheckedCreateInput = {
    id?: number
    studentId: number
    courseId: number
    itemId: number
    issueDate: Date | string
    quantity: number
    remarks?: string | null
    clientAdminId: string
  }

  export type StationeryIssueUpdateInput = {
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    student?: StudentUpdateOneRequiredWithoutStationeryNestedInput
    course?: CourseUpdateOneRequiredWithoutStationeryNestedInput
    item?: StationeryItemUpdateOneRequiredWithoutStationeryIssuesNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutStationeryIssuesNestedInput
  }

  export type StationeryIssueUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type StationeryIssueCreateManyInput = {
    id?: number
    studentId: number
    courseId: number
    itemId: number
    issueDate: Date | string
    quantity: number
    remarks?: string | null
    clientAdminId: string
  }

  export type StationeryIssueUpdateManyMutationInput = {
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StationeryIssueUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type AttendanceRecordCreateInput = {
    date: Date | string
    present: boolean
    batchId?: number | null
    student: StudentCreateNestedOneWithoutAttendanceInput
    course: CourseCreateNestedOneWithoutAttendanceRecordsInput
    markedBy: FacultyCreateNestedOneWithoutAttendanceInput
    clientAdmin: ClientAdminCreateNestedOneWithoutAttendanceRecordsInput
  }

  export type AttendanceRecordUncheckedCreateInput = {
    id?: number
    studentId: number
    courseId: number
    date: Date | string
    present: boolean
    facultyId: number
    batchId?: number | null
    clientAdminId: string
  }

  export type AttendanceRecordUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    present?: BoolFieldUpdateOperationsInput | boolean
    batchId?: NullableIntFieldUpdateOperationsInput | number | null
    student?: StudentUpdateOneRequiredWithoutAttendanceNestedInput
    course?: CourseUpdateOneRequiredWithoutAttendanceRecordsNestedInput
    markedBy?: FacultyUpdateOneRequiredWithoutAttendanceNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutAttendanceRecordsNestedInput
  }

  export type AttendanceRecordUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    present?: BoolFieldUpdateOperationsInput | boolean
    facultyId?: IntFieldUpdateOperationsInput | number
    batchId?: NullableIntFieldUpdateOperationsInput | number | null
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type AttendanceRecordCreateManyInput = {
    id?: number
    studentId: number
    courseId: number
    date: Date | string
    present: boolean
    facultyId: number
    batchId?: number | null
    clientAdminId: string
  }

  export type AttendanceRecordUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    present?: BoolFieldUpdateOperationsInput | boolean
    batchId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AttendanceRecordUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    present?: BoolFieldUpdateOperationsInput | boolean
    facultyId?: IntFieldUpdateOperationsInput | number
    batchId?: NullableIntFieldUpdateOperationsInput | number | null
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentTaskCreateInput = {
    assignedDate: Date | string
    dueDate: Date | string
    description: string
    status: string
    facultyRemarks?: string | null
    grade?: string | null
    student: StudentCreateNestedOneWithoutTasksInput
    course: CourseCreateNestedOneWithoutStudentTasksInput
    faculty?: FacultyCreateNestedOneWithoutTasksInput
    clientAdmin: ClientAdminCreateNestedOneWithoutStudentTasksInput
  }

  export type StudentTaskUncheckedCreateInput = {
    id?: number
    studentId: number
    courseId: number
    assignedDate: Date | string
    dueDate: Date | string
    description: string
    status: string
    facultyRemarks?: string | null
    grade?: string | null
    facultyId?: number | null
    clientAdminId: string
  }

  export type StudentTaskUpdateInput = {
    assignedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    facultyRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    student?: StudentUpdateOneRequiredWithoutTasksNestedInput
    course?: CourseUpdateOneRequiredWithoutStudentTasksNestedInput
    faculty?: FacultyUpdateOneWithoutTasksNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutStudentTasksNestedInput
  }

  export type StudentTaskUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    assignedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    facultyRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    facultyId?: NullableIntFieldUpdateOperationsInput | number | null
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentTaskCreateManyInput = {
    id?: number
    studentId: number
    courseId: number
    assignedDate: Date | string
    dueDate: Date | string
    description: string
    status: string
    facultyRemarks?: string | null
    grade?: string | null
    facultyId?: number | null
    clientAdminId: string
  }

  export type StudentTaskUpdateManyMutationInput = {
    assignedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    facultyRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StudentTaskUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    assignedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    facultyRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    facultyId?: NullableIntFieldUpdateOperationsInput | number | null
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentTestCreateInput = {
    testName: string
    testDate: Date | string
    totalMarks: number
    marksObtained: number
    grade: string
    student: StudentCreateNestedOneWithoutTestsInput
    course: CourseCreateNestedOneWithoutStudentTestsInput
    clientAdmin: ClientAdminCreateNestedOneWithoutStudentTestsInput
  }

  export type StudentTestUncheckedCreateInput = {
    id?: number
    studentId: number
    courseId: number
    testName: string
    testDate: Date | string
    totalMarks: number
    marksObtained: number
    grade: string
    clientAdminId: string
  }

  export type StudentTestUpdateInput = {
    testName?: StringFieldUpdateOperationsInput | string
    testDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalMarks?: IntFieldUpdateOperationsInput | number
    marksObtained?: IntFieldUpdateOperationsInput | number
    grade?: StringFieldUpdateOperationsInput | string
    student?: StudentUpdateOneRequiredWithoutTestsNestedInput
    course?: CourseUpdateOneRequiredWithoutStudentTestsNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutStudentTestsNestedInput
  }

  export type StudentTestUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    testName?: StringFieldUpdateOperationsInput | string
    testDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalMarks?: IntFieldUpdateOperationsInput | number
    marksObtained?: IntFieldUpdateOperationsInput | number
    grade?: StringFieldUpdateOperationsInput | string
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentTestCreateManyInput = {
    id?: number
    studentId: number
    courseId: number
    testName: string
    testDate: Date | string
    totalMarks: number
    marksObtained: number
    grade: string
    clientAdminId: string
  }

  export type StudentTestUpdateManyMutationInput = {
    testName?: StringFieldUpdateOperationsInput | string
    testDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalMarks?: IntFieldUpdateOperationsInput | number
    marksObtained?: IntFieldUpdateOperationsInput | number
    grade?: StringFieldUpdateOperationsInput | string
  }

  export type StudentTestUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    testName?: StringFieldUpdateOperationsInput | string
    testDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalMarks?: IntFieldUpdateOperationsInput | number
    marksObtained?: IntFieldUpdateOperationsInput | number
    grade?: StringFieldUpdateOperationsInput | string
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type CourseCompletionCreateInput = {
    completionDate: Date | string
    feedback?: string | null
    remarks?: string | null
    studentCourse: StudentCourseCreateNestedOneWithoutCompletionsInput
    student: StudentCreateNestedOneWithoutCompletionsInput
    clientAdmin: ClientAdminCreateNestedOneWithoutCourseCompletionsInput
  }

  export type CourseCompletionUncheckedCreateInput = {
    id?: number
    studentCourseId: number
    studentId: number
    completionDate: Date | string
    feedback?: string | null
    remarks?: string | null
    clientAdminId: string
  }

  export type CourseCompletionUpdateInput = {
    completionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    studentCourse?: StudentCourseUpdateOneRequiredWithoutCompletionsNestedInput
    student?: StudentUpdateOneRequiredWithoutCompletionsNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutCourseCompletionsNestedInput
  }

  export type CourseCompletionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentCourseId?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    completionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type CourseCompletionCreateManyInput = {
    id?: number
    studentCourseId: number
    studentId: number
    completionDate: Date | string
    feedback?: string | null
    remarks?: string | null
    clientAdminId: string
  }

  export type CourseCompletionUpdateManyMutationInput = {
    completionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CourseCompletionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentCourseId?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    completionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type CertificateCreateInput = {
    issueDate: Date | string
    certificateUrl: string
    student: StudentCreateNestedOneWithoutCertificatesInput
    course: CourseCreateNestedOneWithoutCertificatesInput
    studentCourse: StudentCourseCreateNestedOneWithoutCertificateInput
    clientAdmin: ClientAdminCreateNestedOneWithoutCertificatesInput
  }

  export type CertificateUncheckedCreateInput = {
    id?: number
    studentId: number
    courseId: number
    studentCourseId: number
    issueDate: Date | string
    certificateUrl: string
    clientAdminId: string
  }

  export type CertificateUpdateInput = {
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    certificateUrl?: StringFieldUpdateOperationsInput | string
    student?: StudentUpdateOneRequiredWithoutCertificatesNestedInput
    course?: CourseUpdateOneRequiredWithoutCertificatesNestedInput
    studentCourse?: StudentCourseUpdateOneRequiredWithoutCertificateNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutCertificatesNestedInput
  }

  export type CertificateUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    studentCourseId?: IntFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    certificateUrl?: StringFieldUpdateOperationsInput | string
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type CertificateCreateManyInput = {
    id?: number
    studentId: number
    courseId: number
    studentCourseId: number
    issueDate: Date | string
    certificateUrl: string
    clientAdminId: string
  }

  export type CertificateUpdateManyMutationInput = {
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    certificateUrl?: StringFieldUpdateOperationsInput | string
  }

  export type CertificateUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    studentCourseId?: IntFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    certificateUrl?: StringFieldUpdateOperationsInput | string
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type FinancialRecordCreateInput = {
    id?: string
    recordType: $Enums.RecordType
    amount: number
    description?: string | null
    date?: Date | string
    paymentMode?: $Enums.PaymentMode | null
    student?: StudentCreateNestedOneWithoutFinancialRecordsInput
    course?: CourseCreateNestedOneWithoutFinancialRecordsInput
    faculty?: FacultyCreateNestedOneWithoutFinancialRecordsInput
    lab?: LabCreateNestedOneWithoutFinancialRecordsInput
    clientAdmin: ClientAdminCreateNestedOneWithoutFinancialRecordsInput
  }

  export type FinancialRecordUncheckedCreateInput = {
    id?: string
    clientAdminId: string
    recordType: $Enums.RecordType
    amount: number
    description?: string | null
    date?: Date | string
    paymentMode?: $Enums.PaymentMode | null
    studentId?: number | null
    courseId?: number | null
    facultyId?: number | null
    labId?: number | null
  }

  export type FinancialRecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordType?: EnumRecordTypeFieldUpdateOperationsInput | $Enums.RecordType
    amount?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMode?: NullableEnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode | null
    student?: StudentUpdateOneWithoutFinancialRecordsNestedInput
    course?: CourseUpdateOneWithoutFinancialRecordsNestedInput
    faculty?: FacultyUpdateOneWithoutFinancialRecordsNestedInput
    lab?: LabUpdateOneWithoutFinancialRecordsNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutFinancialRecordsNestedInput
  }

  export type FinancialRecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientAdminId?: StringFieldUpdateOperationsInput | string
    recordType?: EnumRecordTypeFieldUpdateOperationsInput | $Enums.RecordType
    amount?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMode?: NullableEnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode | null
    studentId?: NullableIntFieldUpdateOperationsInput | number | null
    courseId?: NullableIntFieldUpdateOperationsInput | number | null
    facultyId?: NullableIntFieldUpdateOperationsInput | number | null
    labId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FinancialRecordCreateManyInput = {
    id?: string
    clientAdminId: string
    recordType: $Enums.RecordType
    amount: number
    description?: string | null
    date?: Date | string
    paymentMode?: $Enums.PaymentMode | null
    studentId?: number | null
    courseId?: number | null
    facultyId?: number | null
    labId?: number | null
  }

  export type FinancialRecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordType?: EnumRecordTypeFieldUpdateOperationsInput | $Enums.RecordType
    amount?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMode?: NullableEnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode | null
  }

  export type FinancialRecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientAdminId?: StringFieldUpdateOperationsInput | string
    recordType?: EnumRecordTypeFieldUpdateOperationsInput | $Enums.RecordType
    amount?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMode?: NullableEnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode | null
    studentId?: NullableIntFieldUpdateOperationsInput | number | null
    courseId?: NullableIntFieldUpdateOperationsInput | number | null
    facultyId?: NullableIntFieldUpdateOperationsInput | number | null
    labId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type RoleUserListRelationFilter = {
    every?: RoleUserWhereInput
    some?: RoleUserWhereInput
    none?: RoleUserWhereInput
  }

  export type FacultyListRelationFilter = {
    every?: FacultyWhereInput
    some?: FacultyWhereInput
    none?: FacultyWhereInput
  }

  export type BatchListRelationFilter = {
    every?: BatchWhereInput
    some?: BatchWhereInput
    none?: BatchWhereInput
  }

  export type CourseListRelationFilter = {
    every?: CourseWhereInput
    some?: CourseWhereInput
    none?: CourseWhereInput
  }

  export type EnquiryCourseListRelationFilter = {
    every?: EnquiryCourseWhereInput
    some?: EnquiryCourseWhereInput
    none?: EnquiryCourseWhereInput
  }

  export type LabListRelationFilter = {
    every?: LabWhereInput
    some?: LabWhereInput
    none?: LabWhereInput
  }

  export type LabTimeSlotListRelationFilter = {
    every?: LabTimeSlotWhereInput
    some?: LabTimeSlotWhereInput
    none?: LabTimeSlotWhereInput
  }

  export type LabAllocationListRelationFilter = {
    every?: LabAllocationWhereInput
    some?: LabAllocationWhereInput
    none?: LabAllocationWhereInput
  }

  export type StudentListRelationFilter = {
    every?: StudentWhereInput
    some?: StudentWhereInput
    none?: StudentWhereInput
  }

  export type ActivityLogListRelationFilter = {
    every?: ActivityLogWhereInput
    some?: ActivityLogWhereInput
    none?: ActivityLogWhereInput
  }

  export type StudentCourseListRelationFilter = {
    every?: StudentCourseWhereInput
    some?: StudentCourseWhereInput
    none?: StudentCourseWhereInput
  }

  export type FeeStructureListRelationFilter = {
    every?: FeeStructureWhereInput
    some?: FeeStructureWhereInput
    none?: FeeStructureWhereInput
  }

  export type StudentFeeListRelationFilter = {
    every?: StudentFeeWhereInput
    some?: StudentFeeWhereInput
    none?: StudentFeeWhereInput
  }

  export type StationeryIssueListRelationFilter = {
    every?: StationeryIssueWhereInput
    some?: StationeryIssueWhereInput
    none?: StationeryIssueWhereInput
  }

  export type AttendanceRecordListRelationFilter = {
    every?: AttendanceRecordWhereInput
    some?: AttendanceRecordWhereInput
    none?: AttendanceRecordWhereInput
  }

  export type StudentTaskListRelationFilter = {
    every?: StudentTaskWhereInput
    some?: StudentTaskWhereInput
    none?: StudentTaskWhereInput
  }

  export type StudentTestListRelationFilter = {
    every?: StudentTestWhereInput
    some?: StudentTestWhereInput
    none?: StudentTestWhereInput
  }

  export type CourseCompletionListRelationFilter = {
    every?: CourseCompletionWhereInput
    some?: CourseCompletionWhereInput
    none?: CourseCompletionWhereInput
  }

  export type CertificateListRelationFilter = {
    every?: CertificateWhereInput
    some?: CertificateWhereInput
    none?: CertificateWhereInput
  }

  export type FinancialRecordListRelationFilter = {
    every?: FinancialRecordWhereInput
    some?: FinancialRecordWhereInput
    none?: FinancialRecordWhereInput
  }

  export type EnquiryListRelationFilter = {
    every?: EnquiryWhereInput
    some?: EnquiryWhereInput
    none?: EnquiryWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type CourseFeeStructureListRelationFilter = {
    every?: CourseFeeStructureWhereInput
    some?: CourseFeeStructureWhereInput
    none?: CourseFeeStructureWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type RoleUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FacultyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BatchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EnquiryCourseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LabOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LabTimeSlotOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LabAllocationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ActivityLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentCourseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FeeStructureOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentFeeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StationeryIssueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AttendanceRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentTaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentTestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseCompletionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CertificateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FinancialRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EnquiryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseFeeStructureOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientAdminCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    instituteName?: SortOrder
    slug?: SortOrder
    fullAddress?: SortOrder
    logo?: SortOrder
    certificateName?: SortOrder
    stamp?: SortOrder
    sign?: SortOrder
    contact?: SortOrder
    position?: SortOrder
    country?: SortOrder
    state?: SortOrder
    city?: SortOrder
    zipCode?: SortOrder
    createdAt?: SortOrder
    role?: SortOrder
    currentSessionToken?: SortOrder
    lastLoginAt?: SortOrder
  }

  export type ClientAdminMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    instituteName?: SortOrder
    slug?: SortOrder
    fullAddress?: SortOrder
    logo?: SortOrder
    certificateName?: SortOrder
    stamp?: SortOrder
    sign?: SortOrder
    contact?: SortOrder
    position?: SortOrder
    country?: SortOrder
    state?: SortOrder
    city?: SortOrder
    zipCode?: SortOrder
    createdAt?: SortOrder
    role?: SortOrder
    currentSessionToken?: SortOrder
    lastLoginAt?: SortOrder
  }

  export type ClientAdminMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    instituteName?: SortOrder
    slug?: SortOrder
    fullAddress?: SortOrder
    logo?: SortOrder
    certificateName?: SortOrder
    stamp?: SortOrder
    sign?: SortOrder
    contact?: SortOrder
    position?: SortOrder
    country?: SortOrder
    state?: SortOrder
    city?: SortOrder
    zipCode?: SortOrder
    createdAt?: SortOrder
    role?: SortOrder
    currentSessionToken?: SortOrder
    lastLoginAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type ClientAdminScalarRelationFilter = {
    is?: ClientAdminWhereInput
    isNot?: ClientAdminWhereInput
  }

  export type RoleUserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    country?: SortOrder
    state?: SortOrder
    city?: SortOrder
    zipCode?: SortOrder
    currentSessionToken?: SortOrder
    lastLoginAt?: SortOrder
    clientAdminId?: SortOrder
  }

  export type RoleUserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    country?: SortOrder
    state?: SortOrder
    city?: SortOrder
    zipCode?: SortOrder
    currentSessionToken?: SortOrder
    lastLoginAt?: SortOrder
    clientAdminId?: SortOrder
  }

  export type RoleUserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    country?: SortOrder
    state?: SortOrder
    city?: SortOrder
    zipCode?: SortOrder
    currentSessionToken?: SortOrder
    lastLoginAt?: SortOrder
    clientAdminId?: SortOrder
  }

  export type ActivityLogCountOrderByAggregateInput = {
    id?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    clientAdminId?: SortOrder
  }

  export type ActivityLogMaxOrderByAggregateInput = {
    id?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    clientAdminId?: SortOrder
  }

  export type ActivityLogMinOrderByAggregateInput = {
    id?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    clientAdminId?: SortOrder
  }

  export type EnumLeadStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LeadStatus | EnumLeadStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeadStatusFilter<$PrismaModel> | $Enums.LeadStatus
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type FollowUpListRelationFilter = {
    every?: FollowUpWhereInput
    some?: FollowUpWhereInput
    none?: FollowUpWhereInput
  }

  export type StudentNullableScalarRelationFilter = {
    is?: StudentWhereInput | null
    isNot?: StudentWhereInput | null
  }

  export type NotificationNullableScalarRelationFilter = {
    is?: NotificationWhereInput | null
    isNot?: NotificationWhereInput | null
  }

  export type FollowUpOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EnquiryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contact?: SortOrder
    email?: SortOrder
    course?: SortOrder
    source?: SortOrder
    leadStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isConverted?: SortOrder
    studentId?: SortOrder
    clientAdminId?: SortOrder
  }

  export type EnquiryAvgOrderByAggregateInput = {
    studentId?: SortOrder
  }

  export type EnquiryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contact?: SortOrder
    email?: SortOrder
    course?: SortOrder
    source?: SortOrder
    leadStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isConverted?: SortOrder
    studentId?: SortOrder
    clientAdminId?: SortOrder
  }

  export type EnquiryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contact?: SortOrder
    email?: SortOrder
    course?: SortOrder
    source?: SortOrder
    leadStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isConverted?: SortOrder
    studentId?: SortOrder
    clientAdminId?: SortOrder
  }

  export type EnquirySumOrderByAggregateInput = {
    studentId?: SortOrder
  }

  export type EnumLeadStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeadStatus | EnumLeadStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeadStatusWithAggregatesFilter<$PrismaModel> | $Enums.LeadStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeadStatusFilter<$PrismaModel>
    _max?: NestedEnumLeadStatusFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EnquiryScalarRelationFilter = {
    is?: EnquiryWhereInput
    isNot?: EnquiryWhereInput
  }

  export type CourseScalarRelationFilter = {
    is?: CourseWhereInput
    isNot?: CourseWhereInput
  }

  export type EnquiryCourseEnquiryIdCourseIdCompoundUniqueInput = {
    enquiryId: string
    courseId: number
  }

  export type EnquiryCourseCountOrderByAggregateInput = {
    id?: SortOrder
    enquiryId?: SortOrder
    courseId?: SortOrder
    clientAdminId?: SortOrder
  }

  export type EnquiryCourseAvgOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
  }

  export type EnquiryCourseMaxOrderByAggregateInput = {
    id?: SortOrder
    enquiryId?: SortOrder
    courseId?: SortOrder
    clientAdminId?: SortOrder
  }

  export type EnquiryCourseMinOrderByAggregateInput = {
    id?: SortOrder
    enquiryId?: SortOrder
    courseId?: SortOrder
    clientAdminId?: SortOrder
  }

  export type EnquiryCourseSumOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumFollowUpStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.FollowUpStatus | EnumFollowUpStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FollowUpStatus[] | ListEnumFollowUpStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FollowUpStatus[] | ListEnumFollowUpStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFollowUpStatusFilter<$PrismaModel> | $Enums.FollowUpStatus
  }

  export type FollowUpCountOrderByAggregateInput = {
    id?: SortOrder
    enquiryId?: SortOrder
    scheduledAt?: SortOrder
    doneAt?: SortOrder
    remark?: SortOrder
    createdAt?: SortOrder
    followUpStatus?: SortOrder
  }

  export type FollowUpMaxOrderByAggregateInput = {
    id?: SortOrder
    enquiryId?: SortOrder
    scheduledAt?: SortOrder
    doneAt?: SortOrder
    remark?: SortOrder
    createdAt?: SortOrder
    followUpStatus?: SortOrder
  }

  export type FollowUpMinOrderByAggregateInput = {
    id?: SortOrder
    enquiryId?: SortOrder
    scheduledAt?: SortOrder
    doneAt?: SortOrder
    remark?: SortOrder
    createdAt?: SortOrder
    followUpStatus?: SortOrder
  }

  export type EnumFollowUpStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FollowUpStatus | EnumFollowUpStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FollowUpStatus[] | ListEnumFollowUpStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FollowUpStatus[] | ListEnumFollowUpStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFollowUpStatusWithAggregatesFilter<$PrismaModel> | $Enums.FollowUpStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFollowUpStatusFilter<$PrismaModel>
    _max?: NestedEnumFollowUpStatusFilter<$PrismaModel>
  }

  export type FollowUpNullableScalarRelationFilter = {
    is?: FollowUpWhereInput | null
    isNot?: FollowUpWhereInput | null
  }

  export type EnquiryNullableScalarRelationFilter = {
    is?: EnquiryWhereInput | null
    isNot?: EnquiryWhereInput | null
  }

  export type StudentFeeNullableScalarRelationFilter = {
    is?: StudentFeeWhereInput | null
    isNot?: StudentFeeWhereInput | null
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    message?: SortOrder
    seen?: SortOrder
    createdAt?: SortOrder
    followUpId?: SortOrder
    enquiryId?: SortOrder
    paymentId?: SortOrder
    clientAdminId?: SortOrder
  }

  export type NotificationAvgOrderByAggregateInput = {
    paymentId?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    message?: SortOrder
    seen?: SortOrder
    createdAt?: SortOrder
    followUpId?: SortOrder
    enquiryId?: SortOrder
    paymentId?: SortOrder
    clientAdminId?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    message?: SortOrder
    seen?: SortOrder
    createdAt?: SortOrder
    followUpId?: SortOrder
    enquiryId?: SortOrder
    paymentId?: SortOrder
    clientAdminId?: SortOrder
  }

  export type NotificationSumOrderByAggregateInput = {
    paymentId?: SortOrder
  }

  export type StudentCountOrderByAggregateInput = {
    id?: SortOrder
    serialNumber?: SortOrder
    studentCode?: SortOrder
    fullName?: SortOrder
    fatherName?: SortOrder
    motherName?: SortOrder
    photoUrl?: SortOrder
    contact?: SortOrder
    parentsContact?: SortOrder
    email?: SortOrder
    residentialAddress?: SortOrder
    permenantAddress?: SortOrder
    dob?: SortOrder
    gender?: SortOrder
    religion?: SortOrder
    idProofType?: SortOrder
    idProofNumber?: SortOrder
    admissionDate?: SortOrder
    clientAdminId?: SortOrder
  }

  export type StudentAvgOrderByAggregateInput = {
    id?: SortOrder
    serialNumber?: SortOrder
  }

  export type StudentMaxOrderByAggregateInput = {
    id?: SortOrder
    serialNumber?: SortOrder
    studentCode?: SortOrder
    fullName?: SortOrder
    fatherName?: SortOrder
    motherName?: SortOrder
    photoUrl?: SortOrder
    contact?: SortOrder
    parentsContact?: SortOrder
    email?: SortOrder
    residentialAddress?: SortOrder
    permenantAddress?: SortOrder
    dob?: SortOrder
    gender?: SortOrder
    religion?: SortOrder
    idProofType?: SortOrder
    idProofNumber?: SortOrder
    admissionDate?: SortOrder
    clientAdminId?: SortOrder
  }

  export type StudentMinOrderByAggregateInput = {
    id?: SortOrder
    serialNumber?: SortOrder
    studentCode?: SortOrder
    fullName?: SortOrder
    fatherName?: SortOrder
    motherName?: SortOrder
    photoUrl?: SortOrder
    contact?: SortOrder
    parentsContact?: SortOrder
    email?: SortOrder
    residentialAddress?: SortOrder
    permenantAddress?: SortOrder
    dob?: SortOrder
    gender?: SortOrder
    religion?: SortOrder
    idProofType?: SortOrder
    idProofNumber?: SortOrder
    admissionDate?: SortOrder
    clientAdminId?: SortOrder
  }

  export type StudentSumOrderByAggregateInput = {
    id?: SortOrder
    serialNumber?: SortOrder
  }

  export type CourseFeeStructureNullableScalarRelationFilter = {
    is?: CourseFeeStructureWhereInput | null
    isNot?: CourseFeeStructureWhereInput | null
  }

  export type BatchCourseListRelationFilter = {
    every?: BatchCourseWhereInput
    some?: BatchCourseWhereInput
    none?: BatchCourseWhereInput
  }

  export type BatchCourseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    durationWeeks?: SortOrder
    description?: SortOrder
    clientAdminId?: SortOrder
  }

  export type CourseAvgOrderByAggregateInput = {
    id?: SortOrder
    durationWeeks?: SortOrder
  }

  export type CourseMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    durationWeeks?: SortOrder
    description?: SortOrder
    clientAdminId?: SortOrder
  }

  export type CourseMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    durationWeeks?: SortOrder
    description?: SortOrder
    clientAdminId?: SortOrder
  }

  export type CourseSumOrderByAggregateInput = {
    id?: SortOrder
    durationWeeks?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type InstallmentDetailListRelationFilter = {
    every?: InstallmentDetailWhereInput
    some?: InstallmentDetailWhereInput
    none?: InstallmentDetailWhereInput
  }

  export type InstallmentDetailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseFeeStructureCountOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    totalAmount?: SortOrder
    paymentType?: SortOrder
    clientAdminId?: SortOrder
  }

  export type CourseFeeStructureAvgOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    totalAmount?: SortOrder
  }

  export type CourseFeeStructureMaxOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    totalAmount?: SortOrder
    clientAdminId?: SortOrder
  }

  export type CourseFeeStructureMinOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    totalAmount?: SortOrder
    clientAdminId?: SortOrder
  }

  export type CourseFeeStructureSumOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    totalAmount?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type FacultyNullableScalarRelationFilter = {
    is?: FacultyWhereInput | null
    isNot?: FacultyWhereInput | null
  }

  export type LabTimeSlotScalarRelationFilter = {
    is?: LabTimeSlotWhereInput
    isNot?: LabTimeSlotWhereInput
  }

  export type BatchLabTimeSlotIdClientAdminIdCompoundUniqueInput = {
    labTimeSlotId: number
    clientAdminId: string
  }

  export type BatchCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    facultyId?: SortOrder
    labTimeSlotId?: SortOrder
    clientAdminId?: SortOrder
  }

  export type BatchAvgOrderByAggregateInput = {
    id?: SortOrder
    facultyId?: SortOrder
    labTimeSlotId?: SortOrder
  }

  export type BatchMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    facultyId?: SortOrder
    labTimeSlotId?: SortOrder
    clientAdminId?: SortOrder
  }

  export type BatchMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    facultyId?: SortOrder
    labTimeSlotId?: SortOrder
    clientAdminId?: SortOrder
  }

  export type BatchSumOrderByAggregateInput = {
    id?: SortOrder
    facultyId?: SortOrder
    labTimeSlotId?: SortOrder
  }

  export type BatchScalarRelationFilter = {
    is?: BatchWhereInput
    isNot?: BatchWhereInput
  }

  export type BatchCourseBatchIdCourseIdCompoundUniqueInput = {
    batchId: number
    courseId: number
  }

  export type BatchCourseCountOrderByAggregateInput = {
    id?: SortOrder
    batchId?: SortOrder
    courseId?: SortOrder
    pcsReserved?: SortOrder
  }

  export type BatchCourseAvgOrderByAggregateInput = {
    id?: SortOrder
    batchId?: SortOrder
    courseId?: SortOrder
    pcsReserved?: SortOrder
  }

  export type BatchCourseMaxOrderByAggregateInput = {
    id?: SortOrder
    batchId?: SortOrder
    courseId?: SortOrder
    pcsReserved?: SortOrder
  }

  export type BatchCourseMinOrderByAggregateInput = {
    id?: SortOrder
    batchId?: SortOrder
    courseId?: SortOrder
    pcsReserved?: SortOrder
  }

  export type BatchCourseSumOrderByAggregateInput = {
    id?: SortOrder
    batchId?: SortOrder
    courseId?: SortOrder
    pcsReserved?: SortOrder
  }

  export type FacultyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    contact?: SortOrder
    joiningDate?: SortOrder
    specialization?: SortOrder
    role?: SortOrder
    country?: SortOrder
    state?: SortOrder
    city?: SortOrder
    zipCode?: SortOrder
    currentSessionToken?: SortOrder
    lastLoginAt?: SortOrder
    clientAdminId?: SortOrder
  }

  export type FacultyAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FacultyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    contact?: SortOrder
    joiningDate?: SortOrder
    specialization?: SortOrder
    role?: SortOrder
    country?: SortOrder
    state?: SortOrder
    city?: SortOrder
    zipCode?: SortOrder
    currentSessionToken?: SortOrder
    lastLoginAt?: SortOrder
    clientAdminId?: SortOrder
  }

  export type FacultyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    contact?: SortOrder
    joiningDate?: SortOrder
    specialization?: SortOrder
    role?: SortOrder
    country?: SortOrder
    state?: SortOrder
    city?: SortOrder
    zipCode?: SortOrder
    currentSessionToken?: SortOrder
    lastLoginAt?: SortOrder
    clientAdminId?: SortOrder
  }

  export type FacultySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type LabCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    totalPCs?: SortOrder
    isActive?: SortOrder
    clientAdminId?: SortOrder
  }

  export type LabAvgOrderByAggregateInput = {
    id?: SortOrder
    totalPCs?: SortOrder
  }

  export type LabMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    totalPCs?: SortOrder
    isActive?: SortOrder
    clientAdminId?: SortOrder
  }

  export type LabMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    totalPCs?: SortOrder
    isActive?: SortOrder
    clientAdminId?: SortOrder
  }

  export type LabSumOrderByAggregateInput = {
    id?: SortOrder
    totalPCs?: SortOrder
  }

  export type LabScalarRelationFilter = {
    is?: LabWhereInput
    isNot?: LabWhereInput
  }

  export type LabTimeSlotCountOrderByAggregateInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    day?: SortOrder
    labId?: SortOrder
    availablePCs?: SortOrder
    clientAdminId?: SortOrder
  }

  export type LabTimeSlotAvgOrderByAggregateInput = {
    id?: SortOrder
    labId?: SortOrder
    availablePCs?: SortOrder
  }

  export type LabTimeSlotMaxOrderByAggregateInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    day?: SortOrder
    labId?: SortOrder
    availablePCs?: SortOrder
    clientAdminId?: SortOrder
  }

  export type LabTimeSlotMinOrderByAggregateInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    day?: SortOrder
    labId?: SortOrder
    availablePCs?: SortOrder
    clientAdminId?: SortOrder
  }

  export type LabTimeSlotSumOrderByAggregateInput = {
    id?: SortOrder
    labId?: SortOrder
    availablePCs?: SortOrder
  }

  export type EnumPaymentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentType | EnumPaymentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentType[] | ListEnumPaymentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentType[] | ListEnumPaymentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentTypeFilter<$PrismaModel> | $Enums.PaymentType
  }

  export type PaymentStructureTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    installmentCount?: SortOrder
  }

  export type PaymentStructureTypeAvgOrderByAggregateInput = {
    id?: SortOrder
    installmentCount?: SortOrder
  }

  export type PaymentStructureTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    installmentCount?: SortOrder
  }

  export type PaymentStructureTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    installmentCount?: SortOrder
  }

  export type PaymentStructureTypeSumOrderByAggregateInput = {
    id?: SortOrder
    installmentCount?: SortOrder
  }

  export type EnumPaymentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentType | EnumPaymentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentType[] | ListEnumPaymentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentType[] | ListEnumPaymentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentTypeWithAggregatesFilter<$PrismaModel> | $Enums.PaymentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentTypeFilter<$PrismaModel>
    _max?: NestedEnumPaymentTypeFilter<$PrismaModel>
  }

  export type CourseFeeStructureScalarRelationFilter = {
    is?: CourseFeeStructureWhereInput
    isNot?: CourseFeeStructureWhereInput
  }

  export type InstallmentDetailCountOrderByAggregateInput = {
    id?: SortOrder
    CourseFeeStructureId?: SortOrder
    number?: SortOrder
    amount?: SortOrder
  }

  export type InstallmentDetailAvgOrderByAggregateInput = {
    id?: SortOrder
    CourseFeeStructureId?: SortOrder
    number?: SortOrder
    amount?: SortOrder
  }

  export type InstallmentDetailMaxOrderByAggregateInput = {
    id?: SortOrder
    CourseFeeStructureId?: SortOrder
    number?: SortOrder
    amount?: SortOrder
  }

  export type InstallmentDetailMinOrderByAggregateInput = {
    id?: SortOrder
    CourseFeeStructureId?: SortOrder
    number?: SortOrder
    amount?: SortOrder
  }

  export type InstallmentDetailSumOrderByAggregateInput = {
    id?: SortOrder
    CourseFeeStructureId?: SortOrder
    number?: SortOrder
    amount?: SortOrder
  }

  export type StudentScalarRelationFilter = {
    is?: StudentWhereInput
    isNot?: StudentWhereInput
  }

  export type LabAllocationLabTimeSlotIdPcNumberCompoundUniqueInput = {
    labTimeSlotId: number
    pcNumber: number
  }

  export type LabAllocationLabTimeSlotIdStudentIdCompoundUniqueInput = {
    labTimeSlotId: number
    studentId: number
  }

  export type LabAllocationCountOrderByAggregateInput = {
    id?: SortOrder
    labTimeSlotId?: SortOrder
    studentId?: SortOrder
    pcNumber?: SortOrder
    assignedAt?: SortOrder
    clientAdminId?: SortOrder
  }

  export type LabAllocationAvgOrderByAggregateInput = {
    id?: SortOrder
    labTimeSlotId?: SortOrder
    studentId?: SortOrder
    pcNumber?: SortOrder
  }

  export type LabAllocationMaxOrderByAggregateInput = {
    id?: SortOrder
    labTimeSlotId?: SortOrder
    studentId?: SortOrder
    pcNumber?: SortOrder
    assignedAt?: SortOrder
    clientAdminId?: SortOrder
  }

  export type LabAllocationMinOrderByAggregateInput = {
    id?: SortOrder
    labTimeSlotId?: SortOrder
    studentId?: SortOrder
    pcNumber?: SortOrder
    assignedAt?: SortOrder
    clientAdminId?: SortOrder
  }

  export type LabAllocationSumOrderByAggregateInput = {
    id?: SortOrder
    labTimeSlotId?: SortOrder
    studentId?: SortOrder
    pcNumber?: SortOrder
  }

  export type BatchNullableScalarRelationFilter = {
    is?: BatchWhereInput | null
    isNot?: BatchWhereInput | null
  }

  export type CertificateNullableScalarRelationFilter = {
    is?: CertificateWhereInput | null
    isNot?: CertificateWhereInput | null
  }

  export type StudentCourseCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    courseId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    studentCode?: SortOrder
    batchId?: SortOrder
    internalNotes?: SortOrder
    status?: SortOrder
    clientAdminId?: SortOrder
  }

  export type StudentCourseAvgOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    courseId?: SortOrder
    batchId?: SortOrder
  }

  export type StudentCourseMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    courseId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    studentCode?: SortOrder
    batchId?: SortOrder
    internalNotes?: SortOrder
    status?: SortOrder
    clientAdminId?: SortOrder
  }

  export type StudentCourseMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    courseId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    studentCode?: SortOrder
    batchId?: SortOrder
    internalNotes?: SortOrder
    status?: SortOrder
    clientAdminId?: SortOrder
  }

  export type StudentCourseSumOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    courseId?: SortOrder
    batchId?: SortOrder
  }

  export type InstallmentDetailNullableScalarRelationFilter = {
    is?: InstallmentDetailWhereInput | null
    isNot?: InstallmentDetailWhereInput | null
  }

  export type FeeStructureStudentIdCourseIdCompoundUniqueInput = {
    studentId: number
    courseId: number
  }

  export type FeeStructureCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    courseId?: SortOrder
    totalAmount?: SortOrder
    paymentType?: SortOrder
    installmentCount?: SortOrder
    installmentTypeId?: SortOrder
    clientAdminId?: SortOrder
  }

  export type FeeStructureAvgOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    courseId?: SortOrder
    totalAmount?: SortOrder
    installmentCount?: SortOrder
    installmentTypeId?: SortOrder
  }

  export type FeeStructureMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    courseId?: SortOrder
    totalAmount?: SortOrder
    paymentType?: SortOrder
    installmentCount?: SortOrder
    installmentTypeId?: SortOrder
    clientAdminId?: SortOrder
  }

  export type FeeStructureMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    courseId?: SortOrder
    totalAmount?: SortOrder
    paymentType?: SortOrder
    installmentCount?: SortOrder
    installmentTypeId?: SortOrder
    clientAdminId?: SortOrder
  }

  export type FeeStructureSumOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    courseId?: SortOrder
    totalAmount?: SortOrder
    installmentCount?: SortOrder
    installmentTypeId?: SortOrder
  }

  export type EnumPaymentModeFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMode | EnumPaymentModeFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMode[] | ListEnumPaymentModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMode[] | ListEnumPaymentModeFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentModeFilter<$PrismaModel> | $Enums.PaymentMode
  }

  export type StudentFeeScalarRelationFilter = {
    is?: StudentFeeWhereInput
    isNot?: StudentFeeWhereInput
  }

  export type StudentFeeLogCountOrderByAggregateInput = {
    id?: SortOrder
    studentFeeId?: SortOrder
    amountPaid?: SortOrder
    paymentDate?: SortOrder
    paymentMode?: SortOrder
    receiptNo?: SortOrder
  }

  export type StudentFeeLogAvgOrderByAggregateInput = {
    id?: SortOrder
    studentFeeId?: SortOrder
    amountPaid?: SortOrder
  }

  export type StudentFeeLogMaxOrderByAggregateInput = {
    id?: SortOrder
    studentFeeId?: SortOrder
    amountPaid?: SortOrder
    paymentDate?: SortOrder
    paymentMode?: SortOrder
    receiptNo?: SortOrder
  }

  export type StudentFeeLogMinOrderByAggregateInput = {
    id?: SortOrder
    studentFeeId?: SortOrder
    amountPaid?: SortOrder
    paymentDate?: SortOrder
    paymentMode?: SortOrder
    receiptNo?: SortOrder
  }

  export type StudentFeeLogSumOrderByAggregateInput = {
    id?: SortOrder
    studentFeeId?: SortOrder
    amountPaid?: SortOrder
  }

  export type EnumPaymentModeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMode | EnumPaymentModeFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMode[] | ListEnumPaymentModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMode[] | ListEnumPaymentModeFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentModeWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMode
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentModeFilter<$PrismaModel>
    _max?: NestedEnumPaymentModeFilter<$PrismaModel>
  }

  export type EnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type StudentFeeLogListRelationFilter = {
    every?: StudentFeeLogWhereInput
    some?: StudentFeeLogWhereInput
    none?: StudentFeeLogWhereInput
  }

  export type FeeStructureNullableScalarRelationFilter = {
    is?: FeeStructureWhereInput | null
    isNot?: FeeStructureWhereInput | null
  }

  export type StudentFeeLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentFeeCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    courseId?: SortOrder
    dueDate?: SortOrder
    amountDue?: SortOrder
    amountPaid?: SortOrder
    paymentDate?: SortOrder
    paymentMode?: SortOrder
    receiptNo?: SortOrder
    paymentStatus?: SortOrder
    clientAdminId?: SortOrder
  }

  export type StudentFeeAvgOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    courseId?: SortOrder
    amountDue?: SortOrder
    amountPaid?: SortOrder
  }

  export type StudentFeeMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    courseId?: SortOrder
    dueDate?: SortOrder
    amountDue?: SortOrder
    amountPaid?: SortOrder
    paymentDate?: SortOrder
    paymentMode?: SortOrder
    receiptNo?: SortOrder
    paymentStatus?: SortOrder
    clientAdminId?: SortOrder
  }

  export type StudentFeeMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    courseId?: SortOrder
    dueDate?: SortOrder
    amountDue?: SortOrder
    amountPaid?: SortOrder
    paymentDate?: SortOrder
    paymentMode?: SortOrder
    receiptNo?: SortOrder
    paymentStatus?: SortOrder
    clientAdminId?: SortOrder
  }

  export type StudentFeeSumOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    courseId?: SortOrder
    amountDue?: SortOrder
    amountPaid?: SortOrder
  }

  export type EnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type StationeryItemCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    quantityAvailable?: SortOrder
  }

  export type StationeryItemAvgOrderByAggregateInput = {
    id?: SortOrder
    quantityAvailable?: SortOrder
  }

  export type StationeryItemMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    quantityAvailable?: SortOrder
  }

  export type StationeryItemMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    quantityAvailable?: SortOrder
  }

  export type StationeryItemSumOrderByAggregateInput = {
    id?: SortOrder
    quantityAvailable?: SortOrder
  }

  export type StationeryItemScalarRelationFilter = {
    is?: StationeryItemWhereInput
    isNot?: StationeryItemWhereInput
  }

  export type StationeryIssueCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    courseId?: SortOrder
    itemId?: SortOrder
    issueDate?: SortOrder
    quantity?: SortOrder
    remarks?: SortOrder
    clientAdminId?: SortOrder
  }

  export type StationeryIssueAvgOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    courseId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
  }

  export type StationeryIssueMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    courseId?: SortOrder
    itemId?: SortOrder
    issueDate?: SortOrder
    quantity?: SortOrder
    remarks?: SortOrder
    clientAdminId?: SortOrder
  }

  export type StationeryIssueMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    courseId?: SortOrder
    itemId?: SortOrder
    issueDate?: SortOrder
    quantity?: SortOrder
    remarks?: SortOrder
    clientAdminId?: SortOrder
  }

  export type StationeryIssueSumOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    courseId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
  }

  export type FacultyScalarRelationFilter = {
    is?: FacultyWhereInput
    isNot?: FacultyWhereInput
  }

  export type AttendanceRecordCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    courseId?: SortOrder
    date?: SortOrder
    present?: SortOrder
    facultyId?: SortOrder
    batchId?: SortOrder
    clientAdminId?: SortOrder
  }

  export type AttendanceRecordAvgOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    courseId?: SortOrder
    facultyId?: SortOrder
    batchId?: SortOrder
  }

  export type AttendanceRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    courseId?: SortOrder
    date?: SortOrder
    present?: SortOrder
    facultyId?: SortOrder
    batchId?: SortOrder
    clientAdminId?: SortOrder
  }

  export type AttendanceRecordMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    courseId?: SortOrder
    date?: SortOrder
    present?: SortOrder
    facultyId?: SortOrder
    batchId?: SortOrder
    clientAdminId?: SortOrder
  }

  export type AttendanceRecordSumOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    courseId?: SortOrder
    facultyId?: SortOrder
    batchId?: SortOrder
  }

  export type StudentTaskCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    courseId?: SortOrder
    assignedDate?: SortOrder
    dueDate?: SortOrder
    description?: SortOrder
    status?: SortOrder
    facultyRemarks?: SortOrder
    grade?: SortOrder
    facultyId?: SortOrder
    clientAdminId?: SortOrder
  }

  export type StudentTaskAvgOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    courseId?: SortOrder
    facultyId?: SortOrder
  }

  export type StudentTaskMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    courseId?: SortOrder
    assignedDate?: SortOrder
    dueDate?: SortOrder
    description?: SortOrder
    status?: SortOrder
    facultyRemarks?: SortOrder
    grade?: SortOrder
    facultyId?: SortOrder
    clientAdminId?: SortOrder
  }

  export type StudentTaskMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    courseId?: SortOrder
    assignedDate?: SortOrder
    dueDate?: SortOrder
    description?: SortOrder
    status?: SortOrder
    facultyRemarks?: SortOrder
    grade?: SortOrder
    facultyId?: SortOrder
    clientAdminId?: SortOrder
  }

  export type StudentTaskSumOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    courseId?: SortOrder
    facultyId?: SortOrder
  }

  export type StudentTestCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    courseId?: SortOrder
    testName?: SortOrder
    testDate?: SortOrder
    totalMarks?: SortOrder
    marksObtained?: SortOrder
    grade?: SortOrder
    clientAdminId?: SortOrder
  }

  export type StudentTestAvgOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    courseId?: SortOrder
    totalMarks?: SortOrder
    marksObtained?: SortOrder
  }

  export type StudentTestMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    courseId?: SortOrder
    testName?: SortOrder
    testDate?: SortOrder
    totalMarks?: SortOrder
    marksObtained?: SortOrder
    grade?: SortOrder
    clientAdminId?: SortOrder
  }

  export type StudentTestMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    courseId?: SortOrder
    testName?: SortOrder
    testDate?: SortOrder
    totalMarks?: SortOrder
    marksObtained?: SortOrder
    grade?: SortOrder
    clientAdminId?: SortOrder
  }

  export type StudentTestSumOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    courseId?: SortOrder
    totalMarks?: SortOrder
    marksObtained?: SortOrder
  }

  export type StudentCourseScalarRelationFilter = {
    is?: StudentCourseWhereInput
    isNot?: StudentCourseWhereInput
  }

  export type CourseCompletionCountOrderByAggregateInput = {
    id?: SortOrder
    studentCourseId?: SortOrder
    studentId?: SortOrder
    completionDate?: SortOrder
    feedback?: SortOrder
    remarks?: SortOrder
    clientAdminId?: SortOrder
  }

  export type CourseCompletionAvgOrderByAggregateInput = {
    id?: SortOrder
    studentCourseId?: SortOrder
    studentId?: SortOrder
  }

  export type CourseCompletionMaxOrderByAggregateInput = {
    id?: SortOrder
    studentCourseId?: SortOrder
    studentId?: SortOrder
    completionDate?: SortOrder
    feedback?: SortOrder
    remarks?: SortOrder
    clientAdminId?: SortOrder
  }

  export type CourseCompletionMinOrderByAggregateInput = {
    id?: SortOrder
    studentCourseId?: SortOrder
    studentId?: SortOrder
    completionDate?: SortOrder
    feedback?: SortOrder
    remarks?: SortOrder
    clientAdminId?: SortOrder
  }

  export type CourseCompletionSumOrderByAggregateInput = {
    id?: SortOrder
    studentCourseId?: SortOrder
    studentId?: SortOrder
  }

  export type CertificateCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    courseId?: SortOrder
    studentCourseId?: SortOrder
    issueDate?: SortOrder
    certificateUrl?: SortOrder
    clientAdminId?: SortOrder
  }

  export type CertificateAvgOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    courseId?: SortOrder
    studentCourseId?: SortOrder
  }

  export type CertificateMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    courseId?: SortOrder
    studentCourseId?: SortOrder
    issueDate?: SortOrder
    certificateUrl?: SortOrder
    clientAdminId?: SortOrder
  }

  export type CertificateMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    courseId?: SortOrder
    studentCourseId?: SortOrder
    issueDate?: SortOrder
    certificateUrl?: SortOrder
    clientAdminId?: SortOrder
  }

  export type CertificateSumOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    courseId?: SortOrder
    studentCourseId?: SortOrder
  }

  export type EnumRecordTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RecordType | EnumRecordTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RecordType[] | ListEnumRecordTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RecordType[] | ListEnumRecordTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRecordTypeFilter<$PrismaModel> | $Enums.RecordType
  }

  export type EnumPaymentModeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMode | EnumPaymentModeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentMode[] | ListEnumPaymentModeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentMode[] | ListEnumPaymentModeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentModeNullableFilter<$PrismaModel> | $Enums.PaymentMode | null
  }

  export type CourseNullableScalarRelationFilter = {
    is?: CourseWhereInput | null
    isNot?: CourseWhereInput | null
  }

  export type LabNullableScalarRelationFilter = {
    is?: LabWhereInput | null
    isNot?: LabWhereInput | null
  }

  export type FinancialRecordCountOrderByAggregateInput = {
    id?: SortOrder
    clientAdminId?: SortOrder
    recordType?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    date?: SortOrder
    paymentMode?: SortOrder
    studentId?: SortOrder
    courseId?: SortOrder
    facultyId?: SortOrder
    labId?: SortOrder
  }

  export type FinancialRecordAvgOrderByAggregateInput = {
    amount?: SortOrder
    studentId?: SortOrder
    courseId?: SortOrder
    facultyId?: SortOrder
    labId?: SortOrder
  }

  export type FinancialRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    clientAdminId?: SortOrder
    recordType?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    date?: SortOrder
    paymentMode?: SortOrder
    studentId?: SortOrder
    courseId?: SortOrder
    facultyId?: SortOrder
    labId?: SortOrder
  }

  export type FinancialRecordMinOrderByAggregateInput = {
    id?: SortOrder
    clientAdminId?: SortOrder
    recordType?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    date?: SortOrder
    paymentMode?: SortOrder
    studentId?: SortOrder
    courseId?: SortOrder
    facultyId?: SortOrder
    labId?: SortOrder
  }

  export type FinancialRecordSumOrderByAggregateInput = {
    amount?: SortOrder
    studentId?: SortOrder
    courseId?: SortOrder
    facultyId?: SortOrder
    labId?: SortOrder
  }

  export type EnumRecordTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RecordType | EnumRecordTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RecordType[] | ListEnumRecordTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RecordType[] | ListEnumRecordTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRecordTypeWithAggregatesFilter<$PrismaModel> | $Enums.RecordType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRecordTypeFilter<$PrismaModel>
    _max?: NestedEnumRecordTypeFilter<$PrismaModel>
  }

  export type EnumPaymentModeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMode | EnumPaymentModeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentMode[] | ListEnumPaymentModeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentMode[] | ListEnumPaymentModeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentModeNullableWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMode | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPaymentModeNullableFilter<$PrismaModel>
    _max?: NestedEnumPaymentModeNullableFilter<$PrismaModel>
  }

  export type RoleUserCreateNestedManyWithoutClientAdminInput = {
    create?: XOR<RoleUserCreateWithoutClientAdminInput, RoleUserUncheckedCreateWithoutClientAdminInput> | RoleUserCreateWithoutClientAdminInput[] | RoleUserUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: RoleUserCreateOrConnectWithoutClientAdminInput | RoleUserCreateOrConnectWithoutClientAdminInput[]
    createMany?: RoleUserCreateManyClientAdminInputEnvelope
    connect?: RoleUserWhereUniqueInput | RoleUserWhereUniqueInput[]
  }

  export type FacultyCreateNestedManyWithoutClientAdminInput = {
    create?: XOR<FacultyCreateWithoutClientAdminInput, FacultyUncheckedCreateWithoutClientAdminInput> | FacultyCreateWithoutClientAdminInput[] | FacultyUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: FacultyCreateOrConnectWithoutClientAdminInput | FacultyCreateOrConnectWithoutClientAdminInput[]
    createMany?: FacultyCreateManyClientAdminInputEnvelope
    connect?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[]
  }

  export type BatchCreateNestedManyWithoutClientAdminInput = {
    create?: XOR<BatchCreateWithoutClientAdminInput, BatchUncheckedCreateWithoutClientAdminInput> | BatchCreateWithoutClientAdminInput[] | BatchUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutClientAdminInput | BatchCreateOrConnectWithoutClientAdminInput[]
    createMany?: BatchCreateManyClientAdminInputEnvelope
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
  }

  export type CourseCreateNestedManyWithoutClientAdminInput = {
    create?: XOR<CourseCreateWithoutClientAdminInput, CourseUncheckedCreateWithoutClientAdminInput> | CourseCreateWithoutClientAdminInput[] | CourseUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutClientAdminInput | CourseCreateOrConnectWithoutClientAdminInput[]
    createMany?: CourseCreateManyClientAdminInputEnvelope
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
  }

  export type EnquiryCourseCreateNestedManyWithoutClientAdminInput = {
    create?: XOR<EnquiryCourseCreateWithoutClientAdminInput, EnquiryCourseUncheckedCreateWithoutClientAdminInput> | EnquiryCourseCreateWithoutClientAdminInput[] | EnquiryCourseUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: EnquiryCourseCreateOrConnectWithoutClientAdminInput | EnquiryCourseCreateOrConnectWithoutClientAdminInput[]
    createMany?: EnquiryCourseCreateManyClientAdminInputEnvelope
    connect?: EnquiryCourseWhereUniqueInput | EnquiryCourseWhereUniqueInput[]
  }

  export type LabCreateNestedManyWithoutClientAdminInput = {
    create?: XOR<LabCreateWithoutClientAdminInput, LabUncheckedCreateWithoutClientAdminInput> | LabCreateWithoutClientAdminInput[] | LabUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: LabCreateOrConnectWithoutClientAdminInput | LabCreateOrConnectWithoutClientAdminInput[]
    createMany?: LabCreateManyClientAdminInputEnvelope
    connect?: LabWhereUniqueInput | LabWhereUniqueInput[]
  }

  export type LabTimeSlotCreateNestedManyWithoutClientAdminInput = {
    create?: XOR<LabTimeSlotCreateWithoutClientAdminInput, LabTimeSlotUncheckedCreateWithoutClientAdminInput> | LabTimeSlotCreateWithoutClientAdminInput[] | LabTimeSlotUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: LabTimeSlotCreateOrConnectWithoutClientAdminInput | LabTimeSlotCreateOrConnectWithoutClientAdminInput[]
    createMany?: LabTimeSlotCreateManyClientAdminInputEnvelope
    connect?: LabTimeSlotWhereUniqueInput | LabTimeSlotWhereUniqueInput[]
  }

  export type LabAllocationCreateNestedManyWithoutClientAdminInput = {
    create?: XOR<LabAllocationCreateWithoutClientAdminInput, LabAllocationUncheckedCreateWithoutClientAdminInput> | LabAllocationCreateWithoutClientAdminInput[] | LabAllocationUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: LabAllocationCreateOrConnectWithoutClientAdminInput | LabAllocationCreateOrConnectWithoutClientAdminInput[]
    createMany?: LabAllocationCreateManyClientAdminInputEnvelope
    connect?: LabAllocationWhereUniqueInput | LabAllocationWhereUniqueInput[]
  }

  export type StudentCreateNestedManyWithoutClientAdminInput = {
    create?: XOR<StudentCreateWithoutClientAdminInput, StudentUncheckedCreateWithoutClientAdminInput> | StudentCreateWithoutClientAdminInput[] | StudentUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutClientAdminInput | StudentCreateOrConnectWithoutClientAdminInput[]
    createMany?: StudentCreateManyClientAdminInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type ActivityLogCreateNestedManyWithoutClientAdminInput = {
    create?: XOR<ActivityLogCreateWithoutClientAdminInput, ActivityLogUncheckedCreateWithoutClientAdminInput> | ActivityLogCreateWithoutClientAdminInput[] | ActivityLogUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutClientAdminInput | ActivityLogCreateOrConnectWithoutClientAdminInput[]
    createMany?: ActivityLogCreateManyClientAdminInputEnvelope
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
  }

  export type StudentCourseCreateNestedManyWithoutClientAdminInput = {
    create?: XOR<StudentCourseCreateWithoutClientAdminInput, StudentCourseUncheckedCreateWithoutClientAdminInput> | StudentCourseCreateWithoutClientAdminInput[] | StudentCourseUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: StudentCourseCreateOrConnectWithoutClientAdminInput | StudentCourseCreateOrConnectWithoutClientAdminInput[]
    createMany?: StudentCourseCreateManyClientAdminInputEnvelope
    connect?: StudentCourseWhereUniqueInput | StudentCourseWhereUniqueInput[]
  }

  export type FeeStructureCreateNestedManyWithoutClientAdminInput = {
    create?: XOR<FeeStructureCreateWithoutClientAdminInput, FeeStructureUncheckedCreateWithoutClientAdminInput> | FeeStructureCreateWithoutClientAdminInput[] | FeeStructureUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: FeeStructureCreateOrConnectWithoutClientAdminInput | FeeStructureCreateOrConnectWithoutClientAdminInput[]
    createMany?: FeeStructureCreateManyClientAdminInputEnvelope
    connect?: FeeStructureWhereUniqueInput | FeeStructureWhereUniqueInput[]
  }

  export type StudentFeeCreateNestedManyWithoutClientAdminInput = {
    create?: XOR<StudentFeeCreateWithoutClientAdminInput, StudentFeeUncheckedCreateWithoutClientAdminInput> | StudentFeeCreateWithoutClientAdminInput[] | StudentFeeUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: StudentFeeCreateOrConnectWithoutClientAdminInput | StudentFeeCreateOrConnectWithoutClientAdminInput[]
    createMany?: StudentFeeCreateManyClientAdminInputEnvelope
    connect?: StudentFeeWhereUniqueInput | StudentFeeWhereUniqueInput[]
  }

  export type StationeryIssueCreateNestedManyWithoutClientAdminInput = {
    create?: XOR<StationeryIssueCreateWithoutClientAdminInput, StationeryIssueUncheckedCreateWithoutClientAdminInput> | StationeryIssueCreateWithoutClientAdminInput[] | StationeryIssueUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: StationeryIssueCreateOrConnectWithoutClientAdminInput | StationeryIssueCreateOrConnectWithoutClientAdminInput[]
    createMany?: StationeryIssueCreateManyClientAdminInputEnvelope
    connect?: StationeryIssueWhereUniqueInput | StationeryIssueWhereUniqueInput[]
  }

  export type AttendanceRecordCreateNestedManyWithoutClientAdminInput = {
    create?: XOR<AttendanceRecordCreateWithoutClientAdminInput, AttendanceRecordUncheckedCreateWithoutClientAdminInput> | AttendanceRecordCreateWithoutClientAdminInput[] | AttendanceRecordUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: AttendanceRecordCreateOrConnectWithoutClientAdminInput | AttendanceRecordCreateOrConnectWithoutClientAdminInput[]
    createMany?: AttendanceRecordCreateManyClientAdminInputEnvelope
    connect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
  }

  export type StudentTaskCreateNestedManyWithoutClientAdminInput = {
    create?: XOR<StudentTaskCreateWithoutClientAdminInput, StudentTaskUncheckedCreateWithoutClientAdminInput> | StudentTaskCreateWithoutClientAdminInput[] | StudentTaskUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: StudentTaskCreateOrConnectWithoutClientAdminInput | StudentTaskCreateOrConnectWithoutClientAdminInput[]
    createMany?: StudentTaskCreateManyClientAdminInputEnvelope
    connect?: StudentTaskWhereUniqueInput | StudentTaskWhereUniqueInput[]
  }

  export type StudentTestCreateNestedManyWithoutClientAdminInput = {
    create?: XOR<StudentTestCreateWithoutClientAdminInput, StudentTestUncheckedCreateWithoutClientAdminInput> | StudentTestCreateWithoutClientAdminInput[] | StudentTestUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: StudentTestCreateOrConnectWithoutClientAdminInput | StudentTestCreateOrConnectWithoutClientAdminInput[]
    createMany?: StudentTestCreateManyClientAdminInputEnvelope
    connect?: StudentTestWhereUniqueInput | StudentTestWhereUniqueInput[]
  }

  export type CourseCompletionCreateNestedManyWithoutClientAdminInput = {
    create?: XOR<CourseCompletionCreateWithoutClientAdminInput, CourseCompletionUncheckedCreateWithoutClientAdminInput> | CourseCompletionCreateWithoutClientAdminInput[] | CourseCompletionUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: CourseCompletionCreateOrConnectWithoutClientAdminInput | CourseCompletionCreateOrConnectWithoutClientAdminInput[]
    createMany?: CourseCompletionCreateManyClientAdminInputEnvelope
    connect?: CourseCompletionWhereUniqueInput | CourseCompletionWhereUniqueInput[]
  }

  export type CertificateCreateNestedManyWithoutClientAdminInput = {
    create?: XOR<CertificateCreateWithoutClientAdminInput, CertificateUncheckedCreateWithoutClientAdminInput> | CertificateCreateWithoutClientAdminInput[] | CertificateUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutClientAdminInput | CertificateCreateOrConnectWithoutClientAdminInput[]
    createMany?: CertificateCreateManyClientAdminInputEnvelope
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
  }

  export type FinancialRecordCreateNestedManyWithoutClientAdminInput = {
    create?: XOR<FinancialRecordCreateWithoutClientAdminInput, FinancialRecordUncheckedCreateWithoutClientAdminInput> | FinancialRecordCreateWithoutClientAdminInput[] | FinancialRecordUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: FinancialRecordCreateOrConnectWithoutClientAdminInput | FinancialRecordCreateOrConnectWithoutClientAdminInput[]
    createMany?: FinancialRecordCreateManyClientAdminInputEnvelope
    connect?: FinancialRecordWhereUniqueInput | FinancialRecordWhereUniqueInput[]
  }

  export type EnquiryCreateNestedManyWithoutClientAdminInput = {
    create?: XOR<EnquiryCreateWithoutClientAdminInput, EnquiryUncheckedCreateWithoutClientAdminInput> | EnquiryCreateWithoutClientAdminInput[] | EnquiryUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: EnquiryCreateOrConnectWithoutClientAdminInput | EnquiryCreateOrConnectWithoutClientAdminInput[]
    createMany?: EnquiryCreateManyClientAdminInputEnvelope
    connect?: EnquiryWhereUniqueInput | EnquiryWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutClientAdminInput = {
    create?: XOR<NotificationCreateWithoutClientAdminInput, NotificationUncheckedCreateWithoutClientAdminInput> | NotificationCreateWithoutClientAdminInput[] | NotificationUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutClientAdminInput | NotificationCreateOrConnectWithoutClientAdminInput[]
    createMany?: NotificationCreateManyClientAdminInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type CourseFeeStructureCreateNestedManyWithoutClientAdminInput = {
    create?: XOR<CourseFeeStructureCreateWithoutClientAdminInput, CourseFeeStructureUncheckedCreateWithoutClientAdminInput> | CourseFeeStructureCreateWithoutClientAdminInput[] | CourseFeeStructureUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: CourseFeeStructureCreateOrConnectWithoutClientAdminInput | CourseFeeStructureCreateOrConnectWithoutClientAdminInput[]
    createMany?: CourseFeeStructureCreateManyClientAdminInputEnvelope
    connect?: CourseFeeStructureWhereUniqueInput | CourseFeeStructureWhereUniqueInput[]
  }

  export type RoleUserUncheckedCreateNestedManyWithoutClientAdminInput = {
    create?: XOR<RoleUserCreateWithoutClientAdminInput, RoleUserUncheckedCreateWithoutClientAdminInput> | RoleUserCreateWithoutClientAdminInput[] | RoleUserUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: RoleUserCreateOrConnectWithoutClientAdminInput | RoleUserCreateOrConnectWithoutClientAdminInput[]
    createMany?: RoleUserCreateManyClientAdminInputEnvelope
    connect?: RoleUserWhereUniqueInput | RoleUserWhereUniqueInput[]
  }

  export type FacultyUncheckedCreateNestedManyWithoutClientAdminInput = {
    create?: XOR<FacultyCreateWithoutClientAdminInput, FacultyUncheckedCreateWithoutClientAdminInput> | FacultyCreateWithoutClientAdminInput[] | FacultyUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: FacultyCreateOrConnectWithoutClientAdminInput | FacultyCreateOrConnectWithoutClientAdminInput[]
    createMany?: FacultyCreateManyClientAdminInputEnvelope
    connect?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[]
  }

  export type BatchUncheckedCreateNestedManyWithoutClientAdminInput = {
    create?: XOR<BatchCreateWithoutClientAdminInput, BatchUncheckedCreateWithoutClientAdminInput> | BatchCreateWithoutClientAdminInput[] | BatchUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutClientAdminInput | BatchCreateOrConnectWithoutClientAdminInput[]
    createMany?: BatchCreateManyClientAdminInputEnvelope
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
  }

  export type CourseUncheckedCreateNestedManyWithoutClientAdminInput = {
    create?: XOR<CourseCreateWithoutClientAdminInput, CourseUncheckedCreateWithoutClientAdminInput> | CourseCreateWithoutClientAdminInput[] | CourseUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutClientAdminInput | CourseCreateOrConnectWithoutClientAdminInput[]
    createMany?: CourseCreateManyClientAdminInputEnvelope
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
  }

  export type EnquiryCourseUncheckedCreateNestedManyWithoutClientAdminInput = {
    create?: XOR<EnquiryCourseCreateWithoutClientAdminInput, EnquiryCourseUncheckedCreateWithoutClientAdminInput> | EnquiryCourseCreateWithoutClientAdminInput[] | EnquiryCourseUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: EnquiryCourseCreateOrConnectWithoutClientAdminInput | EnquiryCourseCreateOrConnectWithoutClientAdminInput[]
    createMany?: EnquiryCourseCreateManyClientAdminInputEnvelope
    connect?: EnquiryCourseWhereUniqueInput | EnquiryCourseWhereUniqueInput[]
  }

  export type LabUncheckedCreateNestedManyWithoutClientAdminInput = {
    create?: XOR<LabCreateWithoutClientAdminInput, LabUncheckedCreateWithoutClientAdminInput> | LabCreateWithoutClientAdminInput[] | LabUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: LabCreateOrConnectWithoutClientAdminInput | LabCreateOrConnectWithoutClientAdminInput[]
    createMany?: LabCreateManyClientAdminInputEnvelope
    connect?: LabWhereUniqueInput | LabWhereUniqueInput[]
  }

  export type LabTimeSlotUncheckedCreateNestedManyWithoutClientAdminInput = {
    create?: XOR<LabTimeSlotCreateWithoutClientAdminInput, LabTimeSlotUncheckedCreateWithoutClientAdminInput> | LabTimeSlotCreateWithoutClientAdminInput[] | LabTimeSlotUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: LabTimeSlotCreateOrConnectWithoutClientAdminInput | LabTimeSlotCreateOrConnectWithoutClientAdminInput[]
    createMany?: LabTimeSlotCreateManyClientAdminInputEnvelope
    connect?: LabTimeSlotWhereUniqueInput | LabTimeSlotWhereUniqueInput[]
  }

  export type LabAllocationUncheckedCreateNestedManyWithoutClientAdminInput = {
    create?: XOR<LabAllocationCreateWithoutClientAdminInput, LabAllocationUncheckedCreateWithoutClientAdminInput> | LabAllocationCreateWithoutClientAdminInput[] | LabAllocationUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: LabAllocationCreateOrConnectWithoutClientAdminInput | LabAllocationCreateOrConnectWithoutClientAdminInput[]
    createMany?: LabAllocationCreateManyClientAdminInputEnvelope
    connect?: LabAllocationWhereUniqueInput | LabAllocationWhereUniqueInput[]
  }

  export type StudentUncheckedCreateNestedManyWithoutClientAdminInput = {
    create?: XOR<StudentCreateWithoutClientAdminInput, StudentUncheckedCreateWithoutClientAdminInput> | StudentCreateWithoutClientAdminInput[] | StudentUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutClientAdminInput | StudentCreateOrConnectWithoutClientAdminInput[]
    createMany?: StudentCreateManyClientAdminInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type ActivityLogUncheckedCreateNestedManyWithoutClientAdminInput = {
    create?: XOR<ActivityLogCreateWithoutClientAdminInput, ActivityLogUncheckedCreateWithoutClientAdminInput> | ActivityLogCreateWithoutClientAdminInput[] | ActivityLogUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutClientAdminInput | ActivityLogCreateOrConnectWithoutClientAdminInput[]
    createMany?: ActivityLogCreateManyClientAdminInputEnvelope
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
  }

  export type StudentCourseUncheckedCreateNestedManyWithoutClientAdminInput = {
    create?: XOR<StudentCourseCreateWithoutClientAdminInput, StudentCourseUncheckedCreateWithoutClientAdminInput> | StudentCourseCreateWithoutClientAdminInput[] | StudentCourseUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: StudentCourseCreateOrConnectWithoutClientAdminInput | StudentCourseCreateOrConnectWithoutClientAdminInput[]
    createMany?: StudentCourseCreateManyClientAdminInputEnvelope
    connect?: StudentCourseWhereUniqueInput | StudentCourseWhereUniqueInput[]
  }

  export type FeeStructureUncheckedCreateNestedManyWithoutClientAdminInput = {
    create?: XOR<FeeStructureCreateWithoutClientAdminInput, FeeStructureUncheckedCreateWithoutClientAdminInput> | FeeStructureCreateWithoutClientAdminInput[] | FeeStructureUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: FeeStructureCreateOrConnectWithoutClientAdminInput | FeeStructureCreateOrConnectWithoutClientAdminInput[]
    createMany?: FeeStructureCreateManyClientAdminInputEnvelope
    connect?: FeeStructureWhereUniqueInput | FeeStructureWhereUniqueInput[]
  }

  export type StudentFeeUncheckedCreateNestedManyWithoutClientAdminInput = {
    create?: XOR<StudentFeeCreateWithoutClientAdminInput, StudentFeeUncheckedCreateWithoutClientAdminInput> | StudentFeeCreateWithoutClientAdminInput[] | StudentFeeUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: StudentFeeCreateOrConnectWithoutClientAdminInput | StudentFeeCreateOrConnectWithoutClientAdminInput[]
    createMany?: StudentFeeCreateManyClientAdminInputEnvelope
    connect?: StudentFeeWhereUniqueInput | StudentFeeWhereUniqueInput[]
  }

  export type StationeryIssueUncheckedCreateNestedManyWithoutClientAdminInput = {
    create?: XOR<StationeryIssueCreateWithoutClientAdminInput, StationeryIssueUncheckedCreateWithoutClientAdminInput> | StationeryIssueCreateWithoutClientAdminInput[] | StationeryIssueUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: StationeryIssueCreateOrConnectWithoutClientAdminInput | StationeryIssueCreateOrConnectWithoutClientAdminInput[]
    createMany?: StationeryIssueCreateManyClientAdminInputEnvelope
    connect?: StationeryIssueWhereUniqueInput | StationeryIssueWhereUniqueInput[]
  }

  export type AttendanceRecordUncheckedCreateNestedManyWithoutClientAdminInput = {
    create?: XOR<AttendanceRecordCreateWithoutClientAdminInput, AttendanceRecordUncheckedCreateWithoutClientAdminInput> | AttendanceRecordCreateWithoutClientAdminInput[] | AttendanceRecordUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: AttendanceRecordCreateOrConnectWithoutClientAdminInput | AttendanceRecordCreateOrConnectWithoutClientAdminInput[]
    createMany?: AttendanceRecordCreateManyClientAdminInputEnvelope
    connect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
  }

  export type StudentTaskUncheckedCreateNestedManyWithoutClientAdminInput = {
    create?: XOR<StudentTaskCreateWithoutClientAdminInput, StudentTaskUncheckedCreateWithoutClientAdminInput> | StudentTaskCreateWithoutClientAdminInput[] | StudentTaskUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: StudentTaskCreateOrConnectWithoutClientAdminInput | StudentTaskCreateOrConnectWithoutClientAdminInput[]
    createMany?: StudentTaskCreateManyClientAdminInputEnvelope
    connect?: StudentTaskWhereUniqueInput | StudentTaskWhereUniqueInput[]
  }

  export type StudentTestUncheckedCreateNestedManyWithoutClientAdminInput = {
    create?: XOR<StudentTestCreateWithoutClientAdminInput, StudentTestUncheckedCreateWithoutClientAdminInput> | StudentTestCreateWithoutClientAdminInput[] | StudentTestUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: StudentTestCreateOrConnectWithoutClientAdminInput | StudentTestCreateOrConnectWithoutClientAdminInput[]
    createMany?: StudentTestCreateManyClientAdminInputEnvelope
    connect?: StudentTestWhereUniqueInput | StudentTestWhereUniqueInput[]
  }

  export type CourseCompletionUncheckedCreateNestedManyWithoutClientAdminInput = {
    create?: XOR<CourseCompletionCreateWithoutClientAdminInput, CourseCompletionUncheckedCreateWithoutClientAdminInput> | CourseCompletionCreateWithoutClientAdminInput[] | CourseCompletionUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: CourseCompletionCreateOrConnectWithoutClientAdminInput | CourseCompletionCreateOrConnectWithoutClientAdminInput[]
    createMany?: CourseCompletionCreateManyClientAdminInputEnvelope
    connect?: CourseCompletionWhereUniqueInput | CourseCompletionWhereUniqueInput[]
  }

  export type CertificateUncheckedCreateNestedManyWithoutClientAdminInput = {
    create?: XOR<CertificateCreateWithoutClientAdminInput, CertificateUncheckedCreateWithoutClientAdminInput> | CertificateCreateWithoutClientAdminInput[] | CertificateUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutClientAdminInput | CertificateCreateOrConnectWithoutClientAdminInput[]
    createMany?: CertificateCreateManyClientAdminInputEnvelope
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
  }

  export type FinancialRecordUncheckedCreateNestedManyWithoutClientAdminInput = {
    create?: XOR<FinancialRecordCreateWithoutClientAdminInput, FinancialRecordUncheckedCreateWithoutClientAdminInput> | FinancialRecordCreateWithoutClientAdminInput[] | FinancialRecordUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: FinancialRecordCreateOrConnectWithoutClientAdminInput | FinancialRecordCreateOrConnectWithoutClientAdminInput[]
    createMany?: FinancialRecordCreateManyClientAdminInputEnvelope
    connect?: FinancialRecordWhereUniqueInput | FinancialRecordWhereUniqueInput[]
  }

  export type EnquiryUncheckedCreateNestedManyWithoutClientAdminInput = {
    create?: XOR<EnquiryCreateWithoutClientAdminInput, EnquiryUncheckedCreateWithoutClientAdminInput> | EnquiryCreateWithoutClientAdminInput[] | EnquiryUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: EnquiryCreateOrConnectWithoutClientAdminInput | EnquiryCreateOrConnectWithoutClientAdminInput[]
    createMany?: EnquiryCreateManyClientAdminInputEnvelope
    connect?: EnquiryWhereUniqueInput | EnquiryWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutClientAdminInput = {
    create?: XOR<NotificationCreateWithoutClientAdminInput, NotificationUncheckedCreateWithoutClientAdminInput> | NotificationCreateWithoutClientAdminInput[] | NotificationUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutClientAdminInput | NotificationCreateOrConnectWithoutClientAdminInput[]
    createMany?: NotificationCreateManyClientAdminInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type CourseFeeStructureUncheckedCreateNestedManyWithoutClientAdminInput = {
    create?: XOR<CourseFeeStructureCreateWithoutClientAdminInput, CourseFeeStructureUncheckedCreateWithoutClientAdminInput> | CourseFeeStructureCreateWithoutClientAdminInput[] | CourseFeeStructureUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: CourseFeeStructureCreateOrConnectWithoutClientAdminInput | CourseFeeStructureCreateOrConnectWithoutClientAdminInput[]
    createMany?: CourseFeeStructureCreateManyClientAdminInputEnvelope
    connect?: CourseFeeStructureWhereUniqueInput | CourseFeeStructureWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type RoleUserUpdateManyWithoutClientAdminNestedInput = {
    create?: XOR<RoleUserCreateWithoutClientAdminInput, RoleUserUncheckedCreateWithoutClientAdminInput> | RoleUserCreateWithoutClientAdminInput[] | RoleUserUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: RoleUserCreateOrConnectWithoutClientAdminInput | RoleUserCreateOrConnectWithoutClientAdminInput[]
    upsert?: RoleUserUpsertWithWhereUniqueWithoutClientAdminInput | RoleUserUpsertWithWhereUniqueWithoutClientAdminInput[]
    createMany?: RoleUserCreateManyClientAdminInputEnvelope
    set?: RoleUserWhereUniqueInput | RoleUserWhereUniqueInput[]
    disconnect?: RoleUserWhereUniqueInput | RoleUserWhereUniqueInput[]
    delete?: RoleUserWhereUniqueInput | RoleUserWhereUniqueInput[]
    connect?: RoleUserWhereUniqueInput | RoleUserWhereUniqueInput[]
    update?: RoleUserUpdateWithWhereUniqueWithoutClientAdminInput | RoleUserUpdateWithWhereUniqueWithoutClientAdminInput[]
    updateMany?: RoleUserUpdateManyWithWhereWithoutClientAdminInput | RoleUserUpdateManyWithWhereWithoutClientAdminInput[]
    deleteMany?: RoleUserScalarWhereInput | RoleUserScalarWhereInput[]
  }

  export type FacultyUpdateManyWithoutClientAdminNestedInput = {
    create?: XOR<FacultyCreateWithoutClientAdminInput, FacultyUncheckedCreateWithoutClientAdminInput> | FacultyCreateWithoutClientAdminInput[] | FacultyUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: FacultyCreateOrConnectWithoutClientAdminInput | FacultyCreateOrConnectWithoutClientAdminInput[]
    upsert?: FacultyUpsertWithWhereUniqueWithoutClientAdminInput | FacultyUpsertWithWhereUniqueWithoutClientAdminInput[]
    createMany?: FacultyCreateManyClientAdminInputEnvelope
    set?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[]
    disconnect?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[]
    delete?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[]
    connect?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[]
    update?: FacultyUpdateWithWhereUniqueWithoutClientAdminInput | FacultyUpdateWithWhereUniqueWithoutClientAdminInput[]
    updateMany?: FacultyUpdateManyWithWhereWithoutClientAdminInput | FacultyUpdateManyWithWhereWithoutClientAdminInput[]
    deleteMany?: FacultyScalarWhereInput | FacultyScalarWhereInput[]
  }

  export type BatchUpdateManyWithoutClientAdminNestedInput = {
    create?: XOR<BatchCreateWithoutClientAdminInput, BatchUncheckedCreateWithoutClientAdminInput> | BatchCreateWithoutClientAdminInput[] | BatchUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutClientAdminInput | BatchCreateOrConnectWithoutClientAdminInput[]
    upsert?: BatchUpsertWithWhereUniqueWithoutClientAdminInput | BatchUpsertWithWhereUniqueWithoutClientAdminInput[]
    createMany?: BatchCreateManyClientAdminInputEnvelope
    set?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    disconnect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    delete?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    update?: BatchUpdateWithWhereUniqueWithoutClientAdminInput | BatchUpdateWithWhereUniqueWithoutClientAdminInput[]
    updateMany?: BatchUpdateManyWithWhereWithoutClientAdminInput | BatchUpdateManyWithWhereWithoutClientAdminInput[]
    deleteMany?: BatchScalarWhereInput | BatchScalarWhereInput[]
  }

  export type CourseUpdateManyWithoutClientAdminNestedInput = {
    create?: XOR<CourseCreateWithoutClientAdminInput, CourseUncheckedCreateWithoutClientAdminInput> | CourseCreateWithoutClientAdminInput[] | CourseUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutClientAdminInput | CourseCreateOrConnectWithoutClientAdminInput[]
    upsert?: CourseUpsertWithWhereUniqueWithoutClientAdminInput | CourseUpsertWithWhereUniqueWithoutClientAdminInput[]
    createMany?: CourseCreateManyClientAdminInputEnvelope
    set?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    disconnect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    delete?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    update?: CourseUpdateWithWhereUniqueWithoutClientAdminInput | CourseUpdateWithWhereUniqueWithoutClientAdminInput[]
    updateMany?: CourseUpdateManyWithWhereWithoutClientAdminInput | CourseUpdateManyWithWhereWithoutClientAdminInput[]
    deleteMany?: CourseScalarWhereInput | CourseScalarWhereInput[]
  }

  export type EnquiryCourseUpdateManyWithoutClientAdminNestedInput = {
    create?: XOR<EnquiryCourseCreateWithoutClientAdminInput, EnquiryCourseUncheckedCreateWithoutClientAdminInput> | EnquiryCourseCreateWithoutClientAdminInput[] | EnquiryCourseUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: EnquiryCourseCreateOrConnectWithoutClientAdminInput | EnquiryCourseCreateOrConnectWithoutClientAdminInput[]
    upsert?: EnquiryCourseUpsertWithWhereUniqueWithoutClientAdminInput | EnquiryCourseUpsertWithWhereUniqueWithoutClientAdminInput[]
    createMany?: EnquiryCourseCreateManyClientAdminInputEnvelope
    set?: EnquiryCourseWhereUniqueInput | EnquiryCourseWhereUniqueInput[]
    disconnect?: EnquiryCourseWhereUniqueInput | EnquiryCourseWhereUniqueInput[]
    delete?: EnquiryCourseWhereUniqueInput | EnquiryCourseWhereUniqueInput[]
    connect?: EnquiryCourseWhereUniqueInput | EnquiryCourseWhereUniqueInput[]
    update?: EnquiryCourseUpdateWithWhereUniqueWithoutClientAdminInput | EnquiryCourseUpdateWithWhereUniqueWithoutClientAdminInput[]
    updateMany?: EnquiryCourseUpdateManyWithWhereWithoutClientAdminInput | EnquiryCourseUpdateManyWithWhereWithoutClientAdminInput[]
    deleteMany?: EnquiryCourseScalarWhereInput | EnquiryCourseScalarWhereInput[]
  }

  export type LabUpdateManyWithoutClientAdminNestedInput = {
    create?: XOR<LabCreateWithoutClientAdminInput, LabUncheckedCreateWithoutClientAdminInput> | LabCreateWithoutClientAdminInput[] | LabUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: LabCreateOrConnectWithoutClientAdminInput | LabCreateOrConnectWithoutClientAdminInput[]
    upsert?: LabUpsertWithWhereUniqueWithoutClientAdminInput | LabUpsertWithWhereUniqueWithoutClientAdminInput[]
    createMany?: LabCreateManyClientAdminInputEnvelope
    set?: LabWhereUniqueInput | LabWhereUniqueInput[]
    disconnect?: LabWhereUniqueInput | LabWhereUniqueInput[]
    delete?: LabWhereUniqueInput | LabWhereUniqueInput[]
    connect?: LabWhereUniqueInput | LabWhereUniqueInput[]
    update?: LabUpdateWithWhereUniqueWithoutClientAdminInput | LabUpdateWithWhereUniqueWithoutClientAdminInput[]
    updateMany?: LabUpdateManyWithWhereWithoutClientAdminInput | LabUpdateManyWithWhereWithoutClientAdminInput[]
    deleteMany?: LabScalarWhereInput | LabScalarWhereInput[]
  }

  export type LabTimeSlotUpdateManyWithoutClientAdminNestedInput = {
    create?: XOR<LabTimeSlotCreateWithoutClientAdminInput, LabTimeSlotUncheckedCreateWithoutClientAdminInput> | LabTimeSlotCreateWithoutClientAdminInput[] | LabTimeSlotUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: LabTimeSlotCreateOrConnectWithoutClientAdminInput | LabTimeSlotCreateOrConnectWithoutClientAdminInput[]
    upsert?: LabTimeSlotUpsertWithWhereUniqueWithoutClientAdminInput | LabTimeSlotUpsertWithWhereUniqueWithoutClientAdminInput[]
    createMany?: LabTimeSlotCreateManyClientAdminInputEnvelope
    set?: LabTimeSlotWhereUniqueInput | LabTimeSlotWhereUniqueInput[]
    disconnect?: LabTimeSlotWhereUniqueInput | LabTimeSlotWhereUniqueInput[]
    delete?: LabTimeSlotWhereUniqueInput | LabTimeSlotWhereUniqueInput[]
    connect?: LabTimeSlotWhereUniqueInput | LabTimeSlotWhereUniqueInput[]
    update?: LabTimeSlotUpdateWithWhereUniqueWithoutClientAdminInput | LabTimeSlotUpdateWithWhereUniqueWithoutClientAdminInput[]
    updateMany?: LabTimeSlotUpdateManyWithWhereWithoutClientAdminInput | LabTimeSlotUpdateManyWithWhereWithoutClientAdminInput[]
    deleteMany?: LabTimeSlotScalarWhereInput | LabTimeSlotScalarWhereInput[]
  }

  export type LabAllocationUpdateManyWithoutClientAdminNestedInput = {
    create?: XOR<LabAllocationCreateWithoutClientAdminInput, LabAllocationUncheckedCreateWithoutClientAdminInput> | LabAllocationCreateWithoutClientAdminInput[] | LabAllocationUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: LabAllocationCreateOrConnectWithoutClientAdminInput | LabAllocationCreateOrConnectWithoutClientAdminInput[]
    upsert?: LabAllocationUpsertWithWhereUniqueWithoutClientAdminInput | LabAllocationUpsertWithWhereUniqueWithoutClientAdminInput[]
    createMany?: LabAllocationCreateManyClientAdminInputEnvelope
    set?: LabAllocationWhereUniqueInput | LabAllocationWhereUniqueInput[]
    disconnect?: LabAllocationWhereUniqueInput | LabAllocationWhereUniqueInput[]
    delete?: LabAllocationWhereUniqueInput | LabAllocationWhereUniqueInput[]
    connect?: LabAllocationWhereUniqueInput | LabAllocationWhereUniqueInput[]
    update?: LabAllocationUpdateWithWhereUniqueWithoutClientAdminInput | LabAllocationUpdateWithWhereUniqueWithoutClientAdminInput[]
    updateMany?: LabAllocationUpdateManyWithWhereWithoutClientAdminInput | LabAllocationUpdateManyWithWhereWithoutClientAdminInput[]
    deleteMany?: LabAllocationScalarWhereInput | LabAllocationScalarWhereInput[]
  }

  export type StudentUpdateManyWithoutClientAdminNestedInput = {
    create?: XOR<StudentCreateWithoutClientAdminInput, StudentUncheckedCreateWithoutClientAdminInput> | StudentCreateWithoutClientAdminInput[] | StudentUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutClientAdminInput | StudentCreateOrConnectWithoutClientAdminInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutClientAdminInput | StudentUpsertWithWhereUniqueWithoutClientAdminInput[]
    createMany?: StudentCreateManyClientAdminInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutClientAdminInput | StudentUpdateWithWhereUniqueWithoutClientAdminInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutClientAdminInput | StudentUpdateManyWithWhereWithoutClientAdminInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type ActivityLogUpdateManyWithoutClientAdminNestedInput = {
    create?: XOR<ActivityLogCreateWithoutClientAdminInput, ActivityLogUncheckedCreateWithoutClientAdminInput> | ActivityLogCreateWithoutClientAdminInput[] | ActivityLogUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutClientAdminInput | ActivityLogCreateOrConnectWithoutClientAdminInput[]
    upsert?: ActivityLogUpsertWithWhereUniqueWithoutClientAdminInput | ActivityLogUpsertWithWhereUniqueWithoutClientAdminInput[]
    createMany?: ActivityLogCreateManyClientAdminInputEnvelope
    set?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    disconnect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    delete?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    update?: ActivityLogUpdateWithWhereUniqueWithoutClientAdminInput | ActivityLogUpdateWithWhereUniqueWithoutClientAdminInput[]
    updateMany?: ActivityLogUpdateManyWithWhereWithoutClientAdminInput | ActivityLogUpdateManyWithWhereWithoutClientAdminInput[]
    deleteMany?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
  }

  export type StudentCourseUpdateManyWithoutClientAdminNestedInput = {
    create?: XOR<StudentCourseCreateWithoutClientAdminInput, StudentCourseUncheckedCreateWithoutClientAdminInput> | StudentCourseCreateWithoutClientAdminInput[] | StudentCourseUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: StudentCourseCreateOrConnectWithoutClientAdminInput | StudentCourseCreateOrConnectWithoutClientAdminInput[]
    upsert?: StudentCourseUpsertWithWhereUniqueWithoutClientAdminInput | StudentCourseUpsertWithWhereUniqueWithoutClientAdminInput[]
    createMany?: StudentCourseCreateManyClientAdminInputEnvelope
    set?: StudentCourseWhereUniqueInput | StudentCourseWhereUniqueInput[]
    disconnect?: StudentCourseWhereUniqueInput | StudentCourseWhereUniqueInput[]
    delete?: StudentCourseWhereUniqueInput | StudentCourseWhereUniqueInput[]
    connect?: StudentCourseWhereUniqueInput | StudentCourseWhereUniqueInput[]
    update?: StudentCourseUpdateWithWhereUniqueWithoutClientAdminInput | StudentCourseUpdateWithWhereUniqueWithoutClientAdminInput[]
    updateMany?: StudentCourseUpdateManyWithWhereWithoutClientAdminInput | StudentCourseUpdateManyWithWhereWithoutClientAdminInput[]
    deleteMany?: StudentCourseScalarWhereInput | StudentCourseScalarWhereInput[]
  }

  export type FeeStructureUpdateManyWithoutClientAdminNestedInput = {
    create?: XOR<FeeStructureCreateWithoutClientAdminInput, FeeStructureUncheckedCreateWithoutClientAdminInput> | FeeStructureCreateWithoutClientAdminInput[] | FeeStructureUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: FeeStructureCreateOrConnectWithoutClientAdminInput | FeeStructureCreateOrConnectWithoutClientAdminInput[]
    upsert?: FeeStructureUpsertWithWhereUniqueWithoutClientAdminInput | FeeStructureUpsertWithWhereUniqueWithoutClientAdminInput[]
    createMany?: FeeStructureCreateManyClientAdminInputEnvelope
    set?: FeeStructureWhereUniqueInput | FeeStructureWhereUniqueInput[]
    disconnect?: FeeStructureWhereUniqueInput | FeeStructureWhereUniqueInput[]
    delete?: FeeStructureWhereUniqueInput | FeeStructureWhereUniqueInput[]
    connect?: FeeStructureWhereUniqueInput | FeeStructureWhereUniqueInput[]
    update?: FeeStructureUpdateWithWhereUniqueWithoutClientAdminInput | FeeStructureUpdateWithWhereUniqueWithoutClientAdminInput[]
    updateMany?: FeeStructureUpdateManyWithWhereWithoutClientAdminInput | FeeStructureUpdateManyWithWhereWithoutClientAdminInput[]
    deleteMany?: FeeStructureScalarWhereInput | FeeStructureScalarWhereInput[]
  }

  export type StudentFeeUpdateManyWithoutClientAdminNestedInput = {
    create?: XOR<StudentFeeCreateWithoutClientAdminInput, StudentFeeUncheckedCreateWithoutClientAdminInput> | StudentFeeCreateWithoutClientAdminInput[] | StudentFeeUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: StudentFeeCreateOrConnectWithoutClientAdminInput | StudentFeeCreateOrConnectWithoutClientAdminInput[]
    upsert?: StudentFeeUpsertWithWhereUniqueWithoutClientAdminInput | StudentFeeUpsertWithWhereUniqueWithoutClientAdminInput[]
    createMany?: StudentFeeCreateManyClientAdminInputEnvelope
    set?: StudentFeeWhereUniqueInput | StudentFeeWhereUniqueInput[]
    disconnect?: StudentFeeWhereUniqueInput | StudentFeeWhereUniqueInput[]
    delete?: StudentFeeWhereUniqueInput | StudentFeeWhereUniqueInput[]
    connect?: StudentFeeWhereUniqueInput | StudentFeeWhereUniqueInput[]
    update?: StudentFeeUpdateWithWhereUniqueWithoutClientAdminInput | StudentFeeUpdateWithWhereUniqueWithoutClientAdminInput[]
    updateMany?: StudentFeeUpdateManyWithWhereWithoutClientAdminInput | StudentFeeUpdateManyWithWhereWithoutClientAdminInput[]
    deleteMany?: StudentFeeScalarWhereInput | StudentFeeScalarWhereInput[]
  }

  export type StationeryIssueUpdateManyWithoutClientAdminNestedInput = {
    create?: XOR<StationeryIssueCreateWithoutClientAdminInput, StationeryIssueUncheckedCreateWithoutClientAdminInput> | StationeryIssueCreateWithoutClientAdminInput[] | StationeryIssueUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: StationeryIssueCreateOrConnectWithoutClientAdminInput | StationeryIssueCreateOrConnectWithoutClientAdminInput[]
    upsert?: StationeryIssueUpsertWithWhereUniqueWithoutClientAdminInput | StationeryIssueUpsertWithWhereUniqueWithoutClientAdminInput[]
    createMany?: StationeryIssueCreateManyClientAdminInputEnvelope
    set?: StationeryIssueWhereUniqueInput | StationeryIssueWhereUniqueInput[]
    disconnect?: StationeryIssueWhereUniqueInput | StationeryIssueWhereUniqueInput[]
    delete?: StationeryIssueWhereUniqueInput | StationeryIssueWhereUniqueInput[]
    connect?: StationeryIssueWhereUniqueInput | StationeryIssueWhereUniqueInput[]
    update?: StationeryIssueUpdateWithWhereUniqueWithoutClientAdminInput | StationeryIssueUpdateWithWhereUniqueWithoutClientAdminInput[]
    updateMany?: StationeryIssueUpdateManyWithWhereWithoutClientAdminInput | StationeryIssueUpdateManyWithWhereWithoutClientAdminInput[]
    deleteMany?: StationeryIssueScalarWhereInput | StationeryIssueScalarWhereInput[]
  }

  export type AttendanceRecordUpdateManyWithoutClientAdminNestedInput = {
    create?: XOR<AttendanceRecordCreateWithoutClientAdminInput, AttendanceRecordUncheckedCreateWithoutClientAdminInput> | AttendanceRecordCreateWithoutClientAdminInput[] | AttendanceRecordUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: AttendanceRecordCreateOrConnectWithoutClientAdminInput | AttendanceRecordCreateOrConnectWithoutClientAdminInput[]
    upsert?: AttendanceRecordUpsertWithWhereUniqueWithoutClientAdminInput | AttendanceRecordUpsertWithWhereUniqueWithoutClientAdminInput[]
    createMany?: AttendanceRecordCreateManyClientAdminInputEnvelope
    set?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    disconnect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    delete?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    connect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    update?: AttendanceRecordUpdateWithWhereUniqueWithoutClientAdminInput | AttendanceRecordUpdateWithWhereUniqueWithoutClientAdminInput[]
    updateMany?: AttendanceRecordUpdateManyWithWhereWithoutClientAdminInput | AttendanceRecordUpdateManyWithWhereWithoutClientAdminInput[]
    deleteMany?: AttendanceRecordScalarWhereInput | AttendanceRecordScalarWhereInput[]
  }

  export type StudentTaskUpdateManyWithoutClientAdminNestedInput = {
    create?: XOR<StudentTaskCreateWithoutClientAdminInput, StudentTaskUncheckedCreateWithoutClientAdminInput> | StudentTaskCreateWithoutClientAdminInput[] | StudentTaskUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: StudentTaskCreateOrConnectWithoutClientAdminInput | StudentTaskCreateOrConnectWithoutClientAdminInput[]
    upsert?: StudentTaskUpsertWithWhereUniqueWithoutClientAdminInput | StudentTaskUpsertWithWhereUniqueWithoutClientAdminInput[]
    createMany?: StudentTaskCreateManyClientAdminInputEnvelope
    set?: StudentTaskWhereUniqueInput | StudentTaskWhereUniqueInput[]
    disconnect?: StudentTaskWhereUniqueInput | StudentTaskWhereUniqueInput[]
    delete?: StudentTaskWhereUniqueInput | StudentTaskWhereUniqueInput[]
    connect?: StudentTaskWhereUniqueInput | StudentTaskWhereUniqueInput[]
    update?: StudentTaskUpdateWithWhereUniqueWithoutClientAdminInput | StudentTaskUpdateWithWhereUniqueWithoutClientAdminInput[]
    updateMany?: StudentTaskUpdateManyWithWhereWithoutClientAdminInput | StudentTaskUpdateManyWithWhereWithoutClientAdminInput[]
    deleteMany?: StudentTaskScalarWhereInput | StudentTaskScalarWhereInput[]
  }

  export type StudentTestUpdateManyWithoutClientAdminNestedInput = {
    create?: XOR<StudentTestCreateWithoutClientAdminInput, StudentTestUncheckedCreateWithoutClientAdminInput> | StudentTestCreateWithoutClientAdminInput[] | StudentTestUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: StudentTestCreateOrConnectWithoutClientAdminInput | StudentTestCreateOrConnectWithoutClientAdminInput[]
    upsert?: StudentTestUpsertWithWhereUniqueWithoutClientAdminInput | StudentTestUpsertWithWhereUniqueWithoutClientAdminInput[]
    createMany?: StudentTestCreateManyClientAdminInputEnvelope
    set?: StudentTestWhereUniqueInput | StudentTestWhereUniqueInput[]
    disconnect?: StudentTestWhereUniqueInput | StudentTestWhereUniqueInput[]
    delete?: StudentTestWhereUniqueInput | StudentTestWhereUniqueInput[]
    connect?: StudentTestWhereUniqueInput | StudentTestWhereUniqueInput[]
    update?: StudentTestUpdateWithWhereUniqueWithoutClientAdminInput | StudentTestUpdateWithWhereUniqueWithoutClientAdminInput[]
    updateMany?: StudentTestUpdateManyWithWhereWithoutClientAdminInput | StudentTestUpdateManyWithWhereWithoutClientAdminInput[]
    deleteMany?: StudentTestScalarWhereInput | StudentTestScalarWhereInput[]
  }

  export type CourseCompletionUpdateManyWithoutClientAdminNestedInput = {
    create?: XOR<CourseCompletionCreateWithoutClientAdminInput, CourseCompletionUncheckedCreateWithoutClientAdminInput> | CourseCompletionCreateWithoutClientAdminInput[] | CourseCompletionUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: CourseCompletionCreateOrConnectWithoutClientAdminInput | CourseCompletionCreateOrConnectWithoutClientAdminInput[]
    upsert?: CourseCompletionUpsertWithWhereUniqueWithoutClientAdminInput | CourseCompletionUpsertWithWhereUniqueWithoutClientAdminInput[]
    createMany?: CourseCompletionCreateManyClientAdminInputEnvelope
    set?: CourseCompletionWhereUniqueInput | CourseCompletionWhereUniqueInput[]
    disconnect?: CourseCompletionWhereUniqueInput | CourseCompletionWhereUniqueInput[]
    delete?: CourseCompletionWhereUniqueInput | CourseCompletionWhereUniqueInput[]
    connect?: CourseCompletionWhereUniqueInput | CourseCompletionWhereUniqueInput[]
    update?: CourseCompletionUpdateWithWhereUniqueWithoutClientAdminInput | CourseCompletionUpdateWithWhereUniqueWithoutClientAdminInput[]
    updateMany?: CourseCompletionUpdateManyWithWhereWithoutClientAdminInput | CourseCompletionUpdateManyWithWhereWithoutClientAdminInput[]
    deleteMany?: CourseCompletionScalarWhereInput | CourseCompletionScalarWhereInput[]
  }

  export type CertificateUpdateManyWithoutClientAdminNestedInput = {
    create?: XOR<CertificateCreateWithoutClientAdminInput, CertificateUncheckedCreateWithoutClientAdminInput> | CertificateCreateWithoutClientAdminInput[] | CertificateUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutClientAdminInput | CertificateCreateOrConnectWithoutClientAdminInput[]
    upsert?: CertificateUpsertWithWhereUniqueWithoutClientAdminInput | CertificateUpsertWithWhereUniqueWithoutClientAdminInput[]
    createMany?: CertificateCreateManyClientAdminInputEnvelope
    set?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    disconnect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    delete?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    update?: CertificateUpdateWithWhereUniqueWithoutClientAdminInput | CertificateUpdateWithWhereUniqueWithoutClientAdminInput[]
    updateMany?: CertificateUpdateManyWithWhereWithoutClientAdminInput | CertificateUpdateManyWithWhereWithoutClientAdminInput[]
    deleteMany?: CertificateScalarWhereInput | CertificateScalarWhereInput[]
  }

  export type FinancialRecordUpdateManyWithoutClientAdminNestedInput = {
    create?: XOR<FinancialRecordCreateWithoutClientAdminInput, FinancialRecordUncheckedCreateWithoutClientAdminInput> | FinancialRecordCreateWithoutClientAdminInput[] | FinancialRecordUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: FinancialRecordCreateOrConnectWithoutClientAdminInput | FinancialRecordCreateOrConnectWithoutClientAdminInput[]
    upsert?: FinancialRecordUpsertWithWhereUniqueWithoutClientAdminInput | FinancialRecordUpsertWithWhereUniqueWithoutClientAdminInput[]
    createMany?: FinancialRecordCreateManyClientAdminInputEnvelope
    set?: FinancialRecordWhereUniqueInput | FinancialRecordWhereUniqueInput[]
    disconnect?: FinancialRecordWhereUniqueInput | FinancialRecordWhereUniqueInput[]
    delete?: FinancialRecordWhereUniqueInput | FinancialRecordWhereUniqueInput[]
    connect?: FinancialRecordWhereUniqueInput | FinancialRecordWhereUniqueInput[]
    update?: FinancialRecordUpdateWithWhereUniqueWithoutClientAdminInput | FinancialRecordUpdateWithWhereUniqueWithoutClientAdminInput[]
    updateMany?: FinancialRecordUpdateManyWithWhereWithoutClientAdminInput | FinancialRecordUpdateManyWithWhereWithoutClientAdminInput[]
    deleteMany?: FinancialRecordScalarWhereInput | FinancialRecordScalarWhereInput[]
  }

  export type EnquiryUpdateManyWithoutClientAdminNestedInput = {
    create?: XOR<EnquiryCreateWithoutClientAdminInput, EnquiryUncheckedCreateWithoutClientAdminInput> | EnquiryCreateWithoutClientAdminInput[] | EnquiryUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: EnquiryCreateOrConnectWithoutClientAdminInput | EnquiryCreateOrConnectWithoutClientAdminInput[]
    upsert?: EnquiryUpsertWithWhereUniqueWithoutClientAdminInput | EnquiryUpsertWithWhereUniqueWithoutClientAdminInput[]
    createMany?: EnquiryCreateManyClientAdminInputEnvelope
    set?: EnquiryWhereUniqueInput | EnquiryWhereUniqueInput[]
    disconnect?: EnquiryWhereUniqueInput | EnquiryWhereUniqueInput[]
    delete?: EnquiryWhereUniqueInput | EnquiryWhereUniqueInput[]
    connect?: EnquiryWhereUniqueInput | EnquiryWhereUniqueInput[]
    update?: EnquiryUpdateWithWhereUniqueWithoutClientAdminInput | EnquiryUpdateWithWhereUniqueWithoutClientAdminInput[]
    updateMany?: EnquiryUpdateManyWithWhereWithoutClientAdminInput | EnquiryUpdateManyWithWhereWithoutClientAdminInput[]
    deleteMany?: EnquiryScalarWhereInput | EnquiryScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutClientAdminNestedInput = {
    create?: XOR<NotificationCreateWithoutClientAdminInput, NotificationUncheckedCreateWithoutClientAdminInput> | NotificationCreateWithoutClientAdminInput[] | NotificationUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutClientAdminInput | NotificationCreateOrConnectWithoutClientAdminInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutClientAdminInput | NotificationUpsertWithWhereUniqueWithoutClientAdminInput[]
    createMany?: NotificationCreateManyClientAdminInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutClientAdminInput | NotificationUpdateWithWhereUniqueWithoutClientAdminInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutClientAdminInput | NotificationUpdateManyWithWhereWithoutClientAdminInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type CourseFeeStructureUpdateManyWithoutClientAdminNestedInput = {
    create?: XOR<CourseFeeStructureCreateWithoutClientAdminInput, CourseFeeStructureUncheckedCreateWithoutClientAdminInput> | CourseFeeStructureCreateWithoutClientAdminInput[] | CourseFeeStructureUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: CourseFeeStructureCreateOrConnectWithoutClientAdminInput | CourseFeeStructureCreateOrConnectWithoutClientAdminInput[]
    upsert?: CourseFeeStructureUpsertWithWhereUniqueWithoutClientAdminInput | CourseFeeStructureUpsertWithWhereUniqueWithoutClientAdminInput[]
    createMany?: CourseFeeStructureCreateManyClientAdminInputEnvelope
    set?: CourseFeeStructureWhereUniqueInput | CourseFeeStructureWhereUniqueInput[]
    disconnect?: CourseFeeStructureWhereUniqueInput | CourseFeeStructureWhereUniqueInput[]
    delete?: CourseFeeStructureWhereUniqueInput | CourseFeeStructureWhereUniqueInput[]
    connect?: CourseFeeStructureWhereUniqueInput | CourseFeeStructureWhereUniqueInput[]
    update?: CourseFeeStructureUpdateWithWhereUniqueWithoutClientAdminInput | CourseFeeStructureUpdateWithWhereUniqueWithoutClientAdminInput[]
    updateMany?: CourseFeeStructureUpdateManyWithWhereWithoutClientAdminInput | CourseFeeStructureUpdateManyWithWhereWithoutClientAdminInput[]
    deleteMany?: CourseFeeStructureScalarWhereInput | CourseFeeStructureScalarWhereInput[]
  }

  export type RoleUserUncheckedUpdateManyWithoutClientAdminNestedInput = {
    create?: XOR<RoleUserCreateWithoutClientAdminInput, RoleUserUncheckedCreateWithoutClientAdminInput> | RoleUserCreateWithoutClientAdminInput[] | RoleUserUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: RoleUserCreateOrConnectWithoutClientAdminInput | RoleUserCreateOrConnectWithoutClientAdminInput[]
    upsert?: RoleUserUpsertWithWhereUniqueWithoutClientAdminInput | RoleUserUpsertWithWhereUniqueWithoutClientAdminInput[]
    createMany?: RoleUserCreateManyClientAdminInputEnvelope
    set?: RoleUserWhereUniqueInput | RoleUserWhereUniqueInput[]
    disconnect?: RoleUserWhereUniqueInput | RoleUserWhereUniqueInput[]
    delete?: RoleUserWhereUniqueInput | RoleUserWhereUniqueInput[]
    connect?: RoleUserWhereUniqueInput | RoleUserWhereUniqueInput[]
    update?: RoleUserUpdateWithWhereUniqueWithoutClientAdminInput | RoleUserUpdateWithWhereUniqueWithoutClientAdminInput[]
    updateMany?: RoleUserUpdateManyWithWhereWithoutClientAdminInput | RoleUserUpdateManyWithWhereWithoutClientAdminInput[]
    deleteMany?: RoleUserScalarWhereInput | RoleUserScalarWhereInput[]
  }

  export type FacultyUncheckedUpdateManyWithoutClientAdminNestedInput = {
    create?: XOR<FacultyCreateWithoutClientAdminInput, FacultyUncheckedCreateWithoutClientAdminInput> | FacultyCreateWithoutClientAdminInput[] | FacultyUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: FacultyCreateOrConnectWithoutClientAdminInput | FacultyCreateOrConnectWithoutClientAdminInput[]
    upsert?: FacultyUpsertWithWhereUniqueWithoutClientAdminInput | FacultyUpsertWithWhereUniqueWithoutClientAdminInput[]
    createMany?: FacultyCreateManyClientAdminInputEnvelope
    set?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[]
    disconnect?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[]
    delete?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[]
    connect?: FacultyWhereUniqueInput | FacultyWhereUniqueInput[]
    update?: FacultyUpdateWithWhereUniqueWithoutClientAdminInput | FacultyUpdateWithWhereUniqueWithoutClientAdminInput[]
    updateMany?: FacultyUpdateManyWithWhereWithoutClientAdminInput | FacultyUpdateManyWithWhereWithoutClientAdminInput[]
    deleteMany?: FacultyScalarWhereInput | FacultyScalarWhereInput[]
  }

  export type BatchUncheckedUpdateManyWithoutClientAdminNestedInput = {
    create?: XOR<BatchCreateWithoutClientAdminInput, BatchUncheckedCreateWithoutClientAdminInput> | BatchCreateWithoutClientAdminInput[] | BatchUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutClientAdminInput | BatchCreateOrConnectWithoutClientAdminInput[]
    upsert?: BatchUpsertWithWhereUniqueWithoutClientAdminInput | BatchUpsertWithWhereUniqueWithoutClientAdminInput[]
    createMany?: BatchCreateManyClientAdminInputEnvelope
    set?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    disconnect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    delete?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    update?: BatchUpdateWithWhereUniqueWithoutClientAdminInput | BatchUpdateWithWhereUniqueWithoutClientAdminInput[]
    updateMany?: BatchUpdateManyWithWhereWithoutClientAdminInput | BatchUpdateManyWithWhereWithoutClientAdminInput[]
    deleteMany?: BatchScalarWhereInput | BatchScalarWhereInput[]
  }

  export type CourseUncheckedUpdateManyWithoutClientAdminNestedInput = {
    create?: XOR<CourseCreateWithoutClientAdminInput, CourseUncheckedCreateWithoutClientAdminInput> | CourseCreateWithoutClientAdminInput[] | CourseUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutClientAdminInput | CourseCreateOrConnectWithoutClientAdminInput[]
    upsert?: CourseUpsertWithWhereUniqueWithoutClientAdminInput | CourseUpsertWithWhereUniqueWithoutClientAdminInput[]
    createMany?: CourseCreateManyClientAdminInputEnvelope
    set?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    disconnect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    delete?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    update?: CourseUpdateWithWhereUniqueWithoutClientAdminInput | CourseUpdateWithWhereUniqueWithoutClientAdminInput[]
    updateMany?: CourseUpdateManyWithWhereWithoutClientAdminInput | CourseUpdateManyWithWhereWithoutClientAdminInput[]
    deleteMany?: CourseScalarWhereInput | CourseScalarWhereInput[]
  }

  export type EnquiryCourseUncheckedUpdateManyWithoutClientAdminNestedInput = {
    create?: XOR<EnquiryCourseCreateWithoutClientAdminInput, EnquiryCourseUncheckedCreateWithoutClientAdminInput> | EnquiryCourseCreateWithoutClientAdminInput[] | EnquiryCourseUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: EnquiryCourseCreateOrConnectWithoutClientAdminInput | EnquiryCourseCreateOrConnectWithoutClientAdminInput[]
    upsert?: EnquiryCourseUpsertWithWhereUniqueWithoutClientAdminInput | EnquiryCourseUpsertWithWhereUniqueWithoutClientAdminInput[]
    createMany?: EnquiryCourseCreateManyClientAdminInputEnvelope
    set?: EnquiryCourseWhereUniqueInput | EnquiryCourseWhereUniqueInput[]
    disconnect?: EnquiryCourseWhereUniqueInput | EnquiryCourseWhereUniqueInput[]
    delete?: EnquiryCourseWhereUniqueInput | EnquiryCourseWhereUniqueInput[]
    connect?: EnquiryCourseWhereUniqueInput | EnquiryCourseWhereUniqueInput[]
    update?: EnquiryCourseUpdateWithWhereUniqueWithoutClientAdminInput | EnquiryCourseUpdateWithWhereUniqueWithoutClientAdminInput[]
    updateMany?: EnquiryCourseUpdateManyWithWhereWithoutClientAdminInput | EnquiryCourseUpdateManyWithWhereWithoutClientAdminInput[]
    deleteMany?: EnquiryCourseScalarWhereInput | EnquiryCourseScalarWhereInput[]
  }

  export type LabUncheckedUpdateManyWithoutClientAdminNestedInput = {
    create?: XOR<LabCreateWithoutClientAdminInput, LabUncheckedCreateWithoutClientAdminInput> | LabCreateWithoutClientAdminInput[] | LabUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: LabCreateOrConnectWithoutClientAdminInput | LabCreateOrConnectWithoutClientAdminInput[]
    upsert?: LabUpsertWithWhereUniqueWithoutClientAdminInput | LabUpsertWithWhereUniqueWithoutClientAdminInput[]
    createMany?: LabCreateManyClientAdminInputEnvelope
    set?: LabWhereUniqueInput | LabWhereUniqueInput[]
    disconnect?: LabWhereUniqueInput | LabWhereUniqueInput[]
    delete?: LabWhereUniqueInput | LabWhereUniqueInput[]
    connect?: LabWhereUniqueInput | LabWhereUniqueInput[]
    update?: LabUpdateWithWhereUniqueWithoutClientAdminInput | LabUpdateWithWhereUniqueWithoutClientAdminInput[]
    updateMany?: LabUpdateManyWithWhereWithoutClientAdminInput | LabUpdateManyWithWhereWithoutClientAdminInput[]
    deleteMany?: LabScalarWhereInput | LabScalarWhereInput[]
  }

  export type LabTimeSlotUncheckedUpdateManyWithoutClientAdminNestedInput = {
    create?: XOR<LabTimeSlotCreateWithoutClientAdminInput, LabTimeSlotUncheckedCreateWithoutClientAdminInput> | LabTimeSlotCreateWithoutClientAdminInput[] | LabTimeSlotUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: LabTimeSlotCreateOrConnectWithoutClientAdminInput | LabTimeSlotCreateOrConnectWithoutClientAdminInput[]
    upsert?: LabTimeSlotUpsertWithWhereUniqueWithoutClientAdminInput | LabTimeSlotUpsertWithWhereUniqueWithoutClientAdminInput[]
    createMany?: LabTimeSlotCreateManyClientAdminInputEnvelope
    set?: LabTimeSlotWhereUniqueInput | LabTimeSlotWhereUniqueInput[]
    disconnect?: LabTimeSlotWhereUniqueInput | LabTimeSlotWhereUniqueInput[]
    delete?: LabTimeSlotWhereUniqueInput | LabTimeSlotWhereUniqueInput[]
    connect?: LabTimeSlotWhereUniqueInput | LabTimeSlotWhereUniqueInput[]
    update?: LabTimeSlotUpdateWithWhereUniqueWithoutClientAdminInput | LabTimeSlotUpdateWithWhereUniqueWithoutClientAdminInput[]
    updateMany?: LabTimeSlotUpdateManyWithWhereWithoutClientAdminInput | LabTimeSlotUpdateManyWithWhereWithoutClientAdminInput[]
    deleteMany?: LabTimeSlotScalarWhereInput | LabTimeSlotScalarWhereInput[]
  }

  export type LabAllocationUncheckedUpdateManyWithoutClientAdminNestedInput = {
    create?: XOR<LabAllocationCreateWithoutClientAdminInput, LabAllocationUncheckedCreateWithoutClientAdminInput> | LabAllocationCreateWithoutClientAdminInput[] | LabAllocationUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: LabAllocationCreateOrConnectWithoutClientAdminInput | LabAllocationCreateOrConnectWithoutClientAdminInput[]
    upsert?: LabAllocationUpsertWithWhereUniqueWithoutClientAdminInput | LabAllocationUpsertWithWhereUniqueWithoutClientAdminInput[]
    createMany?: LabAllocationCreateManyClientAdminInputEnvelope
    set?: LabAllocationWhereUniqueInput | LabAllocationWhereUniqueInput[]
    disconnect?: LabAllocationWhereUniqueInput | LabAllocationWhereUniqueInput[]
    delete?: LabAllocationWhereUniqueInput | LabAllocationWhereUniqueInput[]
    connect?: LabAllocationWhereUniqueInput | LabAllocationWhereUniqueInput[]
    update?: LabAllocationUpdateWithWhereUniqueWithoutClientAdminInput | LabAllocationUpdateWithWhereUniqueWithoutClientAdminInput[]
    updateMany?: LabAllocationUpdateManyWithWhereWithoutClientAdminInput | LabAllocationUpdateManyWithWhereWithoutClientAdminInput[]
    deleteMany?: LabAllocationScalarWhereInput | LabAllocationScalarWhereInput[]
  }

  export type StudentUncheckedUpdateManyWithoutClientAdminNestedInput = {
    create?: XOR<StudentCreateWithoutClientAdminInput, StudentUncheckedCreateWithoutClientAdminInput> | StudentCreateWithoutClientAdminInput[] | StudentUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutClientAdminInput | StudentCreateOrConnectWithoutClientAdminInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutClientAdminInput | StudentUpsertWithWhereUniqueWithoutClientAdminInput[]
    createMany?: StudentCreateManyClientAdminInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutClientAdminInput | StudentUpdateWithWhereUniqueWithoutClientAdminInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutClientAdminInput | StudentUpdateManyWithWhereWithoutClientAdminInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type ActivityLogUncheckedUpdateManyWithoutClientAdminNestedInput = {
    create?: XOR<ActivityLogCreateWithoutClientAdminInput, ActivityLogUncheckedCreateWithoutClientAdminInput> | ActivityLogCreateWithoutClientAdminInput[] | ActivityLogUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutClientAdminInput | ActivityLogCreateOrConnectWithoutClientAdminInput[]
    upsert?: ActivityLogUpsertWithWhereUniqueWithoutClientAdminInput | ActivityLogUpsertWithWhereUniqueWithoutClientAdminInput[]
    createMany?: ActivityLogCreateManyClientAdminInputEnvelope
    set?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    disconnect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    delete?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    update?: ActivityLogUpdateWithWhereUniqueWithoutClientAdminInput | ActivityLogUpdateWithWhereUniqueWithoutClientAdminInput[]
    updateMany?: ActivityLogUpdateManyWithWhereWithoutClientAdminInput | ActivityLogUpdateManyWithWhereWithoutClientAdminInput[]
    deleteMany?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
  }

  export type StudentCourseUncheckedUpdateManyWithoutClientAdminNestedInput = {
    create?: XOR<StudentCourseCreateWithoutClientAdminInput, StudentCourseUncheckedCreateWithoutClientAdminInput> | StudentCourseCreateWithoutClientAdminInput[] | StudentCourseUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: StudentCourseCreateOrConnectWithoutClientAdminInput | StudentCourseCreateOrConnectWithoutClientAdminInput[]
    upsert?: StudentCourseUpsertWithWhereUniqueWithoutClientAdminInput | StudentCourseUpsertWithWhereUniqueWithoutClientAdminInput[]
    createMany?: StudentCourseCreateManyClientAdminInputEnvelope
    set?: StudentCourseWhereUniqueInput | StudentCourseWhereUniqueInput[]
    disconnect?: StudentCourseWhereUniqueInput | StudentCourseWhereUniqueInput[]
    delete?: StudentCourseWhereUniqueInput | StudentCourseWhereUniqueInput[]
    connect?: StudentCourseWhereUniqueInput | StudentCourseWhereUniqueInput[]
    update?: StudentCourseUpdateWithWhereUniqueWithoutClientAdminInput | StudentCourseUpdateWithWhereUniqueWithoutClientAdminInput[]
    updateMany?: StudentCourseUpdateManyWithWhereWithoutClientAdminInput | StudentCourseUpdateManyWithWhereWithoutClientAdminInput[]
    deleteMany?: StudentCourseScalarWhereInput | StudentCourseScalarWhereInput[]
  }

  export type FeeStructureUncheckedUpdateManyWithoutClientAdminNestedInput = {
    create?: XOR<FeeStructureCreateWithoutClientAdminInput, FeeStructureUncheckedCreateWithoutClientAdminInput> | FeeStructureCreateWithoutClientAdminInput[] | FeeStructureUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: FeeStructureCreateOrConnectWithoutClientAdminInput | FeeStructureCreateOrConnectWithoutClientAdminInput[]
    upsert?: FeeStructureUpsertWithWhereUniqueWithoutClientAdminInput | FeeStructureUpsertWithWhereUniqueWithoutClientAdminInput[]
    createMany?: FeeStructureCreateManyClientAdminInputEnvelope
    set?: FeeStructureWhereUniqueInput | FeeStructureWhereUniqueInput[]
    disconnect?: FeeStructureWhereUniqueInput | FeeStructureWhereUniqueInput[]
    delete?: FeeStructureWhereUniqueInput | FeeStructureWhereUniqueInput[]
    connect?: FeeStructureWhereUniqueInput | FeeStructureWhereUniqueInput[]
    update?: FeeStructureUpdateWithWhereUniqueWithoutClientAdminInput | FeeStructureUpdateWithWhereUniqueWithoutClientAdminInput[]
    updateMany?: FeeStructureUpdateManyWithWhereWithoutClientAdminInput | FeeStructureUpdateManyWithWhereWithoutClientAdminInput[]
    deleteMany?: FeeStructureScalarWhereInput | FeeStructureScalarWhereInput[]
  }

  export type StudentFeeUncheckedUpdateManyWithoutClientAdminNestedInput = {
    create?: XOR<StudentFeeCreateWithoutClientAdminInput, StudentFeeUncheckedCreateWithoutClientAdminInput> | StudentFeeCreateWithoutClientAdminInput[] | StudentFeeUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: StudentFeeCreateOrConnectWithoutClientAdminInput | StudentFeeCreateOrConnectWithoutClientAdminInput[]
    upsert?: StudentFeeUpsertWithWhereUniqueWithoutClientAdminInput | StudentFeeUpsertWithWhereUniqueWithoutClientAdminInput[]
    createMany?: StudentFeeCreateManyClientAdminInputEnvelope
    set?: StudentFeeWhereUniqueInput | StudentFeeWhereUniqueInput[]
    disconnect?: StudentFeeWhereUniqueInput | StudentFeeWhereUniqueInput[]
    delete?: StudentFeeWhereUniqueInput | StudentFeeWhereUniqueInput[]
    connect?: StudentFeeWhereUniqueInput | StudentFeeWhereUniqueInput[]
    update?: StudentFeeUpdateWithWhereUniqueWithoutClientAdminInput | StudentFeeUpdateWithWhereUniqueWithoutClientAdminInput[]
    updateMany?: StudentFeeUpdateManyWithWhereWithoutClientAdminInput | StudentFeeUpdateManyWithWhereWithoutClientAdminInput[]
    deleteMany?: StudentFeeScalarWhereInput | StudentFeeScalarWhereInput[]
  }

  export type StationeryIssueUncheckedUpdateManyWithoutClientAdminNestedInput = {
    create?: XOR<StationeryIssueCreateWithoutClientAdminInput, StationeryIssueUncheckedCreateWithoutClientAdminInput> | StationeryIssueCreateWithoutClientAdminInput[] | StationeryIssueUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: StationeryIssueCreateOrConnectWithoutClientAdminInput | StationeryIssueCreateOrConnectWithoutClientAdminInput[]
    upsert?: StationeryIssueUpsertWithWhereUniqueWithoutClientAdminInput | StationeryIssueUpsertWithWhereUniqueWithoutClientAdminInput[]
    createMany?: StationeryIssueCreateManyClientAdminInputEnvelope
    set?: StationeryIssueWhereUniqueInput | StationeryIssueWhereUniqueInput[]
    disconnect?: StationeryIssueWhereUniqueInput | StationeryIssueWhereUniqueInput[]
    delete?: StationeryIssueWhereUniqueInput | StationeryIssueWhereUniqueInput[]
    connect?: StationeryIssueWhereUniqueInput | StationeryIssueWhereUniqueInput[]
    update?: StationeryIssueUpdateWithWhereUniqueWithoutClientAdminInput | StationeryIssueUpdateWithWhereUniqueWithoutClientAdminInput[]
    updateMany?: StationeryIssueUpdateManyWithWhereWithoutClientAdminInput | StationeryIssueUpdateManyWithWhereWithoutClientAdminInput[]
    deleteMany?: StationeryIssueScalarWhereInput | StationeryIssueScalarWhereInput[]
  }

  export type AttendanceRecordUncheckedUpdateManyWithoutClientAdminNestedInput = {
    create?: XOR<AttendanceRecordCreateWithoutClientAdminInput, AttendanceRecordUncheckedCreateWithoutClientAdminInput> | AttendanceRecordCreateWithoutClientAdminInput[] | AttendanceRecordUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: AttendanceRecordCreateOrConnectWithoutClientAdminInput | AttendanceRecordCreateOrConnectWithoutClientAdminInput[]
    upsert?: AttendanceRecordUpsertWithWhereUniqueWithoutClientAdminInput | AttendanceRecordUpsertWithWhereUniqueWithoutClientAdminInput[]
    createMany?: AttendanceRecordCreateManyClientAdminInputEnvelope
    set?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    disconnect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    delete?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    connect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    update?: AttendanceRecordUpdateWithWhereUniqueWithoutClientAdminInput | AttendanceRecordUpdateWithWhereUniqueWithoutClientAdminInput[]
    updateMany?: AttendanceRecordUpdateManyWithWhereWithoutClientAdminInput | AttendanceRecordUpdateManyWithWhereWithoutClientAdminInput[]
    deleteMany?: AttendanceRecordScalarWhereInput | AttendanceRecordScalarWhereInput[]
  }

  export type StudentTaskUncheckedUpdateManyWithoutClientAdminNestedInput = {
    create?: XOR<StudentTaskCreateWithoutClientAdminInput, StudentTaskUncheckedCreateWithoutClientAdminInput> | StudentTaskCreateWithoutClientAdminInput[] | StudentTaskUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: StudentTaskCreateOrConnectWithoutClientAdminInput | StudentTaskCreateOrConnectWithoutClientAdminInput[]
    upsert?: StudentTaskUpsertWithWhereUniqueWithoutClientAdminInput | StudentTaskUpsertWithWhereUniqueWithoutClientAdminInput[]
    createMany?: StudentTaskCreateManyClientAdminInputEnvelope
    set?: StudentTaskWhereUniqueInput | StudentTaskWhereUniqueInput[]
    disconnect?: StudentTaskWhereUniqueInput | StudentTaskWhereUniqueInput[]
    delete?: StudentTaskWhereUniqueInput | StudentTaskWhereUniqueInput[]
    connect?: StudentTaskWhereUniqueInput | StudentTaskWhereUniqueInput[]
    update?: StudentTaskUpdateWithWhereUniqueWithoutClientAdminInput | StudentTaskUpdateWithWhereUniqueWithoutClientAdminInput[]
    updateMany?: StudentTaskUpdateManyWithWhereWithoutClientAdminInput | StudentTaskUpdateManyWithWhereWithoutClientAdminInput[]
    deleteMany?: StudentTaskScalarWhereInput | StudentTaskScalarWhereInput[]
  }

  export type StudentTestUncheckedUpdateManyWithoutClientAdminNestedInput = {
    create?: XOR<StudentTestCreateWithoutClientAdminInput, StudentTestUncheckedCreateWithoutClientAdminInput> | StudentTestCreateWithoutClientAdminInput[] | StudentTestUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: StudentTestCreateOrConnectWithoutClientAdminInput | StudentTestCreateOrConnectWithoutClientAdminInput[]
    upsert?: StudentTestUpsertWithWhereUniqueWithoutClientAdminInput | StudentTestUpsertWithWhereUniqueWithoutClientAdminInput[]
    createMany?: StudentTestCreateManyClientAdminInputEnvelope
    set?: StudentTestWhereUniqueInput | StudentTestWhereUniqueInput[]
    disconnect?: StudentTestWhereUniqueInput | StudentTestWhereUniqueInput[]
    delete?: StudentTestWhereUniqueInput | StudentTestWhereUniqueInput[]
    connect?: StudentTestWhereUniqueInput | StudentTestWhereUniqueInput[]
    update?: StudentTestUpdateWithWhereUniqueWithoutClientAdminInput | StudentTestUpdateWithWhereUniqueWithoutClientAdminInput[]
    updateMany?: StudentTestUpdateManyWithWhereWithoutClientAdminInput | StudentTestUpdateManyWithWhereWithoutClientAdminInput[]
    deleteMany?: StudentTestScalarWhereInput | StudentTestScalarWhereInput[]
  }

  export type CourseCompletionUncheckedUpdateManyWithoutClientAdminNestedInput = {
    create?: XOR<CourseCompletionCreateWithoutClientAdminInput, CourseCompletionUncheckedCreateWithoutClientAdminInput> | CourseCompletionCreateWithoutClientAdminInput[] | CourseCompletionUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: CourseCompletionCreateOrConnectWithoutClientAdminInput | CourseCompletionCreateOrConnectWithoutClientAdminInput[]
    upsert?: CourseCompletionUpsertWithWhereUniqueWithoutClientAdminInput | CourseCompletionUpsertWithWhereUniqueWithoutClientAdminInput[]
    createMany?: CourseCompletionCreateManyClientAdminInputEnvelope
    set?: CourseCompletionWhereUniqueInput | CourseCompletionWhereUniqueInput[]
    disconnect?: CourseCompletionWhereUniqueInput | CourseCompletionWhereUniqueInput[]
    delete?: CourseCompletionWhereUniqueInput | CourseCompletionWhereUniqueInput[]
    connect?: CourseCompletionWhereUniqueInput | CourseCompletionWhereUniqueInput[]
    update?: CourseCompletionUpdateWithWhereUniqueWithoutClientAdminInput | CourseCompletionUpdateWithWhereUniqueWithoutClientAdminInput[]
    updateMany?: CourseCompletionUpdateManyWithWhereWithoutClientAdminInput | CourseCompletionUpdateManyWithWhereWithoutClientAdminInput[]
    deleteMany?: CourseCompletionScalarWhereInput | CourseCompletionScalarWhereInput[]
  }

  export type CertificateUncheckedUpdateManyWithoutClientAdminNestedInput = {
    create?: XOR<CertificateCreateWithoutClientAdminInput, CertificateUncheckedCreateWithoutClientAdminInput> | CertificateCreateWithoutClientAdminInput[] | CertificateUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutClientAdminInput | CertificateCreateOrConnectWithoutClientAdminInput[]
    upsert?: CertificateUpsertWithWhereUniqueWithoutClientAdminInput | CertificateUpsertWithWhereUniqueWithoutClientAdminInput[]
    createMany?: CertificateCreateManyClientAdminInputEnvelope
    set?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    disconnect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    delete?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    update?: CertificateUpdateWithWhereUniqueWithoutClientAdminInput | CertificateUpdateWithWhereUniqueWithoutClientAdminInput[]
    updateMany?: CertificateUpdateManyWithWhereWithoutClientAdminInput | CertificateUpdateManyWithWhereWithoutClientAdminInput[]
    deleteMany?: CertificateScalarWhereInput | CertificateScalarWhereInput[]
  }

  export type FinancialRecordUncheckedUpdateManyWithoutClientAdminNestedInput = {
    create?: XOR<FinancialRecordCreateWithoutClientAdminInput, FinancialRecordUncheckedCreateWithoutClientAdminInput> | FinancialRecordCreateWithoutClientAdminInput[] | FinancialRecordUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: FinancialRecordCreateOrConnectWithoutClientAdminInput | FinancialRecordCreateOrConnectWithoutClientAdminInput[]
    upsert?: FinancialRecordUpsertWithWhereUniqueWithoutClientAdminInput | FinancialRecordUpsertWithWhereUniqueWithoutClientAdminInput[]
    createMany?: FinancialRecordCreateManyClientAdminInputEnvelope
    set?: FinancialRecordWhereUniqueInput | FinancialRecordWhereUniqueInput[]
    disconnect?: FinancialRecordWhereUniqueInput | FinancialRecordWhereUniqueInput[]
    delete?: FinancialRecordWhereUniqueInput | FinancialRecordWhereUniqueInput[]
    connect?: FinancialRecordWhereUniqueInput | FinancialRecordWhereUniqueInput[]
    update?: FinancialRecordUpdateWithWhereUniqueWithoutClientAdminInput | FinancialRecordUpdateWithWhereUniqueWithoutClientAdminInput[]
    updateMany?: FinancialRecordUpdateManyWithWhereWithoutClientAdminInput | FinancialRecordUpdateManyWithWhereWithoutClientAdminInput[]
    deleteMany?: FinancialRecordScalarWhereInput | FinancialRecordScalarWhereInput[]
  }

  export type EnquiryUncheckedUpdateManyWithoutClientAdminNestedInput = {
    create?: XOR<EnquiryCreateWithoutClientAdminInput, EnquiryUncheckedCreateWithoutClientAdminInput> | EnquiryCreateWithoutClientAdminInput[] | EnquiryUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: EnquiryCreateOrConnectWithoutClientAdminInput | EnquiryCreateOrConnectWithoutClientAdminInput[]
    upsert?: EnquiryUpsertWithWhereUniqueWithoutClientAdminInput | EnquiryUpsertWithWhereUniqueWithoutClientAdminInput[]
    createMany?: EnquiryCreateManyClientAdminInputEnvelope
    set?: EnquiryWhereUniqueInput | EnquiryWhereUniqueInput[]
    disconnect?: EnquiryWhereUniqueInput | EnquiryWhereUniqueInput[]
    delete?: EnquiryWhereUniqueInput | EnquiryWhereUniqueInput[]
    connect?: EnquiryWhereUniqueInput | EnquiryWhereUniqueInput[]
    update?: EnquiryUpdateWithWhereUniqueWithoutClientAdminInput | EnquiryUpdateWithWhereUniqueWithoutClientAdminInput[]
    updateMany?: EnquiryUpdateManyWithWhereWithoutClientAdminInput | EnquiryUpdateManyWithWhereWithoutClientAdminInput[]
    deleteMany?: EnquiryScalarWhereInput | EnquiryScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutClientAdminNestedInput = {
    create?: XOR<NotificationCreateWithoutClientAdminInput, NotificationUncheckedCreateWithoutClientAdminInput> | NotificationCreateWithoutClientAdminInput[] | NotificationUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutClientAdminInput | NotificationCreateOrConnectWithoutClientAdminInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutClientAdminInput | NotificationUpsertWithWhereUniqueWithoutClientAdminInput[]
    createMany?: NotificationCreateManyClientAdminInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutClientAdminInput | NotificationUpdateWithWhereUniqueWithoutClientAdminInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutClientAdminInput | NotificationUpdateManyWithWhereWithoutClientAdminInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type CourseFeeStructureUncheckedUpdateManyWithoutClientAdminNestedInput = {
    create?: XOR<CourseFeeStructureCreateWithoutClientAdminInput, CourseFeeStructureUncheckedCreateWithoutClientAdminInput> | CourseFeeStructureCreateWithoutClientAdminInput[] | CourseFeeStructureUncheckedCreateWithoutClientAdminInput[]
    connectOrCreate?: CourseFeeStructureCreateOrConnectWithoutClientAdminInput | CourseFeeStructureCreateOrConnectWithoutClientAdminInput[]
    upsert?: CourseFeeStructureUpsertWithWhereUniqueWithoutClientAdminInput | CourseFeeStructureUpsertWithWhereUniqueWithoutClientAdminInput[]
    createMany?: CourseFeeStructureCreateManyClientAdminInputEnvelope
    set?: CourseFeeStructureWhereUniqueInput | CourseFeeStructureWhereUniqueInput[]
    disconnect?: CourseFeeStructureWhereUniqueInput | CourseFeeStructureWhereUniqueInput[]
    delete?: CourseFeeStructureWhereUniqueInput | CourseFeeStructureWhereUniqueInput[]
    connect?: CourseFeeStructureWhereUniqueInput | CourseFeeStructureWhereUniqueInput[]
    update?: CourseFeeStructureUpdateWithWhereUniqueWithoutClientAdminInput | CourseFeeStructureUpdateWithWhereUniqueWithoutClientAdminInput[]
    updateMany?: CourseFeeStructureUpdateManyWithWhereWithoutClientAdminInput | CourseFeeStructureUpdateManyWithWhereWithoutClientAdminInput[]
    deleteMany?: CourseFeeStructureScalarWhereInput | CourseFeeStructureScalarWhereInput[]
  }

  export type ClientAdminCreateNestedOneWithoutRoleUsersInput = {
    create?: XOR<ClientAdminCreateWithoutRoleUsersInput, ClientAdminUncheckedCreateWithoutRoleUsersInput>
    connectOrCreate?: ClientAdminCreateOrConnectWithoutRoleUsersInput
    connect?: ClientAdminWhereUniqueInput
  }

  export type ClientAdminUpdateOneRequiredWithoutRoleUsersNestedInput = {
    create?: XOR<ClientAdminCreateWithoutRoleUsersInput, ClientAdminUncheckedCreateWithoutRoleUsersInput>
    connectOrCreate?: ClientAdminCreateOrConnectWithoutRoleUsersInput
    upsert?: ClientAdminUpsertWithoutRoleUsersInput
    connect?: ClientAdminWhereUniqueInput
    update?: XOR<XOR<ClientAdminUpdateToOneWithWhereWithoutRoleUsersInput, ClientAdminUpdateWithoutRoleUsersInput>, ClientAdminUncheckedUpdateWithoutRoleUsersInput>
  }

  export type ClientAdminCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<ClientAdminCreateWithoutActivitiesInput, ClientAdminUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: ClientAdminCreateOrConnectWithoutActivitiesInput
    connect?: ClientAdminWhereUniqueInput
  }

  export type ClientAdminUpdateOneRequiredWithoutActivitiesNestedInput = {
    create?: XOR<ClientAdminCreateWithoutActivitiesInput, ClientAdminUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: ClientAdminCreateOrConnectWithoutActivitiesInput
    upsert?: ClientAdminUpsertWithoutActivitiesInput
    connect?: ClientAdminWhereUniqueInput
    update?: XOR<XOR<ClientAdminUpdateToOneWithWhereWithoutActivitiesInput, ClientAdminUpdateWithoutActivitiesInput>, ClientAdminUncheckedUpdateWithoutActivitiesInput>
  }

  export type FollowUpCreateNestedManyWithoutEnquiryInput = {
    create?: XOR<FollowUpCreateWithoutEnquiryInput, FollowUpUncheckedCreateWithoutEnquiryInput> | FollowUpCreateWithoutEnquiryInput[] | FollowUpUncheckedCreateWithoutEnquiryInput[]
    connectOrCreate?: FollowUpCreateOrConnectWithoutEnquiryInput | FollowUpCreateOrConnectWithoutEnquiryInput[]
    createMany?: FollowUpCreateManyEnquiryInputEnvelope
    connect?: FollowUpWhereUniqueInput | FollowUpWhereUniqueInput[]
  }

  export type StudentCreateNestedOneWithoutEnquiryInput = {
    create?: XOR<StudentCreateWithoutEnquiryInput, StudentUncheckedCreateWithoutEnquiryInput>
    connectOrCreate?: StudentCreateOrConnectWithoutEnquiryInput
    connect?: StudentWhereUniqueInput
  }

  export type EnquiryCourseCreateNestedManyWithoutEnquiryInput = {
    create?: XOR<EnquiryCourseCreateWithoutEnquiryInput, EnquiryCourseUncheckedCreateWithoutEnquiryInput> | EnquiryCourseCreateWithoutEnquiryInput[] | EnquiryCourseUncheckedCreateWithoutEnquiryInput[]
    connectOrCreate?: EnquiryCourseCreateOrConnectWithoutEnquiryInput | EnquiryCourseCreateOrConnectWithoutEnquiryInput[]
    createMany?: EnquiryCourseCreateManyEnquiryInputEnvelope
    connect?: EnquiryCourseWhereUniqueInput | EnquiryCourseWhereUniqueInput[]
  }

  export type NotificationCreateNestedOneWithoutEnquiryInput = {
    create?: XOR<NotificationCreateWithoutEnquiryInput, NotificationUncheckedCreateWithoutEnquiryInput>
    connectOrCreate?: NotificationCreateOrConnectWithoutEnquiryInput
    connect?: NotificationWhereUniqueInput
  }

  export type ClientAdminCreateNestedOneWithoutEnquiriesInput = {
    create?: XOR<ClientAdminCreateWithoutEnquiriesInput, ClientAdminUncheckedCreateWithoutEnquiriesInput>
    connectOrCreate?: ClientAdminCreateOrConnectWithoutEnquiriesInput
    connect?: ClientAdminWhereUniqueInput
  }

  export type FollowUpUncheckedCreateNestedManyWithoutEnquiryInput = {
    create?: XOR<FollowUpCreateWithoutEnquiryInput, FollowUpUncheckedCreateWithoutEnquiryInput> | FollowUpCreateWithoutEnquiryInput[] | FollowUpUncheckedCreateWithoutEnquiryInput[]
    connectOrCreate?: FollowUpCreateOrConnectWithoutEnquiryInput | FollowUpCreateOrConnectWithoutEnquiryInput[]
    createMany?: FollowUpCreateManyEnquiryInputEnvelope
    connect?: FollowUpWhereUniqueInput | FollowUpWhereUniqueInput[]
  }

  export type EnquiryCourseUncheckedCreateNestedManyWithoutEnquiryInput = {
    create?: XOR<EnquiryCourseCreateWithoutEnquiryInput, EnquiryCourseUncheckedCreateWithoutEnquiryInput> | EnquiryCourseCreateWithoutEnquiryInput[] | EnquiryCourseUncheckedCreateWithoutEnquiryInput[]
    connectOrCreate?: EnquiryCourseCreateOrConnectWithoutEnquiryInput | EnquiryCourseCreateOrConnectWithoutEnquiryInput[]
    createMany?: EnquiryCourseCreateManyEnquiryInputEnvelope
    connect?: EnquiryCourseWhereUniqueInput | EnquiryCourseWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedOneWithoutEnquiryInput = {
    create?: XOR<NotificationCreateWithoutEnquiryInput, NotificationUncheckedCreateWithoutEnquiryInput>
    connectOrCreate?: NotificationCreateOrConnectWithoutEnquiryInput
    connect?: NotificationWhereUniqueInput
  }

  export type EnumLeadStatusFieldUpdateOperationsInput = {
    set?: $Enums.LeadStatus
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type FollowUpUpdateManyWithoutEnquiryNestedInput = {
    create?: XOR<FollowUpCreateWithoutEnquiryInput, FollowUpUncheckedCreateWithoutEnquiryInput> | FollowUpCreateWithoutEnquiryInput[] | FollowUpUncheckedCreateWithoutEnquiryInput[]
    connectOrCreate?: FollowUpCreateOrConnectWithoutEnquiryInput | FollowUpCreateOrConnectWithoutEnquiryInput[]
    upsert?: FollowUpUpsertWithWhereUniqueWithoutEnquiryInput | FollowUpUpsertWithWhereUniqueWithoutEnquiryInput[]
    createMany?: FollowUpCreateManyEnquiryInputEnvelope
    set?: FollowUpWhereUniqueInput | FollowUpWhereUniqueInput[]
    disconnect?: FollowUpWhereUniqueInput | FollowUpWhereUniqueInput[]
    delete?: FollowUpWhereUniqueInput | FollowUpWhereUniqueInput[]
    connect?: FollowUpWhereUniqueInput | FollowUpWhereUniqueInput[]
    update?: FollowUpUpdateWithWhereUniqueWithoutEnquiryInput | FollowUpUpdateWithWhereUniqueWithoutEnquiryInput[]
    updateMany?: FollowUpUpdateManyWithWhereWithoutEnquiryInput | FollowUpUpdateManyWithWhereWithoutEnquiryInput[]
    deleteMany?: FollowUpScalarWhereInput | FollowUpScalarWhereInput[]
  }

  export type StudentUpdateOneWithoutEnquiryNestedInput = {
    create?: XOR<StudentCreateWithoutEnquiryInput, StudentUncheckedCreateWithoutEnquiryInput>
    connectOrCreate?: StudentCreateOrConnectWithoutEnquiryInput
    upsert?: StudentUpsertWithoutEnquiryInput
    disconnect?: StudentWhereInput | boolean
    delete?: StudentWhereInput | boolean
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutEnquiryInput, StudentUpdateWithoutEnquiryInput>, StudentUncheckedUpdateWithoutEnquiryInput>
  }

  export type EnquiryCourseUpdateManyWithoutEnquiryNestedInput = {
    create?: XOR<EnquiryCourseCreateWithoutEnquiryInput, EnquiryCourseUncheckedCreateWithoutEnquiryInput> | EnquiryCourseCreateWithoutEnquiryInput[] | EnquiryCourseUncheckedCreateWithoutEnquiryInput[]
    connectOrCreate?: EnquiryCourseCreateOrConnectWithoutEnquiryInput | EnquiryCourseCreateOrConnectWithoutEnquiryInput[]
    upsert?: EnquiryCourseUpsertWithWhereUniqueWithoutEnquiryInput | EnquiryCourseUpsertWithWhereUniqueWithoutEnquiryInput[]
    createMany?: EnquiryCourseCreateManyEnquiryInputEnvelope
    set?: EnquiryCourseWhereUniqueInput | EnquiryCourseWhereUniqueInput[]
    disconnect?: EnquiryCourseWhereUniqueInput | EnquiryCourseWhereUniqueInput[]
    delete?: EnquiryCourseWhereUniqueInput | EnquiryCourseWhereUniqueInput[]
    connect?: EnquiryCourseWhereUniqueInput | EnquiryCourseWhereUniqueInput[]
    update?: EnquiryCourseUpdateWithWhereUniqueWithoutEnquiryInput | EnquiryCourseUpdateWithWhereUniqueWithoutEnquiryInput[]
    updateMany?: EnquiryCourseUpdateManyWithWhereWithoutEnquiryInput | EnquiryCourseUpdateManyWithWhereWithoutEnquiryInput[]
    deleteMany?: EnquiryCourseScalarWhereInput | EnquiryCourseScalarWhereInput[]
  }

  export type NotificationUpdateOneWithoutEnquiryNestedInput = {
    create?: XOR<NotificationCreateWithoutEnquiryInput, NotificationUncheckedCreateWithoutEnquiryInput>
    connectOrCreate?: NotificationCreateOrConnectWithoutEnquiryInput
    upsert?: NotificationUpsertWithoutEnquiryInput
    disconnect?: NotificationWhereInput | boolean
    delete?: NotificationWhereInput | boolean
    connect?: NotificationWhereUniqueInput
    update?: XOR<XOR<NotificationUpdateToOneWithWhereWithoutEnquiryInput, NotificationUpdateWithoutEnquiryInput>, NotificationUncheckedUpdateWithoutEnquiryInput>
  }

  export type ClientAdminUpdateOneRequiredWithoutEnquiriesNestedInput = {
    create?: XOR<ClientAdminCreateWithoutEnquiriesInput, ClientAdminUncheckedCreateWithoutEnquiriesInput>
    connectOrCreate?: ClientAdminCreateOrConnectWithoutEnquiriesInput
    upsert?: ClientAdminUpsertWithoutEnquiriesInput
    connect?: ClientAdminWhereUniqueInput
    update?: XOR<XOR<ClientAdminUpdateToOneWithWhereWithoutEnquiriesInput, ClientAdminUpdateWithoutEnquiriesInput>, ClientAdminUncheckedUpdateWithoutEnquiriesInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type FollowUpUncheckedUpdateManyWithoutEnquiryNestedInput = {
    create?: XOR<FollowUpCreateWithoutEnquiryInput, FollowUpUncheckedCreateWithoutEnquiryInput> | FollowUpCreateWithoutEnquiryInput[] | FollowUpUncheckedCreateWithoutEnquiryInput[]
    connectOrCreate?: FollowUpCreateOrConnectWithoutEnquiryInput | FollowUpCreateOrConnectWithoutEnquiryInput[]
    upsert?: FollowUpUpsertWithWhereUniqueWithoutEnquiryInput | FollowUpUpsertWithWhereUniqueWithoutEnquiryInput[]
    createMany?: FollowUpCreateManyEnquiryInputEnvelope
    set?: FollowUpWhereUniqueInput | FollowUpWhereUniqueInput[]
    disconnect?: FollowUpWhereUniqueInput | FollowUpWhereUniqueInput[]
    delete?: FollowUpWhereUniqueInput | FollowUpWhereUniqueInput[]
    connect?: FollowUpWhereUniqueInput | FollowUpWhereUniqueInput[]
    update?: FollowUpUpdateWithWhereUniqueWithoutEnquiryInput | FollowUpUpdateWithWhereUniqueWithoutEnquiryInput[]
    updateMany?: FollowUpUpdateManyWithWhereWithoutEnquiryInput | FollowUpUpdateManyWithWhereWithoutEnquiryInput[]
    deleteMany?: FollowUpScalarWhereInput | FollowUpScalarWhereInput[]
  }

  export type EnquiryCourseUncheckedUpdateManyWithoutEnquiryNestedInput = {
    create?: XOR<EnquiryCourseCreateWithoutEnquiryInput, EnquiryCourseUncheckedCreateWithoutEnquiryInput> | EnquiryCourseCreateWithoutEnquiryInput[] | EnquiryCourseUncheckedCreateWithoutEnquiryInput[]
    connectOrCreate?: EnquiryCourseCreateOrConnectWithoutEnquiryInput | EnquiryCourseCreateOrConnectWithoutEnquiryInput[]
    upsert?: EnquiryCourseUpsertWithWhereUniqueWithoutEnquiryInput | EnquiryCourseUpsertWithWhereUniqueWithoutEnquiryInput[]
    createMany?: EnquiryCourseCreateManyEnquiryInputEnvelope
    set?: EnquiryCourseWhereUniqueInput | EnquiryCourseWhereUniqueInput[]
    disconnect?: EnquiryCourseWhereUniqueInput | EnquiryCourseWhereUniqueInput[]
    delete?: EnquiryCourseWhereUniqueInput | EnquiryCourseWhereUniqueInput[]
    connect?: EnquiryCourseWhereUniqueInput | EnquiryCourseWhereUniqueInput[]
    update?: EnquiryCourseUpdateWithWhereUniqueWithoutEnquiryInput | EnquiryCourseUpdateWithWhereUniqueWithoutEnquiryInput[]
    updateMany?: EnquiryCourseUpdateManyWithWhereWithoutEnquiryInput | EnquiryCourseUpdateManyWithWhereWithoutEnquiryInput[]
    deleteMany?: EnquiryCourseScalarWhereInput | EnquiryCourseScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateOneWithoutEnquiryNestedInput = {
    create?: XOR<NotificationCreateWithoutEnquiryInput, NotificationUncheckedCreateWithoutEnquiryInput>
    connectOrCreate?: NotificationCreateOrConnectWithoutEnquiryInput
    upsert?: NotificationUpsertWithoutEnquiryInput
    disconnect?: NotificationWhereInput | boolean
    delete?: NotificationWhereInput | boolean
    connect?: NotificationWhereUniqueInput
    update?: XOR<XOR<NotificationUpdateToOneWithWhereWithoutEnquiryInput, NotificationUpdateWithoutEnquiryInput>, NotificationUncheckedUpdateWithoutEnquiryInput>
  }

  export type EnquiryCreateNestedOneWithoutEnquiryCourseInput = {
    create?: XOR<EnquiryCreateWithoutEnquiryCourseInput, EnquiryUncheckedCreateWithoutEnquiryCourseInput>
    connectOrCreate?: EnquiryCreateOrConnectWithoutEnquiryCourseInput
    connect?: EnquiryWhereUniqueInput
  }

  export type CourseCreateNestedOneWithoutEnquiryCourseInput = {
    create?: XOR<CourseCreateWithoutEnquiryCourseInput, CourseUncheckedCreateWithoutEnquiryCourseInput>
    connectOrCreate?: CourseCreateOrConnectWithoutEnquiryCourseInput
    connect?: CourseWhereUniqueInput
  }

  export type ClientAdminCreateNestedOneWithoutEnquiryCourseInput = {
    create?: XOR<ClientAdminCreateWithoutEnquiryCourseInput, ClientAdminUncheckedCreateWithoutEnquiryCourseInput>
    connectOrCreate?: ClientAdminCreateOrConnectWithoutEnquiryCourseInput
    connect?: ClientAdminWhereUniqueInput
  }

  export type EnquiryUpdateOneRequiredWithoutEnquiryCourseNestedInput = {
    create?: XOR<EnquiryCreateWithoutEnquiryCourseInput, EnquiryUncheckedCreateWithoutEnquiryCourseInput>
    connectOrCreate?: EnquiryCreateOrConnectWithoutEnquiryCourseInput
    upsert?: EnquiryUpsertWithoutEnquiryCourseInput
    connect?: EnquiryWhereUniqueInput
    update?: XOR<XOR<EnquiryUpdateToOneWithWhereWithoutEnquiryCourseInput, EnquiryUpdateWithoutEnquiryCourseInput>, EnquiryUncheckedUpdateWithoutEnquiryCourseInput>
  }

  export type CourseUpdateOneRequiredWithoutEnquiryCourseNestedInput = {
    create?: XOR<CourseCreateWithoutEnquiryCourseInput, CourseUncheckedCreateWithoutEnquiryCourseInput>
    connectOrCreate?: CourseCreateOrConnectWithoutEnquiryCourseInput
    upsert?: CourseUpsertWithoutEnquiryCourseInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutEnquiryCourseInput, CourseUpdateWithoutEnquiryCourseInput>, CourseUncheckedUpdateWithoutEnquiryCourseInput>
  }

  export type ClientAdminUpdateOneRequiredWithoutEnquiryCourseNestedInput = {
    create?: XOR<ClientAdminCreateWithoutEnquiryCourseInput, ClientAdminUncheckedCreateWithoutEnquiryCourseInput>
    connectOrCreate?: ClientAdminCreateOrConnectWithoutEnquiryCourseInput
    upsert?: ClientAdminUpsertWithoutEnquiryCourseInput
    connect?: ClientAdminWhereUniqueInput
    update?: XOR<XOR<ClientAdminUpdateToOneWithWhereWithoutEnquiryCourseInput, ClientAdminUpdateWithoutEnquiryCourseInput>, ClientAdminUncheckedUpdateWithoutEnquiryCourseInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnquiryCreateNestedOneWithoutFollowUpsInput = {
    create?: XOR<EnquiryCreateWithoutFollowUpsInput, EnquiryUncheckedCreateWithoutFollowUpsInput>
    connectOrCreate?: EnquiryCreateOrConnectWithoutFollowUpsInput
    connect?: EnquiryWhereUniqueInput
  }

  export type NotificationCreateNestedOneWithoutFollowUpInput = {
    create?: XOR<NotificationCreateWithoutFollowUpInput, NotificationUncheckedCreateWithoutFollowUpInput>
    connectOrCreate?: NotificationCreateOrConnectWithoutFollowUpInput
    connect?: NotificationWhereUniqueInput
  }

  export type NotificationUncheckedCreateNestedOneWithoutFollowUpInput = {
    create?: XOR<NotificationCreateWithoutFollowUpInput, NotificationUncheckedCreateWithoutFollowUpInput>
    connectOrCreate?: NotificationCreateOrConnectWithoutFollowUpInput
    connect?: NotificationWhereUniqueInput
  }

  export type EnumFollowUpStatusFieldUpdateOperationsInput = {
    set?: $Enums.FollowUpStatus
  }

  export type EnquiryUpdateOneRequiredWithoutFollowUpsNestedInput = {
    create?: XOR<EnquiryCreateWithoutFollowUpsInput, EnquiryUncheckedCreateWithoutFollowUpsInput>
    connectOrCreate?: EnquiryCreateOrConnectWithoutFollowUpsInput
    upsert?: EnquiryUpsertWithoutFollowUpsInput
    connect?: EnquiryWhereUniqueInput
    update?: XOR<XOR<EnquiryUpdateToOneWithWhereWithoutFollowUpsInput, EnquiryUpdateWithoutFollowUpsInput>, EnquiryUncheckedUpdateWithoutFollowUpsInput>
  }

  export type NotificationUpdateOneWithoutFollowUpNestedInput = {
    create?: XOR<NotificationCreateWithoutFollowUpInput, NotificationUncheckedCreateWithoutFollowUpInput>
    connectOrCreate?: NotificationCreateOrConnectWithoutFollowUpInput
    upsert?: NotificationUpsertWithoutFollowUpInput
    disconnect?: NotificationWhereInput | boolean
    delete?: NotificationWhereInput | boolean
    connect?: NotificationWhereUniqueInput
    update?: XOR<XOR<NotificationUpdateToOneWithWhereWithoutFollowUpInput, NotificationUpdateWithoutFollowUpInput>, NotificationUncheckedUpdateWithoutFollowUpInput>
  }

  export type NotificationUncheckedUpdateOneWithoutFollowUpNestedInput = {
    create?: XOR<NotificationCreateWithoutFollowUpInput, NotificationUncheckedCreateWithoutFollowUpInput>
    connectOrCreate?: NotificationCreateOrConnectWithoutFollowUpInput
    upsert?: NotificationUpsertWithoutFollowUpInput
    disconnect?: NotificationWhereInput | boolean
    delete?: NotificationWhereInput | boolean
    connect?: NotificationWhereUniqueInput
    update?: XOR<XOR<NotificationUpdateToOneWithWhereWithoutFollowUpInput, NotificationUpdateWithoutFollowUpInput>, NotificationUncheckedUpdateWithoutFollowUpInput>
  }

  export type FollowUpCreateNestedOneWithoutNotificationInput = {
    create?: XOR<FollowUpCreateWithoutNotificationInput, FollowUpUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: FollowUpCreateOrConnectWithoutNotificationInput
    connect?: FollowUpWhereUniqueInput
  }

  export type EnquiryCreateNestedOneWithoutNotificationInput = {
    create?: XOR<EnquiryCreateWithoutNotificationInput, EnquiryUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: EnquiryCreateOrConnectWithoutNotificationInput
    connect?: EnquiryWhereUniqueInput
  }

  export type StudentFeeCreateNestedOneWithoutNotificationInput = {
    create?: XOR<StudentFeeCreateWithoutNotificationInput, StudentFeeUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: StudentFeeCreateOrConnectWithoutNotificationInput
    connect?: StudentFeeWhereUniqueInput
  }

  export type ClientAdminCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<ClientAdminCreateWithoutNotificationsInput, ClientAdminUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: ClientAdminCreateOrConnectWithoutNotificationsInput
    connect?: ClientAdminWhereUniqueInput
  }

  export type FollowUpUpdateOneWithoutNotificationNestedInput = {
    create?: XOR<FollowUpCreateWithoutNotificationInput, FollowUpUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: FollowUpCreateOrConnectWithoutNotificationInput
    upsert?: FollowUpUpsertWithoutNotificationInput
    disconnect?: FollowUpWhereInput | boolean
    delete?: FollowUpWhereInput | boolean
    connect?: FollowUpWhereUniqueInput
    update?: XOR<XOR<FollowUpUpdateToOneWithWhereWithoutNotificationInput, FollowUpUpdateWithoutNotificationInput>, FollowUpUncheckedUpdateWithoutNotificationInput>
  }

  export type EnquiryUpdateOneWithoutNotificationNestedInput = {
    create?: XOR<EnquiryCreateWithoutNotificationInput, EnquiryUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: EnquiryCreateOrConnectWithoutNotificationInput
    upsert?: EnquiryUpsertWithoutNotificationInput
    disconnect?: EnquiryWhereInput | boolean
    delete?: EnquiryWhereInput | boolean
    connect?: EnquiryWhereUniqueInput
    update?: XOR<XOR<EnquiryUpdateToOneWithWhereWithoutNotificationInput, EnquiryUpdateWithoutNotificationInput>, EnquiryUncheckedUpdateWithoutNotificationInput>
  }

  export type StudentFeeUpdateOneWithoutNotificationNestedInput = {
    create?: XOR<StudentFeeCreateWithoutNotificationInput, StudentFeeUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: StudentFeeCreateOrConnectWithoutNotificationInput
    upsert?: StudentFeeUpsertWithoutNotificationInput
    disconnect?: StudentFeeWhereInput | boolean
    delete?: StudentFeeWhereInput | boolean
    connect?: StudentFeeWhereUniqueInput
    update?: XOR<XOR<StudentFeeUpdateToOneWithWhereWithoutNotificationInput, StudentFeeUpdateWithoutNotificationInput>, StudentFeeUncheckedUpdateWithoutNotificationInput>
  }

  export type ClientAdminUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<ClientAdminCreateWithoutNotificationsInput, ClientAdminUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: ClientAdminCreateOrConnectWithoutNotificationsInput
    upsert?: ClientAdminUpsertWithoutNotificationsInput
    connect?: ClientAdminWhereUniqueInput
    update?: XOR<XOR<ClientAdminUpdateToOneWithWhereWithoutNotificationsInput, ClientAdminUpdateWithoutNotificationsInput>, ClientAdminUncheckedUpdateWithoutNotificationsInput>
  }

  export type EnquiryCreateNestedOneWithoutStudentInput = {
    create?: XOR<EnquiryCreateWithoutStudentInput, EnquiryUncheckedCreateWithoutStudentInput>
    connectOrCreate?: EnquiryCreateOrConnectWithoutStudentInput
    connect?: EnquiryWhereUniqueInput
  }

  export type LabAllocationCreateNestedManyWithoutStudentInput = {
    create?: XOR<LabAllocationCreateWithoutStudentInput, LabAllocationUncheckedCreateWithoutStudentInput> | LabAllocationCreateWithoutStudentInput[] | LabAllocationUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: LabAllocationCreateOrConnectWithoutStudentInput | LabAllocationCreateOrConnectWithoutStudentInput[]
    createMany?: LabAllocationCreateManyStudentInputEnvelope
    connect?: LabAllocationWhereUniqueInput | LabAllocationWhereUniqueInput[]
  }

  export type StudentCourseCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentCourseCreateWithoutStudentInput, StudentCourseUncheckedCreateWithoutStudentInput> | StudentCourseCreateWithoutStudentInput[] | StudentCourseUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentCourseCreateOrConnectWithoutStudentInput | StudentCourseCreateOrConnectWithoutStudentInput[]
    createMany?: StudentCourseCreateManyStudentInputEnvelope
    connect?: StudentCourseWhereUniqueInput | StudentCourseWhereUniqueInput[]
  }

  export type FeeStructureCreateNestedManyWithoutStudentInput = {
    create?: XOR<FeeStructureCreateWithoutStudentInput, FeeStructureUncheckedCreateWithoutStudentInput> | FeeStructureCreateWithoutStudentInput[] | FeeStructureUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: FeeStructureCreateOrConnectWithoutStudentInput | FeeStructureCreateOrConnectWithoutStudentInput[]
    createMany?: FeeStructureCreateManyStudentInputEnvelope
    connect?: FeeStructureWhereUniqueInput | FeeStructureWhereUniqueInput[]
  }

  export type StudentFeeCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentFeeCreateWithoutStudentInput, StudentFeeUncheckedCreateWithoutStudentInput> | StudentFeeCreateWithoutStudentInput[] | StudentFeeUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentFeeCreateOrConnectWithoutStudentInput | StudentFeeCreateOrConnectWithoutStudentInput[]
    createMany?: StudentFeeCreateManyStudentInputEnvelope
    connect?: StudentFeeWhereUniqueInput | StudentFeeWhereUniqueInput[]
  }

  export type AttendanceRecordCreateNestedManyWithoutStudentInput = {
    create?: XOR<AttendanceRecordCreateWithoutStudentInput, AttendanceRecordUncheckedCreateWithoutStudentInput> | AttendanceRecordCreateWithoutStudentInput[] | AttendanceRecordUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AttendanceRecordCreateOrConnectWithoutStudentInput | AttendanceRecordCreateOrConnectWithoutStudentInput[]
    createMany?: AttendanceRecordCreateManyStudentInputEnvelope
    connect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
  }

  export type StudentTaskCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentTaskCreateWithoutStudentInput, StudentTaskUncheckedCreateWithoutStudentInput> | StudentTaskCreateWithoutStudentInput[] | StudentTaskUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentTaskCreateOrConnectWithoutStudentInput | StudentTaskCreateOrConnectWithoutStudentInput[]
    createMany?: StudentTaskCreateManyStudentInputEnvelope
    connect?: StudentTaskWhereUniqueInput | StudentTaskWhereUniqueInput[]
  }

  export type StudentTestCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentTestCreateWithoutStudentInput, StudentTestUncheckedCreateWithoutStudentInput> | StudentTestCreateWithoutStudentInput[] | StudentTestUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentTestCreateOrConnectWithoutStudentInput | StudentTestCreateOrConnectWithoutStudentInput[]
    createMany?: StudentTestCreateManyStudentInputEnvelope
    connect?: StudentTestWhereUniqueInput | StudentTestWhereUniqueInput[]
  }

  export type CourseCompletionCreateNestedManyWithoutStudentInput = {
    create?: XOR<CourseCompletionCreateWithoutStudentInput, CourseCompletionUncheckedCreateWithoutStudentInput> | CourseCompletionCreateWithoutStudentInput[] | CourseCompletionUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: CourseCompletionCreateOrConnectWithoutStudentInput | CourseCompletionCreateOrConnectWithoutStudentInput[]
    createMany?: CourseCompletionCreateManyStudentInputEnvelope
    connect?: CourseCompletionWhereUniqueInput | CourseCompletionWhereUniqueInput[]
  }

  export type StationeryIssueCreateNestedManyWithoutStudentInput = {
    create?: XOR<StationeryIssueCreateWithoutStudentInput, StationeryIssueUncheckedCreateWithoutStudentInput> | StationeryIssueCreateWithoutStudentInput[] | StationeryIssueUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StationeryIssueCreateOrConnectWithoutStudentInput | StationeryIssueCreateOrConnectWithoutStudentInput[]
    createMany?: StationeryIssueCreateManyStudentInputEnvelope
    connect?: StationeryIssueWhereUniqueInput | StationeryIssueWhereUniqueInput[]
  }

  export type CertificateCreateNestedManyWithoutStudentInput = {
    create?: XOR<CertificateCreateWithoutStudentInput, CertificateUncheckedCreateWithoutStudentInput> | CertificateCreateWithoutStudentInput[] | CertificateUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutStudentInput | CertificateCreateOrConnectWithoutStudentInput[]
    createMany?: CertificateCreateManyStudentInputEnvelope
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
  }

  export type FinancialRecordCreateNestedManyWithoutStudentInput = {
    create?: XOR<FinancialRecordCreateWithoutStudentInput, FinancialRecordUncheckedCreateWithoutStudentInput> | FinancialRecordCreateWithoutStudentInput[] | FinancialRecordUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: FinancialRecordCreateOrConnectWithoutStudentInput | FinancialRecordCreateOrConnectWithoutStudentInput[]
    createMany?: FinancialRecordCreateManyStudentInputEnvelope
    connect?: FinancialRecordWhereUniqueInput | FinancialRecordWhereUniqueInput[]
  }

  export type ClientAdminCreateNestedOneWithoutStudentsInput = {
    create?: XOR<ClientAdminCreateWithoutStudentsInput, ClientAdminUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: ClientAdminCreateOrConnectWithoutStudentsInput
    connect?: ClientAdminWhereUniqueInput
  }

  export type EnquiryUncheckedCreateNestedOneWithoutStudentInput = {
    create?: XOR<EnquiryCreateWithoutStudentInput, EnquiryUncheckedCreateWithoutStudentInput>
    connectOrCreate?: EnquiryCreateOrConnectWithoutStudentInput
    connect?: EnquiryWhereUniqueInput
  }

  export type LabAllocationUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<LabAllocationCreateWithoutStudentInput, LabAllocationUncheckedCreateWithoutStudentInput> | LabAllocationCreateWithoutStudentInput[] | LabAllocationUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: LabAllocationCreateOrConnectWithoutStudentInput | LabAllocationCreateOrConnectWithoutStudentInput[]
    createMany?: LabAllocationCreateManyStudentInputEnvelope
    connect?: LabAllocationWhereUniqueInput | LabAllocationWhereUniqueInput[]
  }

  export type StudentCourseUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentCourseCreateWithoutStudentInput, StudentCourseUncheckedCreateWithoutStudentInput> | StudentCourseCreateWithoutStudentInput[] | StudentCourseUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentCourseCreateOrConnectWithoutStudentInput | StudentCourseCreateOrConnectWithoutStudentInput[]
    createMany?: StudentCourseCreateManyStudentInputEnvelope
    connect?: StudentCourseWhereUniqueInput | StudentCourseWhereUniqueInput[]
  }

  export type FeeStructureUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<FeeStructureCreateWithoutStudentInput, FeeStructureUncheckedCreateWithoutStudentInput> | FeeStructureCreateWithoutStudentInput[] | FeeStructureUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: FeeStructureCreateOrConnectWithoutStudentInput | FeeStructureCreateOrConnectWithoutStudentInput[]
    createMany?: FeeStructureCreateManyStudentInputEnvelope
    connect?: FeeStructureWhereUniqueInput | FeeStructureWhereUniqueInput[]
  }

  export type StudentFeeUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentFeeCreateWithoutStudentInput, StudentFeeUncheckedCreateWithoutStudentInput> | StudentFeeCreateWithoutStudentInput[] | StudentFeeUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentFeeCreateOrConnectWithoutStudentInput | StudentFeeCreateOrConnectWithoutStudentInput[]
    createMany?: StudentFeeCreateManyStudentInputEnvelope
    connect?: StudentFeeWhereUniqueInput | StudentFeeWhereUniqueInput[]
  }

  export type AttendanceRecordUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<AttendanceRecordCreateWithoutStudentInput, AttendanceRecordUncheckedCreateWithoutStudentInput> | AttendanceRecordCreateWithoutStudentInput[] | AttendanceRecordUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AttendanceRecordCreateOrConnectWithoutStudentInput | AttendanceRecordCreateOrConnectWithoutStudentInput[]
    createMany?: AttendanceRecordCreateManyStudentInputEnvelope
    connect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
  }

  export type StudentTaskUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentTaskCreateWithoutStudentInput, StudentTaskUncheckedCreateWithoutStudentInput> | StudentTaskCreateWithoutStudentInput[] | StudentTaskUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentTaskCreateOrConnectWithoutStudentInput | StudentTaskCreateOrConnectWithoutStudentInput[]
    createMany?: StudentTaskCreateManyStudentInputEnvelope
    connect?: StudentTaskWhereUniqueInput | StudentTaskWhereUniqueInput[]
  }

  export type StudentTestUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentTestCreateWithoutStudentInput, StudentTestUncheckedCreateWithoutStudentInput> | StudentTestCreateWithoutStudentInput[] | StudentTestUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentTestCreateOrConnectWithoutStudentInput | StudentTestCreateOrConnectWithoutStudentInput[]
    createMany?: StudentTestCreateManyStudentInputEnvelope
    connect?: StudentTestWhereUniqueInput | StudentTestWhereUniqueInput[]
  }

  export type CourseCompletionUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<CourseCompletionCreateWithoutStudentInput, CourseCompletionUncheckedCreateWithoutStudentInput> | CourseCompletionCreateWithoutStudentInput[] | CourseCompletionUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: CourseCompletionCreateOrConnectWithoutStudentInput | CourseCompletionCreateOrConnectWithoutStudentInput[]
    createMany?: CourseCompletionCreateManyStudentInputEnvelope
    connect?: CourseCompletionWhereUniqueInput | CourseCompletionWhereUniqueInput[]
  }

  export type StationeryIssueUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<StationeryIssueCreateWithoutStudentInput, StationeryIssueUncheckedCreateWithoutStudentInput> | StationeryIssueCreateWithoutStudentInput[] | StationeryIssueUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StationeryIssueCreateOrConnectWithoutStudentInput | StationeryIssueCreateOrConnectWithoutStudentInput[]
    createMany?: StationeryIssueCreateManyStudentInputEnvelope
    connect?: StationeryIssueWhereUniqueInput | StationeryIssueWhereUniqueInput[]
  }

  export type CertificateUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<CertificateCreateWithoutStudentInput, CertificateUncheckedCreateWithoutStudentInput> | CertificateCreateWithoutStudentInput[] | CertificateUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutStudentInput | CertificateCreateOrConnectWithoutStudentInput[]
    createMany?: CertificateCreateManyStudentInputEnvelope
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
  }

  export type FinancialRecordUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<FinancialRecordCreateWithoutStudentInput, FinancialRecordUncheckedCreateWithoutStudentInput> | FinancialRecordCreateWithoutStudentInput[] | FinancialRecordUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: FinancialRecordCreateOrConnectWithoutStudentInput | FinancialRecordCreateOrConnectWithoutStudentInput[]
    createMany?: FinancialRecordCreateManyStudentInputEnvelope
    connect?: FinancialRecordWhereUniqueInput | FinancialRecordWhereUniqueInput[]
  }

  export type EnquiryUpdateOneWithoutStudentNestedInput = {
    create?: XOR<EnquiryCreateWithoutStudentInput, EnquiryUncheckedCreateWithoutStudentInput>
    connectOrCreate?: EnquiryCreateOrConnectWithoutStudentInput
    upsert?: EnquiryUpsertWithoutStudentInput
    disconnect?: EnquiryWhereInput | boolean
    delete?: EnquiryWhereInput | boolean
    connect?: EnquiryWhereUniqueInput
    update?: XOR<XOR<EnquiryUpdateToOneWithWhereWithoutStudentInput, EnquiryUpdateWithoutStudentInput>, EnquiryUncheckedUpdateWithoutStudentInput>
  }

  export type LabAllocationUpdateManyWithoutStudentNestedInput = {
    create?: XOR<LabAllocationCreateWithoutStudentInput, LabAllocationUncheckedCreateWithoutStudentInput> | LabAllocationCreateWithoutStudentInput[] | LabAllocationUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: LabAllocationCreateOrConnectWithoutStudentInput | LabAllocationCreateOrConnectWithoutStudentInput[]
    upsert?: LabAllocationUpsertWithWhereUniqueWithoutStudentInput | LabAllocationUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: LabAllocationCreateManyStudentInputEnvelope
    set?: LabAllocationWhereUniqueInput | LabAllocationWhereUniqueInput[]
    disconnect?: LabAllocationWhereUniqueInput | LabAllocationWhereUniqueInput[]
    delete?: LabAllocationWhereUniqueInput | LabAllocationWhereUniqueInput[]
    connect?: LabAllocationWhereUniqueInput | LabAllocationWhereUniqueInput[]
    update?: LabAllocationUpdateWithWhereUniqueWithoutStudentInput | LabAllocationUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: LabAllocationUpdateManyWithWhereWithoutStudentInput | LabAllocationUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: LabAllocationScalarWhereInput | LabAllocationScalarWhereInput[]
  }

  export type StudentCourseUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentCourseCreateWithoutStudentInput, StudentCourseUncheckedCreateWithoutStudentInput> | StudentCourseCreateWithoutStudentInput[] | StudentCourseUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentCourseCreateOrConnectWithoutStudentInput | StudentCourseCreateOrConnectWithoutStudentInput[]
    upsert?: StudentCourseUpsertWithWhereUniqueWithoutStudentInput | StudentCourseUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentCourseCreateManyStudentInputEnvelope
    set?: StudentCourseWhereUniqueInput | StudentCourseWhereUniqueInput[]
    disconnect?: StudentCourseWhereUniqueInput | StudentCourseWhereUniqueInput[]
    delete?: StudentCourseWhereUniqueInput | StudentCourseWhereUniqueInput[]
    connect?: StudentCourseWhereUniqueInput | StudentCourseWhereUniqueInput[]
    update?: StudentCourseUpdateWithWhereUniqueWithoutStudentInput | StudentCourseUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentCourseUpdateManyWithWhereWithoutStudentInput | StudentCourseUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentCourseScalarWhereInput | StudentCourseScalarWhereInput[]
  }

  export type FeeStructureUpdateManyWithoutStudentNestedInput = {
    create?: XOR<FeeStructureCreateWithoutStudentInput, FeeStructureUncheckedCreateWithoutStudentInput> | FeeStructureCreateWithoutStudentInput[] | FeeStructureUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: FeeStructureCreateOrConnectWithoutStudentInput | FeeStructureCreateOrConnectWithoutStudentInput[]
    upsert?: FeeStructureUpsertWithWhereUniqueWithoutStudentInput | FeeStructureUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: FeeStructureCreateManyStudentInputEnvelope
    set?: FeeStructureWhereUniqueInput | FeeStructureWhereUniqueInput[]
    disconnect?: FeeStructureWhereUniqueInput | FeeStructureWhereUniqueInput[]
    delete?: FeeStructureWhereUniqueInput | FeeStructureWhereUniqueInput[]
    connect?: FeeStructureWhereUniqueInput | FeeStructureWhereUniqueInput[]
    update?: FeeStructureUpdateWithWhereUniqueWithoutStudentInput | FeeStructureUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: FeeStructureUpdateManyWithWhereWithoutStudentInput | FeeStructureUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: FeeStructureScalarWhereInput | FeeStructureScalarWhereInput[]
  }

  export type StudentFeeUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentFeeCreateWithoutStudentInput, StudentFeeUncheckedCreateWithoutStudentInput> | StudentFeeCreateWithoutStudentInput[] | StudentFeeUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentFeeCreateOrConnectWithoutStudentInput | StudentFeeCreateOrConnectWithoutStudentInput[]
    upsert?: StudentFeeUpsertWithWhereUniqueWithoutStudentInput | StudentFeeUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentFeeCreateManyStudentInputEnvelope
    set?: StudentFeeWhereUniqueInput | StudentFeeWhereUniqueInput[]
    disconnect?: StudentFeeWhereUniqueInput | StudentFeeWhereUniqueInput[]
    delete?: StudentFeeWhereUniqueInput | StudentFeeWhereUniqueInput[]
    connect?: StudentFeeWhereUniqueInput | StudentFeeWhereUniqueInput[]
    update?: StudentFeeUpdateWithWhereUniqueWithoutStudentInput | StudentFeeUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentFeeUpdateManyWithWhereWithoutStudentInput | StudentFeeUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentFeeScalarWhereInput | StudentFeeScalarWhereInput[]
  }

  export type AttendanceRecordUpdateManyWithoutStudentNestedInput = {
    create?: XOR<AttendanceRecordCreateWithoutStudentInput, AttendanceRecordUncheckedCreateWithoutStudentInput> | AttendanceRecordCreateWithoutStudentInput[] | AttendanceRecordUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AttendanceRecordCreateOrConnectWithoutStudentInput | AttendanceRecordCreateOrConnectWithoutStudentInput[]
    upsert?: AttendanceRecordUpsertWithWhereUniqueWithoutStudentInput | AttendanceRecordUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: AttendanceRecordCreateManyStudentInputEnvelope
    set?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    disconnect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    delete?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    connect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    update?: AttendanceRecordUpdateWithWhereUniqueWithoutStudentInput | AttendanceRecordUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: AttendanceRecordUpdateManyWithWhereWithoutStudentInput | AttendanceRecordUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: AttendanceRecordScalarWhereInput | AttendanceRecordScalarWhereInput[]
  }

  export type StudentTaskUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentTaskCreateWithoutStudentInput, StudentTaskUncheckedCreateWithoutStudentInput> | StudentTaskCreateWithoutStudentInput[] | StudentTaskUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentTaskCreateOrConnectWithoutStudentInput | StudentTaskCreateOrConnectWithoutStudentInput[]
    upsert?: StudentTaskUpsertWithWhereUniqueWithoutStudentInput | StudentTaskUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentTaskCreateManyStudentInputEnvelope
    set?: StudentTaskWhereUniqueInput | StudentTaskWhereUniqueInput[]
    disconnect?: StudentTaskWhereUniqueInput | StudentTaskWhereUniqueInput[]
    delete?: StudentTaskWhereUniqueInput | StudentTaskWhereUniqueInput[]
    connect?: StudentTaskWhereUniqueInput | StudentTaskWhereUniqueInput[]
    update?: StudentTaskUpdateWithWhereUniqueWithoutStudentInput | StudentTaskUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentTaskUpdateManyWithWhereWithoutStudentInput | StudentTaskUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentTaskScalarWhereInput | StudentTaskScalarWhereInput[]
  }

  export type StudentTestUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentTestCreateWithoutStudentInput, StudentTestUncheckedCreateWithoutStudentInput> | StudentTestCreateWithoutStudentInput[] | StudentTestUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentTestCreateOrConnectWithoutStudentInput | StudentTestCreateOrConnectWithoutStudentInput[]
    upsert?: StudentTestUpsertWithWhereUniqueWithoutStudentInput | StudentTestUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentTestCreateManyStudentInputEnvelope
    set?: StudentTestWhereUniqueInput | StudentTestWhereUniqueInput[]
    disconnect?: StudentTestWhereUniqueInput | StudentTestWhereUniqueInput[]
    delete?: StudentTestWhereUniqueInput | StudentTestWhereUniqueInput[]
    connect?: StudentTestWhereUniqueInput | StudentTestWhereUniqueInput[]
    update?: StudentTestUpdateWithWhereUniqueWithoutStudentInput | StudentTestUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentTestUpdateManyWithWhereWithoutStudentInput | StudentTestUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentTestScalarWhereInput | StudentTestScalarWhereInput[]
  }

  export type CourseCompletionUpdateManyWithoutStudentNestedInput = {
    create?: XOR<CourseCompletionCreateWithoutStudentInput, CourseCompletionUncheckedCreateWithoutStudentInput> | CourseCompletionCreateWithoutStudentInput[] | CourseCompletionUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: CourseCompletionCreateOrConnectWithoutStudentInput | CourseCompletionCreateOrConnectWithoutStudentInput[]
    upsert?: CourseCompletionUpsertWithWhereUniqueWithoutStudentInput | CourseCompletionUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: CourseCompletionCreateManyStudentInputEnvelope
    set?: CourseCompletionWhereUniqueInput | CourseCompletionWhereUniqueInput[]
    disconnect?: CourseCompletionWhereUniqueInput | CourseCompletionWhereUniqueInput[]
    delete?: CourseCompletionWhereUniqueInput | CourseCompletionWhereUniqueInput[]
    connect?: CourseCompletionWhereUniqueInput | CourseCompletionWhereUniqueInput[]
    update?: CourseCompletionUpdateWithWhereUniqueWithoutStudentInput | CourseCompletionUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: CourseCompletionUpdateManyWithWhereWithoutStudentInput | CourseCompletionUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: CourseCompletionScalarWhereInput | CourseCompletionScalarWhereInput[]
  }

  export type StationeryIssueUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StationeryIssueCreateWithoutStudentInput, StationeryIssueUncheckedCreateWithoutStudentInput> | StationeryIssueCreateWithoutStudentInput[] | StationeryIssueUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StationeryIssueCreateOrConnectWithoutStudentInput | StationeryIssueCreateOrConnectWithoutStudentInput[]
    upsert?: StationeryIssueUpsertWithWhereUniqueWithoutStudentInput | StationeryIssueUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StationeryIssueCreateManyStudentInputEnvelope
    set?: StationeryIssueWhereUniqueInput | StationeryIssueWhereUniqueInput[]
    disconnect?: StationeryIssueWhereUniqueInput | StationeryIssueWhereUniqueInput[]
    delete?: StationeryIssueWhereUniqueInput | StationeryIssueWhereUniqueInput[]
    connect?: StationeryIssueWhereUniqueInput | StationeryIssueWhereUniqueInput[]
    update?: StationeryIssueUpdateWithWhereUniqueWithoutStudentInput | StationeryIssueUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StationeryIssueUpdateManyWithWhereWithoutStudentInput | StationeryIssueUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StationeryIssueScalarWhereInput | StationeryIssueScalarWhereInput[]
  }

  export type CertificateUpdateManyWithoutStudentNestedInput = {
    create?: XOR<CertificateCreateWithoutStudentInput, CertificateUncheckedCreateWithoutStudentInput> | CertificateCreateWithoutStudentInput[] | CertificateUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutStudentInput | CertificateCreateOrConnectWithoutStudentInput[]
    upsert?: CertificateUpsertWithWhereUniqueWithoutStudentInput | CertificateUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: CertificateCreateManyStudentInputEnvelope
    set?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    disconnect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    delete?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    update?: CertificateUpdateWithWhereUniqueWithoutStudentInput | CertificateUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: CertificateUpdateManyWithWhereWithoutStudentInput | CertificateUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: CertificateScalarWhereInput | CertificateScalarWhereInput[]
  }

  export type FinancialRecordUpdateManyWithoutStudentNestedInput = {
    create?: XOR<FinancialRecordCreateWithoutStudentInput, FinancialRecordUncheckedCreateWithoutStudentInput> | FinancialRecordCreateWithoutStudentInput[] | FinancialRecordUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: FinancialRecordCreateOrConnectWithoutStudentInput | FinancialRecordCreateOrConnectWithoutStudentInput[]
    upsert?: FinancialRecordUpsertWithWhereUniqueWithoutStudentInput | FinancialRecordUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: FinancialRecordCreateManyStudentInputEnvelope
    set?: FinancialRecordWhereUniqueInput | FinancialRecordWhereUniqueInput[]
    disconnect?: FinancialRecordWhereUniqueInput | FinancialRecordWhereUniqueInput[]
    delete?: FinancialRecordWhereUniqueInput | FinancialRecordWhereUniqueInput[]
    connect?: FinancialRecordWhereUniqueInput | FinancialRecordWhereUniqueInput[]
    update?: FinancialRecordUpdateWithWhereUniqueWithoutStudentInput | FinancialRecordUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: FinancialRecordUpdateManyWithWhereWithoutStudentInput | FinancialRecordUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: FinancialRecordScalarWhereInput | FinancialRecordScalarWhereInput[]
  }

  export type ClientAdminUpdateOneRequiredWithoutStudentsNestedInput = {
    create?: XOR<ClientAdminCreateWithoutStudentsInput, ClientAdminUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: ClientAdminCreateOrConnectWithoutStudentsInput
    upsert?: ClientAdminUpsertWithoutStudentsInput
    connect?: ClientAdminWhereUniqueInput
    update?: XOR<XOR<ClientAdminUpdateToOneWithWhereWithoutStudentsInput, ClientAdminUpdateWithoutStudentsInput>, ClientAdminUncheckedUpdateWithoutStudentsInput>
  }

  export type EnquiryUncheckedUpdateOneWithoutStudentNestedInput = {
    create?: XOR<EnquiryCreateWithoutStudentInput, EnquiryUncheckedCreateWithoutStudentInput>
    connectOrCreate?: EnquiryCreateOrConnectWithoutStudentInput
    upsert?: EnquiryUpsertWithoutStudentInput
    disconnect?: EnquiryWhereInput | boolean
    delete?: EnquiryWhereInput | boolean
    connect?: EnquiryWhereUniqueInput
    update?: XOR<XOR<EnquiryUpdateToOneWithWhereWithoutStudentInput, EnquiryUpdateWithoutStudentInput>, EnquiryUncheckedUpdateWithoutStudentInput>
  }

  export type LabAllocationUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<LabAllocationCreateWithoutStudentInput, LabAllocationUncheckedCreateWithoutStudentInput> | LabAllocationCreateWithoutStudentInput[] | LabAllocationUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: LabAllocationCreateOrConnectWithoutStudentInput | LabAllocationCreateOrConnectWithoutStudentInput[]
    upsert?: LabAllocationUpsertWithWhereUniqueWithoutStudentInput | LabAllocationUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: LabAllocationCreateManyStudentInputEnvelope
    set?: LabAllocationWhereUniqueInput | LabAllocationWhereUniqueInput[]
    disconnect?: LabAllocationWhereUniqueInput | LabAllocationWhereUniqueInput[]
    delete?: LabAllocationWhereUniqueInput | LabAllocationWhereUniqueInput[]
    connect?: LabAllocationWhereUniqueInput | LabAllocationWhereUniqueInput[]
    update?: LabAllocationUpdateWithWhereUniqueWithoutStudentInput | LabAllocationUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: LabAllocationUpdateManyWithWhereWithoutStudentInput | LabAllocationUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: LabAllocationScalarWhereInput | LabAllocationScalarWhereInput[]
  }

  export type StudentCourseUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentCourseCreateWithoutStudentInput, StudentCourseUncheckedCreateWithoutStudentInput> | StudentCourseCreateWithoutStudentInput[] | StudentCourseUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentCourseCreateOrConnectWithoutStudentInput | StudentCourseCreateOrConnectWithoutStudentInput[]
    upsert?: StudentCourseUpsertWithWhereUniqueWithoutStudentInput | StudentCourseUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentCourseCreateManyStudentInputEnvelope
    set?: StudentCourseWhereUniqueInput | StudentCourseWhereUniqueInput[]
    disconnect?: StudentCourseWhereUniqueInput | StudentCourseWhereUniqueInput[]
    delete?: StudentCourseWhereUniqueInput | StudentCourseWhereUniqueInput[]
    connect?: StudentCourseWhereUniqueInput | StudentCourseWhereUniqueInput[]
    update?: StudentCourseUpdateWithWhereUniqueWithoutStudentInput | StudentCourseUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentCourseUpdateManyWithWhereWithoutStudentInput | StudentCourseUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentCourseScalarWhereInput | StudentCourseScalarWhereInput[]
  }

  export type FeeStructureUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<FeeStructureCreateWithoutStudentInput, FeeStructureUncheckedCreateWithoutStudentInput> | FeeStructureCreateWithoutStudentInput[] | FeeStructureUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: FeeStructureCreateOrConnectWithoutStudentInput | FeeStructureCreateOrConnectWithoutStudentInput[]
    upsert?: FeeStructureUpsertWithWhereUniqueWithoutStudentInput | FeeStructureUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: FeeStructureCreateManyStudentInputEnvelope
    set?: FeeStructureWhereUniqueInput | FeeStructureWhereUniqueInput[]
    disconnect?: FeeStructureWhereUniqueInput | FeeStructureWhereUniqueInput[]
    delete?: FeeStructureWhereUniqueInput | FeeStructureWhereUniqueInput[]
    connect?: FeeStructureWhereUniqueInput | FeeStructureWhereUniqueInput[]
    update?: FeeStructureUpdateWithWhereUniqueWithoutStudentInput | FeeStructureUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: FeeStructureUpdateManyWithWhereWithoutStudentInput | FeeStructureUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: FeeStructureScalarWhereInput | FeeStructureScalarWhereInput[]
  }

  export type StudentFeeUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentFeeCreateWithoutStudentInput, StudentFeeUncheckedCreateWithoutStudentInput> | StudentFeeCreateWithoutStudentInput[] | StudentFeeUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentFeeCreateOrConnectWithoutStudentInput | StudentFeeCreateOrConnectWithoutStudentInput[]
    upsert?: StudentFeeUpsertWithWhereUniqueWithoutStudentInput | StudentFeeUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentFeeCreateManyStudentInputEnvelope
    set?: StudentFeeWhereUniqueInput | StudentFeeWhereUniqueInput[]
    disconnect?: StudentFeeWhereUniqueInput | StudentFeeWhereUniqueInput[]
    delete?: StudentFeeWhereUniqueInput | StudentFeeWhereUniqueInput[]
    connect?: StudentFeeWhereUniqueInput | StudentFeeWhereUniqueInput[]
    update?: StudentFeeUpdateWithWhereUniqueWithoutStudentInput | StudentFeeUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentFeeUpdateManyWithWhereWithoutStudentInput | StudentFeeUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentFeeScalarWhereInput | StudentFeeScalarWhereInput[]
  }

  export type AttendanceRecordUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<AttendanceRecordCreateWithoutStudentInput, AttendanceRecordUncheckedCreateWithoutStudentInput> | AttendanceRecordCreateWithoutStudentInput[] | AttendanceRecordUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AttendanceRecordCreateOrConnectWithoutStudentInput | AttendanceRecordCreateOrConnectWithoutStudentInput[]
    upsert?: AttendanceRecordUpsertWithWhereUniqueWithoutStudentInput | AttendanceRecordUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: AttendanceRecordCreateManyStudentInputEnvelope
    set?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    disconnect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    delete?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    connect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    update?: AttendanceRecordUpdateWithWhereUniqueWithoutStudentInput | AttendanceRecordUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: AttendanceRecordUpdateManyWithWhereWithoutStudentInput | AttendanceRecordUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: AttendanceRecordScalarWhereInput | AttendanceRecordScalarWhereInput[]
  }

  export type StudentTaskUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentTaskCreateWithoutStudentInput, StudentTaskUncheckedCreateWithoutStudentInput> | StudentTaskCreateWithoutStudentInput[] | StudentTaskUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentTaskCreateOrConnectWithoutStudentInput | StudentTaskCreateOrConnectWithoutStudentInput[]
    upsert?: StudentTaskUpsertWithWhereUniqueWithoutStudentInput | StudentTaskUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentTaskCreateManyStudentInputEnvelope
    set?: StudentTaskWhereUniqueInput | StudentTaskWhereUniqueInput[]
    disconnect?: StudentTaskWhereUniqueInput | StudentTaskWhereUniqueInput[]
    delete?: StudentTaskWhereUniqueInput | StudentTaskWhereUniqueInput[]
    connect?: StudentTaskWhereUniqueInput | StudentTaskWhereUniqueInput[]
    update?: StudentTaskUpdateWithWhereUniqueWithoutStudentInput | StudentTaskUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentTaskUpdateManyWithWhereWithoutStudentInput | StudentTaskUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentTaskScalarWhereInput | StudentTaskScalarWhereInput[]
  }

  export type StudentTestUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentTestCreateWithoutStudentInput, StudentTestUncheckedCreateWithoutStudentInput> | StudentTestCreateWithoutStudentInput[] | StudentTestUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentTestCreateOrConnectWithoutStudentInput | StudentTestCreateOrConnectWithoutStudentInput[]
    upsert?: StudentTestUpsertWithWhereUniqueWithoutStudentInput | StudentTestUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentTestCreateManyStudentInputEnvelope
    set?: StudentTestWhereUniqueInput | StudentTestWhereUniqueInput[]
    disconnect?: StudentTestWhereUniqueInput | StudentTestWhereUniqueInput[]
    delete?: StudentTestWhereUniqueInput | StudentTestWhereUniqueInput[]
    connect?: StudentTestWhereUniqueInput | StudentTestWhereUniqueInput[]
    update?: StudentTestUpdateWithWhereUniqueWithoutStudentInput | StudentTestUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentTestUpdateManyWithWhereWithoutStudentInput | StudentTestUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentTestScalarWhereInput | StudentTestScalarWhereInput[]
  }

  export type CourseCompletionUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<CourseCompletionCreateWithoutStudentInput, CourseCompletionUncheckedCreateWithoutStudentInput> | CourseCompletionCreateWithoutStudentInput[] | CourseCompletionUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: CourseCompletionCreateOrConnectWithoutStudentInput | CourseCompletionCreateOrConnectWithoutStudentInput[]
    upsert?: CourseCompletionUpsertWithWhereUniqueWithoutStudentInput | CourseCompletionUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: CourseCompletionCreateManyStudentInputEnvelope
    set?: CourseCompletionWhereUniqueInput | CourseCompletionWhereUniqueInput[]
    disconnect?: CourseCompletionWhereUniqueInput | CourseCompletionWhereUniqueInput[]
    delete?: CourseCompletionWhereUniqueInput | CourseCompletionWhereUniqueInput[]
    connect?: CourseCompletionWhereUniqueInput | CourseCompletionWhereUniqueInput[]
    update?: CourseCompletionUpdateWithWhereUniqueWithoutStudentInput | CourseCompletionUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: CourseCompletionUpdateManyWithWhereWithoutStudentInput | CourseCompletionUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: CourseCompletionScalarWhereInput | CourseCompletionScalarWhereInput[]
  }

  export type StationeryIssueUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StationeryIssueCreateWithoutStudentInput, StationeryIssueUncheckedCreateWithoutStudentInput> | StationeryIssueCreateWithoutStudentInput[] | StationeryIssueUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StationeryIssueCreateOrConnectWithoutStudentInput | StationeryIssueCreateOrConnectWithoutStudentInput[]
    upsert?: StationeryIssueUpsertWithWhereUniqueWithoutStudentInput | StationeryIssueUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StationeryIssueCreateManyStudentInputEnvelope
    set?: StationeryIssueWhereUniqueInput | StationeryIssueWhereUniqueInput[]
    disconnect?: StationeryIssueWhereUniqueInput | StationeryIssueWhereUniqueInput[]
    delete?: StationeryIssueWhereUniqueInput | StationeryIssueWhereUniqueInput[]
    connect?: StationeryIssueWhereUniqueInput | StationeryIssueWhereUniqueInput[]
    update?: StationeryIssueUpdateWithWhereUniqueWithoutStudentInput | StationeryIssueUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StationeryIssueUpdateManyWithWhereWithoutStudentInput | StationeryIssueUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StationeryIssueScalarWhereInput | StationeryIssueScalarWhereInput[]
  }

  export type CertificateUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<CertificateCreateWithoutStudentInput, CertificateUncheckedCreateWithoutStudentInput> | CertificateCreateWithoutStudentInput[] | CertificateUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutStudentInput | CertificateCreateOrConnectWithoutStudentInput[]
    upsert?: CertificateUpsertWithWhereUniqueWithoutStudentInput | CertificateUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: CertificateCreateManyStudentInputEnvelope
    set?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    disconnect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    delete?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    update?: CertificateUpdateWithWhereUniqueWithoutStudentInput | CertificateUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: CertificateUpdateManyWithWhereWithoutStudentInput | CertificateUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: CertificateScalarWhereInput | CertificateScalarWhereInput[]
  }

  export type FinancialRecordUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<FinancialRecordCreateWithoutStudentInput, FinancialRecordUncheckedCreateWithoutStudentInput> | FinancialRecordCreateWithoutStudentInput[] | FinancialRecordUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: FinancialRecordCreateOrConnectWithoutStudentInput | FinancialRecordCreateOrConnectWithoutStudentInput[]
    upsert?: FinancialRecordUpsertWithWhereUniqueWithoutStudentInput | FinancialRecordUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: FinancialRecordCreateManyStudentInputEnvelope
    set?: FinancialRecordWhereUniqueInput | FinancialRecordWhereUniqueInput[]
    disconnect?: FinancialRecordWhereUniqueInput | FinancialRecordWhereUniqueInput[]
    delete?: FinancialRecordWhereUniqueInput | FinancialRecordWhereUniqueInput[]
    connect?: FinancialRecordWhereUniqueInput | FinancialRecordWhereUniqueInput[]
    update?: FinancialRecordUpdateWithWhereUniqueWithoutStudentInput | FinancialRecordUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: FinancialRecordUpdateManyWithWhereWithoutStudentInput | FinancialRecordUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: FinancialRecordScalarWhereInput | FinancialRecordScalarWhereInput[]
  }

  export type CourseFeeStructureCreateNestedOneWithoutCourseInput = {
    create?: XOR<CourseFeeStructureCreateWithoutCourseInput, CourseFeeStructureUncheckedCreateWithoutCourseInput>
    connectOrCreate?: CourseFeeStructureCreateOrConnectWithoutCourseInput
    connect?: CourseFeeStructureWhereUniqueInput
  }

  export type StudentCourseCreateNestedManyWithoutCourseInput = {
    create?: XOR<StudentCourseCreateWithoutCourseInput, StudentCourseUncheckedCreateWithoutCourseInput> | StudentCourseCreateWithoutCourseInput[] | StudentCourseUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: StudentCourseCreateOrConnectWithoutCourseInput | StudentCourseCreateOrConnectWithoutCourseInput[]
    createMany?: StudentCourseCreateManyCourseInputEnvelope
    connect?: StudentCourseWhereUniqueInput | StudentCourseWhereUniqueInput[]
  }

  export type EnquiryCourseCreateNestedManyWithoutCourseInput = {
    create?: XOR<EnquiryCourseCreateWithoutCourseInput, EnquiryCourseUncheckedCreateWithoutCourseInput> | EnquiryCourseCreateWithoutCourseInput[] | EnquiryCourseUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: EnquiryCourseCreateOrConnectWithoutCourseInput | EnquiryCourseCreateOrConnectWithoutCourseInput[]
    createMany?: EnquiryCourseCreateManyCourseInputEnvelope
    connect?: EnquiryCourseWhereUniqueInput | EnquiryCourseWhereUniqueInput[]
  }

  export type FeeStructureCreateNestedManyWithoutCourseInput = {
    create?: XOR<FeeStructureCreateWithoutCourseInput, FeeStructureUncheckedCreateWithoutCourseInput> | FeeStructureCreateWithoutCourseInput[] | FeeStructureUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: FeeStructureCreateOrConnectWithoutCourseInput | FeeStructureCreateOrConnectWithoutCourseInput[]
    createMany?: FeeStructureCreateManyCourseInputEnvelope
    connect?: FeeStructureWhereUniqueInput | FeeStructureWhereUniqueInput[]
  }

  export type StationeryIssueCreateNestedManyWithoutCourseInput = {
    create?: XOR<StationeryIssueCreateWithoutCourseInput, StationeryIssueUncheckedCreateWithoutCourseInput> | StationeryIssueCreateWithoutCourseInput[] | StationeryIssueUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: StationeryIssueCreateOrConnectWithoutCourseInput | StationeryIssueCreateOrConnectWithoutCourseInput[]
    createMany?: StationeryIssueCreateManyCourseInputEnvelope
    connect?: StationeryIssueWhereUniqueInput | StationeryIssueWhereUniqueInput[]
  }

  export type StudentFeeCreateNestedManyWithoutCourseInput = {
    create?: XOR<StudentFeeCreateWithoutCourseInput, StudentFeeUncheckedCreateWithoutCourseInput> | StudentFeeCreateWithoutCourseInput[] | StudentFeeUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: StudentFeeCreateOrConnectWithoutCourseInput | StudentFeeCreateOrConnectWithoutCourseInput[]
    createMany?: StudentFeeCreateManyCourseInputEnvelope
    connect?: StudentFeeWhereUniqueInput | StudentFeeWhereUniqueInput[]
  }

  export type AttendanceRecordCreateNestedManyWithoutCourseInput = {
    create?: XOR<AttendanceRecordCreateWithoutCourseInput, AttendanceRecordUncheckedCreateWithoutCourseInput> | AttendanceRecordCreateWithoutCourseInput[] | AttendanceRecordUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: AttendanceRecordCreateOrConnectWithoutCourseInput | AttendanceRecordCreateOrConnectWithoutCourseInput[]
    createMany?: AttendanceRecordCreateManyCourseInputEnvelope
    connect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
  }

  export type StudentTaskCreateNestedManyWithoutCourseInput = {
    create?: XOR<StudentTaskCreateWithoutCourseInput, StudentTaskUncheckedCreateWithoutCourseInput> | StudentTaskCreateWithoutCourseInput[] | StudentTaskUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: StudentTaskCreateOrConnectWithoutCourseInput | StudentTaskCreateOrConnectWithoutCourseInput[]
    createMany?: StudentTaskCreateManyCourseInputEnvelope
    connect?: StudentTaskWhereUniqueInput | StudentTaskWhereUniqueInput[]
  }

  export type StudentTestCreateNestedManyWithoutCourseInput = {
    create?: XOR<StudentTestCreateWithoutCourseInput, StudentTestUncheckedCreateWithoutCourseInput> | StudentTestCreateWithoutCourseInput[] | StudentTestUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: StudentTestCreateOrConnectWithoutCourseInput | StudentTestCreateOrConnectWithoutCourseInput[]
    createMany?: StudentTestCreateManyCourseInputEnvelope
    connect?: StudentTestWhereUniqueInput | StudentTestWhereUniqueInput[]
  }

  export type CertificateCreateNestedManyWithoutCourseInput = {
    create?: XOR<CertificateCreateWithoutCourseInput, CertificateUncheckedCreateWithoutCourseInput> | CertificateCreateWithoutCourseInput[] | CertificateUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutCourseInput | CertificateCreateOrConnectWithoutCourseInput[]
    createMany?: CertificateCreateManyCourseInputEnvelope
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
  }

  export type FinancialRecordCreateNestedManyWithoutCourseInput = {
    create?: XOR<FinancialRecordCreateWithoutCourseInput, FinancialRecordUncheckedCreateWithoutCourseInput> | FinancialRecordCreateWithoutCourseInput[] | FinancialRecordUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: FinancialRecordCreateOrConnectWithoutCourseInput | FinancialRecordCreateOrConnectWithoutCourseInput[]
    createMany?: FinancialRecordCreateManyCourseInputEnvelope
    connect?: FinancialRecordWhereUniqueInput | FinancialRecordWhereUniqueInput[]
  }

  export type BatchCourseCreateNestedManyWithoutCourseInput = {
    create?: XOR<BatchCourseCreateWithoutCourseInput, BatchCourseUncheckedCreateWithoutCourseInput> | BatchCourseCreateWithoutCourseInput[] | BatchCourseUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: BatchCourseCreateOrConnectWithoutCourseInput | BatchCourseCreateOrConnectWithoutCourseInput[]
    createMany?: BatchCourseCreateManyCourseInputEnvelope
    connect?: BatchCourseWhereUniqueInput | BatchCourseWhereUniqueInput[]
  }

  export type ClientAdminCreateNestedOneWithoutCoursesInput = {
    create?: XOR<ClientAdminCreateWithoutCoursesInput, ClientAdminUncheckedCreateWithoutCoursesInput>
    connectOrCreate?: ClientAdminCreateOrConnectWithoutCoursesInput
    connect?: ClientAdminWhereUniqueInput
  }

  export type CourseFeeStructureUncheckedCreateNestedOneWithoutCourseInput = {
    create?: XOR<CourseFeeStructureCreateWithoutCourseInput, CourseFeeStructureUncheckedCreateWithoutCourseInput>
    connectOrCreate?: CourseFeeStructureCreateOrConnectWithoutCourseInput
    connect?: CourseFeeStructureWhereUniqueInput
  }

  export type StudentCourseUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<StudentCourseCreateWithoutCourseInput, StudentCourseUncheckedCreateWithoutCourseInput> | StudentCourseCreateWithoutCourseInput[] | StudentCourseUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: StudentCourseCreateOrConnectWithoutCourseInput | StudentCourseCreateOrConnectWithoutCourseInput[]
    createMany?: StudentCourseCreateManyCourseInputEnvelope
    connect?: StudentCourseWhereUniqueInput | StudentCourseWhereUniqueInput[]
  }

  export type EnquiryCourseUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<EnquiryCourseCreateWithoutCourseInput, EnquiryCourseUncheckedCreateWithoutCourseInput> | EnquiryCourseCreateWithoutCourseInput[] | EnquiryCourseUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: EnquiryCourseCreateOrConnectWithoutCourseInput | EnquiryCourseCreateOrConnectWithoutCourseInput[]
    createMany?: EnquiryCourseCreateManyCourseInputEnvelope
    connect?: EnquiryCourseWhereUniqueInput | EnquiryCourseWhereUniqueInput[]
  }

  export type FeeStructureUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<FeeStructureCreateWithoutCourseInput, FeeStructureUncheckedCreateWithoutCourseInput> | FeeStructureCreateWithoutCourseInput[] | FeeStructureUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: FeeStructureCreateOrConnectWithoutCourseInput | FeeStructureCreateOrConnectWithoutCourseInput[]
    createMany?: FeeStructureCreateManyCourseInputEnvelope
    connect?: FeeStructureWhereUniqueInput | FeeStructureWhereUniqueInput[]
  }

  export type StationeryIssueUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<StationeryIssueCreateWithoutCourseInput, StationeryIssueUncheckedCreateWithoutCourseInput> | StationeryIssueCreateWithoutCourseInput[] | StationeryIssueUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: StationeryIssueCreateOrConnectWithoutCourseInput | StationeryIssueCreateOrConnectWithoutCourseInput[]
    createMany?: StationeryIssueCreateManyCourseInputEnvelope
    connect?: StationeryIssueWhereUniqueInput | StationeryIssueWhereUniqueInput[]
  }

  export type StudentFeeUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<StudentFeeCreateWithoutCourseInput, StudentFeeUncheckedCreateWithoutCourseInput> | StudentFeeCreateWithoutCourseInput[] | StudentFeeUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: StudentFeeCreateOrConnectWithoutCourseInput | StudentFeeCreateOrConnectWithoutCourseInput[]
    createMany?: StudentFeeCreateManyCourseInputEnvelope
    connect?: StudentFeeWhereUniqueInput | StudentFeeWhereUniqueInput[]
  }

  export type AttendanceRecordUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<AttendanceRecordCreateWithoutCourseInput, AttendanceRecordUncheckedCreateWithoutCourseInput> | AttendanceRecordCreateWithoutCourseInput[] | AttendanceRecordUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: AttendanceRecordCreateOrConnectWithoutCourseInput | AttendanceRecordCreateOrConnectWithoutCourseInput[]
    createMany?: AttendanceRecordCreateManyCourseInputEnvelope
    connect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
  }

  export type StudentTaskUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<StudentTaskCreateWithoutCourseInput, StudentTaskUncheckedCreateWithoutCourseInput> | StudentTaskCreateWithoutCourseInput[] | StudentTaskUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: StudentTaskCreateOrConnectWithoutCourseInput | StudentTaskCreateOrConnectWithoutCourseInput[]
    createMany?: StudentTaskCreateManyCourseInputEnvelope
    connect?: StudentTaskWhereUniqueInput | StudentTaskWhereUniqueInput[]
  }

  export type StudentTestUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<StudentTestCreateWithoutCourseInput, StudentTestUncheckedCreateWithoutCourseInput> | StudentTestCreateWithoutCourseInput[] | StudentTestUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: StudentTestCreateOrConnectWithoutCourseInput | StudentTestCreateOrConnectWithoutCourseInput[]
    createMany?: StudentTestCreateManyCourseInputEnvelope
    connect?: StudentTestWhereUniqueInput | StudentTestWhereUniqueInput[]
  }

  export type CertificateUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<CertificateCreateWithoutCourseInput, CertificateUncheckedCreateWithoutCourseInput> | CertificateCreateWithoutCourseInput[] | CertificateUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutCourseInput | CertificateCreateOrConnectWithoutCourseInput[]
    createMany?: CertificateCreateManyCourseInputEnvelope
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
  }

  export type FinancialRecordUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<FinancialRecordCreateWithoutCourseInput, FinancialRecordUncheckedCreateWithoutCourseInput> | FinancialRecordCreateWithoutCourseInput[] | FinancialRecordUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: FinancialRecordCreateOrConnectWithoutCourseInput | FinancialRecordCreateOrConnectWithoutCourseInput[]
    createMany?: FinancialRecordCreateManyCourseInputEnvelope
    connect?: FinancialRecordWhereUniqueInput | FinancialRecordWhereUniqueInput[]
  }

  export type BatchCourseUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<BatchCourseCreateWithoutCourseInput, BatchCourseUncheckedCreateWithoutCourseInput> | BatchCourseCreateWithoutCourseInput[] | BatchCourseUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: BatchCourseCreateOrConnectWithoutCourseInput | BatchCourseCreateOrConnectWithoutCourseInput[]
    createMany?: BatchCourseCreateManyCourseInputEnvelope
    connect?: BatchCourseWhereUniqueInput | BatchCourseWhereUniqueInput[]
  }

  export type CourseFeeStructureUpdateOneWithoutCourseNestedInput = {
    create?: XOR<CourseFeeStructureCreateWithoutCourseInput, CourseFeeStructureUncheckedCreateWithoutCourseInput>
    connectOrCreate?: CourseFeeStructureCreateOrConnectWithoutCourseInput
    upsert?: CourseFeeStructureUpsertWithoutCourseInput
    disconnect?: CourseFeeStructureWhereInput | boolean
    delete?: CourseFeeStructureWhereInput | boolean
    connect?: CourseFeeStructureWhereUniqueInput
    update?: XOR<XOR<CourseFeeStructureUpdateToOneWithWhereWithoutCourseInput, CourseFeeStructureUpdateWithoutCourseInput>, CourseFeeStructureUncheckedUpdateWithoutCourseInput>
  }

  export type StudentCourseUpdateManyWithoutCourseNestedInput = {
    create?: XOR<StudentCourseCreateWithoutCourseInput, StudentCourseUncheckedCreateWithoutCourseInput> | StudentCourseCreateWithoutCourseInput[] | StudentCourseUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: StudentCourseCreateOrConnectWithoutCourseInput | StudentCourseCreateOrConnectWithoutCourseInput[]
    upsert?: StudentCourseUpsertWithWhereUniqueWithoutCourseInput | StudentCourseUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: StudentCourseCreateManyCourseInputEnvelope
    set?: StudentCourseWhereUniqueInput | StudentCourseWhereUniqueInput[]
    disconnect?: StudentCourseWhereUniqueInput | StudentCourseWhereUniqueInput[]
    delete?: StudentCourseWhereUniqueInput | StudentCourseWhereUniqueInput[]
    connect?: StudentCourseWhereUniqueInput | StudentCourseWhereUniqueInput[]
    update?: StudentCourseUpdateWithWhereUniqueWithoutCourseInput | StudentCourseUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: StudentCourseUpdateManyWithWhereWithoutCourseInput | StudentCourseUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: StudentCourseScalarWhereInput | StudentCourseScalarWhereInput[]
  }

  export type EnquiryCourseUpdateManyWithoutCourseNestedInput = {
    create?: XOR<EnquiryCourseCreateWithoutCourseInput, EnquiryCourseUncheckedCreateWithoutCourseInput> | EnquiryCourseCreateWithoutCourseInput[] | EnquiryCourseUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: EnquiryCourseCreateOrConnectWithoutCourseInput | EnquiryCourseCreateOrConnectWithoutCourseInput[]
    upsert?: EnquiryCourseUpsertWithWhereUniqueWithoutCourseInput | EnquiryCourseUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: EnquiryCourseCreateManyCourseInputEnvelope
    set?: EnquiryCourseWhereUniqueInput | EnquiryCourseWhereUniqueInput[]
    disconnect?: EnquiryCourseWhereUniqueInput | EnquiryCourseWhereUniqueInput[]
    delete?: EnquiryCourseWhereUniqueInput | EnquiryCourseWhereUniqueInput[]
    connect?: EnquiryCourseWhereUniqueInput | EnquiryCourseWhereUniqueInput[]
    update?: EnquiryCourseUpdateWithWhereUniqueWithoutCourseInput | EnquiryCourseUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: EnquiryCourseUpdateManyWithWhereWithoutCourseInput | EnquiryCourseUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: EnquiryCourseScalarWhereInput | EnquiryCourseScalarWhereInput[]
  }

  export type FeeStructureUpdateManyWithoutCourseNestedInput = {
    create?: XOR<FeeStructureCreateWithoutCourseInput, FeeStructureUncheckedCreateWithoutCourseInput> | FeeStructureCreateWithoutCourseInput[] | FeeStructureUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: FeeStructureCreateOrConnectWithoutCourseInput | FeeStructureCreateOrConnectWithoutCourseInput[]
    upsert?: FeeStructureUpsertWithWhereUniqueWithoutCourseInput | FeeStructureUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: FeeStructureCreateManyCourseInputEnvelope
    set?: FeeStructureWhereUniqueInput | FeeStructureWhereUniqueInput[]
    disconnect?: FeeStructureWhereUniqueInput | FeeStructureWhereUniqueInput[]
    delete?: FeeStructureWhereUniqueInput | FeeStructureWhereUniqueInput[]
    connect?: FeeStructureWhereUniqueInput | FeeStructureWhereUniqueInput[]
    update?: FeeStructureUpdateWithWhereUniqueWithoutCourseInput | FeeStructureUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: FeeStructureUpdateManyWithWhereWithoutCourseInput | FeeStructureUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: FeeStructureScalarWhereInput | FeeStructureScalarWhereInput[]
  }

  export type StationeryIssueUpdateManyWithoutCourseNestedInput = {
    create?: XOR<StationeryIssueCreateWithoutCourseInput, StationeryIssueUncheckedCreateWithoutCourseInput> | StationeryIssueCreateWithoutCourseInput[] | StationeryIssueUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: StationeryIssueCreateOrConnectWithoutCourseInput | StationeryIssueCreateOrConnectWithoutCourseInput[]
    upsert?: StationeryIssueUpsertWithWhereUniqueWithoutCourseInput | StationeryIssueUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: StationeryIssueCreateManyCourseInputEnvelope
    set?: StationeryIssueWhereUniqueInput | StationeryIssueWhereUniqueInput[]
    disconnect?: StationeryIssueWhereUniqueInput | StationeryIssueWhereUniqueInput[]
    delete?: StationeryIssueWhereUniqueInput | StationeryIssueWhereUniqueInput[]
    connect?: StationeryIssueWhereUniqueInput | StationeryIssueWhereUniqueInput[]
    update?: StationeryIssueUpdateWithWhereUniqueWithoutCourseInput | StationeryIssueUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: StationeryIssueUpdateManyWithWhereWithoutCourseInput | StationeryIssueUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: StationeryIssueScalarWhereInput | StationeryIssueScalarWhereInput[]
  }

  export type StudentFeeUpdateManyWithoutCourseNestedInput = {
    create?: XOR<StudentFeeCreateWithoutCourseInput, StudentFeeUncheckedCreateWithoutCourseInput> | StudentFeeCreateWithoutCourseInput[] | StudentFeeUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: StudentFeeCreateOrConnectWithoutCourseInput | StudentFeeCreateOrConnectWithoutCourseInput[]
    upsert?: StudentFeeUpsertWithWhereUniqueWithoutCourseInput | StudentFeeUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: StudentFeeCreateManyCourseInputEnvelope
    set?: StudentFeeWhereUniqueInput | StudentFeeWhereUniqueInput[]
    disconnect?: StudentFeeWhereUniqueInput | StudentFeeWhereUniqueInput[]
    delete?: StudentFeeWhereUniqueInput | StudentFeeWhereUniqueInput[]
    connect?: StudentFeeWhereUniqueInput | StudentFeeWhereUniqueInput[]
    update?: StudentFeeUpdateWithWhereUniqueWithoutCourseInput | StudentFeeUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: StudentFeeUpdateManyWithWhereWithoutCourseInput | StudentFeeUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: StudentFeeScalarWhereInput | StudentFeeScalarWhereInput[]
  }

  export type AttendanceRecordUpdateManyWithoutCourseNestedInput = {
    create?: XOR<AttendanceRecordCreateWithoutCourseInput, AttendanceRecordUncheckedCreateWithoutCourseInput> | AttendanceRecordCreateWithoutCourseInput[] | AttendanceRecordUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: AttendanceRecordCreateOrConnectWithoutCourseInput | AttendanceRecordCreateOrConnectWithoutCourseInput[]
    upsert?: AttendanceRecordUpsertWithWhereUniqueWithoutCourseInput | AttendanceRecordUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: AttendanceRecordCreateManyCourseInputEnvelope
    set?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    disconnect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    delete?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    connect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    update?: AttendanceRecordUpdateWithWhereUniqueWithoutCourseInput | AttendanceRecordUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: AttendanceRecordUpdateManyWithWhereWithoutCourseInput | AttendanceRecordUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: AttendanceRecordScalarWhereInput | AttendanceRecordScalarWhereInput[]
  }

  export type StudentTaskUpdateManyWithoutCourseNestedInput = {
    create?: XOR<StudentTaskCreateWithoutCourseInput, StudentTaskUncheckedCreateWithoutCourseInput> | StudentTaskCreateWithoutCourseInput[] | StudentTaskUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: StudentTaskCreateOrConnectWithoutCourseInput | StudentTaskCreateOrConnectWithoutCourseInput[]
    upsert?: StudentTaskUpsertWithWhereUniqueWithoutCourseInput | StudentTaskUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: StudentTaskCreateManyCourseInputEnvelope
    set?: StudentTaskWhereUniqueInput | StudentTaskWhereUniqueInput[]
    disconnect?: StudentTaskWhereUniqueInput | StudentTaskWhereUniqueInput[]
    delete?: StudentTaskWhereUniqueInput | StudentTaskWhereUniqueInput[]
    connect?: StudentTaskWhereUniqueInput | StudentTaskWhereUniqueInput[]
    update?: StudentTaskUpdateWithWhereUniqueWithoutCourseInput | StudentTaskUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: StudentTaskUpdateManyWithWhereWithoutCourseInput | StudentTaskUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: StudentTaskScalarWhereInput | StudentTaskScalarWhereInput[]
  }

  export type StudentTestUpdateManyWithoutCourseNestedInput = {
    create?: XOR<StudentTestCreateWithoutCourseInput, StudentTestUncheckedCreateWithoutCourseInput> | StudentTestCreateWithoutCourseInput[] | StudentTestUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: StudentTestCreateOrConnectWithoutCourseInput | StudentTestCreateOrConnectWithoutCourseInput[]
    upsert?: StudentTestUpsertWithWhereUniqueWithoutCourseInput | StudentTestUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: StudentTestCreateManyCourseInputEnvelope
    set?: StudentTestWhereUniqueInput | StudentTestWhereUniqueInput[]
    disconnect?: StudentTestWhereUniqueInput | StudentTestWhereUniqueInput[]
    delete?: StudentTestWhereUniqueInput | StudentTestWhereUniqueInput[]
    connect?: StudentTestWhereUniqueInput | StudentTestWhereUniqueInput[]
    update?: StudentTestUpdateWithWhereUniqueWithoutCourseInput | StudentTestUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: StudentTestUpdateManyWithWhereWithoutCourseInput | StudentTestUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: StudentTestScalarWhereInput | StudentTestScalarWhereInput[]
  }

  export type CertificateUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CertificateCreateWithoutCourseInput, CertificateUncheckedCreateWithoutCourseInput> | CertificateCreateWithoutCourseInput[] | CertificateUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutCourseInput | CertificateCreateOrConnectWithoutCourseInput[]
    upsert?: CertificateUpsertWithWhereUniqueWithoutCourseInput | CertificateUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CertificateCreateManyCourseInputEnvelope
    set?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    disconnect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    delete?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    update?: CertificateUpdateWithWhereUniqueWithoutCourseInput | CertificateUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CertificateUpdateManyWithWhereWithoutCourseInput | CertificateUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CertificateScalarWhereInput | CertificateScalarWhereInput[]
  }

  export type FinancialRecordUpdateManyWithoutCourseNestedInput = {
    create?: XOR<FinancialRecordCreateWithoutCourseInput, FinancialRecordUncheckedCreateWithoutCourseInput> | FinancialRecordCreateWithoutCourseInput[] | FinancialRecordUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: FinancialRecordCreateOrConnectWithoutCourseInput | FinancialRecordCreateOrConnectWithoutCourseInput[]
    upsert?: FinancialRecordUpsertWithWhereUniqueWithoutCourseInput | FinancialRecordUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: FinancialRecordCreateManyCourseInputEnvelope
    set?: FinancialRecordWhereUniqueInput | FinancialRecordWhereUniqueInput[]
    disconnect?: FinancialRecordWhereUniqueInput | FinancialRecordWhereUniqueInput[]
    delete?: FinancialRecordWhereUniqueInput | FinancialRecordWhereUniqueInput[]
    connect?: FinancialRecordWhereUniqueInput | FinancialRecordWhereUniqueInput[]
    update?: FinancialRecordUpdateWithWhereUniqueWithoutCourseInput | FinancialRecordUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: FinancialRecordUpdateManyWithWhereWithoutCourseInput | FinancialRecordUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: FinancialRecordScalarWhereInput | FinancialRecordScalarWhereInput[]
  }

  export type BatchCourseUpdateManyWithoutCourseNestedInput = {
    create?: XOR<BatchCourseCreateWithoutCourseInput, BatchCourseUncheckedCreateWithoutCourseInput> | BatchCourseCreateWithoutCourseInput[] | BatchCourseUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: BatchCourseCreateOrConnectWithoutCourseInput | BatchCourseCreateOrConnectWithoutCourseInput[]
    upsert?: BatchCourseUpsertWithWhereUniqueWithoutCourseInput | BatchCourseUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: BatchCourseCreateManyCourseInputEnvelope
    set?: BatchCourseWhereUniqueInput | BatchCourseWhereUniqueInput[]
    disconnect?: BatchCourseWhereUniqueInput | BatchCourseWhereUniqueInput[]
    delete?: BatchCourseWhereUniqueInput | BatchCourseWhereUniqueInput[]
    connect?: BatchCourseWhereUniqueInput | BatchCourseWhereUniqueInput[]
    update?: BatchCourseUpdateWithWhereUniqueWithoutCourseInput | BatchCourseUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: BatchCourseUpdateManyWithWhereWithoutCourseInput | BatchCourseUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: BatchCourseScalarWhereInput | BatchCourseScalarWhereInput[]
  }

  export type ClientAdminUpdateOneRequiredWithoutCoursesNestedInput = {
    create?: XOR<ClientAdminCreateWithoutCoursesInput, ClientAdminUncheckedCreateWithoutCoursesInput>
    connectOrCreate?: ClientAdminCreateOrConnectWithoutCoursesInput
    upsert?: ClientAdminUpsertWithoutCoursesInput
    connect?: ClientAdminWhereUniqueInput
    update?: XOR<XOR<ClientAdminUpdateToOneWithWhereWithoutCoursesInput, ClientAdminUpdateWithoutCoursesInput>, ClientAdminUncheckedUpdateWithoutCoursesInput>
  }

  export type CourseFeeStructureUncheckedUpdateOneWithoutCourseNestedInput = {
    create?: XOR<CourseFeeStructureCreateWithoutCourseInput, CourseFeeStructureUncheckedCreateWithoutCourseInput>
    connectOrCreate?: CourseFeeStructureCreateOrConnectWithoutCourseInput
    upsert?: CourseFeeStructureUpsertWithoutCourseInput
    disconnect?: CourseFeeStructureWhereInput | boolean
    delete?: CourseFeeStructureWhereInput | boolean
    connect?: CourseFeeStructureWhereUniqueInput
    update?: XOR<XOR<CourseFeeStructureUpdateToOneWithWhereWithoutCourseInput, CourseFeeStructureUpdateWithoutCourseInput>, CourseFeeStructureUncheckedUpdateWithoutCourseInput>
  }

  export type StudentCourseUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<StudentCourseCreateWithoutCourseInput, StudentCourseUncheckedCreateWithoutCourseInput> | StudentCourseCreateWithoutCourseInput[] | StudentCourseUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: StudentCourseCreateOrConnectWithoutCourseInput | StudentCourseCreateOrConnectWithoutCourseInput[]
    upsert?: StudentCourseUpsertWithWhereUniqueWithoutCourseInput | StudentCourseUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: StudentCourseCreateManyCourseInputEnvelope
    set?: StudentCourseWhereUniqueInput | StudentCourseWhereUniqueInput[]
    disconnect?: StudentCourseWhereUniqueInput | StudentCourseWhereUniqueInput[]
    delete?: StudentCourseWhereUniqueInput | StudentCourseWhereUniqueInput[]
    connect?: StudentCourseWhereUniqueInput | StudentCourseWhereUniqueInput[]
    update?: StudentCourseUpdateWithWhereUniqueWithoutCourseInput | StudentCourseUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: StudentCourseUpdateManyWithWhereWithoutCourseInput | StudentCourseUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: StudentCourseScalarWhereInput | StudentCourseScalarWhereInput[]
  }

  export type EnquiryCourseUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<EnquiryCourseCreateWithoutCourseInput, EnquiryCourseUncheckedCreateWithoutCourseInput> | EnquiryCourseCreateWithoutCourseInput[] | EnquiryCourseUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: EnquiryCourseCreateOrConnectWithoutCourseInput | EnquiryCourseCreateOrConnectWithoutCourseInput[]
    upsert?: EnquiryCourseUpsertWithWhereUniqueWithoutCourseInput | EnquiryCourseUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: EnquiryCourseCreateManyCourseInputEnvelope
    set?: EnquiryCourseWhereUniqueInput | EnquiryCourseWhereUniqueInput[]
    disconnect?: EnquiryCourseWhereUniqueInput | EnquiryCourseWhereUniqueInput[]
    delete?: EnquiryCourseWhereUniqueInput | EnquiryCourseWhereUniqueInput[]
    connect?: EnquiryCourseWhereUniqueInput | EnquiryCourseWhereUniqueInput[]
    update?: EnquiryCourseUpdateWithWhereUniqueWithoutCourseInput | EnquiryCourseUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: EnquiryCourseUpdateManyWithWhereWithoutCourseInput | EnquiryCourseUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: EnquiryCourseScalarWhereInput | EnquiryCourseScalarWhereInput[]
  }

  export type FeeStructureUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<FeeStructureCreateWithoutCourseInput, FeeStructureUncheckedCreateWithoutCourseInput> | FeeStructureCreateWithoutCourseInput[] | FeeStructureUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: FeeStructureCreateOrConnectWithoutCourseInput | FeeStructureCreateOrConnectWithoutCourseInput[]
    upsert?: FeeStructureUpsertWithWhereUniqueWithoutCourseInput | FeeStructureUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: FeeStructureCreateManyCourseInputEnvelope
    set?: FeeStructureWhereUniqueInput | FeeStructureWhereUniqueInput[]
    disconnect?: FeeStructureWhereUniqueInput | FeeStructureWhereUniqueInput[]
    delete?: FeeStructureWhereUniqueInput | FeeStructureWhereUniqueInput[]
    connect?: FeeStructureWhereUniqueInput | FeeStructureWhereUniqueInput[]
    update?: FeeStructureUpdateWithWhereUniqueWithoutCourseInput | FeeStructureUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: FeeStructureUpdateManyWithWhereWithoutCourseInput | FeeStructureUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: FeeStructureScalarWhereInput | FeeStructureScalarWhereInput[]
  }

  export type StationeryIssueUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<StationeryIssueCreateWithoutCourseInput, StationeryIssueUncheckedCreateWithoutCourseInput> | StationeryIssueCreateWithoutCourseInput[] | StationeryIssueUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: StationeryIssueCreateOrConnectWithoutCourseInput | StationeryIssueCreateOrConnectWithoutCourseInput[]
    upsert?: StationeryIssueUpsertWithWhereUniqueWithoutCourseInput | StationeryIssueUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: StationeryIssueCreateManyCourseInputEnvelope
    set?: StationeryIssueWhereUniqueInput | StationeryIssueWhereUniqueInput[]
    disconnect?: StationeryIssueWhereUniqueInput | StationeryIssueWhereUniqueInput[]
    delete?: StationeryIssueWhereUniqueInput | StationeryIssueWhereUniqueInput[]
    connect?: StationeryIssueWhereUniqueInput | StationeryIssueWhereUniqueInput[]
    update?: StationeryIssueUpdateWithWhereUniqueWithoutCourseInput | StationeryIssueUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: StationeryIssueUpdateManyWithWhereWithoutCourseInput | StationeryIssueUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: StationeryIssueScalarWhereInput | StationeryIssueScalarWhereInput[]
  }

  export type StudentFeeUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<StudentFeeCreateWithoutCourseInput, StudentFeeUncheckedCreateWithoutCourseInput> | StudentFeeCreateWithoutCourseInput[] | StudentFeeUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: StudentFeeCreateOrConnectWithoutCourseInput | StudentFeeCreateOrConnectWithoutCourseInput[]
    upsert?: StudentFeeUpsertWithWhereUniqueWithoutCourseInput | StudentFeeUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: StudentFeeCreateManyCourseInputEnvelope
    set?: StudentFeeWhereUniqueInput | StudentFeeWhereUniqueInput[]
    disconnect?: StudentFeeWhereUniqueInput | StudentFeeWhereUniqueInput[]
    delete?: StudentFeeWhereUniqueInput | StudentFeeWhereUniqueInput[]
    connect?: StudentFeeWhereUniqueInput | StudentFeeWhereUniqueInput[]
    update?: StudentFeeUpdateWithWhereUniqueWithoutCourseInput | StudentFeeUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: StudentFeeUpdateManyWithWhereWithoutCourseInput | StudentFeeUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: StudentFeeScalarWhereInput | StudentFeeScalarWhereInput[]
  }

  export type AttendanceRecordUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<AttendanceRecordCreateWithoutCourseInput, AttendanceRecordUncheckedCreateWithoutCourseInput> | AttendanceRecordCreateWithoutCourseInput[] | AttendanceRecordUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: AttendanceRecordCreateOrConnectWithoutCourseInput | AttendanceRecordCreateOrConnectWithoutCourseInput[]
    upsert?: AttendanceRecordUpsertWithWhereUniqueWithoutCourseInput | AttendanceRecordUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: AttendanceRecordCreateManyCourseInputEnvelope
    set?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    disconnect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    delete?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    connect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    update?: AttendanceRecordUpdateWithWhereUniqueWithoutCourseInput | AttendanceRecordUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: AttendanceRecordUpdateManyWithWhereWithoutCourseInput | AttendanceRecordUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: AttendanceRecordScalarWhereInput | AttendanceRecordScalarWhereInput[]
  }

  export type StudentTaskUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<StudentTaskCreateWithoutCourseInput, StudentTaskUncheckedCreateWithoutCourseInput> | StudentTaskCreateWithoutCourseInput[] | StudentTaskUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: StudentTaskCreateOrConnectWithoutCourseInput | StudentTaskCreateOrConnectWithoutCourseInput[]
    upsert?: StudentTaskUpsertWithWhereUniqueWithoutCourseInput | StudentTaskUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: StudentTaskCreateManyCourseInputEnvelope
    set?: StudentTaskWhereUniqueInput | StudentTaskWhereUniqueInput[]
    disconnect?: StudentTaskWhereUniqueInput | StudentTaskWhereUniqueInput[]
    delete?: StudentTaskWhereUniqueInput | StudentTaskWhereUniqueInput[]
    connect?: StudentTaskWhereUniqueInput | StudentTaskWhereUniqueInput[]
    update?: StudentTaskUpdateWithWhereUniqueWithoutCourseInput | StudentTaskUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: StudentTaskUpdateManyWithWhereWithoutCourseInput | StudentTaskUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: StudentTaskScalarWhereInput | StudentTaskScalarWhereInput[]
  }

  export type StudentTestUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<StudentTestCreateWithoutCourseInput, StudentTestUncheckedCreateWithoutCourseInput> | StudentTestCreateWithoutCourseInput[] | StudentTestUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: StudentTestCreateOrConnectWithoutCourseInput | StudentTestCreateOrConnectWithoutCourseInput[]
    upsert?: StudentTestUpsertWithWhereUniqueWithoutCourseInput | StudentTestUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: StudentTestCreateManyCourseInputEnvelope
    set?: StudentTestWhereUniqueInput | StudentTestWhereUniqueInput[]
    disconnect?: StudentTestWhereUniqueInput | StudentTestWhereUniqueInput[]
    delete?: StudentTestWhereUniqueInput | StudentTestWhereUniqueInput[]
    connect?: StudentTestWhereUniqueInput | StudentTestWhereUniqueInput[]
    update?: StudentTestUpdateWithWhereUniqueWithoutCourseInput | StudentTestUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: StudentTestUpdateManyWithWhereWithoutCourseInput | StudentTestUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: StudentTestScalarWhereInput | StudentTestScalarWhereInput[]
  }

  export type CertificateUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CertificateCreateWithoutCourseInput, CertificateUncheckedCreateWithoutCourseInput> | CertificateCreateWithoutCourseInput[] | CertificateUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutCourseInput | CertificateCreateOrConnectWithoutCourseInput[]
    upsert?: CertificateUpsertWithWhereUniqueWithoutCourseInput | CertificateUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CertificateCreateManyCourseInputEnvelope
    set?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    disconnect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    delete?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    update?: CertificateUpdateWithWhereUniqueWithoutCourseInput | CertificateUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CertificateUpdateManyWithWhereWithoutCourseInput | CertificateUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CertificateScalarWhereInput | CertificateScalarWhereInput[]
  }

  export type FinancialRecordUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<FinancialRecordCreateWithoutCourseInput, FinancialRecordUncheckedCreateWithoutCourseInput> | FinancialRecordCreateWithoutCourseInput[] | FinancialRecordUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: FinancialRecordCreateOrConnectWithoutCourseInput | FinancialRecordCreateOrConnectWithoutCourseInput[]
    upsert?: FinancialRecordUpsertWithWhereUniqueWithoutCourseInput | FinancialRecordUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: FinancialRecordCreateManyCourseInputEnvelope
    set?: FinancialRecordWhereUniqueInput | FinancialRecordWhereUniqueInput[]
    disconnect?: FinancialRecordWhereUniqueInput | FinancialRecordWhereUniqueInput[]
    delete?: FinancialRecordWhereUniqueInput | FinancialRecordWhereUniqueInput[]
    connect?: FinancialRecordWhereUniqueInput | FinancialRecordWhereUniqueInput[]
    update?: FinancialRecordUpdateWithWhereUniqueWithoutCourseInput | FinancialRecordUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: FinancialRecordUpdateManyWithWhereWithoutCourseInput | FinancialRecordUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: FinancialRecordScalarWhereInput | FinancialRecordScalarWhereInput[]
  }

  export type BatchCourseUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<BatchCourseCreateWithoutCourseInput, BatchCourseUncheckedCreateWithoutCourseInput> | BatchCourseCreateWithoutCourseInput[] | BatchCourseUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: BatchCourseCreateOrConnectWithoutCourseInput | BatchCourseCreateOrConnectWithoutCourseInput[]
    upsert?: BatchCourseUpsertWithWhereUniqueWithoutCourseInput | BatchCourseUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: BatchCourseCreateManyCourseInputEnvelope
    set?: BatchCourseWhereUniqueInput | BatchCourseWhereUniqueInput[]
    disconnect?: BatchCourseWhereUniqueInput | BatchCourseWhereUniqueInput[]
    delete?: BatchCourseWhereUniqueInput | BatchCourseWhereUniqueInput[]
    connect?: BatchCourseWhereUniqueInput | BatchCourseWhereUniqueInput[]
    update?: BatchCourseUpdateWithWhereUniqueWithoutCourseInput | BatchCourseUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: BatchCourseUpdateManyWithWhereWithoutCourseInput | BatchCourseUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: BatchCourseScalarWhereInput | BatchCourseScalarWhereInput[]
  }

  export type CourseFeeStructureCreatepaymentTypeInput = {
    set: string[]
  }

  export type CourseCreateNestedOneWithoutCourseFeeStructureInput = {
    create?: XOR<CourseCreateWithoutCourseFeeStructureInput, CourseUncheckedCreateWithoutCourseFeeStructureInput>
    connectOrCreate?: CourseCreateOrConnectWithoutCourseFeeStructureInput
    connect?: CourseWhereUniqueInput
  }

  export type InstallmentDetailCreateNestedManyWithoutCourseFeeStructureInput = {
    create?: XOR<InstallmentDetailCreateWithoutCourseFeeStructureInput, InstallmentDetailUncheckedCreateWithoutCourseFeeStructureInput> | InstallmentDetailCreateWithoutCourseFeeStructureInput[] | InstallmentDetailUncheckedCreateWithoutCourseFeeStructureInput[]
    connectOrCreate?: InstallmentDetailCreateOrConnectWithoutCourseFeeStructureInput | InstallmentDetailCreateOrConnectWithoutCourseFeeStructureInput[]
    createMany?: InstallmentDetailCreateManyCourseFeeStructureInputEnvelope
    connect?: InstallmentDetailWhereUniqueInput | InstallmentDetailWhereUniqueInput[]
  }

  export type ClientAdminCreateNestedOneWithoutCourseFeeStructuresInput = {
    create?: XOR<ClientAdminCreateWithoutCourseFeeStructuresInput, ClientAdminUncheckedCreateWithoutCourseFeeStructuresInput>
    connectOrCreate?: ClientAdminCreateOrConnectWithoutCourseFeeStructuresInput
    connect?: ClientAdminWhereUniqueInput
  }

  export type InstallmentDetailUncheckedCreateNestedManyWithoutCourseFeeStructureInput = {
    create?: XOR<InstallmentDetailCreateWithoutCourseFeeStructureInput, InstallmentDetailUncheckedCreateWithoutCourseFeeStructureInput> | InstallmentDetailCreateWithoutCourseFeeStructureInput[] | InstallmentDetailUncheckedCreateWithoutCourseFeeStructureInput[]
    connectOrCreate?: InstallmentDetailCreateOrConnectWithoutCourseFeeStructureInput | InstallmentDetailCreateOrConnectWithoutCourseFeeStructureInput[]
    createMany?: InstallmentDetailCreateManyCourseFeeStructureInputEnvelope
    connect?: InstallmentDetailWhereUniqueInput | InstallmentDetailWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CourseFeeStructureUpdatepaymentTypeInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CourseUpdateOneRequiredWithoutCourseFeeStructureNestedInput = {
    create?: XOR<CourseCreateWithoutCourseFeeStructureInput, CourseUncheckedCreateWithoutCourseFeeStructureInput>
    connectOrCreate?: CourseCreateOrConnectWithoutCourseFeeStructureInput
    upsert?: CourseUpsertWithoutCourseFeeStructureInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutCourseFeeStructureInput, CourseUpdateWithoutCourseFeeStructureInput>, CourseUncheckedUpdateWithoutCourseFeeStructureInput>
  }

  export type InstallmentDetailUpdateManyWithoutCourseFeeStructureNestedInput = {
    create?: XOR<InstallmentDetailCreateWithoutCourseFeeStructureInput, InstallmentDetailUncheckedCreateWithoutCourseFeeStructureInput> | InstallmentDetailCreateWithoutCourseFeeStructureInput[] | InstallmentDetailUncheckedCreateWithoutCourseFeeStructureInput[]
    connectOrCreate?: InstallmentDetailCreateOrConnectWithoutCourseFeeStructureInput | InstallmentDetailCreateOrConnectWithoutCourseFeeStructureInput[]
    upsert?: InstallmentDetailUpsertWithWhereUniqueWithoutCourseFeeStructureInput | InstallmentDetailUpsertWithWhereUniqueWithoutCourseFeeStructureInput[]
    createMany?: InstallmentDetailCreateManyCourseFeeStructureInputEnvelope
    set?: InstallmentDetailWhereUniqueInput | InstallmentDetailWhereUniqueInput[]
    disconnect?: InstallmentDetailWhereUniqueInput | InstallmentDetailWhereUniqueInput[]
    delete?: InstallmentDetailWhereUniqueInput | InstallmentDetailWhereUniqueInput[]
    connect?: InstallmentDetailWhereUniqueInput | InstallmentDetailWhereUniqueInput[]
    update?: InstallmentDetailUpdateWithWhereUniqueWithoutCourseFeeStructureInput | InstallmentDetailUpdateWithWhereUniqueWithoutCourseFeeStructureInput[]
    updateMany?: InstallmentDetailUpdateManyWithWhereWithoutCourseFeeStructureInput | InstallmentDetailUpdateManyWithWhereWithoutCourseFeeStructureInput[]
    deleteMany?: InstallmentDetailScalarWhereInput | InstallmentDetailScalarWhereInput[]
  }

  export type ClientAdminUpdateOneRequiredWithoutCourseFeeStructuresNestedInput = {
    create?: XOR<ClientAdminCreateWithoutCourseFeeStructuresInput, ClientAdminUncheckedCreateWithoutCourseFeeStructuresInput>
    connectOrCreate?: ClientAdminCreateOrConnectWithoutCourseFeeStructuresInput
    upsert?: ClientAdminUpsertWithoutCourseFeeStructuresInput
    connect?: ClientAdminWhereUniqueInput
    update?: XOR<XOR<ClientAdminUpdateToOneWithWhereWithoutCourseFeeStructuresInput, ClientAdminUpdateWithoutCourseFeeStructuresInput>, ClientAdminUncheckedUpdateWithoutCourseFeeStructuresInput>
  }

  export type InstallmentDetailUncheckedUpdateManyWithoutCourseFeeStructureNestedInput = {
    create?: XOR<InstallmentDetailCreateWithoutCourseFeeStructureInput, InstallmentDetailUncheckedCreateWithoutCourseFeeStructureInput> | InstallmentDetailCreateWithoutCourseFeeStructureInput[] | InstallmentDetailUncheckedCreateWithoutCourseFeeStructureInput[]
    connectOrCreate?: InstallmentDetailCreateOrConnectWithoutCourseFeeStructureInput | InstallmentDetailCreateOrConnectWithoutCourseFeeStructureInput[]
    upsert?: InstallmentDetailUpsertWithWhereUniqueWithoutCourseFeeStructureInput | InstallmentDetailUpsertWithWhereUniqueWithoutCourseFeeStructureInput[]
    createMany?: InstallmentDetailCreateManyCourseFeeStructureInputEnvelope
    set?: InstallmentDetailWhereUniqueInput | InstallmentDetailWhereUniqueInput[]
    disconnect?: InstallmentDetailWhereUniqueInput | InstallmentDetailWhereUniqueInput[]
    delete?: InstallmentDetailWhereUniqueInput | InstallmentDetailWhereUniqueInput[]
    connect?: InstallmentDetailWhereUniqueInput | InstallmentDetailWhereUniqueInput[]
    update?: InstallmentDetailUpdateWithWhereUniqueWithoutCourseFeeStructureInput | InstallmentDetailUpdateWithWhereUniqueWithoutCourseFeeStructureInput[]
    updateMany?: InstallmentDetailUpdateManyWithWhereWithoutCourseFeeStructureInput | InstallmentDetailUpdateManyWithWhereWithoutCourseFeeStructureInput[]
    deleteMany?: InstallmentDetailScalarWhereInput | InstallmentDetailScalarWhereInput[]
  }

  export type FacultyCreateNestedOneWithoutBatchesInput = {
    create?: XOR<FacultyCreateWithoutBatchesInput, FacultyUncheckedCreateWithoutBatchesInput>
    connectOrCreate?: FacultyCreateOrConnectWithoutBatchesInput
    connect?: FacultyWhereUniqueInput
  }

  export type LabTimeSlotCreateNestedOneWithoutBatchesInput = {
    create?: XOR<LabTimeSlotCreateWithoutBatchesInput, LabTimeSlotUncheckedCreateWithoutBatchesInput>
    connectOrCreate?: LabTimeSlotCreateOrConnectWithoutBatchesInput
    connect?: LabTimeSlotWhereUniqueInput
  }

  export type StudentCourseCreateNestedManyWithoutBatchInput = {
    create?: XOR<StudentCourseCreateWithoutBatchInput, StudentCourseUncheckedCreateWithoutBatchInput> | StudentCourseCreateWithoutBatchInput[] | StudentCourseUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: StudentCourseCreateOrConnectWithoutBatchInput | StudentCourseCreateOrConnectWithoutBatchInput[]
    createMany?: StudentCourseCreateManyBatchInputEnvelope
    connect?: StudentCourseWhereUniqueInput | StudentCourseWhereUniqueInput[]
  }

  export type BatchCourseCreateNestedManyWithoutBatchInput = {
    create?: XOR<BatchCourseCreateWithoutBatchInput, BatchCourseUncheckedCreateWithoutBatchInput> | BatchCourseCreateWithoutBatchInput[] | BatchCourseUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: BatchCourseCreateOrConnectWithoutBatchInput | BatchCourseCreateOrConnectWithoutBatchInput[]
    createMany?: BatchCourseCreateManyBatchInputEnvelope
    connect?: BatchCourseWhereUniqueInput | BatchCourseWhereUniqueInput[]
  }

  export type ClientAdminCreateNestedOneWithoutBatchesInput = {
    create?: XOR<ClientAdminCreateWithoutBatchesInput, ClientAdminUncheckedCreateWithoutBatchesInput>
    connectOrCreate?: ClientAdminCreateOrConnectWithoutBatchesInput
    connect?: ClientAdminWhereUniqueInput
  }

  export type StudentCourseUncheckedCreateNestedManyWithoutBatchInput = {
    create?: XOR<StudentCourseCreateWithoutBatchInput, StudentCourseUncheckedCreateWithoutBatchInput> | StudentCourseCreateWithoutBatchInput[] | StudentCourseUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: StudentCourseCreateOrConnectWithoutBatchInput | StudentCourseCreateOrConnectWithoutBatchInput[]
    createMany?: StudentCourseCreateManyBatchInputEnvelope
    connect?: StudentCourseWhereUniqueInput | StudentCourseWhereUniqueInput[]
  }

  export type BatchCourseUncheckedCreateNestedManyWithoutBatchInput = {
    create?: XOR<BatchCourseCreateWithoutBatchInput, BatchCourseUncheckedCreateWithoutBatchInput> | BatchCourseCreateWithoutBatchInput[] | BatchCourseUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: BatchCourseCreateOrConnectWithoutBatchInput | BatchCourseCreateOrConnectWithoutBatchInput[]
    createMany?: BatchCourseCreateManyBatchInputEnvelope
    connect?: BatchCourseWhereUniqueInput | BatchCourseWhereUniqueInput[]
  }

  export type FacultyUpdateOneWithoutBatchesNestedInput = {
    create?: XOR<FacultyCreateWithoutBatchesInput, FacultyUncheckedCreateWithoutBatchesInput>
    connectOrCreate?: FacultyCreateOrConnectWithoutBatchesInput
    upsert?: FacultyUpsertWithoutBatchesInput
    disconnect?: FacultyWhereInput | boolean
    delete?: FacultyWhereInput | boolean
    connect?: FacultyWhereUniqueInput
    update?: XOR<XOR<FacultyUpdateToOneWithWhereWithoutBatchesInput, FacultyUpdateWithoutBatchesInput>, FacultyUncheckedUpdateWithoutBatchesInput>
  }

  export type LabTimeSlotUpdateOneRequiredWithoutBatchesNestedInput = {
    create?: XOR<LabTimeSlotCreateWithoutBatchesInput, LabTimeSlotUncheckedCreateWithoutBatchesInput>
    connectOrCreate?: LabTimeSlotCreateOrConnectWithoutBatchesInput
    upsert?: LabTimeSlotUpsertWithoutBatchesInput
    connect?: LabTimeSlotWhereUniqueInput
    update?: XOR<XOR<LabTimeSlotUpdateToOneWithWhereWithoutBatchesInput, LabTimeSlotUpdateWithoutBatchesInput>, LabTimeSlotUncheckedUpdateWithoutBatchesInput>
  }

  export type StudentCourseUpdateManyWithoutBatchNestedInput = {
    create?: XOR<StudentCourseCreateWithoutBatchInput, StudentCourseUncheckedCreateWithoutBatchInput> | StudentCourseCreateWithoutBatchInput[] | StudentCourseUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: StudentCourseCreateOrConnectWithoutBatchInput | StudentCourseCreateOrConnectWithoutBatchInput[]
    upsert?: StudentCourseUpsertWithWhereUniqueWithoutBatchInput | StudentCourseUpsertWithWhereUniqueWithoutBatchInput[]
    createMany?: StudentCourseCreateManyBatchInputEnvelope
    set?: StudentCourseWhereUniqueInput | StudentCourseWhereUniqueInput[]
    disconnect?: StudentCourseWhereUniqueInput | StudentCourseWhereUniqueInput[]
    delete?: StudentCourseWhereUniqueInput | StudentCourseWhereUniqueInput[]
    connect?: StudentCourseWhereUniqueInput | StudentCourseWhereUniqueInput[]
    update?: StudentCourseUpdateWithWhereUniqueWithoutBatchInput | StudentCourseUpdateWithWhereUniqueWithoutBatchInput[]
    updateMany?: StudentCourseUpdateManyWithWhereWithoutBatchInput | StudentCourseUpdateManyWithWhereWithoutBatchInput[]
    deleteMany?: StudentCourseScalarWhereInput | StudentCourseScalarWhereInput[]
  }

  export type BatchCourseUpdateManyWithoutBatchNestedInput = {
    create?: XOR<BatchCourseCreateWithoutBatchInput, BatchCourseUncheckedCreateWithoutBatchInput> | BatchCourseCreateWithoutBatchInput[] | BatchCourseUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: BatchCourseCreateOrConnectWithoutBatchInput | BatchCourseCreateOrConnectWithoutBatchInput[]
    upsert?: BatchCourseUpsertWithWhereUniqueWithoutBatchInput | BatchCourseUpsertWithWhereUniqueWithoutBatchInput[]
    createMany?: BatchCourseCreateManyBatchInputEnvelope
    set?: BatchCourseWhereUniqueInput | BatchCourseWhereUniqueInput[]
    disconnect?: BatchCourseWhereUniqueInput | BatchCourseWhereUniqueInput[]
    delete?: BatchCourseWhereUniqueInput | BatchCourseWhereUniqueInput[]
    connect?: BatchCourseWhereUniqueInput | BatchCourseWhereUniqueInput[]
    update?: BatchCourseUpdateWithWhereUniqueWithoutBatchInput | BatchCourseUpdateWithWhereUniqueWithoutBatchInput[]
    updateMany?: BatchCourseUpdateManyWithWhereWithoutBatchInput | BatchCourseUpdateManyWithWhereWithoutBatchInput[]
    deleteMany?: BatchCourseScalarWhereInput | BatchCourseScalarWhereInput[]
  }

  export type ClientAdminUpdateOneRequiredWithoutBatchesNestedInput = {
    create?: XOR<ClientAdminCreateWithoutBatchesInput, ClientAdminUncheckedCreateWithoutBatchesInput>
    connectOrCreate?: ClientAdminCreateOrConnectWithoutBatchesInput
    upsert?: ClientAdminUpsertWithoutBatchesInput
    connect?: ClientAdminWhereUniqueInput
    update?: XOR<XOR<ClientAdminUpdateToOneWithWhereWithoutBatchesInput, ClientAdminUpdateWithoutBatchesInput>, ClientAdminUncheckedUpdateWithoutBatchesInput>
  }

  export type StudentCourseUncheckedUpdateManyWithoutBatchNestedInput = {
    create?: XOR<StudentCourseCreateWithoutBatchInput, StudentCourseUncheckedCreateWithoutBatchInput> | StudentCourseCreateWithoutBatchInput[] | StudentCourseUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: StudentCourseCreateOrConnectWithoutBatchInput | StudentCourseCreateOrConnectWithoutBatchInput[]
    upsert?: StudentCourseUpsertWithWhereUniqueWithoutBatchInput | StudentCourseUpsertWithWhereUniqueWithoutBatchInput[]
    createMany?: StudentCourseCreateManyBatchInputEnvelope
    set?: StudentCourseWhereUniqueInput | StudentCourseWhereUniqueInput[]
    disconnect?: StudentCourseWhereUniqueInput | StudentCourseWhereUniqueInput[]
    delete?: StudentCourseWhereUniqueInput | StudentCourseWhereUniqueInput[]
    connect?: StudentCourseWhereUniqueInput | StudentCourseWhereUniqueInput[]
    update?: StudentCourseUpdateWithWhereUniqueWithoutBatchInput | StudentCourseUpdateWithWhereUniqueWithoutBatchInput[]
    updateMany?: StudentCourseUpdateManyWithWhereWithoutBatchInput | StudentCourseUpdateManyWithWhereWithoutBatchInput[]
    deleteMany?: StudentCourseScalarWhereInput | StudentCourseScalarWhereInput[]
  }

  export type BatchCourseUncheckedUpdateManyWithoutBatchNestedInput = {
    create?: XOR<BatchCourseCreateWithoutBatchInput, BatchCourseUncheckedCreateWithoutBatchInput> | BatchCourseCreateWithoutBatchInput[] | BatchCourseUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: BatchCourseCreateOrConnectWithoutBatchInput | BatchCourseCreateOrConnectWithoutBatchInput[]
    upsert?: BatchCourseUpsertWithWhereUniqueWithoutBatchInput | BatchCourseUpsertWithWhereUniqueWithoutBatchInput[]
    createMany?: BatchCourseCreateManyBatchInputEnvelope
    set?: BatchCourseWhereUniqueInput | BatchCourseWhereUniqueInput[]
    disconnect?: BatchCourseWhereUniqueInput | BatchCourseWhereUniqueInput[]
    delete?: BatchCourseWhereUniqueInput | BatchCourseWhereUniqueInput[]
    connect?: BatchCourseWhereUniqueInput | BatchCourseWhereUniqueInput[]
    update?: BatchCourseUpdateWithWhereUniqueWithoutBatchInput | BatchCourseUpdateWithWhereUniqueWithoutBatchInput[]
    updateMany?: BatchCourseUpdateManyWithWhereWithoutBatchInput | BatchCourseUpdateManyWithWhereWithoutBatchInput[]
    deleteMany?: BatchCourseScalarWhereInput | BatchCourseScalarWhereInput[]
  }

  export type BatchCreateNestedOneWithoutBatchCoursesInput = {
    create?: XOR<BatchCreateWithoutBatchCoursesInput, BatchUncheckedCreateWithoutBatchCoursesInput>
    connectOrCreate?: BatchCreateOrConnectWithoutBatchCoursesInput
    connect?: BatchWhereUniqueInput
  }

  export type CourseCreateNestedOneWithoutBatchCoursesInput = {
    create?: XOR<CourseCreateWithoutBatchCoursesInput, CourseUncheckedCreateWithoutBatchCoursesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutBatchCoursesInput
    connect?: CourseWhereUniqueInput
  }

  export type BatchUpdateOneRequiredWithoutBatchCoursesNestedInput = {
    create?: XOR<BatchCreateWithoutBatchCoursesInput, BatchUncheckedCreateWithoutBatchCoursesInput>
    connectOrCreate?: BatchCreateOrConnectWithoutBatchCoursesInput
    upsert?: BatchUpsertWithoutBatchCoursesInput
    connect?: BatchWhereUniqueInput
    update?: XOR<XOR<BatchUpdateToOneWithWhereWithoutBatchCoursesInput, BatchUpdateWithoutBatchCoursesInput>, BatchUncheckedUpdateWithoutBatchCoursesInput>
  }

  export type CourseUpdateOneRequiredWithoutBatchCoursesNestedInput = {
    create?: XOR<CourseCreateWithoutBatchCoursesInput, CourseUncheckedCreateWithoutBatchCoursesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutBatchCoursesInput
    upsert?: CourseUpsertWithoutBatchCoursesInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutBatchCoursesInput, CourseUpdateWithoutBatchCoursesInput>, CourseUncheckedUpdateWithoutBatchCoursesInput>
  }

  export type BatchCreateNestedManyWithoutFacultyInput = {
    create?: XOR<BatchCreateWithoutFacultyInput, BatchUncheckedCreateWithoutFacultyInput> | BatchCreateWithoutFacultyInput[] | BatchUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutFacultyInput | BatchCreateOrConnectWithoutFacultyInput[]
    createMany?: BatchCreateManyFacultyInputEnvelope
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
  }

  export type AttendanceRecordCreateNestedManyWithoutMarkedByInput = {
    create?: XOR<AttendanceRecordCreateWithoutMarkedByInput, AttendanceRecordUncheckedCreateWithoutMarkedByInput> | AttendanceRecordCreateWithoutMarkedByInput[] | AttendanceRecordUncheckedCreateWithoutMarkedByInput[]
    connectOrCreate?: AttendanceRecordCreateOrConnectWithoutMarkedByInput | AttendanceRecordCreateOrConnectWithoutMarkedByInput[]
    createMany?: AttendanceRecordCreateManyMarkedByInputEnvelope
    connect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
  }

  export type StudentTaskCreateNestedManyWithoutFacultyInput = {
    create?: XOR<StudentTaskCreateWithoutFacultyInput, StudentTaskUncheckedCreateWithoutFacultyInput> | StudentTaskCreateWithoutFacultyInput[] | StudentTaskUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: StudentTaskCreateOrConnectWithoutFacultyInput | StudentTaskCreateOrConnectWithoutFacultyInput[]
    createMany?: StudentTaskCreateManyFacultyInputEnvelope
    connect?: StudentTaskWhereUniqueInput | StudentTaskWhereUniqueInput[]
  }

  export type FinancialRecordCreateNestedManyWithoutFacultyInput = {
    create?: XOR<FinancialRecordCreateWithoutFacultyInput, FinancialRecordUncheckedCreateWithoutFacultyInput> | FinancialRecordCreateWithoutFacultyInput[] | FinancialRecordUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: FinancialRecordCreateOrConnectWithoutFacultyInput | FinancialRecordCreateOrConnectWithoutFacultyInput[]
    createMany?: FinancialRecordCreateManyFacultyInputEnvelope
    connect?: FinancialRecordWhereUniqueInput | FinancialRecordWhereUniqueInput[]
  }

  export type ClientAdminCreateNestedOneWithoutFacultiesInput = {
    create?: XOR<ClientAdminCreateWithoutFacultiesInput, ClientAdminUncheckedCreateWithoutFacultiesInput>
    connectOrCreate?: ClientAdminCreateOrConnectWithoutFacultiesInput
    connect?: ClientAdminWhereUniqueInput
  }

  export type BatchUncheckedCreateNestedManyWithoutFacultyInput = {
    create?: XOR<BatchCreateWithoutFacultyInput, BatchUncheckedCreateWithoutFacultyInput> | BatchCreateWithoutFacultyInput[] | BatchUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutFacultyInput | BatchCreateOrConnectWithoutFacultyInput[]
    createMany?: BatchCreateManyFacultyInputEnvelope
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
  }

  export type AttendanceRecordUncheckedCreateNestedManyWithoutMarkedByInput = {
    create?: XOR<AttendanceRecordCreateWithoutMarkedByInput, AttendanceRecordUncheckedCreateWithoutMarkedByInput> | AttendanceRecordCreateWithoutMarkedByInput[] | AttendanceRecordUncheckedCreateWithoutMarkedByInput[]
    connectOrCreate?: AttendanceRecordCreateOrConnectWithoutMarkedByInput | AttendanceRecordCreateOrConnectWithoutMarkedByInput[]
    createMany?: AttendanceRecordCreateManyMarkedByInputEnvelope
    connect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
  }

  export type StudentTaskUncheckedCreateNestedManyWithoutFacultyInput = {
    create?: XOR<StudentTaskCreateWithoutFacultyInput, StudentTaskUncheckedCreateWithoutFacultyInput> | StudentTaskCreateWithoutFacultyInput[] | StudentTaskUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: StudentTaskCreateOrConnectWithoutFacultyInput | StudentTaskCreateOrConnectWithoutFacultyInput[]
    createMany?: StudentTaskCreateManyFacultyInputEnvelope
    connect?: StudentTaskWhereUniqueInput | StudentTaskWhereUniqueInput[]
  }

  export type FinancialRecordUncheckedCreateNestedManyWithoutFacultyInput = {
    create?: XOR<FinancialRecordCreateWithoutFacultyInput, FinancialRecordUncheckedCreateWithoutFacultyInput> | FinancialRecordCreateWithoutFacultyInput[] | FinancialRecordUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: FinancialRecordCreateOrConnectWithoutFacultyInput | FinancialRecordCreateOrConnectWithoutFacultyInput[]
    createMany?: FinancialRecordCreateManyFacultyInputEnvelope
    connect?: FinancialRecordWhereUniqueInput | FinancialRecordWhereUniqueInput[]
  }

  export type BatchUpdateManyWithoutFacultyNestedInput = {
    create?: XOR<BatchCreateWithoutFacultyInput, BatchUncheckedCreateWithoutFacultyInput> | BatchCreateWithoutFacultyInput[] | BatchUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutFacultyInput | BatchCreateOrConnectWithoutFacultyInput[]
    upsert?: BatchUpsertWithWhereUniqueWithoutFacultyInput | BatchUpsertWithWhereUniqueWithoutFacultyInput[]
    createMany?: BatchCreateManyFacultyInputEnvelope
    set?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    disconnect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    delete?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    update?: BatchUpdateWithWhereUniqueWithoutFacultyInput | BatchUpdateWithWhereUniqueWithoutFacultyInput[]
    updateMany?: BatchUpdateManyWithWhereWithoutFacultyInput | BatchUpdateManyWithWhereWithoutFacultyInput[]
    deleteMany?: BatchScalarWhereInput | BatchScalarWhereInput[]
  }

  export type AttendanceRecordUpdateManyWithoutMarkedByNestedInput = {
    create?: XOR<AttendanceRecordCreateWithoutMarkedByInput, AttendanceRecordUncheckedCreateWithoutMarkedByInput> | AttendanceRecordCreateWithoutMarkedByInput[] | AttendanceRecordUncheckedCreateWithoutMarkedByInput[]
    connectOrCreate?: AttendanceRecordCreateOrConnectWithoutMarkedByInput | AttendanceRecordCreateOrConnectWithoutMarkedByInput[]
    upsert?: AttendanceRecordUpsertWithWhereUniqueWithoutMarkedByInput | AttendanceRecordUpsertWithWhereUniqueWithoutMarkedByInput[]
    createMany?: AttendanceRecordCreateManyMarkedByInputEnvelope
    set?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    disconnect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    delete?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    connect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    update?: AttendanceRecordUpdateWithWhereUniqueWithoutMarkedByInput | AttendanceRecordUpdateWithWhereUniqueWithoutMarkedByInput[]
    updateMany?: AttendanceRecordUpdateManyWithWhereWithoutMarkedByInput | AttendanceRecordUpdateManyWithWhereWithoutMarkedByInput[]
    deleteMany?: AttendanceRecordScalarWhereInput | AttendanceRecordScalarWhereInput[]
  }

  export type StudentTaskUpdateManyWithoutFacultyNestedInput = {
    create?: XOR<StudentTaskCreateWithoutFacultyInput, StudentTaskUncheckedCreateWithoutFacultyInput> | StudentTaskCreateWithoutFacultyInput[] | StudentTaskUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: StudentTaskCreateOrConnectWithoutFacultyInput | StudentTaskCreateOrConnectWithoutFacultyInput[]
    upsert?: StudentTaskUpsertWithWhereUniqueWithoutFacultyInput | StudentTaskUpsertWithWhereUniqueWithoutFacultyInput[]
    createMany?: StudentTaskCreateManyFacultyInputEnvelope
    set?: StudentTaskWhereUniqueInput | StudentTaskWhereUniqueInput[]
    disconnect?: StudentTaskWhereUniqueInput | StudentTaskWhereUniqueInput[]
    delete?: StudentTaskWhereUniqueInput | StudentTaskWhereUniqueInput[]
    connect?: StudentTaskWhereUniqueInput | StudentTaskWhereUniqueInput[]
    update?: StudentTaskUpdateWithWhereUniqueWithoutFacultyInput | StudentTaskUpdateWithWhereUniqueWithoutFacultyInput[]
    updateMany?: StudentTaskUpdateManyWithWhereWithoutFacultyInput | StudentTaskUpdateManyWithWhereWithoutFacultyInput[]
    deleteMany?: StudentTaskScalarWhereInput | StudentTaskScalarWhereInput[]
  }

  export type FinancialRecordUpdateManyWithoutFacultyNestedInput = {
    create?: XOR<FinancialRecordCreateWithoutFacultyInput, FinancialRecordUncheckedCreateWithoutFacultyInput> | FinancialRecordCreateWithoutFacultyInput[] | FinancialRecordUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: FinancialRecordCreateOrConnectWithoutFacultyInput | FinancialRecordCreateOrConnectWithoutFacultyInput[]
    upsert?: FinancialRecordUpsertWithWhereUniqueWithoutFacultyInput | FinancialRecordUpsertWithWhereUniqueWithoutFacultyInput[]
    createMany?: FinancialRecordCreateManyFacultyInputEnvelope
    set?: FinancialRecordWhereUniqueInput | FinancialRecordWhereUniqueInput[]
    disconnect?: FinancialRecordWhereUniqueInput | FinancialRecordWhereUniqueInput[]
    delete?: FinancialRecordWhereUniqueInput | FinancialRecordWhereUniqueInput[]
    connect?: FinancialRecordWhereUniqueInput | FinancialRecordWhereUniqueInput[]
    update?: FinancialRecordUpdateWithWhereUniqueWithoutFacultyInput | FinancialRecordUpdateWithWhereUniqueWithoutFacultyInput[]
    updateMany?: FinancialRecordUpdateManyWithWhereWithoutFacultyInput | FinancialRecordUpdateManyWithWhereWithoutFacultyInput[]
    deleteMany?: FinancialRecordScalarWhereInput | FinancialRecordScalarWhereInput[]
  }

  export type ClientAdminUpdateOneRequiredWithoutFacultiesNestedInput = {
    create?: XOR<ClientAdminCreateWithoutFacultiesInput, ClientAdminUncheckedCreateWithoutFacultiesInput>
    connectOrCreate?: ClientAdminCreateOrConnectWithoutFacultiesInput
    upsert?: ClientAdminUpsertWithoutFacultiesInput
    connect?: ClientAdminWhereUniqueInput
    update?: XOR<XOR<ClientAdminUpdateToOneWithWhereWithoutFacultiesInput, ClientAdminUpdateWithoutFacultiesInput>, ClientAdminUncheckedUpdateWithoutFacultiesInput>
  }

  export type BatchUncheckedUpdateManyWithoutFacultyNestedInput = {
    create?: XOR<BatchCreateWithoutFacultyInput, BatchUncheckedCreateWithoutFacultyInput> | BatchCreateWithoutFacultyInput[] | BatchUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutFacultyInput | BatchCreateOrConnectWithoutFacultyInput[]
    upsert?: BatchUpsertWithWhereUniqueWithoutFacultyInput | BatchUpsertWithWhereUniqueWithoutFacultyInput[]
    createMany?: BatchCreateManyFacultyInputEnvelope
    set?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    disconnect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    delete?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    update?: BatchUpdateWithWhereUniqueWithoutFacultyInput | BatchUpdateWithWhereUniqueWithoutFacultyInput[]
    updateMany?: BatchUpdateManyWithWhereWithoutFacultyInput | BatchUpdateManyWithWhereWithoutFacultyInput[]
    deleteMany?: BatchScalarWhereInput | BatchScalarWhereInput[]
  }

  export type AttendanceRecordUncheckedUpdateManyWithoutMarkedByNestedInput = {
    create?: XOR<AttendanceRecordCreateWithoutMarkedByInput, AttendanceRecordUncheckedCreateWithoutMarkedByInput> | AttendanceRecordCreateWithoutMarkedByInput[] | AttendanceRecordUncheckedCreateWithoutMarkedByInput[]
    connectOrCreate?: AttendanceRecordCreateOrConnectWithoutMarkedByInput | AttendanceRecordCreateOrConnectWithoutMarkedByInput[]
    upsert?: AttendanceRecordUpsertWithWhereUniqueWithoutMarkedByInput | AttendanceRecordUpsertWithWhereUniqueWithoutMarkedByInput[]
    createMany?: AttendanceRecordCreateManyMarkedByInputEnvelope
    set?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    disconnect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    delete?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    connect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    update?: AttendanceRecordUpdateWithWhereUniqueWithoutMarkedByInput | AttendanceRecordUpdateWithWhereUniqueWithoutMarkedByInput[]
    updateMany?: AttendanceRecordUpdateManyWithWhereWithoutMarkedByInput | AttendanceRecordUpdateManyWithWhereWithoutMarkedByInput[]
    deleteMany?: AttendanceRecordScalarWhereInput | AttendanceRecordScalarWhereInput[]
  }

  export type StudentTaskUncheckedUpdateManyWithoutFacultyNestedInput = {
    create?: XOR<StudentTaskCreateWithoutFacultyInput, StudentTaskUncheckedCreateWithoutFacultyInput> | StudentTaskCreateWithoutFacultyInput[] | StudentTaskUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: StudentTaskCreateOrConnectWithoutFacultyInput | StudentTaskCreateOrConnectWithoutFacultyInput[]
    upsert?: StudentTaskUpsertWithWhereUniqueWithoutFacultyInput | StudentTaskUpsertWithWhereUniqueWithoutFacultyInput[]
    createMany?: StudentTaskCreateManyFacultyInputEnvelope
    set?: StudentTaskWhereUniqueInput | StudentTaskWhereUniqueInput[]
    disconnect?: StudentTaskWhereUniqueInput | StudentTaskWhereUniqueInput[]
    delete?: StudentTaskWhereUniqueInput | StudentTaskWhereUniqueInput[]
    connect?: StudentTaskWhereUniqueInput | StudentTaskWhereUniqueInput[]
    update?: StudentTaskUpdateWithWhereUniqueWithoutFacultyInput | StudentTaskUpdateWithWhereUniqueWithoutFacultyInput[]
    updateMany?: StudentTaskUpdateManyWithWhereWithoutFacultyInput | StudentTaskUpdateManyWithWhereWithoutFacultyInput[]
    deleteMany?: StudentTaskScalarWhereInput | StudentTaskScalarWhereInput[]
  }

  export type FinancialRecordUncheckedUpdateManyWithoutFacultyNestedInput = {
    create?: XOR<FinancialRecordCreateWithoutFacultyInput, FinancialRecordUncheckedCreateWithoutFacultyInput> | FinancialRecordCreateWithoutFacultyInput[] | FinancialRecordUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: FinancialRecordCreateOrConnectWithoutFacultyInput | FinancialRecordCreateOrConnectWithoutFacultyInput[]
    upsert?: FinancialRecordUpsertWithWhereUniqueWithoutFacultyInput | FinancialRecordUpsertWithWhereUniqueWithoutFacultyInput[]
    createMany?: FinancialRecordCreateManyFacultyInputEnvelope
    set?: FinancialRecordWhereUniqueInput | FinancialRecordWhereUniqueInput[]
    disconnect?: FinancialRecordWhereUniqueInput | FinancialRecordWhereUniqueInput[]
    delete?: FinancialRecordWhereUniqueInput | FinancialRecordWhereUniqueInput[]
    connect?: FinancialRecordWhereUniqueInput | FinancialRecordWhereUniqueInput[]
    update?: FinancialRecordUpdateWithWhereUniqueWithoutFacultyInput | FinancialRecordUpdateWithWhereUniqueWithoutFacultyInput[]
    updateMany?: FinancialRecordUpdateManyWithWhereWithoutFacultyInput | FinancialRecordUpdateManyWithWhereWithoutFacultyInput[]
    deleteMany?: FinancialRecordScalarWhereInput | FinancialRecordScalarWhereInput[]
  }

  export type LabTimeSlotCreateNestedManyWithoutLabInput = {
    create?: XOR<LabTimeSlotCreateWithoutLabInput, LabTimeSlotUncheckedCreateWithoutLabInput> | LabTimeSlotCreateWithoutLabInput[] | LabTimeSlotUncheckedCreateWithoutLabInput[]
    connectOrCreate?: LabTimeSlotCreateOrConnectWithoutLabInput | LabTimeSlotCreateOrConnectWithoutLabInput[]
    createMany?: LabTimeSlotCreateManyLabInputEnvelope
    connect?: LabTimeSlotWhereUniqueInput | LabTimeSlotWhereUniqueInput[]
  }

  export type FinancialRecordCreateNestedManyWithoutLabInput = {
    create?: XOR<FinancialRecordCreateWithoutLabInput, FinancialRecordUncheckedCreateWithoutLabInput> | FinancialRecordCreateWithoutLabInput[] | FinancialRecordUncheckedCreateWithoutLabInput[]
    connectOrCreate?: FinancialRecordCreateOrConnectWithoutLabInput | FinancialRecordCreateOrConnectWithoutLabInput[]
    createMany?: FinancialRecordCreateManyLabInputEnvelope
    connect?: FinancialRecordWhereUniqueInput | FinancialRecordWhereUniqueInput[]
  }

  export type ClientAdminCreateNestedOneWithoutLabsInput = {
    create?: XOR<ClientAdminCreateWithoutLabsInput, ClientAdminUncheckedCreateWithoutLabsInput>
    connectOrCreate?: ClientAdminCreateOrConnectWithoutLabsInput
    connect?: ClientAdminWhereUniqueInput
  }

  export type LabTimeSlotUncheckedCreateNestedManyWithoutLabInput = {
    create?: XOR<LabTimeSlotCreateWithoutLabInput, LabTimeSlotUncheckedCreateWithoutLabInput> | LabTimeSlotCreateWithoutLabInput[] | LabTimeSlotUncheckedCreateWithoutLabInput[]
    connectOrCreate?: LabTimeSlotCreateOrConnectWithoutLabInput | LabTimeSlotCreateOrConnectWithoutLabInput[]
    createMany?: LabTimeSlotCreateManyLabInputEnvelope
    connect?: LabTimeSlotWhereUniqueInput | LabTimeSlotWhereUniqueInput[]
  }

  export type FinancialRecordUncheckedCreateNestedManyWithoutLabInput = {
    create?: XOR<FinancialRecordCreateWithoutLabInput, FinancialRecordUncheckedCreateWithoutLabInput> | FinancialRecordCreateWithoutLabInput[] | FinancialRecordUncheckedCreateWithoutLabInput[]
    connectOrCreate?: FinancialRecordCreateOrConnectWithoutLabInput | FinancialRecordCreateOrConnectWithoutLabInput[]
    createMany?: FinancialRecordCreateManyLabInputEnvelope
    connect?: FinancialRecordWhereUniqueInput | FinancialRecordWhereUniqueInput[]
  }

  export type LabTimeSlotUpdateManyWithoutLabNestedInput = {
    create?: XOR<LabTimeSlotCreateWithoutLabInput, LabTimeSlotUncheckedCreateWithoutLabInput> | LabTimeSlotCreateWithoutLabInput[] | LabTimeSlotUncheckedCreateWithoutLabInput[]
    connectOrCreate?: LabTimeSlotCreateOrConnectWithoutLabInput | LabTimeSlotCreateOrConnectWithoutLabInput[]
    upsert?: LabTimeSlotUpsertWithWhereUniqueWithoutLabInput | LabTimeSlotUpsertWithWhereUniqueWithoutLabInput[]
    createMany?: LabTimeSlotCreateManyLabInputEnvelope
    set?: LabTimeSlotWhereUniqueInput | LabTimeSlotWhereUniqueInput[]
    disconnect?: LabTimeSlotWhereUniqueInput | LabTimeSlotWhereUniqueInput[]
    delete?: LabTimeSlotWhereUniqueInput | LabTimeSlotWhereUniqueInput[]
    connect?: LabTimeSlotWhereUniqueInput | LabTimeSlotWhereUniqueInput[]
    update?: LabTimeSlotUpdateWithWhereUniqueWithoutLabInput | LabTimeSlotUpdateWithWhereUniqueWithoutLabInput[]
    updateMany?: LabTimeSlotUpdateManyWithWhereWithoutLabInput | LabTimeSlotUpdateManyWithWhereWithoutLabInput[]
    deleteMany?: LabTimeSlotScalarWhereInput | LabTimeSlotScalarWhereInput[]
  }

  export type FinancialRecordUpdateManyWithoutLabNestedInput = {
    create?: XOR<FinancialRecordCreateWithoutLabInput, FinancialRecordUncheckedCreateWithoutLabInput> | FinancialRecordCreateWithoutLabInput[] | FinancialRecordUncheckedCreateWithoutLabInput[]
    connectOrCreate?: FinancialRecordCreateOrConnectWithoutLabInput | FinancialRecordCreateOrConnectWithoutLabInput[]
    upsert?: FinancialRecordUpsertWithWhereUniqueWithoutLabInput | FinancialRecordUpsertWithWhereUniqueWithoutLabInput[]
    createMany?: FinancialRecordCreateManyLabInputEnvelope
    set?: FinancialRecordWhereUniqueInput | FinancialRecordWhereUniqueInput[]
    disconnect?: FinancialRecordWhereUniqueInput | FinancialRecordWhereUniqueInput[]
    delete?: FinancialRecordWhereUniqueInput | FinancialRecordWhereUniqueInput[]
    connect?: FinancialRecordWhereUniqueInput | FinancialRecordWhereUniqueInput[]
    update?: FinancialRecordUpdateWithWhereUniqueWithoutLabInput | FinancialRecordUpdateWithWhereUniqueWithoutLabInput[]
    updateMany?: FinancialRecordUpdateManyWithWhereWithoutLabInput | FinancialRecordUpdateManyWithWhereWithoutLabInput[]
    deleteMany?: FinancialRecordScalarWhereInput | FinancialRecordScalarWhereInput[]
  }

  export type ClientAdminUpdateOneRequiredWithoutLabsNestedInput = {
    create?: XOR<ClientAdminCreateWithoutLabsInput, ClientAdminUncheckedCreateWithoutLabsInput>
    connectOrCreate?: ClientAdminCreateOrConnectWithoutLabsInput
    upsert?: ClientAdminUpsertWithoutLabsInput
    connect?: ClientAdminWhereUniqueInput
    update?: XOR<XOR<ClientAdminUpdateToOneWithWhereWithoutLabsInput, ClientAdminUpdateWithoutLabsInput>, ClientAdminUncheckedUpdateWithoutLabsInput>
  }

  export type LabTimeSlotUncheckedUpdateManyWithoutLabNestedInput = {
    create?: XOR<LabTimeSlotCreateWithoutLabInput, LabTimeSlotUncheckedCreateWithoutLabInput> | LabTimeSlotCreateWithoutLabInput[] | LabTimeSlotUncheckedCreateWithoutLabInput[]
    connectOrCreate?: LabTimeSlotCreateOrConnectWithoutLabInput | LabTimeSlotCreateOrConnectWithoutLabInput[]
    upsert?: LabTimeSlotUpsertWithWhereUniqueWithoutLabInput | LabTimeSlotUpsertWithWhereUniqueWithoutLabInput[]
    createMany?: LabTimeSlotCreateManyLabInputEnvelope
    set?: LabTimeSlotWhereUniqueInput | LabTimeSlotWhereUniqueInput[]
    disconnect?: LabTimeSlotWhereUniqueInput | LabTimeSlotWhereUniqueInput[]
    delete?: LabTimeSlotWhereUniqueInput | LabTimeSlotWhereUniqueInput[]
    connect?: LabTimeSlotWhereUniqueInput | LabTimeSlotWhereUniqueInput[]
    update?: LabTimeSlotUpdateWithWhereUniqueWithoutLabInput | LabTimeSlotUpdateWithWhereUniqueWithoutLabInput[]
    updateMany?: LabTimeSlotUpdateManyWithWhereWithoutLabInput | LabTimeSlotUpdateManyWithWhereWithoutLabInput[]
    deleteMany?: LabTimeSlotScalarWhereInput | LabTimeSlotScalarWhereInput[]
  }

  export type FinancialRecordUncheckedUpdateManyWithoutLabNestedInput = {
    create?: XOR<FinancialRecordCreateWithoutLabInput, FinancialRecordUncheckedCreateWithoutLabInput> | FinancialRecordCreateWithoutLabInput[] | FinancialRecordUncheckedCreateWithoutLabInput[]
    connectOrCreate?: FinancialRecordCreateOrConnectWithoutLabInput | FinancialRecordCreateOrConnectWithoutLabInput[]
    upsert?: FinancialRecordUpsertWithWhereUniqueWithoutLabInput | FinancialRecordUpsertWithWhereUniqueWithoutLabInput[]
    createMany?: FinancialRecordCreateManyLabInputEnvelope
    set?: FinancialRecordWhereUniqueInput | FinancialRecordWhereUniqueInput[]
    disconnect?: FinancialRecordWhereUniqueInput | FinancialRecordWhereUniqueInput[]
    delete?: FinancialRecordWhereUniqueInput | FinancialRecordWhereUniqueInput[]
    connect?: FinancialRecordWhereUniqueInput | FinancialRecordWhereUniqueInput[]
    update?: FinancialRecordUpdateWithWhereUniqueWithoutLabInput | FinancialRecordUpdateWithWhereUniqueWithoutLabInput[]
    updateMany?: FinancialRecordUpdateManyWithWhereWithoutLabInput | FinancialRecordUpdateManyWithWhereWithoutLabInput[]
    deleteMany?: FinancialRecordScalarWhereInput | FinancialRecordScalarWhereInput[]
  }

  export type LabCreateNestedOneWithoutTimeSlotsInput = {
    create?: XOR<LabCreateWithoutTimeSlotsInput, LabUncheckedCreateWithoutTimeSlotsInput>
    connectOrCreate?: LabCreateOrConnectWithoutTimeSlotsInput
    connect?: LabWhereUniqueInput
  }

  export type BatchCreateNestedManyWithoutLabTimeSlotInput = {
    create?: XOR<BatchCreateWithoutLabTimeSlotInput, BatchUncheckedCreateWithoutLabTimeSlotInput> | BatchCreateWithoutLabTimeSlotInput[] | BatchUncheckedCreateWithoutLabTimeSlotInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutLabTimeSlotInput | BatchCreateOrConnectWithoutLabTimeSlotInput[]
    createMany?: BatchCreateManyLabTimeSlotInputEnvelope
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
  }

  export type LabAllocationCreateNestedManyWithoutLabTimeSlotInput = {
    create?: XOR<LabAllocationCreateWithoutLabTimeSlotInput, LabAllocationUncheckedCreateWithoutLabTimeSlotInput> | LabAllocationCreateWithoutLabTimeSlotInput[] | LabAllocationUncheckedCreateWithoutLabTimeSlotInput[]
    connectOrCreate?: LabAllocationCreateOrConnectWithoutLabTimeSlotInput | LabAllocationCreateOrConnectWithoutLabTimeSlotInput[]
    createMany?: LabAllocationCreateManyLabTimeSlotInputEnvelope
    connect?: LabAllocationWhereUniqueInput | LabAllocationWhereUniqueInput[]
  }

  export type ClientAdminCreateNestedOneWithoutLabTimeSlotsInput = {
    create?: XOR<ClientAdminCreateWithoutLabTimeSlotsInput, ClientAdminUncheckedCreateWithoutLabTimeSlotsInput>
    connectOrCreate?: ClientAdminCreateOrConnectWithoutLabTimeSlotsInput
    connect?: ClientAdminWhereUniqueInput
  }

  export type BatchUncheckedCreateNestedManyWithoutLabTimeSlotInput = {
    create?: XOR<BatchCreateWithoutLabTimeSlotInput, BatchUncheckedCreateWithoutLabTimeSlotInput> | BatchCreateWithoutLabTimeSlotInput[] | BatchUncheckedCreateWithoutLabTimeSlotInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutLabTimeSlotInput | BatchCreateOrConnectWithoutLabTimeSlotInput[]
    createMany?: BatchCreateManyLabTimeSlotInputEnvelope
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
  }

  export type LabAllocationUncheckedCreateNestedManyWithoutLabTimeSlotInput = {
    create?: XOR<LabAllocationCreateWithoutLabTimeSlotInput, LabAllocationUncheckedCreateWithoutLabTimeSlotInput> | LabAllocationCreateWithoutLabTimeSlotInput[] | LabAllocationUncheckedCreateWithoutLabTimeSlotInput[]
    connectOrCreate?: LabAllocationCreateOrConnectWithoutLabTimeSlotInput | LabAllocationCreateOrConnectWithoutLabTimeSlotInput[]
    createMany?: LabAllocationCreateManyLabTimeSlotInputEnvelope
    connect?: LabAllocationWhereUniqueInput | LabAllocationWhereUniqueInput[]
  }

  export type LabUpdateOneRequiredWithoutTimeSlotsNestedInput = {
    create?: XOR<LabCreateWithoutTimeSlotsInput, LabUncheckedCreateWithoutTimeSlotsInput>
    connectOrCreate?: LabCreateOrConnectWithoutTimeSlotsInput
    upsert?: LabUpsertWithoutTimeSlotsInput
    connect?: LabWhereUniqueInput
    update?: XOR<XOR<LabUpdateToOneWithWhereWithoutTimeSlotsInput, LabUpdateWithoutTimeSlotsInput>, LabUncheckedUpdateWithoutTimeSlotsInput>
  }

  export type BatchUpdateManyWithoutLabTimeSlotNestedInput = {
    create?: XOR<BatchCreateWithoutLabTimeSlotInput, BatchUncheckedCreateWithoutLabTimeSlotInput> | BatchCreateWithoutLabTimeSlotInput[] | BatchUncheckedCreateWithoutLabTimeSlotInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutLabTimeSlotInput | BatchCreateOrConnectWithoutLabTimeSlotInput[]
    upsert?: BatchUpsertWithWhereUniqueWithoutLabTimeSlotInput | BatchUpsertWithWhereUniqueWithoutLabTimeSlotInput[]
    createMany?: BatchCreateManyLabTimeSlotInputEnvelope
    set?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    disconnect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    delete?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    update?: BatchUpdateWithWhereUniqueWithoutLabTimeSlotInput | BatchUpdateWithWhereUniqueWithoutLabTimeSlotInput[]
    updateMany?: BatchUpdateManyWithWhereWithoutLabTimeSlotInput | BatchUpdateManyWithWhereWithoutLabTimeSlotInput[]
    deleteMany?: BatchScalarWhereInput | BatchScalarWhereInput[]
  }

  export type LabAllocationUpdateManyWithoutLabTimeSlotNestedInput = {
    create?: XOR<LabAllocationCreateWithoutLabTimeSlotInput, LabAllocationUncheckedCreateWithoutLabTimeSlotInput> | LabAllocationCreateWithoutLabTimeSlotInput[] | LabAllocationUncheckedCreateWithoutLabTimeSlotInput[]
    connectOrCreate?: LabAllocationCreateOrConnectWithoutLabTimeSlotInput | LabAllocationCreateOrConnectWithoutLabTimeSlotInput[]
    upsert?: LabAllocationUpsertWithWhereUniqueWithoutLabTimeSlotInput | LabAllocationUpsertWithWhereUniqueWithoutLabTimeSlotInput[]
    createMany?: LabAllocationCreateManyLabTimeSlotInputEnvelope
    set?: LabAllocationWhereUniqueInput | LabAllocationWhereUniqueInput[]
    disconnect?: LabAllocationWhereUniqueInput | LabAllocationWhereUniqueInput[]
    delete?: LabAllocationWhereUniqueInput | LabAllocationWhereUniqueInput[]
    connect?: LabAllocationWhereUniqueInput | LabAllocationWhereUniqueInput[]
    update?: LabAllocationUpdateWithWhereUniqueWithoutLabTimeSlotInput | LabAllocationUpdateWithWhereUniqueWithoutLabTimeSlotInput[]
    updateMany?: LabAllocationUpdateManyWithWhereWithoutLabTimeSlotInput | LabAllocationUpdateManyWithWhereWithoutLabTimeSlotInput[]
    deleteMany?: LabAllocationScalarWhereInput | LabAllocationScalarWhereInput[]
  }

  export type ClientAdminUpdateOneRequiredWithoutLabTimeSlotsNestedInput = {
    create?: XOR<ClientAdminCreateWithoutLabTimeSlotsInput, ClientAdminUncheckedCreateWithoutLabTimeSlotsInput>
    connectOrCreate?: ClientAdminCreateOrConnectWithoutLabTimeSlotsInput
    upsert?: ClientAdminUpsertWithoutLabTimeSlotsInput
    connect?: ClientAdminWhereUniqueInput
    update?: XOR<XOR<ClientAdminUpdateToOneWithWhereWithoutLabTimeSlotsInput, ClientAdminUpdateWithoutLabTimeSlotsInput>, ClientAdminUncheckedUpdateWithoutLabTimeSlotsInput>
  }

  export type BatchUncheckedUpdateManyWithoutLabTimeSlotNestedInput = {
    create?: XOR<BatchCreateWithoutLabTimeSlotInput, BatchUncheckedCreateWithoutLabTimeSlotInput> | BatchCreateWithoutLabTimeSlotInput[] | BatchUncheckedCreateWithoutLabTimeSlotInput[]
    connectOrCreate?: BatchCreateOrConnectWithoutLabTimeSlotInput | BatchCreateOrConnectWithoutLabTimeSlotInput[]
    upsert?: BatchUpsertWithWhereUniqueWithoutLabTimeSlotInput | BatchUpsertWithWhereUniqueWithoutLabTimeSlotInput[]
    createMany?: BatchCreateManyLabTimeSlotInputEnvelope
    set?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    disconnect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    delete?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    connect?: BatchWhereUniqueInput | BatchWhereUniqueInput[]
    update?: BatchUpdateWithWhereUniqueWithoutLabTimeSlotInput | BatchUpdateWithWhereUniqueWithoutLabTimeSlotInput[]
    updateMany?: BatchUpdateManyWithWhereWithoutLabTimeSlotInput | BatchUpdateManyWithWhereWithoutLabTimeSlotInput[]
    deleteMany?: BatchScalarWhereInput | BatchScalarWhereInput[]
  }

  export type LabAllocationUncheckedUpdateManyWithoutLabTimeSlotNestedInput = {
    create?: XOR<LabAllocationCreateWithoutLabTimeSlotInput, LabAllocationUncheckedCreateWithoutLabTimeSlotInput> | LabAllocationCreateWithoutLabTimeSlotInput[] | LabAllocationUncheckedCreateWithoutLabTimeSlotInput[]
    connectOrCreate?: LabAllocationCreateOrConnectWithoutLabTimeSlotInput | LabAllocationCreateOrConnectWithoutLabTimeSlotInput[]
    upsert?: LabAllocationUpsertWithWhereUniqueWithoutLabTimeSlotInput | LabAllocationUpsertWithWhereUniqueWithoutLabTimeSlotInput[]
    createMany?: LabAllocationCreateManyLabTimeSlotInputEnvelope
    set?: LabAllocationWhereUniqueInput | LabAllocationWhereUniqueInput[]
    disconnect?: LabAllocationWhereUniqueInput | LabAllocationWhereUniqueInput[]
    delete?: LabAllocationWhereUniqueInput | LabAllocationWhereUniqueInput[]
    connect?: LabAllocationWhereUniqueInput | LabAllocationWhereUniqueInput[]
    update?: LabAllocationUpdateWithWhereUniqueWithoutLabTimeSlotInput | LabAllocationUpdateWithWhereUniqueWithoutLabTimeSlotInput[]
    updateMany?: LabAllocationUpdateManyWithWhereWithoutLabTimeSlotInput | LabAllocationUpdateManyWithWhereWithoutLabTimeSlotInput[]
    deleteMany?: LabAllocationScalarWhereInput | LabAllocationScalarWhereInput[]
  }

  export type EnumPaymentTypeFieldUpdateOperationsInput = {
    set?: $Enums.PaymentType
  }

  export type FeeStructureCreateNestedManyWithoutInstallmentInput = {
    create?: XOR<FeeStructureCreateWithoutInstallmentInput, FeeStructureUncheckedCreateWithoutInstallmentInput> | FeeStructureCreateWithoutInstallmentInput[] | FeeStructureUncheckedCreateWithoutInstallmentInput[]
    connectOrCreate?: FeeStructureCreateOrConnectWithoutInstallmentInput | FeeStructureCreateOrConnectWithoutInstallmentInput[]
    createMany?: FeeStructureCreateManyInstallmentInputEnvelope
    connect?: FeeStructureWhereUniqueInput | FeeStructureWhereUniqueInput[]
  }

  export type CourseFeeStructureCreateNestedOneWithoutInstallmentsInput = {
    create?: XOR<CourseFeeStructureCreateWithoutInstallmentsInput, CourseFeeStructureUncheckedCreateWithoutInstallmentsInput>
    connectOrCreate?: CourseFeeStructureCreateOrConnectWithoutInstallmentsInput
    connect?: CourseFeeStructureWhereUniqueInput
  }

  export type FeeStructureUncheckedCreateNestedManyWithoutInstallmentInput = {
    create?: XOR<FeeStructureCreateWithoutInstallmentInput, FeeStructureUncheckedCreateWithoutInstallmentInput> | FeeStructureCreateWithoutInstallmentInput[] | FeeStructureUncheckedCreateWithoutInstallmentInput[]
    connectOrCreate?: FeeStructureCreateOrConnectWithoutInstallmentInput | FeeStructureCreateOrConnectWithoutInstallmentInput[]
    createMany?: FeeStructureCreateManyInstallmentInputEnvelope
    connect?: FeeStructureWhereUniqueInput | FeeStructureWhereUniqueInput[]
  }

  export type FeeStructureUpdateManyWithoutInstallmentNestedInput = {
    create?: XOR<FeeStructureCreateWithoutInstallmentInput, FeeStructureUncheckedCreateWithoutInstallmentInput> | FeeStructureCreateWithoutInstallmentInput[] | FeeStructureUncheckedCreateWithoutInstallmentInput[]
    connectOrCreate?: FeeStructureCreateOrConnectWithoutInstallmentInput | FeeStructureCreateOrConnectWithoutInstallmentInput[]
    upsert?: FeeStructureUpsertWithWhereUniqueWithoutInstallmentInput | FeeStructureUpsertWithWhereUniqueWithoutInstallmentInput[]
    createMany?: FeeStructureCreateManyInstallmentInputEnvelope
    set?: FeeStructureWhereUniqueInput | FeeStructureWhereUniqueInput[]
    disconnect?: FeeStructureWhereUniqueInput | FeeStructureWhereUniqueInput[]
    delete?: FeeStructureWhereUniqueInput | FeeStructureWhereUniqueInput[]
    connect?: FeeStructureWhereUniqueInput | FeeStructureWhereUniqueInput[]
    update?: FeeStructureUpdateWithWhereUniqueWithoutInstallmentInput | FeeStructureUpdateWithWhereUniqueWithoutInstallmentInput[]
    updateMany?: FeeStructureUpdateManyWithWhereWithoutInstallmentInput | FeeStructureUpdateManyWithWhereWithoutInstallmentInput[]
    deleteMany?: FeeStructureScalarWhereInput | FeeStructureScalarWhereInput[]
  }

  export type CourseFeeStructureUpdateOneRequiredWithoutInstallmentsNestedInput = {
    create?: XOR<CourseFeeStructureCreateWithoutInstallmentsInput, CourseFeeStructureUncheckedCreateWithoutInstallmentsInput>
    connectOrCreate?: CourseFeeStructureCreateOrConnectWithoutInstallmentsInput
    upsert?: CourseFeeStructureUpsertWithoutInstallmentsInput
    connect?: CourseFeeStructureWhereUniqueInput
    update?: XOR<XOR<CourseFeeStructureUpdateToOneWithWhereWithoutInstallmentsInput, CourseFeeStructureUpdateWithoutInstallmentsInput>, CourseFeeStructureUncheckedUpdateWithoutInstallmentsInput>
  }

  export type FeeStructureUncheckedUpdateManyWithoutInstallmentNestedInput = {
    create?: XOR<FeeStructureCreateWithoutInstallmentInput, FeeStructureUncheckedCreateWithoutInstallmentInput> | FeeStructureCreateWithoutInstallmentInput[] | FeeStructureUncheckedCreateWithoutInstallmentInput[]
    connectOrCreate?: FeeStructureCreateOrConnectWithoutInstallmentInput | FeeStructureCreateOrConnectWithoutInstallmentInput[]
    upsert?: FeeStructureUpsertWithWhereUniqueWithoutInstallmentInput | FeeStructureUpsertWithWhereUniqueWithoutInstallmentInput[]
    createMany?: FeeStructureCreateManyInstallmentInputEnvelope
    set?: FeeStructureWhereUniqueInput | FeeStructureWhereUniqueInput[]
    disconnect?: FeeStructureWhereUniqueInput | FeeStructureWhereUniqueInput[]
    delete?: FeeStructureWhereUniqueInput | FeeStructureWhereUniqueInput[]
    connect?: FeeStructureWhereUniqueInput | FeeStructureWhereUniqueInput[]
    update?: FeeStructureUpdateWithWhereUniqueWithoutInstallmentInput | FeeStructureUpdateWithWhereUniqueWithoutInstallmentInput[]
    updateMany?: FeeStructureUpdateManyWithWhereWithoutInstallmentInput | FeeStructureUpdateManyWithWhereWithoutInstallmentInput[]
    deleteMany?: FeeStructureScalarWhereInput | FeeStructureScalarWhereInput[]
  }

  export type LabTimeSlotCreateNestedOneWithoutAllocationsInput = {
    create?: XOR<LabTimeSlotCreateWithoutAllocationsInput, LabTimeSlotUncheckedCreateWithoutAllocationsInput>
    connectOrCreate?: LabTimeSlotCreateOrConnectWithoutAllocationsInput
    connect?: LabTimeSlotWhereUniqueInput
  }

  export type StudentCreateNestedOneWithoutLabAllocationsInput = {
    create?: XOR<StudentCreateWithoutLabAllocationsInput, StudentUncheckedCreateWithoutLabAllocationsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutLabAllocationsInput
    connect?: StudentWhereUniqueInput
  }

  export type ClientAdminCreateNestedOneWithoutLabAllocationsInput = {
    create?: XOR<ClientAdminCreateWithoutLabAllocationsInput, ClientAdminUncheckedCreateWithoutLabAllocationsInput>
    connectOrCreate?: ClientAdminCreateOrConnectWithoutLabAllocationsInput
    connect?: ClientAdminWhereUniqueInput
  }

  export type LabTimeSlotUpdateOneRequiredWithoutAllocationsNestedInput = {
    create?: XOR<LabTimeSlotCreateWithoutAllocationsInput, LabTimeSlotUncheckedCreateWithoutAllocationsInput>
    connectOrCreate?: LabTimeSlotCreateOrConnectWithoutAllocationsInput
    upsert?: LabTimeSlotUpsertWithoutAllocationsInput
    connect?: LabTimeSlotWhereUniqueInput
    update?: XOR<XOR<LabTimeSlotUpdateToOneWithWhereWithoutAllocationsInput, LabTimeSlotUpdateWithoutAllocationsInput>, LabTimeSlotUncheckedUpdateWithoutAllocationsInput>
  }

  export type StudentUpdateOneRequiredWithoutLabAllocationsNestedInput = {
    create?: XOR<StudentCreateWithoutLabAllocationsInput, StudentUncheckedCreateWithoutLabAllocationsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutLabAllocationsInput
    upsert?: StudentUpsertWithoutLabAllocationsInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutLabAllocationsInput, StudentUpdateWithoutLabAllocationsInput>, StudentUncheckedUpdateWithoutLabAllocationsInput>
  }

  export type ClientAdminUpdateOneRequiredWithoutLabAllocationsNestedInput = {
    create?: XOR<ClientAdminCreateWithoutLabAllocationsInput, ClientAdminUncheckedCreateWithoutLabAllocationsInput>
    connectOrCreate?: ClientAdminCreateOrConnectWithoutLabAllocationsInput
    upsert?: ClientAdminUpsertWithoutLabAllocationsInput
    connect?: ClientAdminWhereUniqueInput
    update?: XOR<XOR<ClientAdminUpdateToOneWithWhereWithoutLabAllocationsInput, ClientAdminUpdateWithoutLabAllocationsInput>, ClientAdminUncheckedUpdateWithoutLabAllocationsInput>
  }

  export type StudentCreateNestedOneWithoutStudentCoursesInput = {
    create?: XOR<StudentCreateWithoutStudentCoursesInput, StudentUncheckedCreateWithoutStudentCoursesInput>
    connectOrCreate?: StudentCreateOrConnectWithoutStudentCoursesInput
    connect?: StudentWhereUniqueInput
  }

  export type CourseCreateNestedOneWithoutStudentCoursesInput = {
    create?: XOR<CourseCreateWithoutStudentCoursesInput, CourseUncheckedCreateWithoutStudentCoursesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutStudentCoursesInput
    connect?: CourseWhereUniqueInput
  }

  export type BatchCreateNestedOneWithoutStudentCoursesInput = {
    create?: XOR<BatchCreateWithoutStudentCoursesInput, BatchUncheckedCreateWithoutStudentCoursesInput>
    connectOrCreate?: BatchCreateOrConnectWithoutStudentCoursesInput
    connect?: BatchWhereUniqueInput
  }

  export type CertificateCreateNestedOneWithoutStudentCourseInput = {
    create?: XOR<CertificateCreateWithoutStudentCourseInput, CertificateUncheckedCreateWithoutStudentCourseInput>
    connectOrCreate?: CertificateCreateOrConnectWithoutStudentCourseInput
    connect?: CertificateWhereUniqueInput
  }

  export type CourseCompletionCreateNestedManyWithoutStudentCourseInput = {
    create?: XOR<CourseCompletionCreateWithoutStudentCourseInput, CourseCompletionUncheckedCreateWithoutStudentCourseInput> | CourseCompletionCreateWithoutStudentCourseInput[] | CourseCompletionUncheckedCreateWithoutStudentCourseInput[]
    connectOrCreate?: CourseCompletionCreateOrConnectWithoutStudentCourseInput | CourseCompletionCreateOrConnectWithoutStudentCourseInput[]
    createMany?: CourseCompletionCreateManyStudentCourseInputEnvelope
    connect?: CourseCompletionWhereUniqueInput | CourseCompletionWhereUniqueInput[]
  }

  export type ClientAdminCreateNestedOneWithoutStudentCoursesInput = {
    create?: XOR<ClientAdminCreateWithoutStudentCoursesInput, ClientAdminUncheckedCreateWithoutStudentCoursesInput>
    connectOrCreate?: ClientAdminCreateOrConnectWithoutStudentCoursesInput
    connect?: ClientAdminWhereUniqueInput
  }

  export type CertificateUncheckedCreateNestedOneWithoutStudentCourseInput = {
    create?: XOR<CertificateCreateWithoutStudentCourseInput, CertificateUncheckedCreateWithoutStudentCourseInput>
    connectOrCreate?: CertificateCreateOrConnectWithoutStudentCourseInput
    connect?: CertificateWhereUniqueInput
  }

  export type CourseCompletionUncheckedCreateNestedManyWithoutStudentCourseInput = {
    create?: XOR<CourseCompletionCreateWithoutStudentCourseInput, CourseCompletionUncheckedCreateWithoutStudentCourseInput> | CourseCompletionCreateWithoutStudentCourseInput[] | CourseCompletionUncheckedCreateWithoutStudentCourseInput[]
    connectOrCreate?: CourseCompletionCreateOrConnectWithoutStudentCourseInput | CourseCompletionCreateOrConnectWithoutStudentCourseInput[]
    createMany?: CourseCompletionCreateManyStudentCourseInputEnvelope
    connect?: CourseCompletionWhereUniqueInput | CourseCompletionWhereUniqueInput[]
  }

  export type StudentUpdateOneRequiredWithoutStudentCoursesNestedInput = {
    create?: XOR<StudentCreateWithoutStudentCoursesInput, StudentUncheckedCreateWithoutStudentCoursesInput>
    connectOrCreate?: StudentCreateOrConnectWithoutStudentCoursesInput
    upsert?: StudentUpsertWithoutStudentCoursesInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutStudentCoursesInput, StudentUpdateWithoutStudentCoursesInput>, StudentUncheckedUpdateWithoutStudentCoursesInput>
  }

  export type CourseUpdateOneRequiredWithoutStudentCoursesNestedInput = {
    create?: XOR<CourseCreateWithoutStudentCoursesInput, CourseUncheckedCreateWithoutStudentCoursesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutStudentCoursesInput
    upsert?: CourseUpsertWithoutStudentCoursesInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutStudentCoursesInput, CourseUpdateWithoutStudentCoursesInput>, CourseUncheckedUpdateWithoutStudentCoursesInput>
  }

  export type BatchUpdateOneWithoutStudentCoursesNestedInput = {
    create?: XOR<BatchCreateWithoutStudentCoursesInput, BatchUncheckedCreateWithoutStudentCoursesInput>
    connectOrCreate?: BatchCreateOrConnectWithoutStudentCoursesInput
    upsert?: BatchUpsertWithoutStudentCoursesInput
    disconnect?: BatchWhereInput | boolean
    delete?: BatchWhereInput | boolean
    connect?: BatchWhereUniqueInput
    update?: XOR<XOR<BatchUpdateToOneWithWhereWithoutStudentCoursesInput, BatchUpdateWithoutStudentCoursesInput>, BatchUncheckedUpdateWithoutStudentCoursesInput>
  }

  export type CertificateUpdateOneWithoutStudentCourseNestedInput = {
    create?: XOR<CertificateCreateWithoutStudentCourseInput, CertificateUncheckedCreateWithoutStudentCourseInput>
    connectOrCreate?: CertificateCreateOrConnectWithoutStudentCourseInput
    upsert?: CertificateUpsertWithoutStudentCourseInput
    disconnect?: CertificateWhereInput | boolean
    delete?: CertificateWhereInput | boolean
    connect?: CertificateWhereUniqueInput
    update?: XOR<XOR<CertificateUpdateToOneWithWhereWithoutStudentCourseInput, CertificateUpdateWithoutStudentCourseInput>, CertificateUncheckedUpdateWithoutStudentCourseInput>
  }

  export type CourseCompletionUpdateManyWithoutStudentCourseNestedInput = {
    create?: XOR<CourseCompletionCreateWithoutStudentCourseInput, CourseCompletionUncheckedCreateWithoutStudentCourseInput> | CourseCompletionCreateWithoutStudentCourseInput[] | CourseCompletionUncheckedCreateWithoutStudentCourseInput[]
    connectOrCreate?: CourseCompletionCreateOrConnectWithoutStudentCourseInput | CourseCompletionCreateOrConnectWithoutStudentCourseInput[]
    upsert?: CourseCompletionUpsertWithWhereUniqueWithoutStudentCourseInput | CourseCompletionUpsertWithWhereUniqueWithoutStudentCourseInput[]
    createMany?: CourseCompletionCreateManyStudentCourseInputEnvelope
    set?: CourseCompletionWhereUniqueInput | CourseCompletionWhereUniqueInput[]
    disconnect?: CourseCompletionWhereUniqueInput | CourseCompletionWhereUniqueInput[]
    delete?: CourseCompletionWhereUniqueInput | CourseCompletionWhereUniqueInput[]
    connect?: CourseCompletionWhereUniqueInput | CourseCompletionWhereUniqueInput[]
    update?: CourseCompletionUpdateWithWhereUniqueWithoutStudentCourseInput | CourseCompletionUpdateWithWhereUniqueWithoutStudentCourseInput[]
    updateMany?: CourseCompletionUpdateManyWithWhereWithoutStudentCourseInput | CourseCompletionUpdateManyWithWhereWithoutStudentCourseInput[]
    deleteMany?: CourseCompletionScalarWhereInput | CourseCompletionScalarWhereInput[]
  }

  export type ClientAdminUpdateOneRequiredWithoutStudentCoursesNestedInput = {
    create?: XOR<ClientAdminCreateWithoutStudentCoursesInput, ClientAdminUncheckedCreateWithoutStudentCoursesInput>
    connectOrCreate?: ClientAdminCreateOrConnectWithoutStudentCoursesInput
    upsert?: ClientAdminUpsertWithoutStudentCoursesInput
    connect?: ClientAdminWhereUniqueInput
    update?: XOR<XOR<ClientAdminUpdateToOneWithWhereWithoutStudentCoursesInput, ClientAdminUpdateWithoutStudentCoursesInput>, ClientAdminUncheckedUpdateWithoutStudentCoursesInput>
  }

  export type CertificateUncheckedUpdateOneWithoutStudentCourseNestedInput = {
    create?: XOR<CertificateCreateWithoutStudentCourseInput, CertificateUncheckedCreateWithoutStudentCourseInput>
    connectOrCreate?: CertificateCreateOrConnectWithoutStudentCourseInput
    upsert?: CertificateUpsertWithoutStudentCourseInput
    disconnect?: CertificateWhereInput | boolean
    delete?: CertificateWhereInput | boolean
    connect?: CertificateWhereUniqueInput
    update?: XOR<XOR<CertificateUpdateToOneWithWhereWithoutStudentCourseInput, CertificateUpdateWithoutStudentCourseInput>, CertificateUncheckedUpdateWithoutStudentCourseInput>
  }

  export type CourseCompletionUncheckedUpdateManyWithoutStudentCourseNestedInput = {
    create?: XOR<CourseCompletionCreateWithoutStudentCourseInput, CourseCompletionUncheckedCreateWithoutStudentCourseInput> | CourseCompletionCreateWithoutStudentCourseInput[] | CourseCompletionUncheckedCreateWithoutStudentCourseInput[]
    connectOrCreate?: CourseCompletionCreateOrConnectWithoutStudentCourseInput | CourseCompletionCreateOrConnectWithoutStudentCourseInput[]
    upsert?: CourseCompletionUpsertWithWhereUniqueWithoutStudentCourseInput | CourseCompletionUpsertWithWhereUniqueWithoutStudentCourseInput[]
    createMany?: CourseCompletionCreateManyStudentCourseInputEnvelope
    set?: CourseCompletionWhereUniqueInput | CourseCompletionWhereUniqueInput[]
    disconnect?: CourseCompletionWhereUniqueInput | CourseCompletionWhereUniqueInput[]
    delete?: CourseCompletionWhereUniqueInput | CourseCompletionWhereUniqueInput[]
    connect?: CourseCompletionWhereUniqueInput | CourseCompletionWhereUniqueInput[]
    update?: CourseCompletionUpdateWithWhereUniqueWithoutStudentCourseInput | CourseCompletionUpdateWithWhereUniqueWithoutStudentCourseInput[]
    updateMany?: CourseCompletionUpdateManyWithWhereWithoutStudentCourseInput | CourseCompletionUpdateManyWithWhereWithoutStudentCourseInput[]
    deleteMany?: CourseCompletionScalarWhereInput | CourseCompletionScalarWhereInput[]
  }

  export type StudentCreateNestedOneWithoutFeeStructuresInput = {
    create?: XOR<StudentCreateWithoutFeeStructuresInput, StudentUncheckedCreateWithoutFeeStructuresInput>
    connectOrCreate?: StudentCreateOrConnectWithoutFeeStructuresInput
    connect?: StudentWhereUniqueInput
  }

  export type CourseCreateNestedOneWithoutFeeStructuresInput = {
    create?: XOR<CourseCreateWithoutFeeStructuresInput, CourseUncheckedCreateWithoutFeeStructuresInput>
    connectOrCreate?: CourseCreateOrConnectWithoutFeeStructuresInput
    connect?: CourseWhereUniqueInput
  }

  export type InstallmentDetailCreateNestedOneWithoutFeeStructuresInput = {
    create?: XOR<InstallmentDetailCreateWithoutFeeStructuresInput, InstallmentDetailUncheckedCreateWithoutFeeStructuresInput>
    connectOrCreate?: InstallmentDetailCreateOrConnectWithoutFeeStructuresInput
    connect?: InstallmentDetailWhereUniqueInput
  }

  export type StudentFeeCreateNestedManyWithoutFeeStructureInput = {
    create?: XOR<StudentFeeCreateWithoutFeeStructureInput, StudentFeeUncheckedCreateWithoutFeeStructureInput> | StudentFeeCreateWithoutFeeStructureInput[] | StudentFeeUncheckedCreateWithoutFeeStructureInput[]
    connectOrCreate?: StudentFeeCreateOrConnectWithoutFeeStructureInput | StudentFeeCreateOrConnectWithoutFeeStructureInput[]
    createMany?: StudentFeeCreateManyFeeStructureInputEnvelope
    connect?: StudentFeeWhereUniqueInput | StudentFeeWhereUniqueInput[]
  }

  export type ClientAdminCreateNestedOneWithoutFeeStructuresInput = {
    create?: XOR<ClientAdminCreateWithoutFeeStructuresInput, ClientAdminUncheckedCreateWithoutFeeStructuresInput>
    connectOrCreate?: ClientAdminCreateOrConnectWithoutFeeStructuresInput
    connect?: ClientAdminWhereUniqueInput
  }

  export type StudentFeeUncheckedCreateNestedManyWithoutFeeStructureInput = {
    create?: XOR<StudentFeeCreateWithoutFeeStructureInput, StudentFeeUncheckedCreateWithoutFeeStructureInput> | StudentFeeCreateWithoutFeeStructureInput[] | StudentFeeUncheckedCreateWithoutFeeStructureInput[]
    connectOrCreate?: StudentFeeCreateOrConnectWithoutFeeStructureInput | StudentFeeCreateOrConnectWithoutFeeStructureInput[]
    createMany?: StudentFeeCreateManyFeeStructureInputEnvelope
    connect?: StudentFeeWhereUniqueInput | StudentFeeWhereUniqueInput[]
  }

  export type StudentUpdateOneRequiredWithoutFeeStructuresNestedInput = {
    create?: XOR<StudentCreateWithoutFeeStructuresInput, StudentUncheckedCreateWithoutFeeStructuresInput>
    connectOrCreate?: StudentCreateOrConnectWithoutFeeStructuresInput
    upsert?: StudentUpsertWithoutFeeStructuresInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutFeeStructuresInput, StudentUpdateWithoutFeeStructuresInput>, StudentUncheckedUpdateWithoutFeeStructuresInput>
  }

  export type CourseUpdateOneRequiredWithoutFeeStructuresNestedInput = {
    create?: XOR<CourseCreateWithoutFeeStructuresInput, CourseUncheckedCreateWithoutFeeStructuresInput>
    connectOrCreate?: CourseCreateOrConnectWithoutFeeStructuresInput
    upsert?: CourseUpsertWithoutFeeStructuresInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutFeeStructuresInput, CourseUpdateWithoutFeeStructuresInput>, CourseUncheckedUpdateWithoutFeeStructuresInput>
  }

  export type InstallmentDetailUpdateOneWithoutFeeStructuresNestedInput = {
    create?: XOR<InstallmentDetailCreateWithoutFeeStructuresInput, InstallmentDetailUncheckedCreateWithoutFeeStructuresInput>
    connectOrCreate?: InstallmentDetailCreateOrConnectWithoutFeeStructuresInput
    upsert?: InstallmentDetailUpsertWithoutFeeStructuresInput
    disconnect?: InstallmentDetailWhereInput | boolean
    delete?: InstallmentDetailWhereInput | boolean
    connect?: InstallmentDetailWhereUniqueInput
    update?: XOR<XOR<InstallmentDetailUpdateToOneWithWhereWithoutFeeStructuresInput, InstallmentDetailUpdateWithoutFeeStructuresInput>, InstallmentDetailUncheckedUpdateWithoutFeeStructuresInput>
  }

  export type StudentFeeUpdateManyWithoutFeeStructureNestedInput = {
    create?: XOR<StudentFeeCreateWithoutFeeStructureInput, StudentFeeUncheckedCreateWithoutFeeStructureInput> | StudentFeeCreateWithoutFeeStructureInput[] | StudentFeeUncheckedCreateWithoutFeeStructureInput[]
    connectOrCreate?: StudentFeeCreateOrConnectWithoutFeeStructureInput | StudentFeeCreateOrConnectWithoutFeeStructureInput[]
    upsert?: StudentFeeUpsertWithWhereUniqueWithoutFeeStructureInput | StudentFeeUpsertWithWhereUniqueWithoutFeeStructureInput[]
    createMany?: StudentFeeCreateManyFeeStructureInputEnvelope
    set?: StudentFeeWhereUniqueInput | StudentFeeWhereUniqueInput[]
    disconnect?: StudentFeeWhereUniqueInput | StudentFeeWhereUniqueInput[]
    delete?: StudentFeeWhereUniqueInput | StudentFeeWhereUniqueInput[]
    connect?: StudentFeeWhereUniqueInput | StudentFeeWhereUniqueInput[]
    update?: StudentFeeUpdateWithWhereUniqueWithoutFeeStructureInput | StudentFeeUpdateWithWhereUniqueWithoutFeeStructureInput[]
    updateMany?: StudentFeeUpdateManyWithWhereWithoutFeeStructureInput | StudentFeeUpdateManyWithWhereWithoutFeeStructureInput[]
    deleteMany?: StudentFeeScalarWhereInput | StudentFeeScalarWhereInput[]
  }

  export type ClientAdminUpdateOneRequiredWithoutFeeStructuresNestedInput = {
    create?: XOR<ClientAdminCreateWithoutFeeStructuresInput, ClientAdminUncheckedCreateWithoutFeeStructuresInput>
    connectOrCreate?: ClientAdminCreateOrConnectWithoutFeeStructuresInput
    upsert?: ClientAdminUpsertWithoutFeeStructuresInput
    connect?: ClientAdminWhereUniqueInput
    update?: XOR<XOR<ClientAdminUpdateToOneWithWhereWithoutFeeStructuresInput, ClientAdminUpdateWithoutFeeStructuresInput>, ClientAdminUncheckedUpdateWithoutFeeStructuresInput>
  }

  export type StudentFeeUncheckedUpdateManyWithoutFeeStructureNestedInput = {
    create?: XOR<StudentFeeCreateWithoutFeeStructureInput, StudentFeeUncheckedCreateWithoutFeeStructureInput> | StudentFeeCreateWithoutFeeStructureInput[] | StudentFeeUncheckedCreateWithoutFeeStructureInput[]
    connectOrCreate?: StudentFeeCreateOrConnectWithoutFeeStructureInput | StudentFeeCreateOrConnectWithoutFeeStructureInput[]
    upsert?: StudentFeeUpsertWithWhereUniqueWithoutFeeStructureInput | StudentFeeUpsertWithWhereUniqueWithoutFeeStructureInput[]
    createMany?: StudentFeeCreateManyFeeStructureInputEnvelope
    set?: StudentFeeWhereUniqueInput | StudentFeeWhereUniqueInput[]
    disconnect?: StudentFeeWhereUniqueInput | StudentFeeWhereUniqueInput[]
    delete?: StudentFeeWhereUniqueInput | StudentFeeWhereUniqueInput[]
    connect?: StudentFeeWhereUniqueInput | StudentFeeWhereUniqueInput[]
    update?: StudentFeeUpdateWithWhereUniqueWithoutFeeStructureInput | StudentFeeUpdateWithWhereUniqueWithoutFeeStructureInput[]
    updateMany?: StudentFeeUpdateManyWithWhereWithoutFeeStructureInput | StudentFeeUpdateManyWithWhereWithoutFeeStructureInput[]
    deleteMany?: StudentFeeScalarWhereInput | StudentFeeScalarWhereInput[]
  }

  export type StudentFeeCreateNestedOneWithoutFeeLogsInput = {
    create?: XOR<StudentFeeCreateWithoutFeeLogsInput, StudentFeeUncheckedCreateWithoutFeeLogsInput>
    connectOrCreate?: StudentFeeCreateOrConnectWithoutFeeLogsInput
    connect?: StudentFeeWhereUniqueInput
  }

  export type EnumPaymentModeFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMode
  }

  export type StudentFeeUpdateOneRequiredWithoutFeeLogsNestedInput = {
    create?: XOR<StudentFeeCreateWithoutFeeLogsInput, StudentFeeUncheckedCreateWithoutFeeLogsInput>
    connectOrCreate?: StudentFeeCreateOrConnectWithoutFeeLogsInput
    upsert?: StudentFeeUpsertWithoutFeeLogsInput
    connect?: StudentFeeWhereUniqueInput
    update?: XOR<XOR<StudentFeeUpdateToOneWithWhereWithoutFeeLogsInput, StudentFeeUpdateWithoutFeeLogsInput>, StudentFeeUncheckedUpdateWithoutFeeLogsInput>
  }

  export type StudentCreateNestedOneWithoutFeeRecordsInput = {
    create?: XOR<StudentCreateWithoutFeeRecordsInput, StudentUncheckedCreateWithoutFeeRecordsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutFeeRecordsInput
    connect?: StudentWhereUniqueInput
  }

  export type CourseCreateNestedOneWithoutStudentFeesInput = {
    create?: XOR<CourseCreateWithoutStudentFeesInput, CourseUncheckedCreateWithoutStudentFeesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutStudentFeesInput
    connect?: CourseWhereUniqueInput
  }

  export type StudentFeeLogCreateNestedManyWithoutStudentFeeInput = {
    create?: XOR<StudentFeeLogCreateWithoutStudentFeeInput, StudentFeeLogUncheckedCreateWithoutStudentFeeInput> | StudentFeeLogCreateWithoutStudentFeeInput[] | StudentFeeLogUncheckedCreateWithoutStudentFeeInput[]
    connectOrCreate?: StudentFeeLogCreateOrConnectWithoutStudentFeeInput | StudentFeeLogCreateOrConnectWithoutStudentFeeInput[]
    createMany?: StudentFeeLogCreateManyStudentFeeInputEnvelope
    connect?: StudentFeeLogWhereUniqueInput | StudentFeeLogWhereUniqueInput[]
  }

  export type FeeStructureCreateNestedOneWithoutStudentFeesInput = {
    create?: XOR<FeeStructureCreateWithoutStudentFeesInput, FeeStructureUncheckedCreateWithoutStudentFeesInput>
    connectOrCreate?: FeeStructureCreateOrConnectWithoutStudentFeesInput
    connect?: FeeStructureWhereUniqueInput
  }

  export type NotificationCreateNestedOneWithoutPaymentInput = {
    create?: XOR<NotificationCreateWithoutPaymentInput, NotificationUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: NotificationCreateOrConnectWithoutPaymentInput
    connect?: NotificationWhereUniqueInput
  }

  export type ClientAdminCreateNestedOneWithoutStudentFeesInput = {
    create?: XOR<ClientAdminCreateWithoutStudentFeesInput, ClientAdminUncheckedCreateWithoutStudentFeesInput>
    connectOrCreate?: ClientAdminCreateOrConnectWithoutStudentFeesInput
    connect?: ClientAdminWhereUniqueInput
  }

  export type StudentFeeLogUncheckedCreateNestedManyWithoutStudentFeeInput = {
    create?: XOR<StudentFeeLogCreateWithoutStudentFeeInput, StudentFeeLogUncheckedCreateWithoutStudentFeeInput> | StudentFeeLogCreateWithoutStudentFeeInput[] | StudentFeeLogUncheckedCreateWithoutStudentFeeInput[]
    connectOrCreate?: StudentFeeLogCreateOrConnectWithoutStudentFeeInput | StudentFeeLogCreateOrConnectWithoutStudentFeeInput[]
    createMany?: StudentFeeLogCreateManyStudentFeeInputEnvelope
    connect?: StudentFeeLogWhereUniqueInput | StudentFeeLogWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedOneWithoutPaymentInput = {
    create?: XOR<NotificationCreateWithoutPaymentInput, NotificationUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: NotificationCreateOrConnectWithoutPaymentInput
    connect?: NotificationWhereUniqueInput
  }

  export type EnumPaymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatus
  }

  export type StudentUpdateOneRequiredWithoutFeeRecordsNestedInput = {
    create?: XOR<StudentCreateWithoutFeeRecordsInput, StudentUncheckedCreateWithoutFeeRecordsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutFeeRecordsInput
    upsert?: StudentUpsertWithoutFeeRecordsInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutFeeRecordsInput, StudentUpdateWithoutFeeRecordsInput>, StudentUncheckedUpdateWithoutFeeRecordsInput>
  }

  export type CourseUpdateOneRequiredWithoutStudentFeesNestedInput = {
    create?: XOR<CourseCreateWithoutStudentFeesInput, CourseUncheckedCreateWithoutStudentFeesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutStudentFeesInput
    upsert?: CourseUpsertWithoutStudentFeesInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutStudentFeesInput, CourseUpdateWithoutStudentFeesInput>, CourseUncheckedUpdateWithoutStudentFeesInput>
  }

  export type StudentFeeLogUpdateManyWithoutStudentFeeNestedInput = {
    create?: XOR<StudentFeeLogCreateWithoutStudentFeeInput, StudentFeeLogUncheckedCreateWithoutStudentFeeInput> | StudentFeeLogCreateWithoutStudentFeeInput[] | StudentFeeLogUncheckedCreateWithoutStudentFeeInput[]
    connectOrCreate?: StudentFeeLogCreateOrConnectWithoutStudentFeeInput | StudentFeeLogCreateOrConnectWithoutStudentFeeInput[]
    upsert?: StudentFeeLogUpsertWithWhereUniqueWithoutStudentFeeInput | StudentFeeLogUpsertWithWhereUniqueWithoutStudentFeeInput[]
    createMany?: StudentFeeLogCreateManyStudentFeeInputEnvelope
    set?: StudentFeeLogWhereUniqueInput | StudentFeeLogWhereUniqueInput[]
    disconnect?: StudentFeeLogWhereUniqueInput | StudentFeeLogWhereUniqueInput[]
    delete?: StudentFeeLogWhereUniqueInput | StudentFeeLogWhereUniqueInput[]
    connect?: StudentFeeLogWhereUniqueInput | StudentFeeLogWhereUniqueInput[]
    update?: StudentFeeLogUpdateWithWhereUniqueWithoutStudentFeeInput | StudentFeeLogUpdateWithWhereUniqueWithoutStudentFeeInput[]
    updateMany?: StudentFeeLogUpdateManyWithWhereWithoutStudentFeeInput | StudentFeeLogUpdateManyWithWhereWithoutStudentFeeInput[]
    deleteMany?: StudentFeeLogScalarWhereInput | StudentFeeLogScalarWhereInput[]
  }

  export type FeeStructureUpdateOneWithoutStudentFeesNestedInput = {
    create?: XOR<FeeStructureCreateWithoutStudentFeesInput, FeeStructureUncheckedCreateWithoutStudentFeesInput>
    connectOrCreate?: FeeStructureCreateOrConnectWithoutStudentFeesInput
    upsert?: FeeStructureUpsertWithoutStudentFeesInput
    disconnect?: FeeStructureWhereInput | boolean
    delete?: FeeStructureWhereInput | boolean
    connect?: FeeStructureWhereUniqueInput
    update?: XOR<XOR<FeeStructureUpdateToOneWithWhereWithoutStudentFeesInput, FeeStructureUpdateWithoutStudentFeesInput>, FeeStructureUncheckedUpdateWithoutStudentFeesInput>
  }

  export type NotificationUpdateOneWithoutPaymentNestedInput = {
    create?: XOR<NotificationCreateWithoutPaymentInput, NotificationUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: NotificationCreateOrConnectWithoutPaymentInput
    upsert?: NotificationUpsertWithoutPaymentInput
    disconnect?: NotificationWhereInput | boolean
    delete?: NotificationWhereInput | boolean
    connect?: NotificationWhereUniqueInput
    update?: XOR<XOR<NotificationUpdateToOneWithWhereWithoutPaymentInput, NotificationUpdateWithoutPaymentInput>, NotificationUncheckedUpdateWithoutPaymentInput>
  }

  export type ClientAdminUpdateOneRequiredWithoutStudentFeesNestedInput = {
    create?: XOR<ClientAdminCreateWithoutStudentFeesInput, ClientAdminUncheckedCreateWithoutStudentFeesInput>
    connectOrCreate?: ClientAdminCreateOrConnectWithoutStudentFeesInput
    upsert?: ClientAdminUpsertWithoutStudentFeesInput
    connect?: ClientAdminWhereUniqueInput
    update?: XOR<XOR<ClientAdminUpdateToOneWithWhereWithoutStudentFeesInput, ClientAdminUpdateWithoutStudentFeesInput>, ClientAdminUncheckedUpdateWithoutStudentFeesInput>
  }

  export type StudentFeeLogUncheckedUpdateManyWithoutStudentFeeNestedInput = {
    create?: XOR<StudentFeeLogCreateWithoutStudentFeeInput, StudentFeeLogUncheckedCreateWithoutStudentFeeInput> | StudentFeeLogCreateWithoutStudentFeeInput[] | StudentFeeLogUncheckedCreateWithoutStudentFeeInput[]
    connectOrCreate?: StudentFeeLogCreateOrConnectWithoutStudentFeeInput | StudentFeeLogCreateOrConnectWithoutStudentFeeInput[]
    upsert?: StudentFeeLogUpsertWithWhereUniqueWithoutStudentFeeInput | StudentFeeLogUpsertWithWhereUniqueWithoutStudentFeeInput[]
    createMany?: StudentFeeLogCreateManyStudentFeeInputEnvelope
    set?: StudentFeeLogWhereUniqueInput | StudentFeeLogWhereUniqueInput[]
    disconnect?: StudentFeeLogWhereUniqueInput | StudentFeeLogWhereUniqueInput[]
    delete?: StudentFeeLogWhereUniqueInput | StudentFeeLogWhereUniqueInput[]
    connect?: StudentFeeLogWhereUniqueInput | StudentFeeLogWhereUniqueInput[]
    update?: StudentFeeLogUpdateWithWhereUniqueWithoutStudentFeeInput | StudentFeeLogUpdateWithWhereUniqueWithoutStudentFeeInput[]
    updateMany?: StudentFeeLogUpdateManyWithWhereWithoutStudentFeeInput | StudentFeeLogUpdateManyWithWhereWithoutStudentFeeInput[]
    deleteMany?: StudentFeeLogScalarWhereInput | StudentFeeLogScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateOneWithoutPaymentNestedInput = {
    create?: XOR<NotificationCreateWithoutPaymentInput, NotificationUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: NotificationCreateOrConnectWithoutPaymentInput
    upsert?: NotificationUpsertWithoutPaymentInput
    disconnect?: NotificationWhereInput | boolean
    delete?: NotificationWhereInput | boolean
    connect?: NotificationWhereUniqueInput
    update?: XOR<XOR<NotificationUpdateToOneWithWhereWithoutPaymentInput, NotificationUpdateWithoutPaymentInput>, NotificationUncheckedUpdateWithoutPaymentInput>
  }

  export type StationeryIssueCreateNestedManyWithoutItemInput = {
    create?: XOR<StationeryIssueCreateWithoutItemInput, StationeryIssueUncheckedCreateWithoutItemInput> | StationeryIssueCreateWithoutItemInput[] | StationeryIssueUncheckedCreateWithoutItemInput[]
    connectOrCreate?: StationeryIssueCreateOrConnectWithoutItemInput | StationeryIssueCreateOrConnectWithoutItemInput[]
    createMany?: StationeryIssueCreateManyItemInputEnvelope
    connect?: StationeryIssueWhereUniqueInput | StationeryIssueWhereUniqueInput[]
  }

  export type StationeryIssueUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<StationeryIssueCreateWithoutItemInput, StationeryIssueUncheckedCreateWithoutItemInput> | StationeryIssueCreateWithoutItemInput[] | StationeryIssueUncheckedCreateWithoutItemInput[]
    connectOrCreate?: StationeryIssueCreateOrConnectWithoutItemInput | StationeryIssueCreateOrConnectWithoutItemInput[]
    createMany?: StationeryIssueCreateManyItemInputEnvelope
    connect?: StationeryIssueWhereUniqueInput | StationeryIssueWhereUniqueInput[]
  }

  export type StationeryIssueUpdateManyWithoutItemNestedInput = {
    create?: XOR<StationeryIssueCreateWithoutItemInput, StationeryIssueUncheckedCreateWithoutItemInput> | StationeryIssueCreateWithoutItemInput[] | StationeryIssueUncheckedCreateWithoutItemInput[]
    connectOrCreate?: StationeryIssueCreateOrConnectWithoutItemInput | StationeryIssueCreateOrConnectWithoutItemInput[]
    upsert?: StationeryIssueUpsertWithWhereUniqueWithoutItemInput | StationeryIssueUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: StationeryIssueCreateManyItemInputEnvelope
    set?: StationeryIssueWhereUniqueInput | StationeryIssueWhereUniqueInput[]
    disconnect?: StationeryIssueWhereUniqueInput | StationeryIssueWhereUniqueInput[]
    delete?: StationeryIssueWhereUniqueInput | StationeryIssueWhereUniqueInput[]
    connect?: StationeryIssueWhereUniqueInput | StationeryIssueWhereUniqueInput[]
    update?: StationeryIssueUpdateWithWhereUniqueWithoutItemInput | StationeryIssueUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: StationeryIssueUpdateManyWithWhereWithoutItemInput | StationeryIssueUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: StationeryIssueScalarWhereInput | StationeryIssueScalarWhereInput[]
  }

  export type StationeryIssueUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<StationeryIssueCreateWithoutItemInput, StationeryIssueUncheckedCreateWithoutItemInput> | StationeryIssueCreateWithoutItemInput[] | StationeryIssueUncheckedCreateWithoutItemInput[]
    connectOrCreate?: StationeryIssueCreateOrConnectWithoutItemInput | StationeryIssueCreateOrConnectWithoutItemInput[]
    upsert?: StationeryIssueUpsertWithWhereUniqueWithoutItemInput | StationeryIssueUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: StationeryIssueCreateManyItemInputEnvelope
    set?: StationeryIssueWhereUniqueInput | StationeryIssueWhereUniqueInput[]
    disconnect?: StationeryIssueWhereUniqueInput | StationeryIssueWhereUniqueInput[]
    delete?: StationeryIssueWhereUniqueInput | StationeryIssueWhereUniqueInput[]
    connect?: StationeryIssueWhereUniqueInput | StationeryIssueWhereUniqueInput[]
    update?: StationeryIssueUpdateWithWhereUniqueWithoutItemInput | StationeryIssueUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: StationeryIssueUpdateManyWithWhereWithoutItemInput | StationeryIssueUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: StationeryIssueScalarWhereInput | StationeryIssueScalarWhereInput[]
  }

  export type StudentCreateNestedOneWithoutStationeryInput = {
    create?: XOR<StudentCreateWithoutStationeryInput, StudentUncheckedCreateWithoutStationeryInput>
    connectOrCreate?: StudentCreateOrConnectWithoutStationeryInput
    connect?: StudentWhereUniqueInput
  }

  export type CourseCreateNestedOneWithoutStationeryInput = {
    create?: XOR<CourseCreateWithoutStationeryInput, CourseUncheckedCreateWithoutStationeryInput>
    connectOrCreate?: CourseCreateOrConnectWithoutStationeryInput
    connect?: CourseWhereUniqueInput
  }

  export type StationeryItemCreateNestedOneWithoutStationeryIssuesInput = {
    create?: XOR<StationeryItemCreateWithoutStationeryIssuesInput, StationeryItemUncheckedCreateWithoutStationeryIssuesInput>
    connectOrCreate?: StationeryItemCreateOrConnectWithoutStationeryIssuesInput
    connect?: StationeryItemWhereUniqueInput
  }

  export type ClientAdminCreateNestedOneWithoutStationeryIssuesInput = {
    create?: XOR<ClientAdminCreateWithoutStationeryIssuesInput, ClientAdminUncheckedCreateWithoutStationeryIssuesInput>
    connectOrCreate?: ClientAdminCreateOrConnectWithoutStationeryIssuesInput
    connect?: ClientAdminWhereUniqueInput
  }

  export type StudentUpdateOneRequiredWithoutStationeryNestedInput = {
    create?: XOR<StudentCreateWithoutStationeryInput, StudentUncheckedCreateWithoutStationeryInput>
    connectOrCreate?: StudentCreateOrConnectWithoutStationeryInput
    upsert?: StudentUpsertWithoutStationeryInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutStationeryInput, StudentUpdateWithoutStationeryInput>, StudentUncheckedUpdateWithoutStationeryInput>
  }

  export type CourseUpdateOneRequiredWithoutStationeryNestedInput = {
    create?: XOR<CourseCreateWithoutStationeryInput, CourseUncheckedCreateWithoutStationeryInput>
    connectOrCreate?: CourseCreateOrConnectWithoutStationeryInput
    upsert?: CourseUpsertWithoutStationeryInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutStationeryInput, CourseUpdateWithoutStationeryInput>, CourseUncheckedUpdateWithoutStationeryInput>
  }

  export type StationeryItemUpdateOneRequiredWithoutStationeryIssuesNestedInput = {
    create?: XOR<StationeryItemCreateWithoutStationeryIssuesInput, StationeryItemUncheckedCreateWithoutStationeryIssuesInput>
    connectOrCreate?: StationeryItemCreateOrConnectWithoutStationeryIssuesInput
    upsert?: StationeryItemUpsertWithoutStationeryIssuesInput
    connect?: StationeryItemWhereUniqueInput
    update?: XOR<XOR<StationeryItemUpdateToOneWithWhereWithoutStationeryIssuesInput, StationeryItemUpdateWithoutStationeryIssuesInput>, StationeryItemUncheckedUpdateWithoutStationeryIssuesInput>
  }

  export type ClientAdminUpdateOneRequiredWithoutStationeryIssuesNestedInput = {
    create?: XOR<ClientAdminCreateWithoutStationeryIssuesInput, ClientAdminUncheckedCreateWithoutStationeryIssuesInput>
    connectOrCreate?: ClientAdminCreateOrConnectWithoutStationeryIssuesInput
    upsert?: ClientAdminUpsertWithoutStationeryIssuesInput
    connect?: ClientAdminWhereUniqueInput
    update?: XOR<XOR<ClientAdminUpdateToOneWithWhereWithoutStationeryIssuesInput, ClientAdminUpdateWithoutStationeryIssuesInput>, ClientAdminUncheckedUpdateWithoutStationeryIssuesInput>
  }

  export type StudentCreateNestedOneWithoutAttendanceInput = {
    create?: XOR<StudentCreateWithoutAttendanceInput, StudentUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: StudentCreateOrConnectWithoutAttendanceInput
    connect?: StudentWhereUniqueInput
  }

  export type CourseCreateNestedOneWithoutAttendanceRecordsInput = {
    create?: XOR<CourseCreateWithoutAttendanceRecordsInput, CourseUncheckedCreateWithoutAttendanceRecordsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutAttendanceRecordsInput
    connect?: CourseWhereUniqueInput
  }

  export type FacultyCreateNestedOneWithoutAttendanceInput = {
    create?: XOR<FacultyCreateWithoutAttendanceInput, FacultyUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: FacultyCreateOrConnectWithoutAttendanceInput
    connect?: FacultyWhereUniqueInput
  }

  export type ClientAdminCreateNestedOneWithoutAttendanceRecordsInput = {
    create?: XOR<ClientAdminCreateWithoutAttendanceRecordsInput, ClientAdminUncheckedCreateWithoutAttendanceRecordsInput>
    connectOrCreate?: ClientAdminCreateOrConnectWithoutAttendanceRecordsInput
    connect?: ClientAdminWhereUniqueInput
  }

  export type StudentUpdateOneRequiredWithoutAttendanceNestedInput = {
    create?: XOR<StudentCreateWithoutAttendanceInput, StudentUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: StudentCreateOrConnectWithoutAttendanceInput
    upsert?: StudentUpsertWithoutAttendanceInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutAttendanceInput, StudentUpdateWithoutAttendanceInput>, StudentUncheckedUpdateWithoutAttendanceInput>
  }

  export type CourseUpdateOneRequiredWithoutAttendanceRecordsNestedInput = {
    create?: XOR<CourseCreateWithoutAttendanceRecordsInput, CourseUncheckedCreateWithoutAttendanceRecordsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutAttendanceRecordsInput
    upsert?: CourseUpsertWithoutAttendanceRecordsInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutAttendanceRecordsInput, CourseUpdateWithoutAttendanceRecordsInput>, CourseUncheckedUpdateWithoutAttendanceRecordsInput>
  }

  export type FacultyUpdateOneRequiredWithoutAttendanceNestedInput = {
    create?: XOR<FacultyCreateWithoutAttendanceInput, FacultyUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: FacultyCreateOrConnectWithoutAttendanceInput
    upsert?: FacultyUpsertWithoutAttendanceInput
    connect?: FacultyWhereUniqueInput
    update?: XOR<XOR<FacultyUpdateToOneWithWhereWithoutAttendanceInput, FacultyUpdateWithoutAttendanceInput>, FacultyUncheckedUpdateWithoutAttendanceInput>
  }

  export type ClientAdminUpdateOneRequiredWithoutAttendanceRecordsNestedInput = {
    create?: XOR<ClientAdminCreateWithoutAttendanceRecordsInput, ClientAdminUncheckedCreateWithoutAttendanceRecordsInput>
    connectOrCreate?: ClientAdminCreateOrConnectWithoutAttendanceRecordsInput
    upsert?: ClientAdminUpsertWithoutAttendanceRecordsInput
    connect?: ClientAdminWhereUniqueInput
    update?: XOR<XOR<ClientAdminUpdateToOneWithWhereWithoutAttendanceRecordsInput, ClientAdminUpdateWithoutAttendanceRecordsInput>, ClientAdminUncheckedUpdateWithoutAttendanceRecordsInput>
  }

  export type StudentCreateNestedOneWithoutTasksInput = {
    create?: XOR<StudentCreateWithoutTasksInput, StudentUncheckedCreateWithoutTasksInput>
    connectOrCreate?: StudentCreateOrConnectWithoutTasksInput
    connect?: StudentWhereUniqueInput
  }

  export type CourseCreateNestedOneWithoutStudentTasksInput = {
    create?: XOR<CourseCreateWithoutStudentTasksInput, CourseUncheckedCreateWithoutStudentTasksInput>
    connectOrCreate?: CourseCreateOrConnectWithoutStudentTasksInput
    connect?: CourseWhereUniqueInput
  }

  export type FacultyCreateNestedOneWithoutTasksInput = {
    create?: XOR<FacultyCreateWithoutTasksInput, FacultyUncheckedCreateWithoutTasksInput>
    connectOrCreate?: FacultyCreateOrConnectWithoutTasksInput
    connect?: FacultyWhereUniqueInput
  }

  export type ClientAdminCreateNestedOneWithoutStudentTasksInput = {
    create?: XOR<ClientAdminCreateWithoutStudentTasksInput, ClientAdminUncheckedCreateWithoutStudentTasksInput>
    connectOrCreate?: ClientAdminCreateOrConnectWithoutStudentTasksInput
    connect?: ClientAdminWhereUniqueInput
  }

  export type StudentUpdateOneRequiredWithoutTasksNestedInput = {
    create?: XOR<StudentCreateWithoutTasksInput, StudentUncheckedCreateWithoutTasksInput>
    connectOrCreate?: StudentCreateOrConnectWithoutTasksInput
    upsert?: StudentUpsertWithoutTasksInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutTasksInput, StudentUpdateWithoutTasksInput>, StudentUncheckedUpdateWithoutTasksInput>
  }

  export type CourseUpdateOneRequiredWithoutStudentTasksNestedInput = {
    create?: XOR<CourseCreateWithoutStudentTasksInput, CourseUncheckedCreateWithoutStudentTasksInput>
    connectOrCreate?: CourseCreateOrConnectWithoutStudentTasksInput
    upsert?: CourseUpsertWithoutStudentTasksInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutStudentTasksInput, CourseUpdateWithoutStudentTasksInput>, CourseUncheckedUpdateWithoutStudentTasksInput>
  }

  export type FacultyUpdateOneWithoutTasksNestedInput = {
    create?: XOR<FacultyCreateWithoutTasksInput, FacultyUncheckedCreateWithoutTasksInput>
    connectOrCreate?: FacultyCreateOrConnectWithoutTasksInput
    upsert?: FacultyUpsertWithoutTasksInput
    disconnect?: FacultyWhereInput | boolean
    delete?: FacultyWhereInput | boolean
    connect?: FacultyWhereUniqueInput
    update?: XOR<XOR<FacultyUpdateToOneWithWhereWithoutTasksInput, FacultyUpdateWithoutTasksInput>, FacultyUncheckedUpdateWithoutTasksInput>
  }

  export type ClientAdminUpdateOneRequiredWithoutStudentTasksNestedInput = {
    create?: XOR<ClientAdminCreateWithoutStudentTasksInput, ClientAdminUncheckedCreateWithoutStudentTasksInput>
    connectOrCreate?: ClientAdminCreateOrConnectWithoutStudentTasksInput
    upsert?: ClientAdminUpsertWithoutStudentTasksInput
    connect?: ClientAdminWhereUniqueInput
    update?: XOR<XOR<ClientAdminUpdateToOneWithWhereWithoutStudentTasksInput, ClientAdminUpdateWithoutStudentTasksInput>, ClientAdminUncheckedUpdateWithoutStudentTasksInput>
  }

  export type StudentCreateNestedOneWithoutTestsInput = {
    create?: XOR<StudentCreateWithoutTestsInput, StudentUncheckedCreateWithoutTestsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutTestsInput
    connect?: StudentWhereUniqueInput
  }

  export type CourseCreateNestedOneWithoutStudentTestsInput = {
    create?: XOR<CourseCreateWithoutStudentTestsInput, CourseUncheckedCreateWithoutStudentTestsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutStudentTestsInput
    connect?: CourseWhereUniqueInput
  }

  export type ClientAdminCreateNestedOneWithoutStudentTestsInput = {
    create?: XOR<ClientAdminCreateWithoutStudentTestsInput, ClientAdminUncheckedCreateWithoutStudentTestsInput>
    connectOrCreate?: ClientAdminCreateOrConnectWithoutStudentTestsInput
    connect?: ClientAdminWhereUniqueInput
  }

  export type StudentUpdateOneRequiredWithoutTestsNestedInput = {
    create?: XOR<StudentCreateWithoutTestsInput, StudentUncheckedCreateWithoutTestsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutTestsInput
    upsert?: StudentUpsertWithoutTestsInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutTestsInput, StudentUpdateWithoutTestsInput>, StudentUncheckedUpdateWithoutTestsInput>
  }

  export type CourseUpdateOneRequiredWithoutStudentTestsNestedInput = {
    create?: XOR<CourseCreateWithoutStudentTestsInput, CourseUncheckedCreateWithoutStudentTestsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutStudentTestsInput
    upsert?: CourseUpsertWithoutStudentTestsInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutStudentTestsInput, CourseUpdateWithoutStudentTestsInput>, CourseUncheckedUpdateWithoutStudentTestsInput>
  }

  export type ClientAdminUpdateOneRequiredWithoutStudentTestsNestedInput = {
    create?: XOR<ClientAdminCreateWithoutStudentTestsInput, ClientAdminUncheckedCreateWithoutStudentTestsInput>
    connectOrCreate?: ClientAdminCreateOrConnectWithoutStudentTestsInput
    upsert?: ClientAdminUpsertWithoutStudentTestsInput
    connect?: ClientAdminWhereUniqueInput
    update?: XOR<XOR<ClientAdminUpdateToOneWithWhereWithoutStudentTestsInput, ClientAdminUpdateWithoutStudentTestsInput>, ClientAdminUncheckedUpdateWithoutStudentTestsInput>
  }

  export type StudentCourseCreateNestedOneWithoutCompletionsInput = {
    create?: XOR<StudentCourseCreateWithoutCompletionsInput, StudentCourseUncheckedCreateWithoutCompletionsInput>
    connectOrCreate?: StudentCourseCreateOrConnectWithoutCompletionsInput
    connect?: StudentCourseWhereUniqueInput
  }

  export type StudentCreateNestedOneWithoutCompletionsInput = {
    create?: XOR<StudentCreateWithoutCompletionsInput, StudentUncheckedCreateWithoutCompletionsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutCompletionsInput
    connect?: StudentWhereUniqueInput
  }

  export type ClientAdminCreateNestedOneWithoutCourseCompletionsInput = {
    create?: XOR<ClientAdminCreateWithoutCourseCompletionsInput, ClientAdminUncheckedCreateWithoutCourseCompletionsInput>
    connectOrCreate?: ClientAdminCreateOrConnectWithoutCourseCompletionsInput
    connect?: ClientAdminWhereUniqueInput
  }

  export type StudentCourseUpdateOneRequiredWithoutCompletionsNestedInput = {
    create?: XOR<StudentCourseCreateWithoutCompletionsInput, StudentCourseUncheckedCreateWithoutCompletionsInput>
    connectOrCreate?: StudentCourseCreateOrConnectWithoutCompletionsInput
    upsert?: StudentCourseUpsertWithoutCompletionsInput
    connect?: StudentCourseWhereUniqueInput
    update?: XOR<XOR<StudentCourseUpdateToOneWithWhereWithoutCompletionsInput, StudentCourseUpdateWithoutCompletionsInput>, StudentCourseUncheckedUpdateWithoutCompletionsInput>
  }

  export type StudentUpdateOneRequiredWithoutCompletionsNestedInput = {
    create?: XOR<StudentCreateWithoutCompletionsInput, StudentUncheckedCreateWithoutCompletionsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutCompletionsInput
    upsert?: StudentUpsertWithoutCompletionsInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutCompletionsInput, StudentUpdateWithoutCompletionsInput>, StudentUncheckedUpdateWithoutCompletionsInput>
  }

  export type ClientAdminUpdateOneRequiredWithoutCourseCompletionsNestedInput = {
    create?: XOR<ClientAdminCreateWithoutCourseCompletionsInput, ClientAdminUncheckedCreateWithoutCourseCompletionsInput>
    connectOrCreate?: ClientAdminCreateOrConnectWithoutCourseCompletionsInput
    upsert?: ClientAdminUpsertWithoutCourseCompletionsInput
    connect?: ClientAdminWhereUniqueInput
    update?: XOR<XOR<ClientAdminUpdateToOneWithWhereWithoutCourseCompletionsInput, ClientAdminUpdateWithoutCourseCompletionsInput>, ClientAdminUncheckedUpdateWithoutCourseCompletionsInput>
  }

  export type StudentCreateNestedOneWithoutCertificatesInput = {
    create?: XOR<StudentCreateWithoutCertificatesInput, StudentUncheckedCreateWithoutCertificatesInput>
    connectOrCreate?: StudentCreateOrConnectWithoutCertificatesInput
    connect?: StudentWhereUniqueInput
  }

  export type CourseCreateNestedOneWithoutCertificatesInput = {
    create?: XOR<CourseCreateWithoutCertificatesInput, CourseUncheckedCreateWithoutCertificatesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutCertificatesInput
    connect?: CourseWhereUniqueInput
  }

  export type StudentCourseCreateNestedOneWithoutCertificateInput = {
    create?: XOR<StudentCourseCreateWithoutCertificateInput, StudentCourseUncheckedCreateWithoutCertificateInput>
    connectOrCreate?: StudentCourseCreateOrConnectWithoutCertificateInput
    connect?: StudentCourseWhereUniqueInput
  }

  export type ClientAdminCreateNestedOneWithoutCertificatesInput = {
    create?: XOR<ClientAdminCreateWithoutCertificatesInput, ClientAdminUncheckedCreateWithoutCertificatesInput>
    connectOrCreate?: ClientAdminCreateOrConnectWithoutCertificatesInput
    connect?: ClientAdminWhereUniqueInput
  }

  export type StudentUpdateOneRequiredWithoutCertificatesNestedInput = {
    create?: XOR<StudentCreateWithoutCertificatesInput, StudentUncheckedCreateWithoutCertificatesInput>
    connectOrCreate?: StudentCreateOrConnectWithoutCertificatesInput
    upsert?: StudentUpsertWithoutCertificatesInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutCertificatesInput, StudentUpdateWithoutCertificatesInput>, StudentUncheckedUpdateWithoutCertificatesInput>
  }

  export type CourseUpdateOneRequiredWithoutCertificatesNestedInput = {
    create?: XOR<CourseCreateWithoutCertificatesInput, CourseUncheckedCreateWithoutCertificatesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutCertificatesInput
    upsert?: CourseUpsertWithoutCertificatesInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutCertificatesInput, CourseUpdateWithoutCertificatesInput>, CourseUncheckedUpdateWithoutCertificatesInput>
  }

  export type StudentCourseUpdateOneRequiredWithoutCertificateNestedInput = {
    create?: XOR<StudentCourseCreateWithoutCertificateInput, StudentCourseUncheckedCreateWithoutCertificateInput>
    connectOrCreate?: StudentCourseCreateOrConnectWithoutCertificateInput
    upsert?: StudentCourseUpsertWithoutCertificateInput
    connect?: StudentCourseWhereUniqueInput
    update?: XOR<XOR<StudentCourseUpdateToOneWithWhereWithoutCertificateInput, StudentCourseUpdateWithoutCertificateInput>, StudentCourseUncheckedUpdateWithoutCertificateInput>
  }

  export type ClientAdminUpdateOneRequiredWithoutCertificatesNestedInput = {
    create?: XOR<ClientAdminCreateWithoutCertificatesInput, ClientAdminUncheckedCreateWithoutCertificatesInput>
    connectOrCreate?: ClientAdminCreateOrConnectWithoutCertificatesInput
    upsert?: ClientAdminUpsertWithoutCertificatesInput
    connect?: ClientAdminWhereUniqueInput
    update?: XOR<XOR<ClientAdminUpdateToOneWithWhereWithoutCertificatesInput, ClientAdminUpdateWithoutCertificatesInput>, ClientAdminUncheckedUpdateWithoutCertificatesInput>
  }

  export type StudentCreateNestedOneWithoutFinancialRecordsInput = {
    create?: XOR<StudentCreateWithoutFinancialRecordsInput, StudentUncheckedCreateWithoutFinancialRecordsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutFinancialRecordsInput
    connect?: StudentWhereUniqueInput
  }

  export type CourseCreateNestedOneWithoutFinancialRecordsInput = {
    create?: XOR<CourseCreateWithoutFinancialRecordsInput, CourseUncheckedCreateWithoutFinancialRecordsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutFinancialRecordsInput
    connect?: CourseWhereUniqueInput
  }

  export type FacultyCreateNestedOneWithoutFinancialRecordsInput = {
    create?: XOR<FacultyCreateWithoutFinancialRecordsInput, FacultyUncheckedCreateWithoutFinancialRecordsInput>
    connectOrCreate?: FacultyCreateOrConnectWithoutFinancialRecordsInput
    connect?: FacultyWhereUniqueInput
  }

  export type LabCreateNestedOneWithoutFinancialRecordsInput = {
    create?: XOR<LabCreateWithoutFinancialRecordsInput, LabUncheckedCreateWithoutFinancialRecordsInput>
    connectOrCreate?: LabCreateOrConnectWithoutFinancialRecordsInput
    connect?: LabWhereUniqueInput
  }

  export type ClientAdminCreateNestedOneWithoutFinancialRecordsInput = {
    create?: XOR<ClientAdminCreateWithoutFinancialRecordsInput, ClientAdminUncheckedCreateWithoutFinancialRecordsInput>
    connectOrCreate?: ClientAdminCreateOrConnectWithoutFinancialRecordsInput
    connect?: ClientAdminWhereUniqueInput
  }

  export type EnumRecordTypeFieldUpdateOperationsInput = {
    set?: $Enums.RecordType
  }

  export type NullableEnumPaymentModeFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMode | null
  }

  export type StudentUpdateOneWithoutFinancialRecordsNestedInput = {
    create?: XOR<StudentCreateWithoutFinancialRecordsInput, StudentUncheckedCreateWithoutFinancialRecordsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutFinancialRecordsInput
    upsert?: StudentUpsertWithoutFinancialRecordsInput
    disconnect?: StudentWhereInput | boolean
    delete?: StudentWhereInput | boolean
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutFinancialRecordsInput, StudentUpdateWithoutFinancialRecordsInput>, StudentUncheckedUpdateWithoutFinancialRecordsInput>
  }

  export type CourseUpdateOneWithoutFinancialRecordsNestedInput = {
    create?: XOR<CourseCreateWithoutFinancialRecordsInput, CourseUncheckedCreateWithoutFinancialRecordsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutFinancialRecordsInput
    upsert?: CourseUpsertWithoutFinancialRecordsInput
    disconnect?: CourseWhereInput | boolean
    delete?: CourseWhereInput | boolean
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutFinancialRecordsInput, CourseUpdateWithoutFinancialRecordsInput>, CourseUncheckedUpdateWithoutFinancialRecordsInput>
  }

  export type FacultyUpdateOneWithoutFinancialRecordsNestedInput = {
    create?: XOR<FacultyCreateWithoutFinancialRecordsInput, FacultyUncheckedCreateWithoutFinancialRecordsInput>
    connectOrCreate?: FacultyCreateOrConnectWithoutFinancialRecordsInput
    upsert?: FacultyUpsertWithoutFinancialRecordsInput
    disconnect?: FacultyWhereInput | boolean
    delete?: FacultyWhereInput | boolean
    connect?: FacultyWhereUniqueInput
    update?: XOR<XOR<FacultyUpdateToOneWithWhereWithoutFinancialRecordsInput, FacultyUpdateWithoutFinancialRecordsInput>, FacultyUncheckedUpdateWithoutFinancialRecordsInput>
  }

  export type LabUpdateOneWithoutFinancialRecordsNestedInput = {
    create?: XOR<LabCreateWithoutFinancialRecordsInput, LabUncheckedCreateWithoutFinancialRecordsInput>
    connectOrCreate?: LabCreateOrConnectWithoutFinancialRecordsInput
    upsert?: LabUpsertWithoutFinancialRecordsInput
    disconnect?: LabWhereInput | boolean
    delete?: LabWhereInput | boolean
    connect?: LabWhereUniqueInput
    update?: XOR<XOR<LabUpdateToOneWithWhereWithoutFinancialRecordsInput, LabUpdateWithoutFinancialRecordsInput>, LabUncheckedUpdateWithoutFinancialRecordsInput>
  }

  export type ClientAdminUpdateOneRequiredWithoutFinancialRecordsNestedInput = {
    create?: XOR<ClientAdminCreateWithoutFinancialRecordsInput, ClientAdminUncheckedCreateWithoutFinancialRecordsInput>
    connectOrCreate?: ClientAdminCreateOrConnectWithoutFinancialRecordsInput
    upsert?: ClientAdminUpsertWithoutFinancialRecordsInput
    connect?: ClientAdminWhereUniqueInput
    update?: XOR<XOR<ClientAdminUpdateToOneWithWhereWithoutFinancialRecordsInput, ClientAdminUpdateWithoutFinancialRecordsInput>, ClientAdminUncheckedUpdateWithoutFinancialRecordsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumLeadStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LeadStatus | EnumLeadStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeadStatusFilter<$PrismaModel> | $Enums.LeadStatus
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumLeadStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeadStatus | EnumLeadStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeadStatusWithAggregatesFilter<$PrismaModel> | $Enums.LeadStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeadStatusFilter<$PrismaModel>
    _max?: NestedEnumLeadStatusFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumFollowUpStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.FollowUpStatus | EnumFollowUpStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FollowUpStatus[] | ListEnumFollowUpStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FollowUpStatus[] | ListEnumFollowUpStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFollowUpStatusFilter<$PrismaModel> | $Enums.FollowUpStatus
  }

  export type NestedEnumFollowUpStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FollowUpStatus | EnumFollowUpStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FollowUpStatus[] | ListEnumFollowUpStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FollowUpStatus[] | ListEnumFollowUpStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFollowUpStatusWithAggregatesFilter<$PrismaModel> | $Enums.FollowUpStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFollowUpStatusFilter<$PrismaModel>
    _max?: NestedEnumFollowUpStatusFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumPaymentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentType | EnumPaymentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentType[] | ListEnumPaymentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentType[] | ListEnumPaymentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentTypeFilter<$PrismaModel> | $Enums.PaymentType
  }

  export type NestedEnumPaymentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentType | EnumPaymentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentType[] | ListEnumPaymentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentType[] | ListEnumPaymentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentTypeWithAggregatesFilter<$PrismaModel> | $Enums.PaymentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentTypeFilter<$PrismaModel>
    _max?: NestedEnumPaymentTypeFilter<$PrismaModel>
  }

  export type NestedEnumPaymentModeFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMode | EnumPaymentModeFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMode[] | ListEnumPaymentModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMode[] | ListEnumPaymentModeFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentModeFilter<$PrismaModel> | $Enums.PaymentMode
  }

  export type NestedEnumPaymentModeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMode | EnumPaymentModeFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMode[] | ListEnumPaymentModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMode[] | ListEnumPaymentModeFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentModeWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMode
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentModeFilter<$PrismaModel>
    _max?: NestedEnumPaymentModeFilter<$PrismaModel>
  }

  export type NestedEnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type NestedEnumRecordTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RecordType | EnumRecordTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RecordType[] | ListEnumRecordTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RecordType[] | ListEnumRecordTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRecordTypeFilter<$PrismaModel> | $Enums.RecordType
  }

  export type NestedEnumPaymentModeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMode | EnumPaymentModeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentMode[] | ListEnumPaymentModeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentMode[] | ListEnumPaymentModeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentModeNullableFilter<$PrismaModel> | $Enums.PaymentMode | null
  }

  export type NestedEnumRecordTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RecordType | EnumRecordTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RecordType[] | ListEnumRecordTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RecordType[] | ListEnumRecordTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRecordTypeWithAggregatesFilter<$PrismaModel> | $Enums.RecordType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRecordTypeFilter<$PrismaModel>
    _max?: NestedEnumRecordTypeFilter<$PrismaModel>
  }

  export type NestedEnumPaymentModeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMode | EnumPaymentModeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentMode[] | ListEnumPaymentModeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentMode[] | ListEnumPaymentModeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentModeNullableWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMode | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPaymentModeNullableFilter<$PrismaModel>
    _max?: NestedEnumPaymentModeNullableFilter<$PrismaModel>
  }

  export type RoleUserCreateWithoutClientAdminInput = {
    id?: string
    name: string
    email: string
    password: string
    role: $Enums.UserRole
    createdAt?: Date | string
    country: string
    state: string
    city: string
    zipCode: string
    currentSessionToken?: string | null
    lastLoginAt?: Date | string | null
  }

  export type RoleUserUncheckedCreateWithoutClientAdminInput = {
    id?: string
    name: string
    email: string
    password: string
    role: $Enums.UserRole
    createdAt?: Date | string
    country: string
    state: string
    city: string
    zipCode: string
    currentSessionToken?: string | null
    lastLoginAt?: Date | string | null
  }

  export type RoleUserCreateOrConnectWithoutClientAdminInput = {
    where: RoleUserWhereUniqueInput
    create: XOR<RoleUserCreateWithoutClientAdminInput, RoleUserUncheckedCreateWithoutClientAdminInput>
  }

  export type RoleUserCreateManyClientAdminInputEnvelope = {
    data: RoleUserCreateManyClientAdminInput | RoleUserCreateManyClientAdminInput[]
    skipDuplicates?: boolean
  }

  export type FacultyCreateWithoutClientAdminInput = {
    name: string
    email: string
    password: string
    contact: string
    joiningDate: Date | string
    specialization?: string | null
    role?: $Enums.UserRole
    country: string
    state: string
    city: string
    zipCode: string
    currentSessionToken?: string | null
    lastLoginAt?: Date | string | null
    batches?: BatchCreateNestedManyWithoutFacultyInput
    attendance?: AttendanceRecordCreateNestedManyWithoutMarkedByInput
    tasks?: StudentTaskCreateNestedManyWithoutFacultyInput
    financialRecords?: FinancialRecordCreateNestedManyWithoutFacultyInput
  }

  export type FacultyUncheckedCreateWithoutClientAdminInput = {
    id?: number
    name: string
    email: string
    password: string
    contact: string
    joiningDate: Date | string
    specialization?: string | null
    role?: $Enums.UserRole
    country: string
    state: string
    city: string
    zipCode: string
    currentSessionToken?: string | null
    lastLoginAt?: Date | string | null
    batches?: BatchUncheckedCreateNestedManyWithoutFacultyInput
    attendance?: AttendanceRecordUncheckedCreateNestedManyWithoutMarkedByInput
    tasks?: StudentTaskUncheckedCreateNestedManyWithoutFacultyInput
    financialRecords?: FinancialRecordUncheckedCreateNestedManyWithoutFacultyInput
  }

  export type FacultyCreateOrConnectWithoutClientAdminInput = {
    where: FacultyWhereUniqueInput
    create: XOR<FacultyCreateWithoutClientAdminInput, FacultyUncheckedCreateWithoutClientAdminInput>
  }

  export type FacultyCreateManyClientAdminInputEnvelope = {
    data: FacultyCreateManyClientAdminInput | FacultyCreateManyClientAdminInput[]
    skipDuplicates?: boolean
  }

  export type BatchCreateWithoutClientAdminInput = {
    name: string
    faculty?: FacultyCreateNestedOneWithoutBatchesInput
    labTimeSlot: LabTimeSlotCreateNestedOneWithoutBatchesInput
    studentCourses?: StudentCourseCreateNestedManyWithoutBatchInput
    batchCourses?: BatchCourseCreateNestedManyWithoutBatchInput
  }

  export type BatchUncheckedCreateWithoutClientAdminInput = {
    id?: number
    name: string
    facultyId?: number | null
    labTimeSlotId: number
    studentCourses?: StudentCourseUncheckedCreateNestedManyWithoutBatchInput
    batchCourses?: BatchCourseUncheckedCreateNestedManyWithoutBatchInput
  }

  export type BatchCreateOrConnectWithoutClientAdminInput = {
    where: BatchWhereUniqueInput
    create: XOR<BatchCreateWithoutClientAdminInput, BatchUncheckedCreateWithoutClientAdminInput>
  }

  export type BatchCreateManyClientAdminInputEnvelope = {
    data: BatchCreateManyClientAdminInput | BatchCreateManyClientAdminInput[]
    skipDuplicates?: boolean
  }

  export type CourseCreateWithoutClientAdminInput = {
    name: string
    durationWeeks: number
    description?: string | null
    courseFeeStructure?: CourseFeeStructureCreateNestedOneWithoutCourseInput
    studentCourses?: StudentCourseCreateNestedManyWithoutCourseInput
    enquiryCourse?: EnquiryCourseCreateNestedManyWithoutCourseInput
    feeStructures?: FeeStructureCreateNestedManyWithoutCourseInput
    stationery?: StationeryIssueCreateNestedManyWithoutCourseInput
    studentFees?: StudentFeeCreateNestedManyWithoutCourseInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutCourseInput
    studentTasks?: StudentTaskCreateNestedManyWithoutCourseInput
    studentTests?: StudentTestCreateNestedManyWithoutCourseInput
    certificates?: CertificateCreateNestedManyWithoutCourseInput
    financialRecords?: FinancialRecordCreateNestedManyWithoutCourseInput
    batchCourses?: BatchCourseCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutClientAdminInput = {
    id?: number
    name: string
    durationWeeks: number
    description?: string | null
    courseFeeStructure?: CourseFeeStructureUncheckedCreateNestedOneWithoutCourseInput
    studentCourses?: StudentCourseUncheckedCreateNestedManyWithoutCourseInput
    enquiryCourse?: EnquiryCourseUncheckedCreateNestedManyWithoutCourseInput
    feeStructures?: FeeStructureUncheckedCreateNestedManyWithoutCourseInput
    stationery?: StationeryIssueUncheckedCreateNestedManyWithoutCourseInput
    studentFees?: StudentFeeUncheckedCreateNestedManyWithoutCourseInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutCourseInput
    studentTasks?: StudentTaskUncheckedCreateNestedManyWithoutCourseInput
    studentTests?: StudentTestUncheckedCreateNestedManyWithoutCourseInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutCourseInput
    financialRecords?: FinancialRecordUncheckedCreateNestedManyWithoutCourseInput
    batchCourses?: BatchCourseUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutClientAdminInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutClientAdminInput, CourseUncheckedCreateWithoutClientAdminInput>
  }

  export type CourseCreateManyClientAdminInputEnvelope = {
    data: CourseCreateManyClientAdminInput | CourseCreateManyClientAdminInput[]
    skipDuplicates?: boolean
  }

  export type EnquiryCourseCreateWithoutClientAdminInput = {
    enquiry: EnquiryCreateNestedOneWithoutEnquiryCourseInput
    course: CourseCreateNestedOneWithoutEnquiryCourseInput
  }

  export type EnquiryCourseUncheckedCreateWithoutClientAdminInput = {
    id?: number
    enquiryId: string
    courseId: number
  }

  export type EnquiryCourseCreateOrConnectWithoutClientAdminInput = {
    where: EnquiryCourseWhereUniqueInput
    create: XOR<EnquiryCourseCreateWithoutClientAdminInput, EnquiryCourseUncheckedCreateWithoutClientAdminInput>
  }

  export type EnquiryCourseCreateManyClientAdminInputEnvelope = {
    data: EnquiryCourseCreateManyClientAdminInput | EnquiryCourseCreateManyClientAdminInput[]
    skipDuplicates?: boolean
  }

  export type LabCreateWithoutClientAdminInput = {
    name: string
    location?: string | null
    totalPCs: number
    isActive?: boolean
    timeSlots?: LabTimeSlotCreateNestedManyWithoutLabInput
    financialRecords?: FinancialRecordCreateNestedManyWithoutLabInput
  }

  export type LabUncheckedCreateWithoutClientAdminInput = {
    id?: number
    name: string
    location?: string | null
    totalPCs: number
    isActive?: boolean
    timeSlots?: LabTimeSlotUncheckedCreateNestedManyWithoutLabInput
    financialRecords?: FinancialRecordUncheckedCreateNestedManyWithoutLabInput
  }

  export type LabCreateOrConnectWithoutClientAdminInput = {
    where: LabWhereUniqueInput
    create: XOR<LabCreateWithoutClientAdminInput, LabUncheckedCreateWithoutClientAdminInput>
  }

  export type LabCreateManyClientAdminInputEnvelope = {
    data: LabCreateManyClientAdminInput | LabCreateManyClientAdminInput[]
    skipDuplicates?: boolean
  }

  export type LabTimeSlotCreateWithoutClientAdminInput = {
    startTime: string
    endTime: string
    day: string
    availablePCs: number
    lab: LabCreateNestedOneWithoutTimeSlotsInput
    batches?: BatchCreateNestedManyWithoutLabTimeSlotInput
    allocations?: LabAllocationCreateNestedManyWithoutLabTimeSlotInput
  }

  export type LabTimeSlotUncheckedCreateWithoutClientAdminInput = {
    id?: number
    startTime: string
    endTime: string
    day: string
    labId: number
    availablePCs: number
    batches?: BatchUncheckedCreateNestedManyWithoutLabTimeSlotInput
    allocations?: LabAllocationUncheckedCreateNestedManyWithoutLabTimeSlotInput
  }

  export type LabTimeSlotCreateOrConnectWithoutClientAdminInput = {
    where: LabTimeSlotWhereUniqueInput
    create: XOR<LabTimeSlotCreateWithoutClientAdminInput, LabTimeSlotUncheckedCreateWithoutClientAdminInput>
  }

  export type LabTimeSlotCreateManyClientAdminInputEnvelope = {
    data: LabTimeSlotCreateManyClientAdminInput | LabTimeSlotCreateManyClientAdminInput[]
    skipDuplicates?: boolean
  }

  export type LabAllocationCreateWithoutClientAdminInput = {
    pcNumber: number
    assignedAt?: Date | string
    labTimeSlot: LabTimeSlotCreateNestedOneWithoutAllocationsInput
    student: StudentCreateNestedOneWithoutLabAllocationsInput
  }

  export type LabAllocationUncheckedCreateWithoutClientAdminInput = {
    id?: number
    labTimeSlotId: number
    studentId: number
    pcNumber: number
    assignedAt?: Date | string
  }

  export type LabAllocationCreateOrConnectWithoutClientAdminInput = {
    where: LabAllocationWhereUniqueInput
    create: XOR<LabAllocationCreateWithoutClientAdminInput, LabAllocationUncheckedCreateWithoutClientAdminInput>
  }

  export type LabAllocationCreateManyClientAdminInputEnvelope = {
    data: LabAllocationCreateManyClientAdminInput | LabAllocationCreateManyClientAdminInput[]
    skipDuplicates?: boolean
  }

  export type StudentCreateWithoutClientAdminInput = {
    serialNumber: number
    studentCode: string
    fullName: string
    fatherName: string
    motherName: string
    photoUrl?: string | null
    contact: string
    parentsContact: string
    email?: string | null
    residentialAddress?: string | null
    permenantAddress?: string | null
    dob: string
    gender: string
    religion?: string | null
    idProofType?: string | null
    idProofNumber?: string | null
    admissionDate: Date | string
    enquiry?: EnquiryCreateNestedOneWithoutStudentInput
    labAllocations?: LabAllocationCreateNestedManyWithoutStudentInput
    studentCourses?: StudentCourseCreateNestedManyWithoutStudentInput
    feeStructures?: FeeStructureCreateNestedManyWithoutStudentInput
    feeRecords?: StudentFeeCreateNestedManyWithoutStudentInput
    attendance?: AttendanceRecordCreateNestedManyWithoutStudentInput
    tasks?: StudentTaskCreateNestedManyWithoutStudentInput
    tests?: StudentTestCreateNestedManyWithoutStudentInput
    completions?: CourseCompletionCreateNestedManyWithoutStudentInput
    stationery?: StationeryIssueCreateNestedManyWithoutStudentInput
    certificates?: CertificateCreateNestedManyWithoutStudentInput
    financialRecords?: FinancialRecordCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutClientAdminInput = {
    id?: number
    serialNumber: number
    studentCode: string
    fullName: string
    fatherName: string
    motherName: string
    photoUrl?: string | null
    contact: string
    parentsContact: string
    email?: string | null
    residentialAddress?: string | null
    permenantAddress?: string | null
    dob: string
    gender: string
    religion?: string | null
    idProofType?: string | null
    idProofNumber?: string | null
    admissionDate: Date | string
    enquiry?: EnquiryUncheckedCreateNestedOneWithoutStudentInput
    labAllocations?: LabAllocationUncheckedCreateNestedManyWithoutStudentInput
    studentCourses?: StudentCourseUncheckedCreateNestedManyWithoutStudentInput
    feeStructures?: FeeStructureUncheckedCreateNestedManyWithoutStudentInput
    feeRecords?: StudentFeeUncheckedCreateNestedManyWithoutStudentInput
    attendance?: AttendanceRecordUncheckedCreateNestedManyWithoutStudentInput
    tasks?: StudentTaskUncheckedCreateNestedManyWithoutStudentInput
    tests?: StudentTestUncheckedCreateNestedManyWithoutStudentInput
    completions?: CourseCompletionUncheckedCreateNestedManyWithoutStudentInput
    stationery?: StationeryIssueUncheckedCreateNestedManyWithoutStudentInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutStudentInput
    financialRecords?: FinancialRecordUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutClientAdminInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutClientAdminInput, StudentUncheckedCreateWithoutClientAdminInput>
  }

  export type StudentCreateManyClientAdminInputEnvelope = {
    data: StudentCreateManyClientAdminInput | StudentCreateManyClientAdminInput[]
    skipDuplicates?: boolean
  }

  export type ActivityLogCreateWithoutClientAdminInput = {
    id?: string
    entity: string
    entityId: string
    action: string
    message?: string | null
    createdAt?: Date | string
  }

  export type ActivityLogUncheckedCreateWithoutClientAdminInput = {
    id?: string
    entity: string
    entityId: string
    action: string
    message?: string | null
    createdAt?: Date | string
  }

  export type ActivityLogCreateOrConnectWithoutClientAdminInput = {
    where: ActivityLogWhereUniqueInput
    create: XOR<ActivityLogCreateWithoutClientAdminInput, ActivityLogUncheckedCreateWithoutClientAdminInput>
  }

  export type ActivityLogCreateManyClientAdminInputEnvelope = {
    data: ActivityLogCreateManyClientAdminInput | ActivityLogCreateManyClientAdminInput[]
    skipDuplicates?: boolean
  }

  export type StudentCourseCreateWithoutClientAdminInput = {
    startDate: Date | string
    endDate: Date | string
    studentCode: string
    internalNotes?: string | null
    status: string
    student: StudentCreateNestedOneWithoutStudentCoursesInput
    course: CourseCreateNestedOneWithoutStudentCoursesInput
    batch?: BatchCreateNestedOneWithoutStudentCoursesInput
    certificate?: CertificateCreateNestedOneWithoutStudentCourseInput
    completions?: CourseCompletionCreateNestedManyWithoutStudentCourseInput
  }

  export type StudentCourseUncheckedCreateWithoutClientAdminInput = {
    id?: number
    studentId: number
    courseId: number
    startDate: Date | string
    endDate: Date | string
    studentCode: string
    batchId?: number | null
    internalNotes?: string | null
    status: string
    certificate?: CertificateUncheckedCreateNestedOneWithoutStudentCourseInput
    completions?: CourseCompletionUncheckedCreateNestedManyWithoutStudentCourseInput
  }

  export type StudentCourseCreateOrConnectWithoutClientAdminInput = {
    where: StudentCourseWhereUniqueInput
    create: XOR<StudentCourseCreateWithoutClientAdminInput, StudentCourseUncheckedCreateWithoutClientAdminInput>
  }

  export type StudentCourseCreateManyClientAdminInputEnvelope = {
    data: StudentCourseCreateManyClientAdminInput | StudentCourseCreateManyClientAdminInput[]
    skipDuplicates?: boolean
  }

  export type FeeStructureCreateWithoutClientAdminInput = {
    totalAmount: number
    paymentType: $Enums.PaymentType
    installmentCount?: number | null
    student: StudentCreateNestedOneWithoutFeeStructuresInput
    course: CourseCreateNestedOneWithoutFeeStructuresInput
    installment?: InstallmentDetailCreateNestedOneWithoutFeeStructuresInput
    studentFees?: StudentFeeCreateNestedManyWithoutFeeStructureInput
  }

  export type FeeStructureUncheckedCreateWithoutClientAdminInput = {
    id?: number
    studentId: number
    courseId: number
    totalAmount: number
    paymentType: $Enums.PaymentType
    installmentCount?: number | null
    installmentTypeId?: number | null
    studentFees?: StudentFeeUncheckedCreateNestedManyWithoutFeeStructureInput
  }

  export type FeeStructureCreateOrConnectWithoutClientAdminInput = {
    where: FeeStructureWhereUniqueInput
    create: XOR<FeeStructureCreateWithoutClientAdminInput, FeeStructureUncheckedCreateWithoutClientAdminInput>
  }

  export type FeeStructureCreateManyClientAdminInputEnvelope = {
    data: FeeStructureCreateManyClientAdminInput | FeeStructureCreateManyClientAdminInput[]
    skipDuplicates?: boolean
  }

  export type StudentFeeCreateWithoutClientAdminInput = {
    dueDate: Date | string
    amountDue: number
    amountPaid: number
    paymentDate?: Date | string | null
    paymentMode: $Enums.PaymentMode
    receiptNo: string
    paymentStatus?: $Enums.PaymentStatus
    student: StudentCreateNestedOneWithoutFeeRecordsInput
    course: CourseCreateNestedOneWithoutStudentFeesInput
    feeLogs?: StudentFeeLogCreateNestedManyWithoutStudentFeeInput
    feeStructure?: FeeStructureCreateNestedOneWithoutStudentFeesInput
    notification?: NotificationCreateNestedOneWithoutPaymentInput
  }

  export type StudentFeeUncheckedCreateWithoutClientAdminInput = {
    id?: number
    studentId: number
    courseId: number
    dueDate: Date | string
    amountDue: number
    amountPaid: number
    paymentDate?: Date | string | null
    paymentMode: $Enums.PaymentMode
    receiptNo: string
    paymentStatus?: $Enums.PaymentStatus
    feeLogs?: StudentFeeLogUncheckedCreateNestedManyWithoutStudentFeeInput
    notification?: NotificationUncheckedCreateNestedOneWithoutPaymentInput
  }

  export type StudentFeeCreateOrConnectWithoutClientAdminInput = {
    where: StudentFeeWhereUniqueInput
    create: XOR<StudentFeeCreateWithoutClientAdminInput, StudentFeeUncheckedCreateWithoutClientAdminInput>
  }

  export type StudentFeeCreateManyClientAdminInputEnvelope = {
    data: StudentFeeCreateManyClientAdminInput | StudentFeeCreateManyClientAdminInput[]
    skipDuplicates?: boolean
  }

  export type StationeryIssueCreateWithoutClientAdminInput = {
    issueDate: Date | string
    quantity: number
    remarks?: string | null
    student: StudentCreateNestedOneWithoutStationeryInput
    course: CourseCreateNestedOneWithoutStationeryInput
    item: StationeryItemCreateNestedOneWithoutStationeryIssuesInput
  }

  export type StationeryIssueUncheckedCreateWithoutClientAdminInput = {
    id?: number
    studentId: number
    courseId: number
    itemId: number
    issueDate: Date | string
    quantity: number
    remarks?: string | null
  }

  export type StationeryIssueCreateOrConnectWithoutClientAdminInput = {
    where: StationeryIssueWhereUniqueInput
    create: XOR<StationeryIssueCreateWithoutClientAdminInput, StationeryIssueUncheckedCreateWithoutClientAdminInput>
  }

  export type StationeryIssueCreateManyClientAdminInputEnvelope = {
    data: StationeryIssueCreateManyClientAdminInput | StationeryIssueCreateManyClientAdminInput[]
    skipDuplicates?: boolean
  }

  export type AttendanceRecordCreateWithoutClientAdminInput = {
    date: Date | string
    present: boolean
    batchId?: number | null
    student: StudentCreateNestedOneWithoutAttendanceInput
    course: CourseCreateNestedOneWithoutAttendanceRecordsInput
    markedBy: FacultyCreateNestedOneWithoutAttendanceInput
  }

  export type AttendanceRecordUncheckedCreateWithoutClientAdminInput = {
    id?: number
    studentId: number
    courseId: number
    date: Date | string
    present: boolean
    facultyId: number
    batchId?: number | null
  }

  export type AttendanceRecordCreateOrConnectWithoutClientAdminInput = {
    where: AttendanceRecordWhereUniqueInput
    create: XOR<AttendanceRecordCreateWithoutClientAdminInput, AttendanceRecordUncheckedCreateWithoutClientAdminInput>
  }

  export type AttendanceRecordCreateManyClientAdminInputEnvelope = {
    data: AttendanceRecordCreateManyClientAdminInput | AttendanceRecordCreateManyClientAdminInput[]
    skipDuplicates?: boolean
  }

  export type StudentTaskCreateWithoutClientAdminInput = {
    assignedDate: Date | string
    dueDate: Date | string
    description: string
    status: string
    facultyRemarks?: string | null
    grade?: string | null
    student: StudentCreateNestedOneWithoutTasksInput
    course: CourseCreateNestedOneWithoutStudentTasksInput
    faculty?: FacultyCreateNestedOneWithoutTasksInput
  }

  export type StudentTaskUncheckedCreateWithoutClientAdminInput = {
    id?: number
    studentId: number
    courseId: number
    assignedDate: Date | string
    dueDate: Date | string
    description: string
    status: string
    facultyRemarks?: string | null
    grade?: string | null
    facultyId?: number | null
  }

  export type StudentTaskCreateOrConnectWithoutClientAdminInput = {
    where: StudentTaskWhereUniqueInput
    create: XOR<StudentTaskCreateWithoutClientAdminInput, StudentTaskUncheckedCreateWithoutClientAdminInput>
  }

  export type StudentTaskCreateManyClientAdminInputEnvelope = {
    data: StudentTaskCreateManyClientAdminInput | StudentTaskCreateManyClientAdminInput[]
    skipDuplicates?: boolean
  }

  export type StudentTestCreateWithoutClientAdminInput = {
    testName: string
    testDate: Date | string
    totalMarks: number
    marksObtained: number
    grade: string
    student: StudentCreateNestedOneWithoutTestsInput
    course: CourseCreateNestedOneWithoutStudentTestsInput
  }

  export type StudentTestUncheckedCreateWithoutClientAdminInput = {
    id?: number
    studentId: number
    courseId: number
    testName: string
    testDate: Date | string
    totalMarks: number
    marksObtained: number
    grade: string
  }

  export type StudentTestCreateOrConnectWithoutClientAdminInput = {
    where: StudentTestWhereUniqueInput
    create: XOR<StudentTestCreateWithoutClientAdminInput, StudentTestUncheckedCreateWithoutClientAdminInput>
  }

  export type StudentTestCreateManyClientAdminInputEnvelope = {
    data: StudentTestCreateManyClientAdminInput | StudentTestCreateManyClientAdminInput[]
    skipDuplicates?: boolean
  }

  export type CourseCompletionCreateWithoutClientAdminInput = {
    completionDate: Date | string
    feedback?: string | null
    remarks?: string | null
    studentCourse: StudentCourseCreateNestedOneWithoutCompletionsInput
    student: StudentCreateNestedOneWithoutCompletionsInput
  }

  export type CourseCompletionUncheckedCreateWithoutClientAdminInput = {
    id?: number
    studentCourseId: number
    studentId: number
    completionDate: Date | string
    feedback?: string | null
    remarks?: string | null
  }

  export type CourseCompletionCreateOrConnectWithoutClientAdminInput = {
    where: CourseCompletionWhereUniqueInput
    create: XOR<CourseCompletionCreateWithoutClientAdminInput, CourseCompletionUncheckedCreateWithoutClientAdminInput>
  }

  export type CourseCompletionCreateManyClientAdminInputEnvelope = {
    data: CourseCompletionCreateManyClientAdminInput | CourseCompletionCreateManyClientAdminInput[]
    skipDuplicates?: boolean
  }

  export type CertificateCreateWithoutClientAdminInput = {
    issueDate: Date | string
    certificateUrl: string
    student: StudentCreateNestedOneWithoutCertificatesInput
    course: CourseCreateNestedOneWithoutCertificatesInput
    studentCourse: StudentCourseCreateNestedOneWithoutCertificateInput
  }

  export type CertificateUncheckedCreateWithoutClientAdminInput = {
    id?: number
    studentId: number
    courseId: number
    studentCourseId: number
    issueDate: Date | string
    certificateUrl: string
  }

  export type CertificateCreateOrConnectWithoutClientAdminInput = {
    where: CertificateWhereUniqueInput
    create: XOR<CertificateCreateWithoutClientAdminInput, CertificateUncheckedCreateWithoutClientAdminInput>
  }

  export type CertificateCreateManyClientAdminInputEnvelope = {
    data: CertificateCreateManyClientAdminInput | CertificateCreateManyClientAdminInput[]
    skipDuplicates?: boolean
  }

  export type FinancialRecordCreateWithoutClientAdminInput = {
    id?: string
    recordType: $Enums.RecordType
    amount: number
    description?: string | null
    date?: Date | string
    paymentMode?: $Enums.PaymentMode | null
    student?: StudentCreateNestedOneWithoutFinancialRecordsInput
    course?: CourseCreateNestedOneWithoutFinancialRecordsInput
    faculty?: FacultyCreateNestedOneWithoutFinancialRecordsInput
    lab?: LabCreateNestedOneWithoutFinancialRecordsInput
  }

  export type FinancialRecordUncheckedCreateWithoutClientAdminInput = {
    id?: string
    recordType: $Enums.RecordType
    amount: number
    description?: string | null
    date?: Date | string
    paymentMode?: $Enums.PaymentMode | null
    studentId?: number | null
    courseId?: number | null
    facultyId?: number | null
    labId?: number | null
  }

  export type FinancialRecordCreateOrConnectWithoutClientAdminInput = {
    where: FinancialRecordWhereUniqueInput
    create: XOR<FinancialRecordCreateWithoutClientAdminInput, FinancialRecordUncheckedCreateWithoutClientAdminInput>
  }

  export type FinancialRecordCreateManyClientAdminInputEnvelope = {
    data: FinancialRecordCreateManyClientAdminInput | FinancialRecordCreateManyClientAdminInput[]
    skipDuplicates?: boolean
  }

  export type EnquiryCreateWithoutClientAdminInput = {
    id?: string
    name: string
    contact: string
    email?: string | null
    course?: string | null
    source?: string | null
    leadStatus?: $Enums.LeadStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    isConverted?: boolean
    followUps?: FollowUpCreateNestedManyWithoutEnquiryInput
    student?: StudentCreateNestedOneWithoutEnquiryInput
    enquiryCourse?: EnquiryCourseCreateNestedManyWithoutEnquiryInput
    notification?: NotificationCreateNestedOneWithoutEnquiryInput
  }

  export type EnquiryUncheckedCreateWithoutClientAdminInput = {
    id?: string
    name: string
    contact: string
    email?: string | null
    course?: string | null
    source?: string | null
    leadStatus?: $Enums.LeadStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    isConverted?: boolean
    studentId?: number | null
    followUps?: FollowUpUncheckedCreateNestedManyWithoutEnquiryInput
    enquiryCourse?: EnquiryCourseUncheckedCreateNestedManyWithoutEnquiryInput
    notification?: NotificationUncheckedCreateNestedOneWithoutEnquiryInput
  }

  export type EnquiryCreateOrConnectWithoutClientAdminInput = {
    where: EnquiryWhereUniqueInput
    create: XOR<EnquiryCreateWithoutClientAdminInput, EnquiryUncheckedCreateWithoutClientAdminInput>
  }

  export type EnquiryCreateManyClientAdminInputEnvelope = {
    data: EnquiryCreateManyClientAdminInput | EnquiryCreateManyClientAdminInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutClientAdminInput = {
    id?: string
    message: string
    seen?: boolean
    createdAt?: Date | string
    followUp?: FollowUpCreateNestedOneWithoutNotificationInput
    enquiry?: EnquiryCreateNestedOneWithoutNotificationInput
    payment?: StudentFeeCreateNestedOneWithoutNotificationInput
  }

  export type NotificationUncheckedCreateWithoutClientAdminInput = {
    id?: string
    message: string
    seen?: boolean
    createdAt?: Date | string
    followUpId?: string | null
    enquiryId?: string | null
    paymentId?: number | null
  }

  export type NotificationCreateOrConnectWithoutClientAdminInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutClientAdminInput, NotificationUncheckedCreateWithoutClientAdminInput>
  }

  export type NotificationCreateManyClientAdminInputEnvelope = {
    data: NotificationCreateManyClientAdminInput | NotificationCreateManyClientAdminInput[]
    skipDuplicates?: boolean
  }

  export type CourseFeeStructureCreateWithoutClientAdminInput = {
    totalAmount: number
    paymentType?: CourseFeeStructureCreatepaymentTypeInput | string[]
    course: CourseCreateNestedOneWithoutCourseFeeStructureInput
    installments?: InstallmentDetailCreateNestedManyWithoutCourseFeeStructureInput
  }

  export type CourseFeeStructureUncheckedCreateWithoutClientAdminInput = {
    id?: number
    courseId: number
    totalAmount: number
    paymentType?: CourseFeeStructureCreatepaymentTypeInput | string[]
    installments?: InstallmentDetailUncheckedCreateNestedManyWithoutCourseFeeStructureInput
  }

  export type CourseFeeStructureCreateOrConnectWithoutClientAdminInput = {
    where: CourseFeeStructureWhereUniqueInput
    create: XOR<CourseFeeStructureCreateWithoutClientAdminInput, CourseFeeStructureUncheckedCreateWithoutClientAdminInput>
  }

  export type CourseFeeStructureCreateManyClientAdminInputEnvelope = {
    data: CourseFeeStructureCreateManyClientAdminInput | CourseFeeStructureCreateManyClientAdminInput[]
    skipDuplicates?: boolean
  }

  export type RoleUserUpsertWithWhereUniqueWithoutClientAdminInput = {
    where: RoleUserWhereUniqueInput
    update: XOR<RoleUserUpdateWithoutClientAdminInput, RoleUserUncheckedUpdateWithoutClientAdminInput>
    create: XOR<RoleUserCreateWithoutClientAdminInput, RoleUserUncheckedCreateWithoutClientAdminInput>
  }

  export type RoleUserUpdateWithWhereUniqueWithoutClientAdminInput = {
    where: RoleUserWhereUniqueInput
    data: XOR<RoleUserUpdateWithoutClientAdminInput, RoleUserUncheckedUpdateWithoutClientAdminInput>
  }

  export type RoleUserUpdateManyWithWhereWithoutClientAdminInput = {
    where: RoleUserScalarWhereInput
    data: XOR<RoleUserUpdateManyMutationInput, RoleUserUncheckedUpdateManyWithoutClientAdminInput>
  }

  export type RoleUserScalarWhereInput = {
    AND?: RoleUserScalarWhereInput | RoleUserScalarWhereInput[]
    OR?: RoleUserScalarWhereInput[]
    NOT?: RoleUserScalarWhereInput | RoleUserScalarWhereInput[]
    id?: StringFilter<"RoleUser"> | string
    name?: StringFilter<"RoleUser"> | string
    email?: StringFilter<"RoleUser"> | string
    password?: StringFilter<"RoleUser"> | string
    role?: EnumUserRoleFilter<"RoleUser"> | $Enums.UserRole
    createdAt?: DateTimeFilter<"RoleUser"> | Date | string
    country?: StringFilter<"RoleUser"> | string
    state?: StringFilter<"RoleUser"> | string
    city?: StringFilter<"RoleUser"> | string
    zipCode?: StringFilter<"RoleUser"> | string
    currentSessionToken?: StringNullableFilter<"RoleUser"> | string | null
    lastLoginAt?: DateTimeNullableFilter<"RoleUser"> | Date | string | null
    clientAdminId?: StringFilter<"RoleUser"> | string
  }

  export type FacultyUpsertWithWhereUniqueWithoutClientAdminInput = {
    where: FacultyWhereUniqueInput
    update: XOR<FacultyUpdateWithoutClientAdminInput, FacultyUncheckedUpdateWithoutClientAdminInput>
    create: XOR<FacultyCreateWithoutClientAdminInput, FacultyUncheckedCreateWithoutClientAdminInput>
  }

  export type FacultyUpdateWithWhereUniqueWithoutClientAdminInput = {
    where: FacultyWhereUniqueInput
    data: XOR<FacultyUpdateWithoutClientAdminInput, FacultyUncheckedUpdateWithoutClientAdminInput>
  }

  export type FacultyUpdateManyWithWhereWithoutClientAdminInput = {
    where: FacultyScalarWhereInput
    data: XOR<FacultyUpdateManyMutationInput, FacultyUncheckedUpdateManyWithoutClientAdminInput>
  }

  export type FacultyScalarWhereInput = {
    AND?: FacultyScalarWhereInput | FacultyScalarWhereInput[]
    OR?: FacultyScalarWhereInput[]
    NOT?: FacultyScalarWhereInput | FacultyScalarWhereInput[]
    id?: IntFilter<"Faculty"> | number
    name?: StringFilter<"Faculty"> | string
    email?: StringFilter<"Faculty"> | string
    password?: StringFilter<"Faculty"> | string
    contact?: StringFilter<"Faculty"> | string
    joiningDate?: DateTimeFilter<"Faculty"> | Date | string
    specialization?: StringNullableFilter<"Faculty"> | string | null
    role?: EnumUserRoleFilter<"Faculty"> | $Enums.UserRole
    country?: StringFilter<"Faculty"> | string
    state?: StringFilter<"Faculty"> | string
    city?: StringFilter<"Faculty"> | string
    zipCode?: StringFilter<"Faculty"> | string
    currentSessionToken?: StringNullableFilter<"Faculty"> | string | null
    lastLoginAt?: DateTimeNullableFilter<"Faculty"> | Date | string | null
    clientAdminId?: StringFilter<"Faculty"> | string
  }

  export type BatchUpsertWithWhereUniqueWithoutClientAdminInput = {
    where: BatchWhereUniqueInput
    update: XOR<BatchUpdateWithoutClientAdminInput, BatchUncheckedUpdateWithoutClientAdminInput>
    create: XOR<BatchCreateWithoutClientAdminInput, BatchUncheckedCreateWithoutClientAdminInput>
  }

  export type BatchUpdateWithWhereUniqueWithoutClientAdminInput = {
    where: BatchWhereUniqueInput
    data: XOR<BatchUpdateWithoutClientAdminInput, BatchUncheckedUpdateWithoutClientAdminInput>
  }

  export type BatchUpdateManyWithWhereWithoutClientAdminInput = {
    where: BatchScalarWhereInput
    data: XOR<BatchUpdateManyMutationInput, BatchUncheckedUpdateManyWithoutClientAdminInput>
  }

  export type BatchScalarWhereInput = {
    AND?: BatchScalarWhereInput | BatchScalarWhereInput[]
    OR?: BatchScalarWhereInput[]
    NOT?: BatchScalarWhereInput | BatchScalarWhereInput[]
    id?: IntFilter<"Batch"> | number
    name?: StringFilter<"Batch"> | string
    facultyId?: IntNullableFilter<"Batch"> | number | null
    labTimeSlotId?: IntFilter<"Batch"> | number
    clientAdminId?: StringFilter<"Batch"> | string
  }

  export type CourseUpsertWithWhereUniqueWithoutClientAdminInput = {
    where: CourseWhereUniqueInput
    update: XOR<CourseUpdateWithoutClientAdminInput, CourseUncheckedUpdateWithoutClientAdminInput>
    create: XOR<CourseCreateWithoutClientAdminInput, CourseUncheckedCreateWithoutClientAdminInput>
  }

  export type CourseUpdateWithWhereUniqueWithoutClientAdminInput = {
    where: CourseWhereUniqueInput
    data: XOR<CourseUpdateWithoutClientAdminInput, CourseUncheckedUpdateWithoutClientAdminInput>
  }

  export type CourseUpdateManyWithWhereWithoutClientAdminInput = {
    where: CourseScalarWhereInput
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyWithoutClientAdminInput>
  }

  export type CourseScalarWhereInput = {
    AND?: CourseScalarWhereInput | CourseScalarWhereInput[]
    OR?: CourseScalarWhereInput[]
    NOT?: CourseScalarWhereInput | CourseScalarWhereInput[]
    id?: IntFilter<"Course"> | number
    name?: StringFilter<"Course"> | string
    durationWeeks?: IntFilter<"Course"> | number
    description?: StringNullableFilter<"Course"> | string | null
    clientAdminId?: StringFilter<"Course"> | string
  }

  export type EnquiryCourseUpsertWithWhereUniqueWithoutClientAdminInput = {
    where: EnquiryCourseWhereUniqueInput
    update: XOR<EnquiryCourseUpdateWithoutClientAdminInput, EnquiryCourseUncheckedUpdateWithoutClientAdminInput>
    create: XOR<EnquiryCourseCreateWithoutClientAdminInput, EnquiryCourseUncheckedCreateWithoutClientAdminInput>
  }

  export type EnquiryCourseUpdateWithWhereUniqueWithoutClientAdminInput = {
    where: EnquiryCourseWhereUniqueInput
    data: XOR<EnquiryCourseUpdateWithoutClientAdminInput, EnquiryCourseUncheckedUpdateWithoutClientAdminInput>
  }

  export type EnquiryCourseUpdateManyWithWhereWithoutClientAdminInput = {
    where: EnquiryCourseScalarWhereInput
    data: XOR<EnquiryCourseUpdateManyMutationInput, EnquiryCourseUncheckedUpdateManyWithoutClientAdminInput>
  }

  export type EnquiryCourseScalarWhereInput = {
    AND?: EnquiryCourseScalarWhereInput | EnquiryCourseScalarWhereInput[]
    OR?: EnquiryCourseScalarWhereInput[]
    NOT?: EnquiryCourseScalarWhereInput | EnquiryCourseScalarWhereInput[]
    id?: IntFilter<"EnquiryCourse"> | number
    enquiryId?: StringFilter<"EnquiryCourse"> | string
    courseId?: IntFilter<"EnquiryCourse"> | number
    clientAdminId?: StringFilter<"EnquiryCourse"> | string
  }

  export type LabUpsertWithWhereUniqueWithoutClientAdminInput = {
    where: LabWhereUniqueInput
    update: XOR<LabUpdateWithoutClientAdminInput, LabUncheckedUpdateWithoutClientAdminInput>
    create: XOR<LabCreateWithoutClientAdminInput, LabUncheckedCreateWithoutClientAdminInput>
  }

  export type LabUpdateWithWhereUniqueWithoutClientAdminInput = {
    where: LabWhereUniqueInput
    data: XOR<LabUpdateWithoutClientAdminInput, LabUncheckedUpdateWithoutClientAdminInput>
  }

  export type LabUpdateManyWithWhereWithoutClientAdminInput = {
    where: LabScalarWhereInput
    data: XOR<LabUpdateManyMutationInput, LabUncheckedUpdateManyWithoutClientAdminInput>
  }

  export type LabScalarWhereInput = {
    AND?: LabScalarWhereInput | LabScalarWhereInput[]
    OR?: LabScalarWhereInput[]
    NOT?: LabScalarWhereInput | LabScalarWhereInput[]
    id?: IntFilter<"Lab"> | number
    name?: StringFilter<"Lab"> | string
    location?: StringNullableFilter<"Lab"> | string | null
    totalPCs?: IntFilter<"Lab"> | number
    isActive?: BoolFilter<"Lab"> | boolean
    clientAdminId?: StringFilter<"Lab"> | string
  }

  export type LabTimeSlotUpsertWithWhereUniqueWithoutClientAdminInput = {
    where: LabTimeSlotWhereUniqueInput
    update: XOR<LabTimeSlotUpdateWithoutClientAdminInput, LabTimeSlotUncheckedUpdateWithoutClientAdminInput>
    create: XOR<LabTimeSlotCreateWithoutClientAdminInput, LabTimeSlotUncheckedCreateWithoutClientAdminInput>
  }

  export type LabTimeSlotUpdateWithWhereUniqueWithoutClientAdminInput = {
    where: LabTimeSlotWhereUniqueInput
    data: XOR<LabTimeSlotUpdateWithoutClientAdminInput, LabTimeSlotUncheckedUpdateWithoutClientAdminInput>
  }

  export type LabTimeSlotUpdateManyWithWhereWithoutClientAdminInput = {
    where: LabTimeSlotScalarWhereInput
    data: XOR<LabTimeSlotUpdateManyMutationInput, LabTimeSlotUncheckedUpdateManyWithoutClientAdminInput>
  }

  export type LabTimeSlotScalarWhereInput = {
    AND?: LabTimeSlotScalarWhereInput | LabTimeSlotScalarWhereInput[]
    OR?: LabTimeSlotScalarWhereInput[]
    NOT?: LabTimeSlotScalarWhereInput | LabTimeSlotScalarWhereInput[]
    id?: IntFilter<"LabTimeSlot"> | number
    startTime?: StringFilter<"LabTimeSlot"> | string
    endTime?: StringFilter<"LabTimeSlot"> | string
    day?: StringFilter<"LabTimeSlot"> | string
    labId?: IntFilter<"LabTimeSlot"> | number
    availablePCs?: IntFilter<"LabTimeSlot"> | number
    clientAdminId?: StringFilter<"LabTimeSlot"> | string
  }

  export type LabAllocationUpsertWithWhereUniqueWithoutClientAdminInput = {
    where: LabAllocationWhereUniqueInput
    update: XOR<LabAllocationUpdateWithoutClientAdminInput, LabAllocationUncheckedUpdateWithoutClientAdminInput>
    create: XOR<LabAllocationCreateWithoutClientAdminInput, LabAllocationUncheckedCreateWithoutClientAdminInput>
  }

  export type LabAllocationUpdateWithWhereUniqueWithoutClientAdminInput = {
    where: LabAllocationWhereUniqueInput
    data: XOR<LabAllocationUpdateWithoutClientAdminInput, LabAllocationUncheckedUpdateWithoutClientAdminInput>
  }

  export type LabAllocationUpdateManyWithWhereWithoutClientAdminInput = {
    where: LabAllocationScalarWhereInput
    data: XOR<LabAllocationUpdateManyMutationInput, LabAllocationUncheckedUpdateManyWithoutClientAdminInput>
  }

  export type LabAllocationScalarWhereInput = {
    AND?: LabAllocationScalarWhereInput | LabAllocationScalarWhereInput[]
    OR?: LabAllocationScalarWhereInput[]
    NOT?: LabAllocationScalarWhereInput | LabAllocationScalarWhereInput[]
    id?: IntFilter<"LabAllocation"> | number
    labTimeSlotId?: IntFilter<"LabAllocation"> | number
    studentId?: IntFilter<"LabAllocation"> | number
    pcNumber?: IntFilter<"LabAllocation"> | number
    assignedAt?: DateTimeFilter<"LabAllocation"> | Date | string
    clientAdminId?: StringFilter<"LabAllocation"> | string
  }

  export type StudentUpsertWithWhereUniqueWithoutClientAdminInput = {
    where: StudentWhereUniqueInput
    update: XOR<StudentUpdateWithoutClientAdminInput, StudentUncheckedUpdateWithoutClientAdminInput>
    create: XOR<StudentCreateWithoutClientAdminInput, StudentUncheckedCreateWithoutClientAdminInput>
  }

  export type StudentUpdateWithWhereUniqueWithoutClientAdminInput = {
    where: StudentWhereUniqueInput
    data: XOR<StudentUpdateWithoutClientAdminInput, StudentUncheckedUpdateWithoutClientAdminInput>
  }

  export type StudentUpdateManyWithWhereWithoutClientAdminInput = {
    where: StudentScalarWhereInput
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyWithoutClientAdminInput>
  }

  export type StudentScalarWhereInput = {
    AND?: StudentScalarWhereInput | StudentScalarWhereInput[]
    OR?: StudentScalarWhereInput[]
    NOT?: StudentScalarWhereInput | StudentScalarWhereInput[]
    id?: IntFilter<"Student"> | number
    serialNumber?: IntFilter<"Student"> | number
    studentCode?: StringFilter<"Student"> | string
    fullName?: StringFilter<"Student"> | string
    fatherName?: StringFilter<"Student"> | string
    motherName?: StringFilter<"Student"> | string
    photoUrl?: StringNullableFilter<"Student"> | string | null
    contact?: StringFilter<"Student"> | string
    parentsContact?: StringFilter<"Student"> | string
    email?: StringNullableFilter<"Student"> | string | null
    residentialAddress?: StringNullableFilter<"Student"> | string | null
    permenantAddress?: StringNullableFilter<"Student"> | string | null
    dob?: StringFilter<"Student"> | string
    gender?: StringFilter<"Student"> | string
    religion?: StringNullableFilter<"Student"> | string | null
    idProofType?: StringNullableFilter<"Student"> | string | null
    idProofNumber?: StringNullableFilter<"Student"> | string | null
    admissionDate?: DateTimeFilter<"Student"> | Date | string
    clientAdminId?: StringFilter<"Student"> | string
  }

  export type ActivityLogUpsertWithWhereUniqueWithoutClientAdminInput = {
    where: ActivityLogWhereUniqueInput
    update: XOR<ActivityLogUpdateWithoutClientAdminInput, ActivityLogUncheckedUpdateWithoutClientAdminInput>
    create: XOR<ActivityLogCreateWithoutClientAdminInput, ActivityLogUncheckedCreateWithoutClientAdminInput>
  }

  export type ActivityLogUpdateWithWhereUniqueWithoutClientAdminInput = {
    where: ActivityLogWhereUniqueInput
    data: XOR<ActivityLogUpdateWithoutClientAdminInput, ActivityLogUncheckedUpdateWithoutClientAdminInput>
  }

  export type ActivityLogUpdateManyWithWhereWithoutClientAdminInput = {
    where: ActivityLogScalarWhereInput
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyWithoutClientAdminInput>
  }

  export type ActivityLogScalarWhereInput = {
    AND?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
    OR?: ActivityLogScalarWhereInput[]
    NOT?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
    id?: StringFilter<"ActivityLog"> | string
    entity?: StringFilter<"ActivityLog"> | string
    entityId?: StringFilter<"ActivityLog"> | string
    action?: StringFilter<"ActivityLog"> | string
    message?: StringNullableFilter<"ActivityLog"> | string | null
    createdAt?: DateTimeFilter<"ActivityLog"> | Date | string
    clientAdminId?: StringFilter<"ActivityLog"> | string
  }

  export type StudentCourseUpsertWithWhereUniqueWithoutClientAdminInput = {
    where: StudentCourseWhereUniqueInput
    update: XOR<StudentCourseUpdateWithoutClientAdminInput, StudentCourseUncheckedUpdateWithoutClientAdminInput>
    create: XOR<StudentCourseCreateWithoutClientAdminInput, StudentCourseUncheckedCreateWithoutClientAdminInput>
  }

  export type StudentCourseUpdateWithWhereUniqueWithoutClientAdminInput = {
    where: StudentCourseWhereUniqueInput
    data: XOR<StudentCourseUpdateWithoutClientAdminInput, StudentCourseUncheckedUpdateWithoutClientAdminInput>
  }

  export type StudentCourseUpdateManyWithWhereWithoutClientAdminInput = {
    where: StudentCourseScalarWhereInput
    data: XOR<StudentCourseUpdateManyMutationInput, StudentCourseUncheckedUpdateManyWithoutClientAdminInput>
  }

  export type StudentCourseScalarWhereInput = {
    AND?: StudentCourseScalarWhereInput | StudentCourseScalarWhereInput[]
    OR?: StudentCourseScalarWhereInput[]
    NOT?: StudentCourseScalarWhereInput | StudentCourseScalarWhereInput[]
    id?: IntFilter<"StudentCourse"> | number
    studentId?: IntFilter<"StudentCourse"> | number
    courseId?: IntFilter<"StudentCourse"> | number
    startDate?: DateTimeFilter<"StudentCourse"> | Date | string
    endDate?: DateTimeFilter<"StudentCourse"> | Date | string
    studentCode?: StringFilter<"StudentCourse"> | string
    batchId?: IntNullableFilter<"StudentCourse"> | number | null
    internalNotes?: StringNullableFilter<"StudentCourse"> | string | null
    status?: StringFilter<"StudentCourse"> | string
    clientAdminId?: StringFilter<"StudentCourse"> | string
  }

  export type FeeStructureUpsertWithWhereUniqueWithoutClientAdminInput = {
    where: FeeStructureWhereUniqueInput
    update: XOR<FeeStructureUpdateWithoutClientAdminInput, FeeStructureUncheckedUpdateWithoutClientAdminInput>
    create: XOR<FeeStructureCreateWithoutClientAdminInput, FeeStructureUncheckedCreateWithoutClientAdminInput>
  }

  export type FeeStructureUpdateWithWhereUniqueWithoutClientAdminInput = {
    where: FeeStructureWhereUniqueInput
    data: XOR<FeeStructureUpdateWithoutClientAdminInput, FeeStructureUncheckedUpdateWithoutClientAdminInput>
  }

  export type FeeStructureUpdateManyWithWhereWithoutClientAdminInput = {
    where: FeeStructureScalarWhereInput
    data: XOR<FeeStructureUpdateManyMutationInput, FeeStructureUncheckedUpdateManyWithoutClientAdminInput>
  }

  export type FeeStructureScalarWhereInput = {
    AND?: FeeStructureScalarWhereInput | FeeStructureScalarWhereInput[]
    OR?: FeeStructureScalarWhereInput[]
    NOT?: FeeStructureScalarWhereInput | FeeStructureScalarWhereInput[]
    id?: IntFilter<"FeeStructure"> | number
    studentId?: IntFilter<"FeeStructure"> | number
    courseId?: IntFilter<"FeeStructure"> | number
    totalAmount?: FloatFilter<"FeeStructure"> | number
    paymentType?: EnumPaymentTypeFilter<"FeeStructure"> | $Enums.PaymentType
    installmentCount?: IntNullableFilter<"FeeStructure"> | number | null
    installmentTypeId?: IntNullableFilter<"FeeStructure"> | number | null
    clientAdminId?: StringFilter<"FeeStructure"> | string
  }

  export type StudentFeeUpsertWithWhereUniqueWithoutClientAdminInput = {
    where: StudentFeeWhereUniqueInput
    update: XOR<StudentFeeUpdateWithoutClientAdminInput, StudentFeeUncheckedUpdateWithoutClientAdminInput>
    create: XOR<StudentFeeCreateWithoutClientAdminInput, StudentFeeUncheckedCreateWithoutClientAdminInput>
  }

  export type StudentFeeUpdateWithWhereUniqueWithoutClientAdminInput = {
    where: StudentFeeWhereUniqueInput
    data: XOR<StudentFeeUpdateWithoutClientAdminInput, StudentFeeUncheckedUpdateWithoutClientAdminInput>
  }

  export type StudentFeeUpdateManyWithWhereWithoutClientAdminInput = {
    where: StudentFeeScalarWhereInput
    data: XOR<StudentFeeUpdateManyMutationInput, StudentFeeUncheckedUpdateManyWithoutClientAdminInput>
  }

  export type StudentFeeScalarWhereInput = {
    AND?: StudentFeeScalarWhereInput | StudentFeeScalarWhereInput[]
    OR?: StudentFeeScalarWhereInput[]
    NOT?: StudentFeeScalarWhereInput | StudentFeeScalarWhereInput[]
    id?: IntFilter<"StudentFee"> | number
    studentId?: IntFilter<"StudentFee"> | number
    courseId?: IntFilter<"StudentFee"> | number
    dueDate?: DateTimeFilter<"StudentFee"> | Date | string
    amountDue?: FloatFilter<"StudentFee"> | number
    amountPaid?: FloatFilter<"StudentFee"> | number
    paymentDate?: DateTimeNullableFilter<"StudentFee"> | Date | string | null
    paymentMode?: EnumPaymentModeFilter<"StudentFee"> | $Enums.PaymentMode
    receiptNo?: StringFilter<"StudentFee"> | string
    paymentStatus?: EnumPaymentStatusFilter<"StudentFee"> | $Enums.PaymentStatus
    clientAdminId?: StringFilter<"StudentFee"> | string
  }

  export type StationeryIssueUpsertWithWhereUniqueWithoutClientAdminInput = {
    where: StationeryIssueWhereUniqueInput
    update: XOR<StationeryIssueUpdateWithoutClientAdminInput, StationeryIssueUncheckedUpdateWithoutClientAdminInput>
    create: XOR<StationeryIssueCreateWithoutClientAdminInput, StationeryIssueUncheckedCreateWithoutClientAdminInput>
  }

  export type StationeryIssueUpdateWithWhereUniqueWithoutClientAdminInput = {
    where: StationeryIssueWhereUniqueInput
    data: XOR<StationeryIssueUpdateWithoutClientAdminInput, StationeryIssueUncheckedUpdateWithoutClientAdminInput>
  }

  export type StationeryIssueUpdateManyWithWhereWithoutClientAdminInput = {
    where: StationeryIssueScalarWhereInput
    data: XOR<StationeryIssueUpdateManyMutationInput, StationeryIssueUncheckedUpdateManyWithoutClientAdminInput>
  }

  export type StationeryIssueScalarWhereInput = {
    AND?: StationeryIssueScalarWhereInput | StationeryIssueScalarWhereInput[]
    OR?: StationeryIssueScalarWhereInput[]
    NOT?: StationeryIssueScalarWhereInput | StationeryIssueScalarWhereInput[]
    id?: IntFilter<"StationeryIssue"> | number
    studentId?: IntFilter<"StationeryIssue"> | number
    courseId?: IntFilter<"StationeryIssue"> | number
    itemId?: IntFilter<"StationeryIssue"> | number
    issueDate?: DateTimeFilter<"StationeryIssue"> | Date | string
    quantity?: IntFilter<"StationeryIssue"> | number
    remarks?: StringNullableFilter<"StationeryIssue"> | string | null
    clientAdminId?: StringFilter<"StationeryIssue"> | string
  }

  export type AttendanceRecordUpsertWithWhereUniqueWithoutClientAdminInput = {
    where: AttendanceRecordWhereUniqueInput
    update: XOR<AttendanceRecordUpdateWithoutClientAdminInput, AttendanceRecordUncheckedUpdateWithoutClientAdminInput>
    create: XOR<AttendanceRecordCreateWithoutClientAdminInput, AttendanceRecordUncheckedCreateWithoutClientAdminInput>
  }

  export type AttendanceRecordUpdateWithWhereUniqueWithoutClientAdminInput = {
    where: AttendanceRecordWhereUniqueInput
    data: XOR<AttendanceRecordUpdateWithoutClientAdminInput, AttendanceRecordUncheckedUpdateWithoutClientAdminInput>
  }

  export type AttendanceRecordUpdateManyWithWhereWithoutClientAdminInput = {
    where: AttendanceRecordScalarWhereInput
    data: XOR<AttendanceRecordUpdateManyMutationInput, AttendanceRecordUncheckedUpdateManyWithoutClientAdminInput>
  }

  export type AttendanceRecordScalarWhereInput = {
    AND?: AttendanceRecordScalarWhereInput | AttendanceRecordScalarWhereInput[]
    OR?: AttendanceRecordScalarWhereInput[]
    NOT?: AttendanceRecordScalarWhereInput | AttendanceRecordScalarWhereInput[]
    id?: IntFilter<"AttendanceRecord"> | number
    studentId?: IntFilter<"AttendanceRecord"> | number
    courseId?: IntFilter<"AttendanceRecord"> | number
    date?: DateTimeFilter<"AttendanceRecord"> | Date | string
    present?: BoolFilter<"AttendanceRecord"> | boolean
    facultyId?: IntFilter<"AttendanceRecord"> | number
    batchId?: IntNullableFilter<"AttendanceRecord"> | number | null
    clientAdminId?: StringFilter<"AttendanceRecord"> | string
  }

  export type StudentTaskUpsertWithWhereUniqueWithoutClientAdminInput = {
    where: StudentTaskWhereUniqueInput
    update: XOR<StudentTaskUpdateWithoutClientAdminInput, StudentTaskUncheckedUpdateWithoutClientAdminInput>
    create: XOR<StudentTaskCreateWithoutClientAdminInput, StudentTaskUncheckedCreateWithoutClientAdminInput>
  }

  export type StudentTaskUpdateWithWhereUniqueWithoutClientAdminInput = {
    where: StudentTaskWhereUniqueInput
    data: XOR<StudentTaskUpdateWithoutClientAdminInput, StudentTaskUncheckedUpdateWithoutClientAdminInput>
  }

  export type StudentTaskUpdateManyWithWhereWithoutClientAdminInput = {
    where: StudentTaskScalarWhereInput
    data: XOR<StudentTaskUpdateManyMutationInput, StudentTaskUncheckedUpdateManyWithoutClientAdminInput>
  }

  export type StudentTaskScalarWhereInput = {
    AND?: StudentTaskScalarWhereInput | StudentTaskScalarWhereInput[]
    OR?: StudentTaskScalarWhereInput[]
    NOT?: StudentTaskScalarWhereInput | StudentTaskScalarWhereInput[]
    id?: IntFilter<"StudentTask"> | number
    studentId?: IntFilter<"StudentTask"> | number
    courseId?: IntFilter<"StudentTask"> | number
    assignedDate?: DateTimeFilter<"StudentTask"> | Date | string
    dueDate?: DateTimeFilter<"StudentTask"> | Date | string
    description?: StringFilter<"StudentTask"> | string
    status?: StringFilter<"StudentTask"> | string
    facultyRemarks?: StringNullableFilter<"StudentTask"> | string | null
    grade?: StringNullableFilter<"StudentTask"> | string | null
    facultyId?: IntNullableFilter<"StudentTask"> | number | null
    clientAdminId?: StringFilter<"StudentTask"> | string
  }

  export type StudentTestUpsertWithWhereUniqueWithoutClientAdminInput = {
    where: StudentTestWhereUniqueInput
    update: XOR<StudentTestUpdateWithoutClientAdminInput, StudentTestUncheckedUpdateWithoutClientAdminInput>
    create: XOR<StudentTestCreateWithoutClientAdminInput, StudentTestUncheckedCreateWithoutClientAdminInput>
  }

  export type StudentTestUpdateWithWhereUniqueWithoutClientAdminInput = {
    where: StudentTestWhereUniqueInput
    data: XOR<StudentTestUpdateWithoutClientAdminInput, StudentTestUncheckedUpdateWithoutClientAdminInput>
  }

  export type StudentTestUpdateManyWithWhereWithoutClientAdminInput = {
    where: StudentTestScalarWhereInput
    data: XOR<StudentTestUpdateManyMutationInput, StudentTestUncheckedUpdateManyWithoutClientAdminInput>
  }

  export type StudentTestScalarWhereInput = {
    AND?: StudentTestScalarWhereInput | StudentTestScalarWhereInput[]
    OR?: StudentTestScalarWhereInput[]
    NOT?: StudentTestScalarWhereInput | StudentTestScalarWhereInput[]
    id?: IntFilter<"StudentTest"> | number
    studentId?: IntFilter<"StudentTest"> | number
    courseId?: IntFilter<"StudentTest"> | number
    testName?: StringFilter<"StudentTest"> | string
    testDate?: DateTimeFilter<"StudentTest"> | Date | string
    totalMarks?: IntFilter<"StudentTest"> | number
    marksObtained?: IntFilter<"StudentTest"> | number
    grade?: StringFilter<"StudentTest"> | string
    clientAdminId?: StringFilter<"StudentTest"> | string
  }

  export type CourseCompletionUpsertWithWhereUniqueWithoutClientAdminInput = {
    where: CourseCompletionWhereUniqueInput
    update: XOR<CourseCompletionUpdateWithoutClientAdminInput, CourseCompletionUncheckedUpdateWithoutClientAdminInput>
    create: XOR<CourseCompletionCreateWithoutClientAdminInput, CourseCompletionUncheckedCreateWithoutClientAdminInput>
  }

  export type CourseCompletionUpdateWithWhereUniqueWithoutClientAdminInput = {
    where: CourseCompletionWhereUniqueInput
    data: XOR<CourseCompletionUpdateWithoutClientAdminInput, CourseCompletionUncheckedUpdateWithoutClientAdminInput>
  }

  export type CourseCompletionUpdateManyWithWhereWithoutClientAdminInput = {
    where: CourseCompletionScalarWhereInput
    data: XOR<CourseCompletionUpdateManyMutationInput, CourseCompletionUncheckedUpdateManyWithoutClientAdminInput>
  }

  export type CourseCompletionScalarWhereInput = {
    AND?: CourseCompletionScalarWhereInput | CourseCompletionScalarWhereInput[]
    OR?: CourseCompletionScalarWhereInput[]
    NOT?: CourseCompletionScalarWhereInput | CourseCompletionScalarWhereInput[]
    id?: IntFilter<"CourseCompletion"> | number
    studentCourseId?: IntFilter<"CourseCompletion"> | number
    studentId?: IntFilter<"CourseCompletion"> | number
    completionDate?: DateTimeFilter<"CourseCompletion"> | Date | string
    feedback?: StringNullableFilter<"CourseCompletion"> | string | null
    remarks?: StringNullableFilter<"CourseCompletion"> | string | null
    clientAdminId?: StringFilter<"CourseCompletion"> | string
  }

  export type CertificateUpsertWithWhereUniqueWithoutClientAdminInput = {
    where: CertificateWhereUniqueInput
    update: XOR<CertificateUpdateWithoutClientAdminInput, CertificateUncheckedUpdateWithoutClientAdminInput>
    create: XOR<CertificateCreateWithoutClientAdminInput, CertificateUncheckedCreateWithoutClientAdminInput>
  }

  export type CertificateUpdateWithWhereUniqueWithoutClientAdminInput = {
    where: CertificateWhereUniqueInput
    data: XOR<CertificateUpdateWithoutClientAdminInput, CertificateUncheckedUpdateWithoutClientAdminInput>
  }

  export type CertificateUpdateManyWithWhereWithoutClientAdminInput = {
    where: CertificateScalarWhereInput
    data: XOR<CertificateUpdateManyMutationInput, CertificateUncheckedUpdateManyWithoutClientAdminInput>
  }

  export type CertificateScalarWhereInput = {
    AND?: CertificateScalarWhereInput | CertificateScalarWhereInput[]
    OR?: CertificateScalarWhereInput[]
    NOT?: CertificateScalarWhereInput | CertificateScalarWhereInput[]
    id?: IntFilter<"Certificate"> | number
    studentId?: IntFilter<"Certificate"> | number
    courseId?: IntFilter<"Certificate"> | number
    studentCourseId?: IntFilter<"Certificate"> | number
    issueDate?: DateTimeFilter<"Certificate"> | Date | string
    certificateUrl?: StringFilter<"Certificate"> | string
    clientAdminId?: StringFilter<"Certificate"> | string
  }

  export type FinancialRecordUpsertWithWhereUniqueWithoutClientAdminInput = {
    where: FinancialRecordWhereUniqueInput
    update: XOR<FinancialRecordUpdateWithoutClientAdminInput, FinancialRecordUncheckedUpdateWithoutClientAdminInput>
    create: XOR<FinancialRecordCreateWithoutClientAdminInput, FinancialRecordUncheckedCreateWithoutClientAdminInput>
  }

  export type FinancialRecordUpdateWithWhereUniqueWithoutClientAdminInput = {
    where: FinancialRecordWhereUniqueInput
    data: XOR<FinancialRecordUpdateWithoutClientAdminInput, FinancialRecordUncheckedUpdateWithoutClientAdminInput>
  }

  export type FinancialRecordUpdateManyWithWhereWithoutClientAdminInput = {
    where: FinancialRecordScalarWhereInput
    data: XOR<FinancialRecordUpdateManyMutationInput, FinancialRecordUncheckedUpdateManyWithoutClientAdminInput>
  }

  export type FinancialRecordScalarWhereInput = {
    AND?: FinancialRecordScalarWhereInput | FinancialRecordScalarWhereInput[]
    OR?: FinancialRecordScalarWhereInput[]
    NOT?: FinancialRecordScalarWhereInput | FinancialRecordScalarWhereInput[]
    id?: StringFilter<"FinancialRecord"> | string
    clientAdminId?: StringFilter<"FinancialRecord"> | string
    recordType?: EnumRecordTypeFilter<"FinancialRecord"> | $Enums.RecordType
    amount?: FloatFilter<"FinancialRecord"> | number
    description?: StringNullableFilter<"FinancialRecord"> | string | null
    date?: DateTimeFilter<"FinancialRecord"> | Date | string
    paymentMode?: EnumPaymentModeNullableFilter<"FinancialRecord"> | $Enums.PaymentMode | null
    studentId?: IntNullableFilter<"FinancialRecord"> | number | null
    courseId?: IntNullableFilter<"FinancialRecord"> | number | null
    facultyId?: IntNullableFilter<"FinancialRecord"> | number | null
    labId?: IntNullableFilter<"FinancialRecord"> | number | null
  }

  export type EnquiryUpsertWithWhereUniqueWithoutClientAdminInput = {
    where: EnquiryWhereUniqueInput
    update: XOR<EnquiryUpdateWithoutClientAdminInput, EnquiryUncheckedUpdateWithoutClientAdminInput>
    create: XOR<EnquiryCreateWithoutClientAdminInput, EnquiryUncheckedCreateWithoutClientAdminInput>
  }

  export type EnquiryUpdateWithWhereUniqueWithoutClientAdminInput = {
    where: EnquiryWhereUniqueInput
    data: XOR<EnquiryUpdateWithoutClientAdminInput, EnquiryUncheckedUpdateWithoutClientAdminInput>
  }

  export type EnquiryUpdateManyWithWhereWithoutClientAdminInput = {
    where: EnquiryScalarWhereInput
    data: XOR<EnquiryUpdateManyMutationInput, EnquiryUncheckedUpdateManyWithoutClientAdminInput>
  }

  export type EnquiryScalarWhereInput = {
    AND?: EnquiryScalarWhereInput | EnquiryScalarWhereInput[]
    OR?: EnquiryScalarWhereInput[]
    NOT?: EnquiryScalarWhereInput | EnquiryScalarWhereInput[]
    id?: StringFilter<"Enquiry"> | string
    name?: StringFilter<"Enquiry"> | string
    contact?: StringFilter<"Enquiry"> | string
    email?: StringNullableFilter<"Enquiry"> | string | null
    course?: StringNullableFilter<"Enquiry"> | string | null
    source?: StringNullableFilter<"Enquiry"> | string | null
    leadStatus?: EnumLeadStatusFilter<"Enquiry"> | $Enums.LeadStatus
    createdAt?: DateTimeFilter<"Enquiry"> | Date | string
    updatedAt?: DateTimeFilter<"Enquiry"> | Date | string
    isConverted?: BoolFilter<"Enquiry"> | boolean
    studentId?: IntNullableFilter<"Enquiry"> | number | null
    clientAdminId?: StringFilter<"Enquiry"> | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutClientAdminInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutClientAdminInput, NotificationUncheckedUpdateWithoutClientAdminInput>
    create: XOR<NotificationCreateWithoutClientAdminInput, NotificationUncheckedCreateWithoutClientAdminInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutClientAdminInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutClientAdminInput, NotificationUncheckedUpdateWithoutClientAdminInput>
  }

  export type NotificationUpdateManyWithWhereWithoutClientAdminInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutClientAdminInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    seen?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    followUpId?: StringNullableFilter<"Notification"> | string | null
    enquiryId?: StringNullableFilter<"Notification"> | string | null
    paymentId?: IntNullableFilter<"Notification"> | number | null
    clientAdminId?: StringFilter<"Notification"> | string
  }

  export type CourseFeeStructureUpsertWithWhereUniqueWithoutClientAdminInput = {
    where: CourseFeeStructureWhereUniqueInput
    update: XOR<CourseFeeStructureUpdateWithoutClientAdminInput, CourseFeeStructureUncheckedUpdateWithoutClientAdminInput>
    create: XOR<CourseFeeStructureCreateWithoutClientAdminInput, CourseFeeStructureUncheckedCreateWithoutClientAdminInput>
  }

  export type CourseFeeStructureUpdateWithWhereUniqueWithoutClientAdminInput = {
    where: CourseFeeStructureWhereUniqueInput
    data: XOR<CourseFeeStructureUpdateWithoutClientAdminInput, CourseFeeStructureUncheckedUpdateWithoutClientAdminInput>
  }

  export type CourseFeeStructureUpdateManyWithWhereWithoutClientAdminInput = {
    where: CourseFeeStructureScalarWhereInput
    data: XOR<CourseFeeStructureUpdateManyMutationInput, CourseFeeStructureUncheckedUpdateManyWithoutClientAdminInput>
  }

  export type CourseFeeStructureScalarWhereInput = {
    AND?: CourseFeeStructureScalarWhereInput | CourseFeeStructureScalarWhereInput[]
    OR?: CourseFeeStructureScalarWhereInput[]
    NOT?: CourseFeeStructureScalarWhereInput | CourseFeeStructureScalarWhereInput[]
    id?: IntFilter<"CourseFeeStructure"> | number
    courseId?: IntFilter<"CourseFeeStructure"> | number
    totalAmount?: FloatFilter<"CourseFeeStructure"> | number
    paymentType?: StringNullableListFilter<"CourseFeeStructure">
    clientAdminId?: StringFilter<"CourseFeeStructure"> | string
  }

  export type ClientAdminCreateWithoutRoleUsersInput = {
    id?: string
    name: string
    email: string
    password: string
    instituteName: string
    slug: string
    fullAddress: string
    logo?: string | null
    certificateName?: string | null
    stamp?: string | null
    sign?: string | null
    contact: string
    position: string
    country: string
    state: string
    city: string
    zipCode: string
    createdAt?: Date | string
    role?: $Enums.UserRole
    currentSessionToken?: string | null
    lastLoginAt?: Date | string | null
    faculties?: FacultyCreateNestedManyWithoutClientAdminInput
    batches?: BatchCreateNestedManyWithoutClientAdminInput
    courses?: CourseCreateNestedManyWithoutClientAdminInput
    enquiryCourse?: EnquiryCourseCreateNestedManyWithoutClientAdminInput
    labs?: LabCreateNestedManyWithoutClientAdminInput
    labTimeSlots?: LabTimeSlotCreateNestedManyWithoutClientAdminInput
    labAllocations?: LabAllocationCreateNestedManyWithoutClientAdminInput
    students?: StudentCreateNestedManyWithoutClientAdminInput
    activities?: ActivityLogCreateNestedManyWithoutClientAdminInput
    studentCourses?: StudentCourseCreateNestedManyWithoutClientAdminInput
    feeStructures?: FeeStructureCreateNestedManyWithoutClientAdminInput
    studentFees?: StudentFeeCreateNestedManyWithoutClientAdminInput
    stationeryIssues?: StationeryIssueCreateNestedManyWithoutClientAdminInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutClientAdminInput
    studentTasks?: StudentTaskCreateNestedManyWithoutClientAdminInput
    studentTests?: StudentTestCreateNestedManyWithoutClientAdminInput
    courseCompletions?: CourseCompletionCreateNestedManyWithoutClientAdminInput
    certificates?: CertificateCreateNestedManyWithoutClientAdminInput
    financialRecords?: FinancialRecordCreateNestedManyWithoutClientAdminInput
    enquiries?: EnquiryCreateNestedManyWithoutClientAdminInput
    notifications?: NotificationCreateNestedManyWithoutClientAdminInput
    courseFeeStructures?: CourseFeeStructureCreateNestedManyWithoutClientAdminInput
  }

  export type ClientAdminUncheckedCreateWithoutRoleUsersInput = {
    id?: string
    name: string
    email: string
    password: string
    instituteName: string
    slug: string
    fullAddress: string
    logo?: string | null
    certificateName?: string | null
    stamp?: string | null
    sign?: string | null
    contact: string
    position: string
    country: string
    state: string
    city: string
    zipCode: string
    createdAt?: Date | string
    role?: $Enums.UserRole
    currentSessionToken?: string | null
    lastLoginAt?: Date | string | null
    faculties?: FacultyUncheckedCreateNestedManyWithoutClientAdminInput
    batches?: BatchUncheckedCreateNestedManyWithoutClientAdminInput
    courses?: CourseUncheckedCreateNestedManyWithoutClientAdminInput
    enquiryCourse?: EnquiryCourseUncheckedCreateNestedManyWithoutClientAdminInput
    labs?: LabUncheckedCreateNestedManyWithoutClientAdminInput
    labTimeSlots?: LabTimeSlotUncheckedCreateNestedManyWithoutClientAdminInput
    labAllocations?: LabAllocationUncheckedCreateNestedManyWithoutClientAdminInput
    students?: StudentUncheckedCreateNestedManyWithoutClientAdminInput
    activities?: ActivityLogUncheckedCreateNestedManyWithoutClientAdminInput
    studentCourses?: StudentCourseUncheckedCreateNestedManyWithoutClientAdminInput
    feeStructures?: FeeStructureUncheckedCreateNestedManyWithoutClientAdminInput
    studentFees?: StudentFeeUncheckedCreateNestedManyWithoutClientAdminInput
    stationeryIssues?: StationeryIssueUncheckedCreateNestedManyWithoutClientAdminInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutClientAdminInput
    studentTasks?: StudentTaskUncheckedCreateNestedManyWithoutClientAdminInput
    studentTests?: StudentTestUncheckedCreateNestedManyWithoutClientAdminInput
    courseCompletions?: CourseCompletionUncheckedCreateNestedManyWithoutClientAdminInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutClientAdminInput
    financialRecords?: FinancialRecordUncheckedCreateNestedManyWithoutClientAdminInput
    enquiries?: EnquiryUncheckedCreateNestedManyWithoutClientAdminInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutClientAdminInput
    courseFeeStructures?: CourseFeeStructureUncheckedCreateNestedManyWithoutClientAdminInput
  }

  export type ClientAdminCreateOrConnectWithoutRoleUsersInput = {
    where: ClientAdminWhereUniqueInput
    create: XOR<ClientAdminCreateWithoutRoleUsersInput, ClientAdminUncheckedCreateWithoutRoleUsersInput>
  }

  export type ClientAdminUpsertWithoutRoleUsersInput = {
    update: XOR<ClientAdminUpdateWithoutRoleUsersInput, ClientAdminUncheckedUpdateWithoutRoleUsersInput>
    create: XOR<ClientAdminCreateWithoutRoleUsersInput, ClientAdminUncheckedCreateWithoutRoleUsersInput>
    where?: ClientAdminWhereInput
  }

  export type ClientAdminUpdateToOneWithWhereWithoutRoleUsersInput = {
    where?: ClientAdminWhereInput
    data: XOR<ClientAdminUpdateWithoutRoleUsersInput, ClientAdminUncheckedUpdateWithoutRoleUsersInput>
  }

  export type ClientAdminUpdateWithoutRoleUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    instituteName?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    fullAddress?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    certificateName?: NullableStringFieldUpdateOperationsInput | string | null
    stamp?: NullableStringFieldUpdateOperationsInput | string | null
    sign?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    currentSessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    faculties?: FacultyUpdateManyWithoutClientAdminNestedInput
    batches?: BatchUpdateManyWithoutClientAdminNestedInput
    courses?: CourseUpdateManyWithoutClientAdminNestedInput
    enquiryCourse?: EnquiryCourseUpdateManyWithoutClientAdminNestedInput
    labs?: LabUpdateManyWithoutClientAdminNestedInput
    labTimeSlots?: LabTimeSlotUpdateManyWithoutClientAdminNestedInput
    labAllocations?: LabAllocationUpdateManyWithoutClientAdminNestedInput
    students?: StudentUpdateManyWithoutClientAdminNestedInput
    activities?: ActivityLogUpdateManyWithoutClientAdminNestedInput
    studentCourses?: StudentCourseUpdateManyWithoutClientAdminNestedInput
    feeStructures?: FeeStructureUpdateManyWithoutClientAdminNestedInput
    studentFees?: StudentFeeUpdateManyWithoutClientAdminNestedInput
    stationeryIssues?: StationeryIssueUpdateManyWithoutClientAdminNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutClientAdminNestedInput
    studentTasks?: StudentTaskUpdateManyWithoutClientAdminNestedInput
    studentTests?: StudentTestUpdateManyWithoutClientAdminNestedInput
    courseCompletions?: CourseCompletionUpdateManyWithoutClientAdminNestedInput
    certificates?: CertificateUpdateManyWithoutClientAdminNestedInput
    financialRecords?: FinancialRecordUpdateManyWithoutClientAdminNestedInput
    enquiries?: EnquiryUpdateManyWithoutClientAdminNestedInput
    notifications?: NotificationUpdateManyWithoutClientAdminNestedInput
    courseFeeStructures?: CourseFeeStructureUpdateManyWithoutClientAdminNestedInput
  }

  export type ClientAdminUncheckedUpdateWithoutRoleUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    instituteName?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    fullAddress?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    certificateName?: NullableStringFieldUpdateOperationsInput | string | null
    stamp?: NullableStringFieldUpdateOperationsInput | string | null
    sign?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    currentSessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    faculties?: FacultyUncheckedUpdateManyWithoutClientAdminNestedInput
    batches?: BatchUncheckedUpdateManyWithoutClientAdminNestedInput
    courses?: CourseUncheckedUpdateManyWithoutClientAdminNestedInput
    enquiryCourse?: EnquiryCourseUncheckedUpdateManyWithoutClientAdminNestedInput
    labs?: LabUncheckedUpdateManyWithoutClientAdminNestedInput
    labTimeSlots?: LabTimeSlotUncheckedUpdateManyWithoutClientAdminNestedInput
    labAllocations?: LabAllocationUncheckedUpdateManyWithoutClientAdminNestedInput
    students?: StudentUncheckedUpdateManyWithoutClientAdminNestedInput
    activities?: ActivityLogUncheckedUpdateManyWithoutClientAdminNestedInput
    studentCourses?: StudentCourseUncheckedUpdateManyWithoutClientAdminNestedInput
    feeStructures?: FeeStructureUncheckedUpdateManyWithoutClientAdminNestedInput
    studentFees?: StudentFeeUncheckedUpdateManyWithoutClientAdminNestedInput
    stationeryIssues?: StationeryIssueUncheckedUpdateManyWithoutClientAdminNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutClientAdminNestedInput
    studentTasks?: StudentTaskUncheckedUpdateManyWithoutClientAdminNestedInput
    studentTests?: StudentTestUncheckedUpdateManyWithoutClientAdminNestedInput
    courseCompletions?: CourseCompletionUncheckedUpdateManyWithoutClientAdminNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutClientAdminNestedInput
    financialRecords?: FinancialRecordUncheckedUpdateManyWithoutClientAdminNestedInput
    enquiries?: EnquiryUncheckedUpdateManyWithoutClientAdminNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutClientAdminNestedInput
    courseFeeStructures?: CourseFeeStructureUncheckedUpdateManyWithoutClientAdminNestedInput
  }

  export type ClientAdminCreateWithoutActivitiesInput = {
    id?: string
    name: string
    email: string
    password: string
    instituteName: string
    slug: string
    fullAddress: string
    logo?: string | null
    certificateName?: string | null
    stamp?: string | null
    sign?: string | null
    contact: string
    position: string
    country: string
    state: string
    city: string
    zipCode: string
    createdAt?: Date | string
    role?: $Enums.UserRole
    currentSessionToken?: string | null
    lastLoginAt?: Date | string | null
    roleUsers?: RoleUserCreateNestedManyWithoutClientAdminInput
    faculties?: FacultyCreateNestedManyWithoutClientAdminInput
    batches?: BatchCreateNestedManyWithoutClientAdminInput
    courses?: CourseCreateNestedManyWithoutClientAdminInput
    enquiryCourse?: EnquiryCourseCreateNestedManyWithoutClientAdminInput
    labs?: LabCreateNestedManyWithoutClientAdminInput
    labTimeSlots?: LabTimeSlotCreateNestedManyWithoutClientAdminInput
    labAllocations?: LabAllocationCreateNestedManyWithoutClientAdminInput
    students?: StudentCreateNestedManyWithoutClientAdminInput
    studentCourses?: StudentCourseCreateNestedManyWithoutClientAdminInput
    feeStructures?: FeeStructureCreateNestedManyWithoutClientAdminInput
    studentFees?: StudentFeeCreateNestedManyWithoutClientAdminInput
    stationeryIssues?: StationeryIssueCreateNestedManyWithoutClientAdminInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutClientAdminInput
    studentTasks?: StudentTaskCreateNestedManyWithoutClientAdminInput
    studentTests?: StudentTestCreateNestedManyWithoutClientAdminInput
    courseCompletions?: CourseCompletionCreateNestedManyWithoutClientAdminInput
    certificates?: CertificateCreateNestedManyWithoutClientAdminInput
    financialRecords?: FinancialRecordCreateNestedManyWithoutClientAdminInput
    enquiries?: EnquiryCreateNestedManyWithoutClientAdminInput
    notifications?: NotificationCreateNestedManyWithoutClientAdminInput
    courseFeeStructures?: CourseFeeStructureCreateNestedManyWithoutClientAdminInput
  }

  export type ClientAdminUncheckedCreateWithoutActivitiesInput = {
    id?: string
    name: string
    email: string
    password: string
    instituteName: string
    slug: string
    fullAddress: string
    logo?: string | null
    certificateName?: string | null
    stamp?: string | null
    sign?: string | null
    contact: string
    position: string
    country: string
    state: string
    city: string
    zipCode: string
    createdAt?: Date | string
    role?: $Enums.UserRole
    currentSessionToken?: string | null
    lastLoginAt?: Date | string | null
    roleUsers?: RoleUserUncheckedCreateNestedManyWithoutClientAdminInput
    faculties?: FacultyUncheckedCreateNestedManyWithoutClientAdminInput
    batches?: BatchUncheckedCreateNestedManyWithoutClientAdminInput
    courses?: CourseUncheckedCreateNestedManyWithoutClientAdminInput
    enquiryCourse?: EnquiryCourseUncheckedCreateNestedManyWithoutClientAdminInput
    labs?: LabUncheckedCreateNestedManyWithoutClientAdminInput
    labTimeSlots?: LabTimeSlotUncheckedCreateNestedManyWithoutClientAdminInput
    labAllocations?: LabAllocationUncheckedCreateNestedManyWithoutClientAdminInput
    students?: StudentUncheckedCreateNestedManyWithoutClientAdminInput
    studentCourses?: StudentCourseUncheckedCreateNestedManyWithoutClientAdminInput
    feeStructures?: FeeStructureUncheckedCreateNestedManyWithoutClientAdminInput
    studentFees?: StudentFeeUncheckedCreateNestedManyWithoutClientAdminInput
    stationeryIssues?: StationeryIssueUncheckedCreateNestedManyWithoutClientAdminInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutClientAdminInput
    studentTasks?: StudentTaskUncheckedCreateNestedManyWithoutClientAdminInput
    studentTests?: StudentTestUncheckedCreateNestedManyWithoutClientAdminInput
    courseCompletions?: CourseCompletionUncheckedCreateNestedManyWithoutClientAdminInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutClientAdminInput
    financialRecords?: FinancialRecordUncheckedCreateNestedManyWithoutClientAdminInput
    enquiries?: EnquiryUncheckedCreateNestedManyWithoutClientAdminInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutClientAdminInput
    courseFeeStructures?: CourseFeeStructureUncheckedCreateNestedManyWithoutClientAdminInput
  }

  export type ClientAdminCreateOrConnectWithoutActivitiesInput = {
    where: ClientAdminWhereUniqueInput
    create: XOR<ClientAdminCreateWithoutActivitiesInput, ClientAdminUncheckedCreateWithoutActivitiesInput>
  }

  export type ClientAdminUpsertWithoutActivitiesInput = {
    update: XOR<ClientAdminUpdateWithoutActivitiesInput, ClientAdminUncheckedUpdateWithoutActivitiesInput>
    create: XOR<ClientAdminCreateWithoutActivitiesInput, ClientAdminUncheckedCreateWithoutActivitiesInput>
    where?: ClientAdminWhereInput
  }

  export type ClientAdminUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: ClientAdminWhereInput
    data: XOR<ClientAdminUpdateWithoutActivitiesInput, ClientAdminUncheckedUpdateWithoutActivitiesInput>
  }

  export type ClientAdminUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    instituteName?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    fullAddress?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    certificateName?: NullableStringFieldUpdateOperationsInput | string | null
    stamp?: NullableStringFieldUpdateOperationsInput | string | null
    sign?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    currentSessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleUsers?: RoleUserUpdateManyWithoutClientAdminNestedInput
    faculties?: FacultyUpdateManyWithoutClientAdminNestedInput
    batches?: BatchUpdateManyWithoutClientAdminNestedInput
    courses?: CourseUpdateManyWithoutClientAdminNestedInput
    enquiryCourse?: EnquiryCourseUpdateManyWithoutClientAdminNestedInput
    labs?: LabUpdateManyWithoutClientAdminNestedInput
    labTimeSlots?: LabTimeSlotUpdateManyWithoutClientAdminNestedInput
    labAllocations?: LabAllocationUpdateManyWithoutClientAdminNestedInput
    students?: StudentUpdateManyWithoutClientAdminNestedInput
    studentCourses?: StudentCourseUpdateManyWithoutClientAdminNestedInput
    feeStructures?: FeeStructureUpdateManyWithoutClientAdminNestedInput
    studentFees?: StudentFeeUpdateManyWithoutClientAdminNestedInput
    stationeryIssues?: StationeryIssueUpdateManyWithoutClientAdminNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutClientAdminNestedInput
    studentTasks?: StudentTaskUpdateManyWithoutClientAdminNestedInput
    studentTests?: StudentTestUpdateManyWithoutClientAdminNestedInput
    courseCompletions?: CourseCompletionUpdateManyWithoutClientAdminNestedInput
    certificates?: CertificateUpdateManyWithoutClientAdminNestedInput
    financialRecords?: FinancialRecordUpdateManyWithoutClientAdminNestedInput
    enquiries?: EnquiryUpdateManyWithoutClientAdminNestedInput
    notifications?: NotificationUpdateManyWithoutClientAdminNestedInput
    courseFeeStructures?: CourseFeeStructureUpdateManyWithoutClientAdminNestedInput
  }

  export type ClientAdminUncheckedUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    instituteName?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    fullAddress?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    certificateName?: NullableStringFieldUpdateOperationsInput | string | null
    stamp?: NullableStringFieldUpdateOperationsInput | string | null
    sign?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    currentSessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleUsers?: RoleUserUncheckedUpdateManyWithoutClientAdminNestedInput
    faculties?: FacultyUncheckedUpdateManyWithoutClientAdminNestedInput
    batches?: BatchUncheckedUpdateManyWithoutClientAdminNestedInput
    courses?: CourseUncheckedUpdateManyWithoutClientAdminNestedInput
    enquiryCourse?: EnquiryCourseUncheckedUpdateManyWithoutClientAdminNestedInput
    labs?: LabUncheckedUpdateManyWithoutClientAdminNestedInput
    labTimeSlots?: LabTimeSlotUncheckedUpdateManyWithoutClientAdminNestedInput
    labAllocations?: LabAllocationUncheckedUpdateManyWithoutClientAdminNestedInput
    students?: StudentUncheckedUpdateManyWithoutClientAdminNestedInput
    studentCourses?: StudentCourseUncheckedUpdateManyWithoutClientAdminNestedInput
    feeStructures?: FeeStructureUncheckedUpdateManyWithoutClientAdminNestedInput
    studentFees?: StudentFeeUncheckedUpdateManyWithoutClientAdminNestedInput
    stationeryIssues?: StationeryIssueUncheckedUpdateManyWithoutClientAdminNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutClientAdminNestedInput
    studentTasks?: StudentTaskUncheckedUpdateManyWithoutClientAdminNestedInput
    studentTests?: StudentTestUncheckedUpdateManyWithoutClientAdminNestedInput
    courseCompletions?: CourseCompletionUncheckedUpdateManyWithoutClientAdminNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutClientAdminNestedInput
    financialRecords?: FinancialRecordUncheckedUpdateManyWithoutClientAdminNestedInput
    enquiries?: EnquiryUncheckedUpdateManyWithoutClientAdminNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutClientAdminNestedInput
    courseFeeStructures?: CourseFeeStructureUncheckedUpdateManyWithoutClientAdminNestedInput
  }

  export type FollowUpCreateWithoutEnquiryInput = {
    id?: string
    scheduledAt?: Date | string | null
    doneAt?: Date | string | null
    remark: string
    createdAt?: Date | string
    followUpStatus?: $Enums.FollowUpStatus
    notification?: NotificationCreateNestedOneWithoutFollowUpInput
  }

  export type FollowUpUncheckedCreateWithoutEnquiryInput = {
    id?: string
    scheduledAt?: Date | string | null
    doneAt?: Date | string | null
    remark: string
    createdAt?: Date | string
    followUpStatus?: $Enums.FollowUpStatus
    notification?: NotificationUncheckedCreateNestedOneWithoutFollowUpInput
  }

  export type FollowUpCreateOrConnectWithoutEnquiryInput = {
    where: FollowUpWhereUniqueInput
    create: XOR<FollowUpCreateWithoutEnquiryInput, FollowUpUncheckedCreateWithoutEnquiryInput>
  }

  export type FollowUpCreateManyEnquiryInputEnvelope = {
    data: FollowUpCreateManyEnquiryInput | FollowUpCreateManyEnquiryInput[]
    skipDuplicates?: boolean
  }

  export type StudentCreateWithoutEnquiryInput = {
    serialNumber: number
    studentCode: string
    fullName: string
    fatherName: string
    motherName: string
    photoUrl?: string | null
    contact: string
    parentsContact: string
    email?: string | null
    residentialAddress?: string | null
    permenantAddress?: string | null
    dob: string
    gender: string
    religion?: string | null
    idProofType?: string | null
    idProofNumber?: string | null
    admissionDate: Date | string
    labAllocations?: LabAllocationCreateNestedManyWithoutStudentInput
    studentCourses?: StudentCourseCreateNestedManyWithoutStudentInput
    feeStructures?: FeeStructureCreateNestedManyWithoutStudentInput
    feeRecords?: StudentFeeCreateNestedManyWithoutStudentInput
    attendance?: AttendanceRecordCreateNestedManyWithoutStudentInput
    tasks?: StudentTaskCreateNestedManyWithoutStudentInput
    tests?: StudentTestCreateNestedManyWithoutStudentInput
    completions?: CourseCompletionCreateNestedManyWithoutStudentInput
    stationery?: StationeryIssueCreateNestedManyWithoutStudentInput
    certificates?: CertificateCreateNestedManyWithoutStudentInput
    financialRecords?: FinancialRecordCreateNestedManyWithoutStudentInput
    clientAdmin: ClientAdminCreateNestedOneWithoutStudentsInput
  }

  export type StudentUncheckedCreateWithoutEnquiryInput = {
    id?: number
    serialNumber: number
    studentCode: string
    fullName: string
    fatherName: string
    motherName: string
    photoUrl?: string | null
    contact: string
    parentsContact: string
    email?: string | null
    residentialAddress?: string | null
    permenantAddress?: string | null
    dob: string
    gender: string
    religion?: string | null
    idProofType?: string | null
    idProofNumber?: string | null
    admissionDate: Date | string
    clientAdminId: string
    labAllocations?: LabAllocationUncheckedCreateNestedManyWithoutStudentInput
    studentCourses?: StudentCourseUncheckedCreateNestedManyWithoutStudentInput
    feeStructures?: FeeStructureUncheckedCreateNestedManyWithoutStudentInput
    feeRecords?: StudentFeeUncheckedCreateNestedManyWithoutStudentInput
    attendance?: AttendanceRecordUncheckedCreateNestedManyWithoutStudentInput
    tasks?: StudentTaskUncheckedCreateNestedManyWithoutStudentInput
    tests?: StudentTestUncheckedCreateNestedManyWithoutStudentInput
    completions?: CourseCompletionUncheckedCreateNestedManyWithoutStudentInput
    stationery?: StationeryIssueUncheckedCreateNestedManyWithoutStudentInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutStudentInput
    financialRecords?: FinancialRecordUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutEnquiryInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutEnquiryInput, StudentUncheckedCreateWithoutEnquiryInput>
  }

  export type EnquiryCourseCreateWithoutEnquiryInput = {
    course: CourseCreateNestedOneWithoutEnquiryCourseInput
    clientAdmin: ClientAdminCreateNestedOneWithoutEnquiryCourseInput
  }

  export type EnquiryCourseUncheckedCreateWithoutEnquiryInput = {
    id?: number
    courseId: number
    clientAdminId: string
  }

  export type EnquiryCourseCreateOrConnectWithoutEnquiryInput = {
    where: EnquiryCourseWhereUniqueInput
    create: XOR<EnquiryCourseCreateWithoutEnquiryInput, EnquiryCourseUncheckedCreateWithoutEnquiryInput>
  }

  export type EnquiryCourseCreateManyEnquiryInputEnvelope = {
    data: EnquiryCourseCreateManyEnquiryInput | EnquiryCourseCreateManyEnquiryInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutEnquiryInput = {
    id?: string
    message: string
    seen?: boolean
    createdAt?: Date | string
    followUp?: FollowUpCreateNestedOneWithoutNotificationInput
    payment?: StudentFeeCreateNestedOneWithoutNotificationInput
    clientAdmin: ClientAdminCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutEnquiryInput = {
    id?: string
    message: string
    seen?: boolean
    createdAt?: Date | string
    followUpId?: string | null
    paymentId?: number | null
    clientAdminId: string
  }

  export type NotificationCreateOrConnectWithoutEnquiryInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutEnquiryInput, NotificationUncheckedCreateWithoutEnquiryInput>
  }

  export type ClientAdminCreateWithoutEnquiriesInput = {
    id?: string
    name: string
    email: string
    password: string
    instituteName: string
    slug: string
    fullAddress: string
    logo?: string | null
    certificateName?: string | null
    stamp?: string | null
    sign?: string | null
    contact: string
    position: string
    country: string
    state: string
    city: string
    zipCode: string
    createdAt?: Date | string
    role?: $Enums.UserRole
    currentSessionToken?: string | null
    lastLoginAt?: Date | string | null
    roleUsers?: RoleUserCreateNestedManyWithoutClientAdminInput
    faculties?: FacultyCreateNestedManyWithoutClientAdminInput
    batches?: BatchCreateNestedManyWithoutClientAdminInput
    courses?: CourseCreateNestedManyWithoutClientAdminInput
    enquiryCourse?: EnquiryCourseCreateNestedManyWithoutClientAdminInput
    labs?: LabCreateNestedManyWithoutClientAdminInput
    labTimeSlots?: LabTimeSlotCreateNestedManyWithoutClientAdminInput
    labAllocations?: LabAllocationCreateNestedManyWithoutClientAdminInput
    students?: StudentCreateNestedManyWithoutClientAdminInput
    activities?: ActivityLogCreateNestedManyWithoutClientAdminInput
    studentCourses?: StudentCourseCreateNestedManyWithoutClientAdminInput
    feeStructures?: FeeStructureCreateNestedManyWithoutClientAdminInput
    studentFees?: StudentFeeCreateNestedManyWithoutClientAdminInput
    stationeryIssues?: StationeryIssueCreateNestedManyWithoutClientAdminInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutClientAdminInput
    studentTasks?: StudentTaskCreateNestedManyWithoutClientAdminInput
    studentTests?: StudentTestCreateNestedManyWithoutClientAdminInput
    courseCompletions?: CourseCompletionCreateNestedManyWithoutClientAdminInput
    certificates?: CertificateCreateNestedManyWithoutClientAdminInput
    financialRecords?: FinancialRecordCreateNestedManyWithoutClientAdminInput
    notifications?: NotificationCreateNestedManyWithoutClientAdminInput
    courseFeeStructures?: CourseFeeStructureCreateNestedManyWithoutClientAdminInput
  }

  export type ClientAdminUncheckedCreateWithoutEnquiriesInput = {
    id?: string
    name: string
    email: string
    password: string
    instituteName: string
    slug: string
    fullAddress: string
    logo?: string | null
    certificateName?: string | null
    stamp?: string | null
    sign?: string | null
    contact: string
    position: string
    country: string
    state: string
    city: string
    zipCode: string
    createdAt?: Date | string
    role?: $Enums.UserRole
    currentSessionToken?: string | null
    lastLoginAt?: Date | string | null
    roleUsers?: RoleUserUncheckedCreateNestedManyWithoutClientAdminInput
    faculties?: FacultyUncheckedCreateNestedManyWithoutClientAdminInput
    batches?: BatchUncheckedCreateNestedManyWithoutClientAdminInput
    courses?: CourseUncheckedCreateNestedManyWithoutClientAdminInput
    enquiryCourse?: EnquiryCourseUncheckedCreateNestedManyWithoutClientAdminInput
    labs?: LabUncheckedCreateNestedManyWithoutClientAdminInput
    labTimeSlots?: LabTimeSlotUncheckedCreateNestedManyWithoutClientAdminInput
    labAllocations?: LabAllocationUncheckedCreateNestedManyWithoutClientAdminInput
    students?: StudentUncheckedCreateNestedManyWithoutClientAdminInput
    activities?: ActivityLogUncheckedCreateNestedManyWithoutClientAdminInput
    studentCourses?: StudentCourseUncheckedCreateNestedManyWithoutClientAdminInput
    feeStructures?: FeeStructureUncheckedCreateNestedManyWithoutClientAdminInput
    studentFees?: StudentFeeUncheckedCreateNestedManyWithoutClientAdminInput
    stationeryIssues?: StationeryIssueUncheckedCreateNestedManyWithoutClientAdminInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutClientAdminInput
    studentTasks?: StudentTaskUncheckedCreateNestedManyWithoutClientAdminInput
    studentTests?: StudentTestUncheckedCreateNestedManyWithoutClientAdminInput
    courseCompletions?: CourseCompletionUncheckedCreateNestedManyWithoutClientAdminInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutClientAdminInput
    financialRecords?: FinancialRecordUncheckedCreateNestedManyWithoutClientAdminInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutClientAdminInput
    courseFeeStructures?: CourseFeeStructureUncheckedCreateNestedManyWithoutClientAdminInput
  }

  export type ClientAdminCreateOrConnectWithoutEnquiriesInput = {
    where: ClientAdminWhereUniqueInput
    create: XOR<ClientAdminCreateWithoutEnquiriesInput, ClientAdminUncheckedCreateWithoutEnquiriesInput>
  }

  export type FollowUpUpsertWithWhereUniqueWithoutEnquiryInput = {
    where: FollowUpWhereUniqueInput
    update: XOR<FollowUpUpdateWithoutEnquiryInput, FollowUpUncheckedUpdateWithoutEnquiryInput>
    create: XOR<FollowUpCreateWithoutEnquiryInput, FollowUpUncheckedCreateWithoutEnquiryInput>
  }

  export type FollowUpUpdateWithWhereUniqueWithoutEnquiryInput = {
    where: FollowUpWhereUniqueInput
    data: XOR<FollowUpUpdateWithoutEnquiryInput, FollowUpUncheckedUpdateWithoutEnquiryInput>
  }

  export type FollowUpUpdateManyWithWhereWithoutEnquiryInput = {
    where: FollowUpScalarWhereInput
    data: XOR<FollowUpUpdateManyMutationInput, FollowUpUncheckedUpdateManyWithoutEnquiryInput>
  }

  export type FollowUpScalarWhereInput = {
    AND?: FollowUpScalarWhereInput | FollowUpScalarWhereInput[]
    OR?: FollowUpScalarWhereInput[]
    NOT?: FollowUpScalarWhereInput | FollowUpScalarWhereInput[]
    id?: StringFilter<"FollowUp"> | string
    enquiryId?: StringFilter<"FollowUp"> | string
    scheduledAt?: DateTimeNullableFilter<"FollowUp"> | Date | string | null
    doneAt?: DateTimeNullableFilter<"FollowUp"> | Date | string | null
    remark?: StringFilter<"FollowUp"> | string
    createdAt?: DateTimeFilter<"FollowUp"> | Date | string
    followUpStatus?: EnumFollowUpStatusFilter<"FollowUp"> | $Enums.FollowUpStatus
  }

  export type StudentUpsertWithoutEnquiryInput = {
    update: XOR<StudentUpdateWithoutEnquiryInput, StudentUncheckedUpdateWithoutEnquiryInput>
    create: XOR<StudentCreateWithoutEnquiryInput, StudentUncheckedCreateWithoutEnquiryInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutEnquiryInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutEnquiryInput, StudentUncheckedUpdateWithoutEnquiryInput>
  }

  export type StudentUpdateWithoutEnquiryInput = {
    serialNumber?: IntFieldUpdateOperationsInput | number
    studentCode?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    fatherName?: StringFieldUpdateOperationsInput | string
    motherName?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: StringFieldUpdateOperationsInput | string
    parentsContact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: NullableStringFieldUpdateOperationsInput | string | null
    permenantAddress?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    idProofType?: NullableStringFieldUpdateOperationsInput | string | null
    idProofNumber?: NullableStringFieldUpdateOperationsInput | string | null
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    labAllocations?: LabAllocationUpdateManyWithoutStudentNestedInput
    studentCourses?: StudentCourseUpdateManyWithoutStudentNestedInput
    feeStructures?: FeeStructureUpdateManyWithoutStudentNestedInput
    feeRecords?: StudentFeeUpdateManyWithoutStudentNestedInput
    attendance?: AttendanceRecordUpdateManyWithoutStudentNestedInput
    tasks?: StudentTaskUpdateManyWithoutStudentNestedInput
    tests?: StudentTestUpdateManyWithoutStudentNestedInput
    completions?: CourseCompletionUpdateManyWithoutStudentNestedInput
    stationery?: StationeryIssueUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUpdateManyWithoutStudentNestedInput
    financialRecords?: FinancialRecordUpdateManyWithoutStudentNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutStudentsNestedInput
  }

  export type StudentUncheckedUpdateWithoutEnquiryInput = {
    id?: IntFieldUpdateOperationsInput | number
    serialNumber?: IntFieldUpdateOperationsInput | number
    studentCode?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    fatherName?: StringFieldUpdateOperationsInput | string
    motherName?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: StringFieldUpdateOperationsInput | string
    parentsContact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: NullableStringFieldUpdateOperationsInput | string | null
    permenantAddress?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    idProofType?: NullableStringFieldUpdateOperationsInput | string | null
    idProofNumber?: NullableStringFieldUpdateOperationsInput | string | null
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    clientAdminId?: StringFieldUpdateOperationsInput | string
    labAllocations?: LabAllocationUncheckedUpdateManyWithoutStudentNestedInput
    studentCourses?: StudentCourseUncheckedUpdateManyWithoutStudentNestedInput
    feeStructures?: FeeStructureUncheckedUpdateManyWithoutStudentNestedInput
    feeRecords?: StudentFeeUncheckedUpdateManyWithoutStudentNestedInput
    attendance?: AttendanceRecordUncheckedUpdateManyWithoutStudentNestedInput
    tasks?: StudentTaskUncheckedUpdateManyWithoutStudentNestedInput
    tests?: StudentTestUncheckedUpdateManyWithoutStudentNestedInput
    completions?: CourseCompletionUncheckedUpdateManyWithoutStudentNestedInput
    stationery?: StationeryIssueUncheckedUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutStudentNestedInput
    financialRecords?: FinancialRecordUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type EnquiryCourseUpsertWithWhereUniqueWithoutEnquiryInput = {
    where: EnquiryCourseWhereUniqueInput
    update: XOR<EnquiryCourseUpdateWithoutEnquiryInput, EnquiryCourseUncheckedUpdateWithoutEnquiryInput>
    create: XOR<EnquiryCourseCreateWithoutEnquiryInput, EnquiryCourseUncheckedCreateWithoutEnquiryInput>
  }

  export type EnquiryCourseUpdateWithWhereUniqueWithoutEnquiryInput = {
    where: EnquiryCourseWhereUniqueInput
    data: XOR<EnquiryCourseUpdateWithoutEnquiryInput, EnquiryCourseUncheckedUpdateWithoutEnquiryInput>
  }

  export type EnquiryCourseUpdateManyWithWhereWithoutEnquiryInput = {
    where: EnquiryCourseScalarWhereInput
    data: XOR<EnquiryCourseUpdateManyMutationInput, EnquiryCourseUncheckedUpdateManyWithoutEnquiryInput>
  }

  export type NotificationUpsertWithoutEnquiryInput = {
    update: XOR<NotificationUpdateWithoutEnquiryInput, NotificationUncheckedUpdateWithoutEnquiryInput>
    create: XOR<NotificationCreateWithoutEnquiryInput, NotificationUncheckedCreateWithoutEnquiryInput>
    where?: NotificationWhereInput
  }

  export type NotificationUpdateToOneWithWhereWithoutEnquiryInput = {
    where?: NotificationWhereInput
    data: XOR<NotificationUpdateWithoutEnquiryInput, NotificationUncheckedUpdateWithoutEnquiryInput>
  }

  export type NotificationUpdateWithoutEnquiryInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    seen?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    followUp?: FollowUpUpdateOneWithoutNotificationNestedInput
    payment?: StudentFeeUpdateOneWithoutNotificationNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutEnquiryInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    seen?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    followUpId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableIntFieldUpdateOperationsInput | number | null
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type ClientAdminUpsertWithoutEnquiriesInput = {
    update: XOR<ClientAdminUpdateWithoutEnquiriesInput, ClientAdminUncheckedUpdateWithoutEnquiriesInput>
    create: XOR<ClientAdminCreateWithoutEnquiriesInput, ClientAdminUncheckedCreateWithoutEnquiriesInput>
    where?: ClientAdminWhereInput
  }

  export type ClientAdminUpdateToOneWithWhereWithoutEnquiriesInput = {
    where?: ClientAdminWhereInput
    data: XOR<ClientAdminUpdateWithoutEnquiriesInput, ClientAdminUncheckedUpdateWithoutEnquiriesInput>
  }

  export type ClientAdminUpdateWithoutEnquiriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    instituteName?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    fullAddress?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    certificateName?: NullableStringFieldUpdateOperationsInput | string | null
    stamp?: NullableStringFieldUpdateOperationsInput | string | null
    sign?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    currentSessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleUsers?: RoleUserUpdateManyWithoutClientAdminNestedInput
    faculties?: FacultyUpdateManyWithoutClientAdminNestedInput
    batches?: BatchUpdateManyWithoutClientAdminNestedInput
    courses?: CourseUpdateManyWithoutClientAdminNestedInput
    enquiryCourse?: EnquiryCourseUpdateManyWithoutClientAdminNestedInput
    labs?: LabUpdateManyWithoutClientAdminNestedInput
    labTimeSlots?: LabTimeSlotUpdateManyWithoutClientAdminNestedInput
    labAllocations?: LabAllocationUpdateManyWithoutClientAdminNestedInput
    students?: StudentUpdateManyWithoutClientAdminNestedInput
    activities?: ActivityLogUpdateManyWithoutClientAdminNestedInput
    studentCourses?: StudentCourseUpdateManyWithoutClientAdminNestedInput
    feeStructures?: FeeStructureUpdateManyWithoutClientAdminNestedInput
    studentFees?: StudentFeeUpdateManyWithoutClientAdminNestedInput
    stationeryIssues?: StationeryIssueUpdateManyWithoutClientAdminNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutClientAdminNestedInput
    studentTasks?: StudentTaskUpdateManyWithoutClientAdminNestedInput
    studentTests?: StudentTestUpdateManyWithoutClientAdminNestedInput
    courseCompletions?: CourseCompletionUpdateManyWithoutClientAdminNestedInput
    certificates?: CertificateUpdateManyWithoutClientAdminNestedInput
    financialRecords?: FinancialRecordUpdateManyWithoutClientAdminNestedInput
    notifications?: NotificationUpdateManyWithoutClientAdminNestedInput
    courseFeeStructures?: CourseFeeStructureUpdateManyWithoutClientAdminNestedInput
  }

  export type ClientAdminUncheckedUpdateWithoutEnquiriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    instituteName?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    fullAddress?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    certificateName?: NullableStringFieldUpdateOperationsInput | string | null
    stamp?: NullableStringFieldUpdateOperationsInput | string | null
    sign?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    currentSessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleUsers?: RoleUserUncheckedUpdateManyWithoutClientAdminNestedInput
    faculties?: FacultyUncheckedUpdateManyWithoutClientAdminNestedInput
    batches?: BatchUncheckedUpdateManyWithoutClientAdminNestedInput
    courses?: CourseUncheckedUpdateManyWithoutClientAdminNestedInput
    enquiryCourse?: EnquiryCourseUncheckedUpdateManyWithoutClientAdminNestedInput
    labs?: LabUncheckedUpdateManyWithoutClientAdminNestedInput
    labTimeSlots?: LabTimeSlotUncheckedUpdateManyWithoutClientAdminNestedInput
    labAllocations?: LabAllocationUncheckedUpdateManyWithoutClientAdminNestedInput
    students?: StudentUncheckedUpdateManyWithoutClientAdminNestedInput
    activities?: ActivityLogUncheckedUpdateManyWithoutClientAdminNestedInput
    studentCourses?: StudentCourseUncheckedUpdateManyWithoutClientAdminNestedInput
    feeStructures?: FeeStructureUncheckedUpdateManyWithoutClientAdminNestedInput
    studentFees?: StudentFeeUncheckedUpdateManyWithoutClientAdminNestedInput
    stationeryIssues?: StationeryIssueUncheckedUpdateManyWithoutClientAdminNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutClientAdminNestedInput
    studentTasks?: StudentTaskUncheckedUpdateManyWithoutClientAdminNestedInput
    studentTests?: StudentTestUncheckedUpdateManyWithoutClientAdminNestedInput
    courseCompletions?: CourseCompletionUncheckedUpdateManyWithoutClientAdminNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutClientAdminNestedInput
    financialRecords?: FinancialRecordUncheckedUpdateManyWithoutClientAdminNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutClientAdminNestedInput
    courseFeeStructures?: CourseFeeStructureUncheckedUpdateManyWithoutClientAdminNestedInput
  }

  export type EnquiryCreateWithoutEnquiryCourseInput = {
    id?: string
    name: string
    contact: string
    email?: string | null
    course?: string | null
    source?: string | null
    leadStatus?: $Enums.LeadStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    isConverted?: boolean
    followUps?: FollowUpCreateNestedManyWithoutEnquiryInput
    student?: StudentCreateNestedOneWithoutEnquiryInput
    notification?: NotificationCreateNestedOneWithoutEnquiryInput
    clientAdmin: ClientAdminCreateNestedOneWithoutEnquiriesInput
  }

  export type EnquiryUncheckedCreateWithoutEnquiryCourseInput = {
    id?: string
    name: string
    contact: string
    email?: string | null
    course?: string | null
    source?: string | null
    leadStatus?: $Enums.LeadStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    isConverted?: boolean
    studentId?: number | null
    clientAdminId: string
    followUps?: FollowUpUncheckedCreateNestedManyWithoutEnquiryInput
    notification?: NotificationUncheckedCreateNestedOneWithoutEnquiryInput
  }

  export type EnquiryCreateOrConnectWithoutEnquiryCourseInput = {
    where: EnquiryWhereUniqueInput
    create: XOR<EnquiryCreateWithoutEnquiryCourseInput, EnquiryUncheckedCreateWithoutEnquiryCourseInput>
  }

  export type CourseCreateWithoutEnquiryCourseInput = {
    name: string
    durationWeeks: number
    description?: string | null
    courseFeeStructure?: CourseFeeStructureCreateNestedOneWithoutCourseInput
    studentCourses?: StudentCourseCreateNestedManyWithoutCourseInput
    feeStructures?: FeeStructureCreateNestedManyWithoutCourseInput
    stationery?: StationeryIssueCreateNestedManyWithoutCourseInput
    studentFees?: StudentFeeCreateNestedManyWithoutCourseInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutCourseInput
    studentTasks?: StudentTaskCreateNestedManyWithoutCourseInput
    studentTests?: StudentTestCreateNestedManyWithoutCourseInput
    certificates?: CertificateCreateNestedManyWithoutCourseInput
    financialRecords?: FinancialRecordCreateNestedManyWithoutCourseInput
    batchCourses?: BatchCourseCreateNestedManyWithoutCourseInput
    clientAdmin: ClientAdminCreateNestedOneWithoutCoursesInput
  }

  export type CourseUncheckedCreateWithoutEnquiryCourseInput = {
    id?: number
    name: string
    durationWeeks: number
    description?: string | null
    clientAdminId: string
    courseFeeStructure?: CourseFeeStructureUncheckedCreateNestedOneWithoutCourseInput
    studentCourses?: StudentCourseUncheckedCreateNestedManyWithoutCourseInput
    feeStructures?: FeeStructureUncheckedCreateNestedManyWithoutCourseInput
    stationery?: StationeryIssueUncheckedCreateNestedManyWithoutCourseInput
    studentFees?: StudentFeeUncheckedCreateNestedManyWithoutCourseInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutCourseInput
    studentTasks?: StudentTaskUncheckedCreateNestedManyWithoutCourseInput
    studentTests?: StudentTestUncheckedCreateNestedManyWithoutCourseInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutCourseInput
    financialRecords?: FinancialRecordUncheckedCreateNestedManyWithoutCourseInput
    batchCourses?: BatchCourseUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutEnquiryCourseInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutEnquiryCourseInput, CourseUncheckedCreateWithoutEnquiryCourseInput>
  }

  export type ClientAdminCreateWithoutEnquiryCourseInput = {
    id?: string
    name: string
    email: string
    password: string
    instituteName: string
    slug: string
    fullAddress: string
    logo?: string | null
    certificateName?: string | null
    stamp?: string | null
    sign?: string | null
    contact: string
    position: string
    country: string
    state: string
    city: string
    zipCode: string
    createdAt?: Date | string
    role?: $Enums.UserRole
    currentSessionToken?: string | null
    lastLoginAt?: Date | string | null
    roleUsers?: RoleUserCreateNestedManyWithoutClientAdminInput
    faculties?: FacultyCreateNestedManyWithoutClientAdminInput
    batches?: BatchCreateNestedManyWithoutClientAdminInput
    courses?: CourseCreateNestedManyWithoutClientAdminInput
    labs?: LabCreateNestedManyWithoutClientAdminInput
    labTimeSlots?: LabTimeSlotCreateNestedManyWithoutClientAdminInput
    labAllocations?: LabAllocationCreateNestedManyWithoutClientAdminInput
    students?: StudentCreateNestedManyWithoutClientAdminInput
    activities?: ActivityLogCreateNestedManyWithoutClientAdminInput
    studentCourses?: StudentCourseCreateNestedManyWithoutClientAdminInput
    feeStructures?: FeeStructureCreateNestedManyWithoutClientAdminInput
    studentFees?: StudentFeeCreateNestedManyWithoutClientAdminInput
    stationeryIssues?: StationeryIssueCreateNestedManyWithoutClientAdminInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutClientAdminInput
    studentTasks?: StudentTaskCreateNestedManyWithoutClientAdminInput
    studentTests?: StudentTestCreateNestedManyWithoutClientAdminInput
    courseCompletions?: CourseCompletionCreateNestedManyWithoutClientAdminInput
    certificates?: CertificateCreateNestedManyWithoutClientAdminInput
    financialRecords?: FinancialRecordCreateNestedManyWithoutClientAdminInput
    enquiries?: EnquiryCreateNestedManyWithoutClientAdminInput
    notifications?: NotificationCreateNestedManyWithoutClientAdminInput
    courseFeeStructures?: CourseFeeStructureCreateNestedManyWithoutClientAdminInput
  }

  export type ClientAdminUncheckedCreateWithoutEnquiryCourseInput = {
    id?: string
    name: string
    email: string
    password: string
    instituteName: string
    slug: string
    fullAddress: string
    logo?: string | null
    certificateName?: string | null
    stamp?: string | null
    sign?: string | null
    contact: string
    position: string
    country: string
    state: string
    city: string
    zipCode: string
    createdAt?: Date | string
    role?: $Enums.UserRole
    currentSessionToken?: string | null
    lastLoginAt?: Date | string | null
    roleUsers?: RoleUserUncheckedCreateNestedManyWithoutClientAdminInput
    faculties?: FacultyUncheckedCreateNestedManyWithoutClientAdminInput
    batches?: BatchUncheckedCreateNestedManyWithoutClientAdminInput
    courses?: CourseUncheckedCreateNestedManyWithoutClientAdminInput
    labs?: LabUncheckedCreateNestedManyWithoutClientAdminInput
    labTimeSlots?: LabTimeSlotUncheckedCreateNestedManyWithoutClientAdminInput
    labAllocations?: LabAllocationUncheckedCreateNestedManyWithoutClientAdminInput
    students?: StudentUncheckedCreateNestedManyWithoutClientAdminInput
    activities?: ActivityLogUncheckedCreateNestedManyWithoutClientAdminInput
    studentCourses?: StudentCourseUncheckedCreateNestedManyWithoutClientAdminInput
    feeStructures?: FeeStructureUncheckedCreateNestedManyWithoutClientAdminInput
    studentFees?: StudentFeeUncheckedCreateNestedManyWithoutClientAdminInput
    stationeryIssues?: StationeryIssueUncheckedCreateNestedManyWithoutClientAdminInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutClientAdminInput
    studentTasks?: StudentTaskUncheckedCreateNestedManyWithoutClientAdminInput
    studentTests?: StudentTestUncheckedCreateNestedManyWithoutClientAdminInput
    courseCompletions?: CourseCompletionUncheckedCreateNestedManyWithoutClientAdminInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutClientAdminInput
    financialRecords?: FinancialRecordUncheckedCreateNestedManyWithoutClientAdminInput
    enquiries?: EnquiryUncheckedCreateNestedManyWithoutClientAdminInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutClientAdminInput
    courseFeeStructures?: CourseFeeStructureUncheckedCreateNestedManyWithoutClientAdminInput
  }

  export type ClientAdminCreateOrConnectWithoutEnquiryCourseInput = {
    where: ClientAdminWhereUniqueInput
    create: XOR<ClientAdminCreateWithoutEnquiryCourseInput, ClientAdminUncheckedCreateWithoutEnquiryCourseInput>
  }

  export type EnquiryUpsertWithoutEnquiryCourseInput = {
    update: XOR<EnquiryUpdateWithoutEnquiryCourseInput, EnquiryUncheckedUpdateWithoutEnquiryCourseInput>
    create: XOR<EnquiryCreateWithoutEnquiryCourseInput, EnquiryUncheckedCreateWithoutEnquiryCourseInput>
    where?: EnquiryWhereInput
  }

  export type EnquiryUpdateToOneWithWhereWithoutEnquiryCourseInput = {
    where?: EnquiryWhereInput
    data: XOR<EnquiryUpdateWithoutEnquiryCourseInput, EnquiryUncheckedUpdateWithoutEnquiryCourseInput>
  }

  export type EnquiryUpdateWithoutEnquiryCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    course?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    leadStatus?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isConverted?: BoolFieldUpdateOperationsInput | boolean
    followUps?: FollowUpUpdateManyWithoutEnquiryNestedInput
    student?: StudentUpdateOneWithoutEnquiryNestedInput
    notification?: NotificationUpdateOneWithoutEnquiryNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutEnquiriesNestedInput
  }

  export type EnquiryUncheckedUpdateWithoutEnquiryCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    course?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    leadStatus?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isConverted?: BoolFieldUpdateOperationsInput | boolean
    studentId?: NullableIntFieldUpdateOperationsInput | number | null
    clientAdminId?: StringFieldUpdateOperationsInput | string
    followUps?: FollowUpUncheckedUpdateManyWithoutEnquiryNestedInput
    notification?: NotificationUncheckedUpdateOneWithoutEnquiryNestedInput
  }

  export type CourseUpsertWithoutEnquiryCourseInput = {
    update: XOR<CourseUpdateWithoutEnquiryCourseInput, CourseUncheckedUpdateWithoutEnquiryCourseInput>
    create: XOR<CourseCreateWithoutEnquiryCourseInput, CourseUncheckedCreateWithoutEnquiryCourseInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutEnquiryCourseInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutEnquiryCourseInput, CourseUncheckedUpdateWithoutEnquiryCourseInput>
  }

  export type CourseUpdateWithoutEnquiryCourseInput = {
    name?: StringFieldUpdateOperationsInput | string
    durationWeeks?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    courseFeeStructure?: CourseFeeStructureUpdateOneWithoutCourseNestedInput
    studentCourses?: StudentCourseUpdateManyWithoutCourseNestedInput
    feeStructures?: FeeStructureUpdateManyWithoutCourseNestedInput
    stationery?: StationeryIssueUpdateManyWithoutCourseNestedInput
    studentFees?: StudentFeeUpdateManyWithoutCourseNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutCourseNestedInput
    studentTasks?: StudentTaskUpdateManyWithoutCourseNestedInput
    studentTests?: StudentTestUpdateManyWithoutCourseNestedInput
    certificates?: CertificateUpdateManyWithoutCourseNestedInput
    financialRecords?: FinancialRecordUpdateManyWithoutCourseNestedInput
    batchCourses?: BatchCourseUpdateManyWithoutCourseNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutCoursesNestedInput
  }

  export type CourseUncheckedUpdateWithoutEnquiryCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    durationWeeks?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    clientAdminId?: StringFieldUpdateOperationsInput | string
    courseFeeStructure?: CourseFeeStructureUncheckedUpdateOneWithoutCourseNestedInput
    studentCourses?: StudentCourseUncheckedUpdateManyWithoutCourseNestedInput
    feeStructures?: FeeStructureUncheckedUpdateManyWithoutCourseNestedInput
    stationery?: StationeryIssueUncheckedUpdateManyWithoutCourseNestedInput
    studentFees?: StudentFeeUncheckedUpdateManyWithoutCourseNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutCourseNestedInput
    studentTasks?: StudentTaskUncheckedUpdateManyWithoutCourseNestedInput
    studentTests?: StudentTestUncheckedUpdateManyWithoutCourseNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutCourseNestedInput
    financialRecords?: FinancialRecordUncheckedUpdateManyWithoutCourseNestedInput
    batchCourses?: BatchCourseUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type ClientAdminUpsertWithoutEnquiryCourseInput = {
    update: XOR<ClientAdminUpdateWithoutEnquiryCourseInput, ClientAdminUncheckedUpdateWithoutEnquiryCourseInput>
    create: XOR<ClientAdminCreateWithoutEnquiryCourseInput, ClientAdminUncheckedCreateWithoutEnquiryCourseInput>
    where?: ClientAdminWhereInput
  }

  export type ClientAdminUpdateToOneWithWhereWithoutEnquiryCourseInput = {
    where?: ClientAdminWhereInput
    data: XOR<ClientAdminUpdateWithoutEnquiryCourseInput, ClientAdminUncheckedUpdateWithoutEnquiryCourseInput>
  }

  export type ClientAdminUpdateWithoutEnquiryCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    instituteName?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    fullAddress?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    certificateName?: NullableStringFieldUpdateOperationsInput | string | null
    stamp?: NullableStringFieldUpdateOperationsInput | string | null
    sign?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    currentSessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleUsers?: RoleUserUpdateManyWithoutClientAdminNestedInput
    faculties?: FacultyUpdateManyWithoutClientAdminNestedInput
    batches?: BatchUpdateManyWithoutClientAdminNestedInput
    courses?: CourseUpdateManyWithoutClientAdminNestedInput
    labs?: LabUpdateManyWithoutClientAdminNestedInput
    labTimeSlots?: LabTimeSlotUpdateManyWithoutClientAdminNestedInput
    labAllocations?: LabAllocationUpdateManyWithoutClientAdminNestedInput
    students?: StudentUpdateManyWithoutClientAdminNestedInput
    activities?: ActivityLogUpdateManyWithoutClientAdminNestedInput
    studentCourses?: StudentCourseUpdateManyWithoutClientAdminNestedInput
    feeStructures?: FeeStructureUpdateManyWithoutClientAdminNestedInput
    studentFees?: StudentFeeUpdateManyWithoutClientAdminNestedInput
    stationeryIssues?: StationeryIssueUpdateManyWithoutClientAdminNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutClientAdminNestedInput
    studentTasks?: StudentTaskUpdateManyWithoutClientAdminNestedInput
    studentTests?: StudentTestUpdateManyWithoutClientAdminNestedInput
    courseCompletions?: CourseCompletionUpdateManyWithoutClientAdminNestedInput
    certificates?: CertificateUpdateManyWithoutClientAdminNestedInput
    financialRecords?: FinancialRecordUpdateManyWithoutClientAdminNestedInput
    enquiries?: EnquiryUpdateManyWithoutClientAdminNestedInput
    notifications?: NotificationUpdateManyWithoutClientAdminNestedInput
    courseFeeStructures?: CourseFeeStructureUpdateManyWithoutClientAdminNestedInput
  }

  export type ClientAdminUncheckedUpdateWithoutEnquiryCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    instituteName?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    fullAddress?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    certificateName?: NullableStringFieldUpdateOperationsInput | string | null
    stamp?: NullableStringFieldUpdateOperationsInput | string | null
    sign?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    currentSessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleUsers?: RoleUserUncheckedUpdateManyWithoutClientAdminNestedInput
    faculties?: FacultyUncheckedUpdateManyWithoutClientAdminNestedInput
    batches?: BatchUncheckedUpdateManyWithoutClientAdminNestedInput
    courses?: CourseUncheckedUpdateManyWithoutClientAdminNestedInput
    labs?: LabUncheckedUpdateManyWithoutClientAdminNestedInput
    labTimeSlots?: LabTimeSlotUncheckedUpdateManyWithoutClientAdminNestedInput
    labAllocations?: LabAllocationUncheckedUpdateManyWithoutClientAdminNestedInput
    students?: StudentUncheckedUpdateManyWithoutClientAdminNestedInput
    activities?: ActivityLogUncheckedUpdateManyWithoutClientAdminNestedInput
    studentCourses?: StudentCourseUncheckedUpdateManyWithoutClientAdminNestedInput
    feeStructures?: FeeStructureUncheckedUpdateManyWithoutClientAdminNestedInput
    studentFees?: StudentFeeUncheckedUpdateManyWithoutClientAdminNestedInput
    stationeryIssues?: StationeryIssueUncheckedUpdateManyWithoutClientAdminNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutClientAdminNestedInput
    studentTasks?: StudentTaskUncheckedUpdateManyWithoutClientAdminNestedInput
    studentTests?: StudentTestUncheckedUpdateManyWithoutClientAdminNestedInput
    courseCompletions?: CourseCompletionUncheckedUpdateManyWithoutClientAdminNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutClientAdminNestedInput
    financialRecords?: FinancialRecordUncheckedUpdateManyWithoutClientAdminNestedInput
    enquiries?: EnquiryUncheckedUpdateManyWithoutClientAdminNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutClientAdminNestedInput
    courseFeeStructures?: CourseFeeStructureUncheckedUpdateManyWithoutClientAdminNestedInput
  }

  export type EnquiryCreateWithoutFollowUpsInput = {
    id?: string
    name: string
    contact: string
    email?: string | null
    course?: string | null
    source?: string | null
    leadStatus?: $Enums.LeadStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    isConverted?: boolean
    student?: StudentCreateNestedOneWithoutEnquiryInput
    enquiryCourse?: EnquiryCourseCreateNestedManyWithoutEnquiryInput
    notification?: NotificationCreateNestedOneWithoutEnquiryInput
    clientAdmin: ClientAdminCreateNestedOneWithoutEnquiriesInput
  }

  export type EnquiryUncheckedCreateWithoutFollowUpsInput = {
    id?: string
    name: string
    contact: string
    email?: string | null
    course?: string | null
    source?: string | null
    leadStatus?: $Enums.LeadStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    isConverted?: boolean
    studentId?: number | null
    clientAdminId: string
    enquiryCourse?: EnquiryCourseUncheckedCreateNestedManyWithoutEnquiryInput
    notification?: NotificationUncheckedCreateNestedOneWithoutEnquiryInput
  }

  export type EnquiryCreateOrConnectWithoutFollowUpsInput = {
    where: EnquiryWhereUniqueInput
    create: XOR<EnquiryCreateWithoutFollowUpsInput, EnquiryUncheckedCreateWithoutFollowUpsInput>
  }

  export type NotificationCreateWithoutFollowUpInput = {
    id?: string
    message: string
    seen?: boolean
    createdAt?: Date | string
    enquiry?: EnquiryCreateNestedOneWithoutNotificationInput
    payment?: StudentFeeCreateNestedOneWithoutNotificationInput
    clientAdmin: ClientAdminCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutFollowUpInput = {
    id?: string
    message: string
    seen?: boolean
    createdAt?: Date | string
    enquiryId?: string | null
    paymentId?: number | null
    clientAdminId: string
  }

  export type NotificationCreateOrConnectWithoutFollowUpInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutFollowUpInput, NotificationUncheckedCreateWithoutFollowUpInput>
  }

  export type EnquiryUpsertWithoutFollowUpsInput = {
    update: XOR<EnquiryUpdateWithoutFollowUpsInput, EnquiryUncheckedUpdateWithoutFollowUpsInput>
    create: XOR<EnquiryCreateWithoutFollowUpsInput, EnquiryUncheckedCreateWithoutFollowUpsInput>
    where?: EnquiryWhereInput
  }

  export type EnquiryUpdateToOneWithWhereWithoutFollowUpsInput = {
    where?: EnquiryWhereInput
    data: XOR<EnquiryUpdateWithoutFollowUpsInput, EnquiryUncheckedUpdateWithoutFollowUpsInput>
  }

  export type EnquiryUpdateWithoutFollowUpsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    course?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    leadStatus?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isConverted?: BoolFieldUpdateOperationsInput | boolean
    student?: StudentUpdateOneWithoutEnquiryNestedInput
    enquiryCourse?: EnquiryCourseUpdateManyWithoutEnquiryNestedInput
    notification?: NotificationUpdateOneWithoutEnquiryNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutEnquiriesNestedInput
  }

  export type EnquiryUncheckedUpdateWithoutFollowUpsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    course?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    leadStatus?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isConverted?: BoolFieldUpdateOperationsInput | boolean
    studentId?: NullableIntFieldUpdateOperationsInput | number | null
    clientAdminId?: StringFieldUpdateOperationsInput | string
    enquiryCourse?: EnquiryCourseUncheckedUpdateManyWithoutEnquiryNestedInput
    notification?: NotificationUncheckedUpdateOneWithoutEnquiryNestedInput
  }

  export type NotificationUpsertWithoutFollowUpInput = {
    update: XOR<NotificationUpdateWithoutFollowUpInput, NotificationUncheckedUpdateWithoutFollowUpInput>
    create: XOR<NotificationCreateWithoutFollowUpInput, NotificationUncheckedCreateWithoutFollowUpInput>
    where?: NotificationWhereInput
  }

  export type NotificationUpdateToOneWithWhereWithoutFollowUpInput = {
    where?: NotificationWhereInput
    data: XOR<NotificationUpdateWithoutFollowUpInput, NotificationUncheckedUpdateWithoutFollowUpInput>
  }

  export type NotificationUpdateWithoutFollowUpInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    seen?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enquiry?: EnquiryUpdateOneWithoutNotificationNestedInput
    payment?: StudentFeeUpdateOneWithoutNotificationNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutFollowUpInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    seen?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enquiryId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableIntFieldUpdateOperationsInput | number | null
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type FollowUpCreateWithoutNotificationInput = {
    id?: string
    scheduledAt?: Date | string | null
    doneAt?: Date | string | null
    remark: string
    createdAt?: Date | string
    followUpStatus?: $Enums.FollowUpStatus
    enquiry: EnquiryCreateNestedOneWithoutFollowUpsInput
  }

  export type FollowUpUncheckedCreateWithoutNotificationInput = {
    id?: string
    enquiryId: string
    scheduledAt?: Date | string | null
    doneAt?: Date | string | null
    remark: string
    createdAt?: Date | string
    followUpStatus?: $Enums.FollowUpStatus
  }

  export type FollowUpCreateOrConnectWithoutNotificationInput = {
    where: FollowUpWhereUniqueInput
    create: XOR<FollowUpCreateWithoutNotificationInput, FollowUpUncheckedCreateWithoutNotificationInput>
  }

  export type EnquiryCreateWithoutNotificationInput = {
    id?: string
    name: string
    contact: string
    email?: string | null
    course?: string | null
    source?: string | null
    leadStatus?: $Enums.LeadStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    isConverted?: boolean
    followUps?: FollowUpCreateNestedManyWithoutEnquiryInput
    student?: StudentCreateNestedOneWithoutEnquiryInput
    enquiryCourse?: EnquiryCourseCreateNestedManyWithoutEnquiryInput
    clientAdmin: ClientAdminCreateNestedOneWithoutEnquiriesInput
  }

  export type EnquiryUncheckedCreateWithoutNotificationInput = {
    id?: string
    name: string
    contact: string
    email?: string | null
    course?: string | null
    source?: string | null
    leadStatus?: $Enums.LeadStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    isConverted?: boolean
    studentId?: number | null
    clientAdminId: string
    followUps?: FollowUpUncheckedCreateNestedManyWithoutEnquiryInput
    enquiryCourse?: EnquiryCourseUncheckedCreateNestedManyWithoutEnquiryInput
  }

  export type EnquiryCreateOrConnectWithoutNotificationInput = {
    where: EnquiryWhereUniqueInput
    create: XOR<EnquiryCreateWithoutNotificationInput, EnquiryUncheckedCreateWithoutNotificationInput>
  }

  export type StudentFeeCreateWithoutNotificationInput = {
    dueDate: Date | string
    amountDue: number
    amountPaid: number
    paymentDate?: Date | string | null
    paymentMode: $Enums.PaymentMode
    receiptNo: string
    paymentStatus?: $Enums.PaymentStatus
    student: StudentCreateNestedOneWithoutFeeRecordsInput
    course: CourseCreateNestedOneWithoutStudentFeesInput
    feeLogs?: StudentFeeLogCreateNestedManyWithoutStudentFeeInput
    feeStructure?: FeeStructureCreateNestedOneWithoutStudentFeesInput
    clientAdmin: ClientAdminCreateNestedOneWithoutStudentFeesInput
  }

  export type StudentFeeUncheckedCreateWithoutNotificationInput = {
    id?: number
    studentId: number
    courseId: number
    dueDate: Date | string
    amountDue: number
    amountPaid: number
    paymentDate?: Date | string | null
    paymentMode: $Enums.PaymentMode
    receiptNo: string
    paymentStatus?: $Enums.PaymentStatus
    clientAdminId: string
    feeLogs?: StudentFeeLogUncheckedCreateNestedManyWithoutStudentFeeInput
  }

  export type StudentFeeCreateOrConnectWithoutNotificationInput = {
    where: StudentFeeWhereUniqueInput
    create: XOR<StudentFeeCreateWithoutNotificationInput, StudentFeeUncheckedCreateWithoutNotificationInput>
  }

  export type ClientAdminCreateWithoutNotificationsInput = {
    id?: string
    name: string
    email: string
    password: string
    instituteName: string
    slug: string
    fullAddress: string
    logo?: string | null
    certificateName?: string | null
    stamp?: string | null
    sign?: string | null
    contact: string
    position: string
    country: string
    state: string
    city: string
    zipCode: string
    createdAt?: Date | string
    role?: $Enums.UserRole
    currentSessionToken?: string | null
    lastLoginAt?: Date | string | null
    roleUsers?: RoleUserCreateNestedManyWithoutClientAdminInput
    faculties?: FacultyCreateNestedManyWithoutClientAdminInput
    batches?: BatchCreateNestedManyWithoutClientAdminInput
    courses?: CourseCreateNestedManyWithoutClientAdminInput
    enquiryCourse?: EnquiryCourseCreateNestedManyWithoutClientAdminInput
    labs?: LabCreateNestedManyWithoutClientAdminInput
    labTimeSlots?: LabTimeSlotCreateNestedManyWithoutClientAdminInput
    labAllocations?: LabAllocationCreateNestedManyWithoutClientAdminInput
    students?: StudentCreateNestedManyWithoutClientAdminInput
    activities?: ActivityLogCreateNestedManyWithoutClientAdminInput
    studentCourses?: StudentCourseCreateNestedManyWithoutClientAdminInput
    feeStructures?: FeeStructureCreateNestedManyWithoutClientAdminInput
    studentFees?: StudentFeeCreateNestedManyWithoutClientAdminInput
    stationeryIssues?: StationeryIssueCreateNestedManyWithoutClientAdminInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutClientAdminInput
    studentTasks?: StudentTaskCreateNestedManyWithoutClientAdminInput
    studentTests?: StudentTestCreateNestedManyWithoutClientAdminInput
    courseCompletions?: CourseCompletionCreateNestedManyWithoutClientAdminInput
    certificates?: CertificateCreateNestedManyWithoutClientAdminInput
    financialRecords?: FinancialRecordCreateNestedManyWithoutClientAdminInput
    enquiries?: EnquiryCreateNestedManyWithoutClientAdminInput
    courseFeeStructures?: CourseFeeStructureCreateNestedManyWithoutClientAdminInput
  }

  export type ClientAdminUncheckedCreateWithoutNotificationsInput = {
    id?: string
    name: string
    email: string
    password: string
    instituteName: string
    slug: string
    fullAddress: string
    logo?: string | null
    certificateName?: string | null
    stamp?: string | null
    sign?: string | null
    contact: string
    position: string
    country: string
    state: string
    city: string
    zipCode: string
    createdAt?: Date | string
    role?: $Enums.UserRole
    currentSessionToken?: string | null
    lastLoginAt?: Date | string | null
    roleUsers?: RoleUserUncheckedCreateNestedManyWithoutClientAdminInput
    faculties?: FacultyUncheckedCreateNestedManyWithoutClientAdminInput
    batches?: BatchUncheckedCreateNestedManyWithoutClientAdminInput
    courses?: CourseUncheckedCreateNestedManyWithoutClientAdminInput
    enquiryCourse?: EnquiryCourseUncheckedCreateNestedManyWithoutClientAdminInput
    labs?: LabUncheckedCreateNestedManyWithoutClientAdminInput
    labTimeSlots?: LabTimeSlotUncheckedCreateNestedManyWithoutClientAdminInput
    labAllocations?: LabAllocationUncheckedCreateNestedManyWithoutClientAdminInput
    students?: StudentUncheckedCreateNestedManyWithoutClientAdminInput
    activities?: ActivityLogUncheckedCreateNestedManyWithoutClientAdminInput
    studentCourses?: StudentCourseUncheckedCreateNestedManyWithoutClientAdminInput
    feeStructures?: FeeStructureUncheckedCreateNestedManyWithoutClientAdminInput
    studentFees?: StudentFeeUncheckedCreateNestedManyWithoutClientAdminInput
    stationeryIssues?: StationeryIssueUncheckedCreateNestedManyWithoutClientAdminInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutClientAdminInput
    studentTasks?: StudentTaskUncheckedCreateNestedManyWithoutClientAdminInput
    studentTests?: StudentTestUncheckedCreateNestedManyWithoutClientAdminInput
    courseCompletions?: CourseCompletionUncheckedCreateNestedManyWithoutClientAdminInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutClientAdminInput
    financialRecords?: FinancialRecordUncheckedCreateNestedManyWithoutClientAdminInput
    enquiries?: EnquiryUncheckedCreateNestedManyWithoutClientAdminInput
    courseFeeStructures?: CourseFeeStructureUncheckedCreateNestedManyWithoutClientAdminInput
  }

  export type ClientAdminCreateOrConnectWithoutNotificationsInput = {
    where: ClientAdminWhereUniqueInput
    create: XOR<ClientAdminCreateWithoutNotificationsInput, ClientAdminUncheckedCreateWithoutNotificationsInput>
  }

  export type FollowUpUpsertWithoutNotificationInput = {
    update: XOR<FollowUpUpdateWithoutNotificationInput, FollowUpUncheckedUpdateWithoutNotificationInput>
    create: XOR<FollowUpCreateWithoutNotificationInput, FollowUpUncheckedCreateWithoutNotificationInput>
    where?: FollowUpWhereInput
  }

  export type FollowUpUpdateToOneWithWhereWithoutNotificationInput = {
    where?: FollowUpWhereInput
    data: XOR<FollowUpUpdateWithoutNotificationInput, FollowUpUncheckedUpdateWithoutNotificationInput>
  }

  export type FollowUpUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doneAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remark?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    followUpStatus?: EnumFollowUpStatusFieldUpdateOperationsInput | $Enums.FollowUpStatus
    enquiry?: EnquiryUpdateOneRequiredWithoutFollowUpsNestedInput
  }

  export type FollowUpUncheckedUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    enquiryId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doneAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remark?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    followUpStatus?: EnumFollowUpStatusFieldUpdateOperationsInput | $Enums.FollowUpStatus
  }

  export type EnquiryUpsertWithoutNotificationInput = {
    update: XOR<EnquiryUpdateWithoutNotificationInput, EnquiryUncheckedUpdateWithoutNotificationInput>
    create: XOR<EnquiryCreateWithoutNotificationInput, EnquiryUncheckedCreateWithoutNotificationInput>
    where?: EnquiryWhereInput
  }

  export type EnquiryUpdateToOneWithWhereWithoutNotificationInput = {
    where?: EnquiryWhereInput
    data: XOR<EnquiryUpdateWithoutNotificationInput, EnquiryUncheckedUpdateWithoutNotificationInput>
  }

  export type EnquiryUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    course?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    leadStatus?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isConverted?: BoolFieldUpdateOperationsInput | boolean
    followUps?: FollowUpUpdateManyWithoutEnquiryNestedInput
    student?: StudentUpdateOneWithoutEnquiryNestedInput
    enquiryCourse?: EnquiryCourseUpdateManyWithoutEnquiryNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutEnquiriesNestedInput
  }

  export type EnquiryUncheckedUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    course?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    leadStatus?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isConverted?: BoolFieldUpdateOperationsInput | boolean
    studentId?: NullableIntFieldUpdateOperationsInput | number | null
    clientAdminId?: StringFieldUpdateOperationsInput | string
    followUps?: FollowUpUncheckedUpdateManyWithoutEnquiryNestedInput
    enquiryCourse?: EnquiryCourseUncheckedUpdateManyWithoutEnquiryNestedInput
  }

  export type StudentFeeUpsertWithoutNotificationInput = {
    update: XOR<StudentFeeUpdateWithoutNotificationInput, StudentFeeUncheckedUpdateWithoutNotificationInput>
    create: XOR<StudentFeeCreateWithoutNotificationInput, StudentFeeUncheckedCreateWithoutNotificationInput>
    where?: StudentFeeWhereInput
  }

  export type StudentFeeUpdateToOneWithWhereWithoutNotificationInput = {
    where?: StudentFeeWhereInput
    data: XOR<StudentFeeUpdateWithoutNotificationInput, StudentFeeUncheckedUpdateWithoutNotificationInput>
  }

  export type StudentFeeUpdateWithoutNotificationInput = {
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amountDue?: FloatFieldUpdateOperationsInput | number
    amountPaid?: FloatFieldUpdateOperationsInput | number
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMode?: EnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode
    receiptNo?: StringFieldUpdateOperationsInput | string
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    student?: StudentUpdateOneRequiredWithoutFeeRecordsNestedInput
    course?: CourseUpdateOneRequiredWithoutStudentFeesNestedInput
    feeLogs?: StudentFeeLogUpdateManyWithoutStudentFeeNestedInput
    feeStructure?: FeeStructureUpdateOneWithoutStudentFeesNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutStudentFeesNestedInput
  }

  export type StudentFeeUncheckedUpdateWithoutNotificationInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amountDue?: FloatFieldUpdateOperationsInput | number
    amountPaid?: FloatFieldUpdateOperationsInput | number
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMode?: EnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode
    receiptNo?: StringFieldUpdateOperationsInput | string
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    clientAdminId?: StringFieldUpdateOperationsInput | string
    feeLogs?: StudentFeeLogUncheckedUpdateManyWithoutStudentFeeNestedInput
  }

  export type ClientAdminUpsertWithoutNotificationsInput = {
    update: XOR<ClientAdminUpdateWithoutNotificationsInput, ClientAdminUncheckedUpdateWithoutNotificationsInput>
    create: XOR<ClientAdminCreateWithoutNotificationsInput, ClientAdminUncheckedCreateWithoutNotificationsInput>
    where?: ClientAdminWhereInput
  }

  export type ClientAdminUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: ClientAdminWhereInput
    data: XOR<ClientAdminUpdateWithoutNotificationsInput, ClientAdminUncheckedUpdateWithoutNotificationsInput>
  }

  export type ClientAdminUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    instituteName?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    fullAddress?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    certificateName?: NullableStringFieldUpdateOperationsInput | string | null
    stamp?: NullableStringFieldUpdateOperationsInput | string | null
    sign?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    currentSessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleUsers?: RoleUserUpdateManyWithoutClientAdminNestedInput
    faculties?: FacultyUpdateManyWithoutClientAdminNestedInput
    batches?: BatchUpdateManyWithoutClientAdminNestedInput
    courses?: CourseUpdateManyWithoutClientAdminNestedInput
    enquiryCourse?: EnquiryCourseUpdateManyWithoutClientAdminNestedInput
    labs?: LabUpdateManyWithoutClientAdminNestedInput
    labTimeSlots?: LabTimeSlotUpdateManyWithoutClientAdminNestedInput
    labAllocations?: LabAllocationUpdateManyWithoutClientAdminNestedInput
    students?: StudentUpdateManyWithoutClientAdminNestedInput
    activities?: ActivityLogUpdateManyWithoutClientAdminNestedInput
    studentCourses?: StudentCourseUpdateManyWithoutClientAdminNestedInput
    feeStructures?: FeeStructureUpdateManyWithoutClientAdminNestedInput
    studentFees?: StudentFeeUpdateManyWithoutClientAdminNestedInput
    stationeryIssues?: StationeryIssueUpdateManyWithoutClientAdminNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutClientAdminNestedInput
    studentTasks?: StudentTaskUpdateManyWithoutClientAdminNestedInput
    studentTests?: StudentTestUpdateManyWithoutClientAdminNestedInput
    courseCompletions?: CourseCompletionUpdateManyWithoutClientAdminNestedInput
    certificates?: CertificateUpdateManyWithoutClientAdminNestedInput
    financialRecords?: FinancialRecordUpdateManyWithoutClientAdminNestedInput
    enquiries?: EnquiryUpdateManyWithoutClientAdminNestedInput
    courseFeeStructures?: CourseFeeStructureUpdateManyWithoutClientAdminNestedInput
  }

  export type ClientAdminUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    instituteName?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    fullAddress?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    certificateName?: NullableStringFieldUpdateOperationsInput | string | null
    stamp?: NullableStringFieldUpdateOperationsInput | string | null
    sign?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    currentSessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleUsers?: RoleUserUncheckedUpdateManyWithoutClientAdminNestedInput
    faculties?: FacultyUncheckedUpdateManyWithoutClientAdminNestedInput
    batches?: BatchUncheckedUpdateManyWithoutClientAdminNestedInput
    courses?: CourseUncheckedUpdateManyWithoutClientAdminNestedInput
    enquiryCourse?: EnquiryCourseUncheckedUpdateManyWithoutClientAdminNestedInput
    labs?: LabUncheckedUpdateManyWithoutClientAdminNestedInput
    labTimeSlots?: LabTimeSlotUncheckedUpdateManyWithoutClientAdminNestedInput
    labAllocations?: LabAllocationUncheckedUpdateManyWithoutClientAdminNestedInput
    students?: StudentUncheckedUpdateManyWithoutClientAdminNestedInput
    activities?: ActivityLogUncheckedUpdateManyWithoutClientAdminNestedInput
    studentCourses?: StudentCourseUncheckedUpdateManyWithoutClientAdminNestedInput
    feeStructures?: FeeStructureUncheckedUpdateManyWithoutClientAdminNestedInput
    studentFees?: StudentFeeUncheckedUpdateManyWithoutClientAdminNestedInput
    stationeryIssues?: StationeryIssueUncheckedUpdateManyWithoutClientAdminNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutClientAdminNestedInput
    studentTasks?: StudentTaskUncheckedUpdateManyWithoutClientAdminNestedInput
    studentTests?: StudentTestUncheckedUpdateManyWithoutClientAdminNestedInput
    courseCompletions?: CourseCompletionUncheckedUpdateManyWithoutClientAdminNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutClientAdminNestedInput
    financialRecords?: FinancialRecordUncheckedUpdateManyWithoutClientAdminNestedInput
    enquiries?: EnquiryUncheckedUpdateManyWithoutClientAdminNestedInput
    courseFeeStructures?: CourseFeeStructureUncheckedUpdateManyWithoutClientAdminNestedInput
  }

  export type EnquiryCreateWithoutStudentInput = {
    id?: string
    name: string
    contact: string
    email?: string | null
    course?: string | null
    source?: string | null
    leadStatus?: $Enums.LeadStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    isConverted?: boolean
    followUps?: FollowUpCreateNestedManyWithoutEnquiryInput
    enquiryCourse?: EnquiryCourseCreateNestedManyWithoutEnquiryInput
    notification?: NotificationCreateNestedOneWithoutEnquiryInput
    clientAdmin: ClientAdminCreateNestedOneWithoutEnquiriesInput
  }

  export type EnquiryUncheckedCreateWithoutStudentInput = {
    id?: string
    name: string
    contact: string
    email?: string | null
    course?: string | null
    source?: string | null
    leadStatus?: $Enums.LeadStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    isConverted?: boolean
    clientAdminId: string
    followUps?: FollowUpUncheckedCreateNestedManyWithoutEnquiryInput
    enquiryCourse?: EnquiryCourseUncheckedCreateNestedManyWithoutEnquiryInput
    notification?: NotificationUncheckedCreateNestedOneWithoutEnquiryInput
  }

  export type EnquiryCreateOrConnectWithoutStudentInput = {
    where: EnquiryWhereUniqueInput
    create: XOR<EnquiryCreateWithoutStudentInput, EnquiryUncheckedCreateWithoutStudentInput>
  }

  export type LabAllocationCreateWithoutStudentInput = {
    pcNumber: number
    assignedAt?: Date | string
    labTimeSlot: LabTimeSlotCreateNestedOneWithoutAllocationsInput
    clientAdmin: ClientAdminCreateNestedOneWithoutLabAllocationsInput
  }

  export type LabAllocationUncheckedCreateWithoutStudentInput = {
    id?: number
    labTimeSlotId: number
    pcNumber: number
    assignedAt?: Date | string
    clientAdminId: string
  }

  export type LabAllocationCreateOrConnectWithoutStudentInput = {
    where: LabAllocationWhereUniqueInput
    create: XOR<LabAllocationCreateWithoutStudentInput, LabAllocationUncheckedCreateWithoutStudentInput>
  }

  export type LabAllocationCreateManyStudentInputEnvelope = {
    data: LabAllocationCreateManyStudentInput | LabAllocationCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type StudentCourseCreateWithoutStudentInput = {
    startDate: Date | string
    endDate: Date | string
    studentCode: string
    internalNotes?: string | null
    status: string
    course: CourseCreateNestedOneWithoutStudentCoursesInput
    batch?: BatchCreateNestedOneWithoutStudentCoursesInput
    certificate?: CertificateCreateNestedOneWithoutStudentCourseInput
    completions?: CourseCompletionCreateNestedManyWithoutStudentCourseInput
    clientAdmin: ClientAdminCreateNestedOneWithoutStudentCoursesInput
  }

  export type StudentCourseUncheckedCreateWithoutStudentInput = {
    id?: number
    courseId: number
    startDate: Date | string
    endDate: Date | string
    studentCode: string
    batchId?: number | null
    internalNotes?: string | null
    status: string
    clientAdminId: string
    certificate?: CertificateUncheckedCreateNestedOneWithoutStudentCourseInput
    completions?: CourseCompletionUncheckedCreateNestedManyWithoutStudentCourseInput
  }

  export type StudentCourseCreateOrConnectWithoutStudentInput = {
    where: StudentCourseWhereUniqueInput
    create: XOR<StudentCourseCreateWithoutStudentInput, StudentCourseUncheckedCreateWithoutStudentInput>
  }

  export type StudentCourseCreateManyStudentInputEnvelope = {
    data: StudentCourseCreateManyStudentInput | StudentCourseCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type FeeStructureCreateWithoutStudentInput = {
    totalAmount: number
    paymentType: $Enums.PaymentType
    installmentCount?: number | null
    course: CourseCreateNestedOneWithoutFeeStructuresInput
    installment?: InstallmentDetailCreateNestedOneWithoutFeeStructuresInput
    studentFees?: StudentFeeCreateNestedManyWithoutFeeStructureInput
    clientAdmin: ClientAdminCreateNestedOneWithoutFeeStructuresInput
  }

  export type FeeStructureUncheckedCreateWithoutStudentInput = {
    id?: number
    courseId: number
    totalAmount: number
    paymentType: $Enums.PaymentType
    installmentCount?: number | null
    installmentTypeId?: number | null
    clientAdminId: string
    studentFees?: StudentFeeUncheckedCreateNestedManyWithoutFeeStructureInput
  }

  export type FeeStructureCreateOrConnectWithoutStudentInput = {
    where: FeeStructureWhereUniqueInput
    create: XOR<FeeStructureCreateWithoutStudentInput, FeeStructureUncheckedCreateWithoutStudentInput>
  }

  export type FeeStructureCreateManyStudentInputEnvelope = {
    data: FeeStructureCreateManyStudentInput | FeeStructureCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type StudentFeeCreateWithoutStudentInput = {
    dueDate: Date | string
    amountDue: number
    amountPaid: number
    paymentDate?: Date | string | null
    paymentMode: $Enums.PaymentMode
    receiptNo: string
    paymentStatus?: $Enums.PaymentStatus
    course: CourseCreateNestedOneWithoutStudentFeesInput
    feeLogs?: StudentFeeLogCreateNestedManyWithoutStudentFeeInput
    feeStructure?: FeeStructureCreateNestedOneWithoutStudentFeesInput
    notification?: NotificationCreateNestedOneWithoutPaymentInput
    clientAdmin: ClientAdminCreateNestedOneWithoutStudentFeesInput
  }

  export type StudentFeeUncheckedCreateWithoutStudentInput = {
    id?: number
    courseId: number
    dueDate: Date | string
    amountDue: number
    amountPaid: number
    paymentDate?: Date | string | null
    paymentMode: $Enums.PaymentMode
    receiptNo: string
    paymentStatus?: $Enums.PaymentStatus
    clientAdminId: string
    feeLogs?: StudentFeeLogUncheckedCreateNestedManyWithoutStudentFeeInput
    notification?: NotificationUncheckedCreateNestedOneWithoutPaymentInput
  }

  export type StudentFeeCreateOrConnectWithoutStudentInput = {
    where: StudentFeeWhereUniqueInput
    create: XOR<StudentFeeCreateWithoutStudentInput, StudentFeeUncheckedCreateWithoutStudentInput>
  }

  export type StudentFeeCreateManyStudentInputEnvelope = {
    data: StudentFeeCreateManyStudentInput | StudentFeeCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type AttendanceRecordCreateWithoutStudentInput = {
    date: Date | string
    present: boolean
    batchId?: number | null
    course: CourseCreateNestedOneWithoutAttendanceRecordsInput
    markedBy: FacultyCreateNestedOneWithoutAttendanceInput
    clientAdmin: ClientAdminCreateNestedOneWithoutAttendanceRecordsInput
  }

  export type AttendanceRecordUncheckedCreateWithoutStudentInput = {
    id?: number
    courseId: number
    date: Date | string
    present: boolean
    facultyId: number
    batchId?: number | null
    clientAdminId: string
  }

  export type AttendanceRecordCreateOrConnectWithoutStudentInput = {
    where: AttendanceRecordWhereUniqueInput
    create: XOR<AttendanceRecordCreateWithoutStudentInput, AttendanceRecordUncheckedCreateWithoutStudentInput>
  }

  export type AttendanceRecordCreateManyStudentInputEnvelope = {
    data: AttendanceRecordCreateManyStudentInput | AttendanceRecordCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type StudentTaskCreateWithoutStudentInput = {
    assignedDate: Date | string
    dueDate: Date | string
    description: string
    status: string
    facultyRemarks?: string | null
    grade?: string | null
    course: CourseCreateNestedOneWithoutStudentTasksInput
    faculty?: FacultyCreateNestedOneWithoutTasksInput
    clientAdmin: ClientAdminCreateNestedOneWithoutStudentTasksInput
  }

  export type StudentTaskUncheckedCreateWithoutStudentInput = {
    id?: number
    courseId: number
    assignedDate: Date | string
    dueDate: Date | string
    description: string
    status: string
    facultyRemarks?: string | null
    grade?: string | null
    facultyId?: number | null
    clientAdminId: string
  }

  export type StudentTaskCreateOrConnectWithoutStudentInput = {
    where: StudentTaskWhereUniqueInput
    create: XOR<StudentTaskCreateWithoutStudentInput, StudentTaskUncheckedCreateWithoutStudentInput>
  }

  export type StudentTaskCreateManyStudentInputEnvelope = {
    data: StudentTaskCreateManyStudentInput | StudentTaskCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type StudentTestCreateWithoutStudentInput = {
    testName: string
    testDate: Date | string
    totalMarks: number
    marksObtained: number
    grade: string
    course: CourseCreateNestedOneWithoutStudentTestsInput
    clientAdmin: ClientAdminCreateNestedOneWithoutStudentTestsInput
  }

  export type StudentTestUncheckedCreateWithoutStudentInput = {
    id?: number
    courseId: number
    testName: string
    testDate: Date | string
    totalMarks: number
    marksObtained: number
    grade: string
    clientAdminId: string
  }

  export type StudentTestCreateOrConnectWithoutStudentInput = {
    where: StudentTestWhereUniqueInput
    create: XOR<StudentTestCreateWithoutStudentInput, StudentTestUncheckedCreateWithoutStudentInput>
  }

  export type StudentTestCreateManyStudentInputEnvelope = {
    data: StudentTestCreateManyStudentInput | StudentTestCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type CourseCompletionCreateWithoutStudentInput = {
    completionDate: Date | string
    feedback?: string | null
    remarks?: string | null
    studentCourse: StudentCourseCreateNestedOneWithoutCompletionsInput
    clientAdmin: ClientAdminCreateNestedOneWithoutCourseCompletionsInput
  }

  export type CourseCompletionUncheckedCreateWithoutStudentInput = {
    id?: number
    studentCourseId: number
    completionDate: Date | string
    feedback?: string | null
    remarks?: string | null
    clientAdminId: string
  }

  export type CourseCompletionCreateOrConnectWithoutStudentInput = {
    where: CourseCompletionWhereUniqueInput
    create: XOR<CourseCompletionCreateWithoutStudentInput, CourseCompletionUncheckedCreateWithoutStudentInput>
  }

  export type CourseCompletionCreateManyStudentInputEnvelope = {
    data: CourseCompletionCreateManyStudentInput | CourseCompletionCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type StationeryIssueCreateWithoutStudentInput = {
    issueDate: Date | string
    quantity: number
    remarks?: string | null
    course: CourseCreateNestedOneWithoutStationeryInput
    item: StationeryItemCreateNestedOneWithoutStationeryIssuesInput
    clientAdmin: ClientAdminCreateNestedOneWithoutStationeryIssuesInput
  }

  export type StationeryIssueUncheckedCreateWithoutStudentInput = {
    id?: number
    courseId: number
    itemId: number
    issueDate: Date | string
    quantity: number
    remarks?: string | null
    clientAdminId: string
  }

  export type StationeryIssueCreateOrConnectWithoutStudentInput = {
    where: StationeryIssueWhereUniqueInput
    create: XOR<StationeryIssueCreateWithoutStudentInput, StationeryIssueUncheckedCreateWithoutStudentInput>
  }

  export type StationeryIssueCreateManyStudentInputEnvelope = {
    data: StationeryIssueCreateManyStudentInput | StationeryIssueCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type CertificateCreateWithoutStudentInput = {
    issueDate: Date | string
    certificateUrl: string
    course: CourseCreateNestedOneWithoutCertificatesInput
    studentCourse: StudentCourseCreateNestedOneWithoutCertificateInput
    clientAdmin: ClientAdminCreateNestedOneWithoutCertificatesInput
  }

  export type CertificateUncheckedCreateWithoutStudentInput = {
    id?: number
    courseId: number
    studentCourseId: number
    issueDate: Date | string
    certificateUrl: string
    clientAdminId: string
  }

  export type CertificateCreateOrConnectWithoutStudentInput = {
    where: CertificateWhereUniqueInput
    create: XOR<CertificateCreateWithoutStudentInput, CertificateUncheckedCreateWithoutStudentInput>
  }

  export type CertificateCreateManyStudentInputEnvelope = {
    data: CertificateCreateManyStudentInput | CertificateCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type FinancialRecordCreateWithoutStudentInput = {
    id?: string
    recordType: $Enums.RecordType
    amount: number
    description?: string | null
    date?: Date | string
    paymentMode?: $Enums.PaymentMode | null
    course?: CourseCreateNestedOneWithoutFinancialRecordsInput
    faculty?: FacultyCreateNestedOneWithoutFinancialRecordsInput
    lab?: LabCreateNestedOneWithoutFinancialRecordsInput
    clientAdmin: ClientAdminCreateNestedOneWithoutFinancialRecordsInput
  }

  export type FinancialRecordUncheckedCreateWithoutStudentInput = {
    id?: string
    clientAdminId: string
    recordType: $Enums.RecordType
    amount: number
    description?: string | null
    date?: Date | string
    paymentMode?: $Enums.PaymentMode | null
    courseId?: number | null
    facultyId?: number | null
    labId?: number | null
  }

  export type FinancialRecordCreateOrConnectWithoutStudentInput = {
    where: FinancialRecordWhereUniqueInput
    create: XOR<FinancialRecordCreateWithoutStudentInput, FinancialRecordUncheckedCreateWithoutStudentInput>
  }

  export type FinancialRecordCreateManyStudentInputEnvelope = {
    data: FinancialRecordCreateManyStudentInput | FinancialRecordCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type ClientAdminCreateWithoutStudentsInput = {
    id?: string
    name: string
    email: string
    password: string
    instituteName: string
    slug: string
    fullAddress: string
    logo?: string | null
    certificateName?: string | null
    stamp?: string | null
    sign?: string | null
    contact: string
    position: string
    country: string
    state: string
    city: string
    zipCode: string
    createdAt?: Date | string
    role?: $Enums.UserRole
    currentSessionToken?: string | null
    lastLoginAt?: Date | string | null
    roleUsers?: RoleUserCreateNestedManyWithoutClientAdminInput
    faculties?: FacultyCreateNestedManyWithoutClientAdminInput
    batches?: BatchCreateNestedManyWithoutClientAdminInput
    courses?: CourseCreateNestedManyWithoutClientAdminInput
    enquiryCourse?: EnquiryCourseCreateNestedManyWithoutClientAdminInput
    labs?: LabCreateNestedManyWithoutClientAdminInput
    labTimeSlots?: LabTimeSlotCreateNestedManyWithoutClientAdminInput
    labAllocations?: LabAllocationCreateNestedManyWithoutClientAdminInput
    activities?: ActivityLogCreateNestedManyWithoutClientAdminInput
    studentCourses?: StudentCourseCreateNestedManyWithoutClientAdminInput
    feeStructures?: FeeStructureCreateNestedManyWithoutClientAdminInput
    studentFees?: StudentFeeCreateNestedManyWithoutClientAdminInput
    stationeryIssues?: StationeryIssueCreateNestedManyWithoutClientAdminInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutClientAdminInput
    studentTasks?: StudentTaskCreateNestedManyWithoutClientAdminInput
    studentTests?: StudentTestCreateNestedManyWithoutClientAdminInput
    courseCompletions?: CourseCompletionCreateNestedManyWithoutClientAdminInput
    certificates?: CertificateCreateNestedManyWithoutClientAdminInput
    financialRecords?: FinancialRecordCreateNestedManyWithoutClientAdminInput
    enquiries?: EnquiryCreateNestedManyWithoutClientAdminInput
    notifications?: NotificationCreateNestedManyWithoutClientAdminInput
    courseFeeStructures?: CourseFeeStructureCreateNestedManyWithoutClientAdminInput
  }

  export type ClientAdminUncheckedCreateWithoutStudentsInput = {
    id?: string
    name: string
    email: string
    password: string
    instituteName: string
    slug: string
    fullAddress: string
    logo?: string | null
    certificateName?: string | null
    stamp?: string | null
    sign?: string | null
    contact: string
    position: string
    country: string
    state: string
    city: string
    zipCode: string
    createdAt?: Date | string
    role?: $Enums.UserRole
    currentSessionToken?: string | null
    lastLoginAt?: Date | string | null
    roleUsers?: RoleUserUncheckedCreateNestedManyWithoutClientAdminInput
    faculties?: FacultyUncheckedCreateNestedManyWithoutClientAdminInput
    batches?: BatchUncheckedCreateNestedManyWithoutClientAdminInput
    courses?: CourseUncheckedCreateNestedManyWithoutClientAdminInput
    enquiryCourse?: EnquiryCourseUncheckedCreateNestedManyWithoutClientAdminInput
    labs?: LabUncheckedCreateNestedManyWithoutClientAdminInput
    labTimeSlots?: LabTimeSlotUncheckedCreateNestedManyWithoutClientAdminInput
    labAllocations?: LabAllocationUncheckedCreateNestedManyWithoutClientAdminInput
    activities?: ActivityLogUncheckedCreateNestedManyWithoutClientAdminInput
    studentCourses?: StudentCourseUncheckedCreateNestedManyWithoutClientAdminInput
    feeStructures?: FeeStructureUncheckedCreateNestedManyWithoutClientAdminInput
    studentFees?: StudentFeeUncheckedCreateNestedManyWithoutClientAdminInput
    stationeryIssues?: StationeryIssueUncheckedCreateNestedManyWithoutClientAdminInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutClientAdminInput
    studentTasks?: StudentTaskUncheckedCreateNestedManyWithoutClientAdminInput
    studentTests?: StudentTestUncheckedCreateNestedManyWithoutClientAdminInput
    courseCompletions?: CourseCompletionUncheckedCreateNestedManyWithoutClientAdminInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutClientAdminInput
    financialRecords?: FinancialRecordUncheckedCreateNestedManyWithoutClientAdminInput
    enquiries?: EnquiryUncheckedCreateNestedManyWithoutClientAdminInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutClientAdminInput
    courseFeeStructures?: CourseFeeStructureUncheckedCreateNestedManyWithoutClientAdminInput
  }

  export type ClientAdminCreateOrConnectWithoutStudentsInput = {
    where: ClientAdminWhereUniqueInput
    create: XOR<ClientAdminCreateWithoutStudentsInput, ClientAdminUncheckedCreateWithoutStudentsInput>
  }

  export type EnquiryUpsertWithoutStudentInput = {
    update: XOR<EnquiryUpdateWithoutStudentInput, EnquiryUncheckedUpdateWithoutStudentInput>
    create: XOR<EnquiryCreateWithoutStudentInput, EnquiryUncheckedCreateWithoutStudentInput>
    where?: EnquiryWhereInput
  }

  export type EnquiryUpdateToOneWithWhereWithoutStudentInput = {
    where?: EnquiryWhereInput
    data: XOR<EnquiryUpdateWithoutStudentInput, EnquiryUncheckedUpdateWithoutStudentInput>
  }

  export type EnquiryUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    course?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    leadStatus?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isConverted?: BoolFieldUpdateOperationsInput | boolean
    followUps?: FollowUpUpdateManyWithoutEnquiryNestedInput
    enquiryCourse?: EnquiryCourseUpdateManyWithoutEnquiryNestedInput
    notification?: NotificationUpdateOneWithoutEnquiryNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutEnquiriesNestedInput
  }

  export type EnquiryUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    course?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    leadStatus?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isConverted?: BoolFieldUpdateOperationsInput | boolean
    clientAdminId?: StringFieldUpdateOperationsInput | string
    followUps?: FollowUpUncheckedUpdateManyWithoutEnquiryNestedInput
    enquiryCourse?: EnquiryCourseUncheckedUpdateManyWithoutEnquiryNestedInput
    notification?: NotificationUncheckedUpdateOneWithoutEnquiryNestedInput
  }

  export type LabAllocationUpsertWithWhereUniqueWithoutStudentInput = {
    where: LabAllocationWhereUniqueInput
    update: XOR<LabAllocationUpdateWithoutStudentInput, LabAllocationUncheckedUpdateWithoutStudentInput>
    create: XOR<LabAllocationCreateWithoutStudentInput, LabAllocationUncheckedCreateWithoutStudentInput>
  }

  export type LabAllocationUpdateWithWhereUniqueWithoutStudentInput = {
    where: LabAllocationWhereUniqueInput
    data: XOR<LabAllocationUpdateWithoutStudentInput, LabAllocationUncheckedUpdateWithoutStudentInput>
  }

  export type LabAllocationUpdateManyWithWhereWithoutStudentInput = {
    where: LabAllocationScalarWhereInput
    data: XOR<LabAllocationUpdateManyMutationInput, LabAllocationUncheckedUpdateManyWithoutStudentInput>
  }

  export type StudentCourseUpsertWithWhereUniqueWithoutStudentInput = {
    where: StudentCourseWhereUniqueInput
    update: XOR<StudentCourseUpdateWithoutStudentInput, StudentCourseUncheckedUpdateWithoutStudentInput>
    create: XOR<StudentCourseCreateWithoutStudentInput, StudentCourseUncheckedCreateWithoutStudentInput>
  }

  export type StudentCourseUpdateWithWhereUniqueWithoutStudentInput = {
    where: StudentCourseWhereUniqueInput
    data: XOR<StudentCourseUpdateWithoutStudentInput, StudentCourseUncheckedUpdateWithoutStudentInput>
  }

  export type StudentCourseUpdateManyWithWhereWithoutStudentInput = {
    where: StudentCourseScalarWhereInput
    data: XOR<StudentCourseUpdateManyMutationInput, StudentCourseUncheckedUpdateManyWithoutStudentInput>
  }

  export type FeeStructureUpsertWithWhereUniqueWithoutStudentInput = {
    where: FeeStructureWhereUniqueInput
    update: XOR<FeeStructureUpdateWithoutStudentInput, FeeStructureUncheckedUpdateWithoutStudentInput>
    create: XOR<FeeStructureCreateWithoutStudentInput, FeeStructureUncheckedCreateWithoutStudentInput>
  }

  export type FeeStructureUpdateWithWhereUniqueWithoutStudentInput = {
    where: FeeStructureWhereUniqueInput
    data: XOR<FeeStructureUpdateWithoutStudentInput, FeeStructureUncheckedUpdateWithoutStudentInput>
  }

  export type FeeStructureUpdateManyWithWhereWithoutStudentInput = {
    where: FeeStructureScalarWhereInput
    data: XOR<FeeStructureUpdateManyMutationInput, FeeStructureUncheckedUpdateManyWithoutStudentInput>
  }

  export type StudentFeeUpsertWithWhereUniqueWithoutStudentInput = {
    where: StudentFeeWhereUniqueInput
    update: XOR<StudentFeeUpdateWithoutStudentInput, StudentFeeUncheckedUpdateWithoutStudentInput>
    create: XOR<StudentFeeCreateWithoutStudentInput, StudentFeeUncheckedCreateWithoutStudentInput>
  }

  export type StudentFeeUpdateWithWhereUniqueWithoutStudentInput = {
    where: StudentFeeWhereUniqueInput
    data: XOR<StudentFeeUpdateWithoutStudentInput, StudentFeeUncheckedUpdateWithoutStudentInput>
  }

  export type StudentFeeUpdateManyWithWhereWithoutStudentInput = {
    where: StudentFeeScalarWhereInput
    data: XOR<StudentFeeUpdateManyMutationInput, StudentFeeUncheckedUpdateManyWithoutStudentInput>
  }

  export type AttendanceRecordUpsertWithWhereUniqueWithoutStudentInput = {
    where: AttendanceRecordWhereUniqueInput
    update: XOR<AttendanceRecordUpdateWithoutStudentInput, AttendanceRecordUncheckedUpdateWithoutStudentInput>
    create: XOR<AttendanceRecordCreateWithoutStudentInput, AttendanceRecordUncheckedCreateWithoutStudentInput>
  }

  export type AttendanceRecordUpdateWithWhereUniqueWithoutStudentInput = {
    where: AttendanceRecordWhereUniqueInput
    data: XOR<AttendanceRecordUpdateWithoutStudentInput, AttendanceRecordUncheckedUpdateWithoutStudentInput>
  }

  export type AttendanceRecordUpdateManyWithWhereWithoutStudentInput = {
    where: AttendanceRecordScalarWhereInput
    data: XOR<AttendanceRecordUpdateManyMutationInput, AttendanceRecordUncheckedUpdateManyWithoutStudentInput>
  }

  export type StudentTaskUpsertWithWhereUniqueWithoutStudentInput = {
    where: StudentTaskWhereUniqueInput
    update: XOR<StudentTaskUpdateWithoutStudentInput, StudentTaskUncheckedUpdateWithoutStudentInput>
    create: XOR<StudentTaskCreateWithoutStudentInput, StudentTaskUncheckedCreateWithoutStudentInput>
  }

  export type StudentTaskUpdateWithWhereUniqueWithoutStudentInput = {
    where: StudentTaskWhereUniqueInput
    data: XOR<StudentTaskUpdateWithoutStudentInput, StudentTaskUncheckedUpdateWithoutStudentInput>
  }

  export type StudentTaskUpdateManyWithWhereWithoutStudentInput = {
    where: StudentTaskScalarWhereInput
    data: XOR<StudentTaskUpdateManyMutationInput, StudentTaskUncheckedUpdateManyWithoutStudentInput>
  }

  export type StudentTestUpsertWithWhereUniqueWithoutStudentInput = {
    where: StudentTestWhereUniqueInput
    update: XOR<StudentTestUpdateWithoutStudentInput, StudentTestUncheckedUpdateWithoutStudentInput>
    create: XOR<StudentTestCreateWithoutStudentInput, StudentTestUncheckedCreateWithoutStudentInput>
  }

  export type StudentTestUpdateWithWhereUniqueWithoutStudentInput = {
    where: StudentTestWhereUniqueInput
    data: XOR<StudentTestUpdateWithoutStudentInput, StudentTestUncheckedUpdateWithoutStudentInput>
  }

  export type StudentTestUpdateManyWithWhereWithoutStudentInput = {
    where: StudentTestScalarWhereInput
    data: XOR<StudentTestUpdateManyMutationInput, StudentTestUncheckedUpdateManyWithoutStudentInput>
  }

  export type CourseCompletionUpsertWithWhereUniqueWithoutStudentInput = {
    where: CourseCompletionWhereUniqueInput
    update: XOR<CourseCompletionUpdateWithoutStudentInput, CourseCompletionUncheckedUpdateWithoutStudentInput>
    create: XOR<CourseCompletionCreateWithoutStudentInput, CourseCompletionUncheckedCreateWithoutStudentInput>
  }

  export type CourseCompletionUpdateWithWhereUniqueWithoutStudentInput = {
    where: CourseCompletionWhereUniqueInput
    data: XOR<CourseCompletionUpdateWithoutStudentInput, CourseCompletionUncheckedUpdateWithoutStudentInput>
  }

  export type CourseCompletionUpdateManyWithWhereWithoutStudentInput = {
    where: CourseCompletionScalarWhereInput
    data: XOR<CourseCompletionUpdateManyMutationInput, CourseCompletionUncheckedUpdateManyWithoutStudentInput>
  }

  export type StationeryIssueUpsertWithWhereUniqueWithoutStudentInput = {
    where: StationeryIssueWhereUniqueInput
    update: XOR<StationeryIssueUpdateWithoutStudentInput, StationeryIssueUncheckedUpdateWithoutStudentInput>
    create: XOR<StationeryIssueCreateWithoutStudentInput, StationeryIssueUncheckedCreateWithoutStudentInput>
  }

  export type StationeryIssueUpdateWithWhereUniqueWithoutStudentInput = {
    where: StationeryIssueWhereUniqueInput
    data: XOR<StationeryIssueUpdateWithoutStudentInput, StationeryIssueUncheckedUpdateWithoutStudentInput>
  }

  export type StationeryIssueUpdateManyWithWhereWithoutStudentInput = {
    where: StationeryIssueScalarWhereInput
    data: XOR<StationeryIssueUpdateManyMutationInput, StationeryIssueUncheckedUpdateManyWithoutStudentInput>
  }

  export type CertificateUpsertWithWhereUniqueWithoutStudentInput = {
    where: CertificateWhereUniqueInput
    update: XOR<CertificateUpdateWithoutStudentInput, CertificateUncheckedUpdateWithoutStudentInput>
    create: XOR<CertificateCreateWithoutStudentInput, CertificateUncheckedCreateWithoutStudentInput>
  }

  export type CertificateUpdateWithWhereUniqueWithoutStudentInput = {
    where: CertificateWhereUniqueInput
    data: XOR<CertificateUpdateWithoutStudentInput, CertificateUncheckedUpdateWithoutStudentInput>
  }

  export type CertificateUpdateManyWithWhereWithoutStudentInput = {
    where: CertificateScalarWhereInput
    data: XOR<CertificateUpdateManyMutationInput, CertificateUncheckedUpdateManyWithoutStudentInput>
  }

  export type FinancialRecordUpsertWithWhereUniqueWithoutStudentInput = {
    where: FinancialRecordWhereUniqueInput
    update: XOR<FinancialRecordUpdateWithoutStudentInput, FinancialRecordUncheckedUpdateWithoutStudentInput>
    create: XOR<FinancialRecordCreateWithoutStudentInput, FinancialRecordUncheckedCreateWithoutStudentInput>
  }

  export type FinancialRecordUpdateWithWhereUniqueWithoutStudentInput = {
    where: FinancialRecordWhereUniqueInput
    data: XOR<FinancialRecordUpdateWithoutStudentInput, FinancialRecordUncheckedUpdateWithoutStudentInput>
  }

  export type FinancialRecordUpdateManyWithWhereWithoutStudentInput = {
    where: FinancialRecordScalarWhereInput
    data: XOR<FinancialRecordUpdateManyMutationInput, FinancialRecordUncheckedUpdateManyWithoutStudentInput>
  }

  export type ClientAdminUpsertWithoutStudentsInput = {
    update: XOR<ClientAdminUpdateWithoutStudentsInput, ClientAdminUncheckedUpdateWithoutStudentsInput>
    create: XOR<ClientAdminCreateWithoutStudentsInput, ClientAdminUncheckedCreateWithoutStudentsInput>
    where?: ClientAdminWhereInput
  }

  export type ClientAdminUpdateToOneWithWhereWithoutStudentsInput = {
    where?: ClientAdminWhereInput
    data: XOR<ClientAdminUpdateWithoutStudentsInput, ClientAdminUncheckedUpdateWithoutStudentsInput>
  }

  export type ClientAdminUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    instituteName?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    fullAddress?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    certificateName?: NullableStringFieldUpdateOperationsInput | string | null
    stamp?: NullableStringFieldUpdateOperationsInput | string | null
    sign?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    currentSessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleUsers?: RoleUserUpdateManyWithoutClientAdminNestedInput
    faculties?: FacultyUpdateManyWithoutClientAdminNestedInput
    batches?: BatchUpdateManyWithoutClientAdminNestedInput
    courses?: CourseUpdateManyWithoutClientAdminNestedInput
    enquiryCourse?: EnquiryCourseUpdateManyWithoutClientAdminNestedInput
    labs?: LabUpdateManyWithoutClientAdminNestedInput
    labTimeSlots?: LabTimeSlotUpdateManyWithoutClientAdminNestedInput
    labAllocations?: LabAllocationUpdateManyWithoutClientAdminNestedInput
    activities?: ActivityLogUpdateManyWithoutClientAdminNestedInput
    studentCourses?: StudentCourseUpdateManyWithoutClientAdminNestedInput
    feeStructures?: FeeStructureUpdateManyWithoutClientAdminNestedInput
    studentFees?: StudentFeeUpdateManyWithoutClientAdminNestedInput
    stationeryIssues?: StationeryIssueUpdateManyWithoutClientAdminNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutClientAdminNestedInput
    studentTasks?: StudentTaskUpdateManyWithoutClientAdminNestedInput
    studentTests?: StudentTestUpdateManyWithoutClientAdminNestedInput
    courseCompletions?: CourseCompletionUpdateManyWithoutClientAdminNestedInput
    certificates?: CertificateUpdateManyWithoutClientAdminNestedInput
    financialRecords?: FinancialRecordUpdateManyWithoutClientAdminNestedInput
    enquiries?: EnquiryUpdateManyWithoutClientAdminNestedInput
    notifications?: NotificationUpdateManyWithoutClientAdminNestedInput
    courseFeeStructures?: CourseFeeStructureUpdateManyWithoutClientAdminNestedInput
  }

  export type ClientAdminUncheckedUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    instituteName?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    fullAddress?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    certificateName?: NullableStringFieldUpdateOperationsInput | string | null
    stamp?: NullableStringFieldUpdateOperationsInput | string | null
    sign?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    currentSessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleUsers?: RoleUserUncheckedUpdateManyWithoutClientAdminNestedInput
    faculties?: FacultyUncheckedUpdateManyWithoutClientAdminNestedInput
    batches?: BatchUncheckedUpdateManyWithoutClientAdminNestedInput
    courses?: CourseUncheckedUpdateManyWithoutClientAdminNestedInput
    enquiryCourse?: EnquiryCourseUncheckedUpdateManyWithoutClientAdminNestedInput
    labs?: LabUncheckedUpdateManyWithoutClientAdminNestedInput
    labTimeSlots?: LabTimeSlotUncheckedUpdateManyWithoutClientAdminNestedInput
    labAllocations?: LabAllocationUncheckedUpdateManyWithoutClientAdminNestedInput
    activities?: ActivityLogUncheckedUpdateManyWithoutClientAdminNestedInput
    studentCourses?: StudentCourseUncheckedUpdateManyWithoutClientAdminNestedInput
    feeStructures?: FeeStructureUncheckedUpdateManyWithoutClientAdminNestedInput
    studentFees?: StudentFeeUncheckedUpdateManyWithoutClientAdminNestedInput
    stationeryIssues?: StationeryIssueUncheckedUpdateManyWithoutClientAdminNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutClientAdminNestedInput
    studentTasks?: StudentTaskUncheckedUpdateManyWithoutClientAdminNestedInput
    studentTests?: StudentTestUncheckedUpdateManyWithoutClientAdminNestedInput
    courseCompletions?: CourseCompletionUncheckedUpdateManyWithoutClientAdminNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutClientAdminNestedInput
    financialRecords?: FinancialRecordUncheckedUpdateManyWithoutClientAdminNestedInput
    enquiries?: EnquiryUncheckedUpdateManyWithoutClientAdminNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutClientAdminNestedInput
    courseFeeStructures?: CourseFeeStructureUncheckedUpdateManyWithoutClientAdminNestedInput
  }

  export type CourseFeeStructureCreateWithoutCourseInput = {
    totalAmount: number
    paymentType?: CourseFeeStructureCreatepaymentTypeInput | string[]
    installments?: InstallmentDetailCreateNestedManyWithoutCourseFeeStructureInput
    clientAdmin: ClientAdminCreateNestedOneWithoutCourseFeeStructuresInput
  }

  export type CourseFeeStructureUncheckedCreateWithoutCourseInput = {
    id?: number
    totalAmount: number
    paymentType?: CourseFeeStructureCreatepaymentTypeInput | string[]
    clientAdminId: string
    installments?: InstallmentDetailUncheckedCreateNestedManyWithoutCourseFeeStructureInput
  }

  export type CourseFeeStructureCreateOrConnectWithoutCourseInput = {
    where: CourseFeeStructureWhereUniqueInput
    create: XOR<CourseFeeStructureCreateWithoutCourseInput, CourseFeeStructureUncheckedCreateWithoutCourseInput>
  }

  export type StudentCourseCreateWithoutCourseInput = {
    startDate: Date | string
    endDate: Date | string
    studentCode: string
    internalNotes?: string | null
    status: string
    student: StudentCreateNestedOneWithoutStudentCoursesInput
    batch?: BatchCreateNestedOneWithoutStudentCoursesInput
    certificate?: CertificateCreateNestedOneWithoutStudentCourseInput
    completions?: CourseCompletionCreateNestedManyWithoutStudentCourseInput
    clientAdmin: ClientAdminCreateNestedOneWithoutStudentCoursesInput
  }

  export type StudentCourseUncheckedCreateWithoutCourseInput = {
    id?: number
    studentId: number
    startDate: Date | string
    endDate: Date | string
    studentCode: string
    batchId?: number | null
    internalNotes?: string | null
    status: string
    clientAdminId: string
    certificate?: CertificateUncheckedCreateNestedOneWithoutStudentCourseInput
    completions?: CourseCompletionUncheckedCreateNestedManyWithoutStudentCourseInput
  }

  export type StudentCourseCreateOrConnectWithoutCourseInput = {
    where: StudentCourseWhereUniqueInput
    create: XOR<StudentCourseCreateWithoutCourseInput, StudentCourseUncheckedCreateWithoutCourseInput>
  }

  export type StudentCourseCreateManyCourseInputEnvelope = {
    data: StudentCourseCreateManyCourseInput | StudentCourseCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type EnquiryCourseCreateWithoutCourseInput = {
    enquiry: EnquiryCreateNestedOneWithoutEnquiryCourseInput
    clientAdmin: ClientAdminCreateNestedOneWithoutEnquiryCourseInput
  }

  export type EnquiryCourseUncheckedCreateWithoutCourseInput = {
    id?: number
    enquiryId: string
    clientAdminId: string
  }

  export type EnquiryCourseCreateOrConnectWithoutCourseInput = {
    where: EnquiryCourseWhereUniqueInput
    create: XOR<EnquiryCourseCreateWithoutCourseInput, EnquiryCourseUncheckedCreateWithoutCourseInput>
  }

  export type EnquiryCourseCreateManyCourseInputEnvelope = {
    data: EnquiryCourseCreateManyCourseInput | EnquiryCourseCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type FeeStructureCreateWithoutCourseInput = {
    totalAmount: number
    paymentType: $Enums.PaymentType
    installmentCount?: number | null
    student: StudentCreateNestedOneWithoutFeeStructuresInput
    installment?: InstallmentDetailCreateNestedOneWithoutFeeStructuresInput
    studentFees?: StudentFeeCreateNestedManyWithoutFeeStructureInput
    clientAdmin: ClientAdminCreateNestedOneWithoutFeeStructuresInput
  }

  export type FeeStructureUncheckedCreateWithoutCourseInput = {
    id?: number
    studentId: number
    totalAmount: number
    paymentType: $Enums.PaymentType
    installmentCount?: number | null
    installmentTypeId?: number | null
    clientAdminId: string
    studentFees?: StudentFeeUncheckedCreateNestedManyWithoutFeeStructureInput
  }

  export type FeeStructureCreateOrConnectWithoutCourseInput = {
    where: FeeStructureWhereUniqueInput
    create: XOR<FeeStructureCreateWithoutCourseInput, FeeStructureUncheckedCreateWithoutCourseInput>
  }

  export type FeeStructureCreateManyCourseInputEnvelope = {
    data: FeeStructureCreateManyCourseInput | FeeStructureCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type StationeryIssueCreateWithoutCourseInput = {
    issueDate: Date | string
    quantity: number
    remarks?: string | null
    student: StudentCreateNestedOneWithoutStationeryInput
    item: StationeryItemCreateNestedOneWithoutStationeryIssuesInput
    clientAdmin: ClientAdminCreateNestedOneWithoutStationeryIssuesInput
  }

  export type StationeryIssueUncheckedCreateWithoutCourseInput = {
    id?: number
    studentId: number
    itemId: number
    issueDate: Date | string
    quantity: number
    remarks?: string | null
    clientAdminId: string
  }

  export type StationeryIssueCreateOrConnectWithoutCourseInput = {
    where: StationeryIssueWhereUniqueInput
    create: XOR<StationeryIssueCreateWithoutCourseInput, StationeryIssueUncheckedCreateWithoutCourseInput>
  }

  export type StationeryIssueCreateManyCourseInputEnvelope = {
    data: StationeryIssueCreateManyCourseInput | StationeryIssueCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type StudentFeeCreateWithoutCourseInput = {
    dueDate: Date | string
    amountDue: number
    amountPaid: number
    paymentDate?: Date | string | null
    paymentMode: $Enums.PaymentMode
    receiptNo: string
    paymentStatus?: $Enums.PaymentStatus
    student: StudentCreateNestedOneWithoutFeeRecordsInput
    feeLogs?: StudentFeeLogCreateNestedManyWithoutStudentFeeInput
    feeStructure?: FeeStructureCreateNestedOneWithoutStudentFeesInput
    notification?: NotificationCreateNestedOneWithoutPaymentInput
    clientAdmin: ClientAdminCreateNestedOneWithoutStudentFeesInput
  }

  export type StudentFeeUncheckedCreateWithoutCourseInput = {
    id?: number
    studentId: number
    dueDate: Date | string
    amountDue: number
    amountPaid: number
    paymentDate?: Date | string | null
    paymentMode: $Enums.PaymentMode
    receiptNo: string
    paymentStatus?: $Enums.PaymentStatus
    clientAdminId: string
    feeLogs?: StudentFeeLogUncheckedCreateNestedManyWithoutStudentFeeInput
    notification?: NotificationUncheckedCreateNestedOneWithoutPaymentInput
  }

  export type StudentFeeCreateOrConnectWithoutCourseInput = {
    where: StudentFeeWhereUniqueInput
    create: XOR<StudentFeeCreateWithoutCourseInput, StudentFeeUncheckedCreateWithoutCourseInput>
  }

  export type StudentFeeCreateManyCourseInputEnvelope = {
    data: StudentFeeCreateManyCourseInput | StudentFeeCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type AttendanceRecordCreateWithoutCourseInput = {
    date: Date | string
    present: boolean
    batchId?: number | null
    student: StudentCreateNestedOneWithoutAttendanceInput
    markedBy: FacultyCreateNestedOneWithoutAttendanceInput
    clientAdmin: ClientAdminCreateNestedOneWithoutAttendanceRecordsInput
  }

  export type AttendanceRecordUncheckedCreateWithoutCourseInput = {
    id?: number
    studentId: number
    date: Date | string
    present: boolean
    facultyId: number
    batchId?: number | null
    clientAdminId: string
  }

  export type AttendanceRecordCreateOrConnectWithoutCourseInput = {
    where: AttendanceRecordWhereUniqueInput
    create: XOR<AttendanceRecordCreateWithoutCourseInput, AttendanceRecordUncheckedCreateWithoutCourseInput>
  }

  export type AttendanceRecordCreateManyCourseInputEnvelope = {
    data: AttendanceRecordCreateManyCourseInput | AttendanceRecordCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type StudentTaskCreateWithoutCourseInput = {
    assignedDate: Date | string
    dueDate: Date | string
    description: string
    status: string
    facultyRemarks?: string | null
    grade?: string | null
    student: StudentCreateNestedOneWithoutTasksInput
    faculty?: FacultyCreateNestedOneWithoutTasksInput
    clientAdmin: ClientAdminCreateNestedOneWithoutStudentTasksInput
  }

  export type StudentTaskUncheckedCreateWithoutCourseInput = {
    id?: number
    studentId: number
    assignedDate: Date | string
    dueDate: Date | string
    description: string
    status: string
    facultyRemarks?: string | null
    grade?: string | null
    facultyId?: number | null
    clientAdminId: string
  }

  export type StudentTaskCreateOrConnectWithoutCourseInput = {
    where: StudentTaskWhereUniqueInput
    create: XOR<StudentTaskCreateWithoutCourseInput, StudentTaskUncheckedCreateWithoutCourseInput>
  }

  export type StudentTaskCreateManyCourseInputEnvelope = {
    data: StudentTaskCreateManyCourseInput | StudentTaskCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type StudentTestCreateWithoutCourseInput = {
    testName: string
    testDate: Date | string
    totalMarks: number
    marksObtained: number
    grade: string
    student: StudentCreateNestedOneWithoutTestsInput
    clientAdmin: ClientAdminCreateNestedOneWithoutStudentTestsInput
  }

  export type StudentTestUncheckedCreateWithoutCourseInput = {
    id?: number
    studentId: number
    testName: string
    testDate: Date | string
    totalMarks: number
    marksObtained: number
    grade: string
    clientAdminId: string
  }

  export type StudentTestCreateOrConnectWithoutCourseInput = {
    where: StudentTestWhereUniqueInput
    create: XOR<StudentTestCreateWithoutCourseInput, StudentTestUncheckedCreateWithoutCourseInput>
  }

  export type StudentTestCreateManyCourseInputEnvelope = {
    data: StudentTestCreateManyCourseInput | StudentTestCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type CertificateCreateWithoutCourseInput = {
    issueDate: Date | string
    certificateUrl: string
    student: StudentCreateNestedOneWithoutCertificatesInput
    studentCourse: StudentCourseCreateNestedOneWithoutCertificateInput
    clientAdmin: ClientAdminCreateNestedOneWithoutCertificatesInput
  }

  export type CertificateUncheckedCreateWithoutCourseInput = {
    id?: number
    studentId: number
    studentCourseId: number
    issueDate: Date | string
    certificateUrl: string
    clientAdminId: string
  }

  export type CertificateCreateOrConnectWithoutCourseInput = {
    where: CertificateWhereUniqueInput
    create: XOR<CertificateCreateWithoutCourseInput, CertificateUncheckedCreateWithoutCourseInput>
  }

  export type CertificateCreateManyCourseInputEnvelope = {
    data: CertificateCreateManyCourseInput | CertificateCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type FinancialRecordCreateWithoutCourseInput = {
    id?: string
    recordType: $Enums.RecordType
    amount: number
    description?: string | null
    date?: Date | string
    paymentMode?: $Enums.PaymentMode | null
    student?: StudentCreateNestedOneWithoutFinancialRecordsInput
    faculty?: FacultyCreateNestedOneWithoutFinancialRecordsInput
    lab?: LabCreateNestedOneWithoutFinancialRecordsInput
    clientAdmin: ClientAdminCreateNestedOneWithoutFinancialRecordsInput
  }

  export type FinancialRecordUncheckedCreateWithoutCourseInput = {
    id?: string
    clientAdminId: string
    recordType: $Enums.RecordType
    amount: number
    description?: string | null
    date?: Date | string
    paymentMode?: $Enums.PaymentMode | null
    studentId?: number | null
    facultyId?: number | null
    labId?: number | null
  }

  export type FinancialRecordCreateOrConnectWithoutCourseInput = {
    where: FinancialRecordWhereUniqueInput
    create: XOR<FinancialRecordCreateWithoutCourseInput, FinancialRecordUncheckedCreateWithoutCourseInput>
  }

  export type FinancialRecordCreateManyCourseInputEnvelope = {
    data: FinancialRecordCreateManyCourseInput | FinancialRecordCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type BatchCourseCreateWithoutCourseInput = {
    pcsReserved?: number | null
    batch: BatchCreateNestedOneWithoutBatchCoursesInput
  }

  export type BatchCourseUncheckedCreateWithoutCourseInput = {
    id?: number
    batchId: number
    pcsReserved?: number | null
  }

  export type BatchCourseCreateOrConnectWithoutCourseInput = {
    where: BatchCourseWhereUniqueInput
    create: XOR<BatchCourseCreateWithoutCourseInput, BatchCourseUncheckedCreateWithoutCourseInput>
  }

  export type BatchCourseCreateManyCourseInputEnvelope = {
    data: BatchCourseCreateManyCourseInput | BatchCourseCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type ClientAdminCreateWithoutCoursesInput = {
    id?: string
    name: string
    email: string
    password: string
    instituteName: string
    slug: string
    fullAddress: string
    logo?: string | null
    certificateName?: string | null
    stamp?: string | null
    sign?: string | null
    contact: string
    position: string
    country: string
    state: string
    city: string
    zipCode: string
    createdAt?: Date | string
    role?: $Enums.UserRole
    currentSessionToken?: string | null
    lastLoginAt?: Date | string | null
    roleUsers?: RoleUserCreateNestedManyWithoutClientAdminInput
    faculties?: FacultyCreateNestedManyWithoutClientAdminInput
    batches?: BatchCreateNestedManyWithoutClientAdminInput
    enquiryCourse?: EnquiryCourseCreateNestedManyWithoutClientAdminInput
    labs?: LabCreateNestedManyWithoutClientAdminInput
    labTimeSlots?: LabTimeSlotCreateNestedManyWithoutClientAdminInput
    labAllocations?: LabAllocationCreateNestedManyWithoutClientAdminInput
    students?: StudentCreateNestedManyWithoutClientAdminInput
    activities?: ActivityLogCreateNestedManyWithoutClientAdminInput
    studentCourses?: StudentCourseCreateNestedManyWithoutClientAdminInput
    feeStructures?: FeeStructureCreateNestedManyWithoutClientAdminInput
    studentFees?: StudentFeeCreateNestedManyWithoutClientAdminInput
    stationeryIssues?: StationeryIssueCreateNestedManyWithoutClientAdminInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutClientAdminInput
    studentTasks?: StudentTaskCreateNestedManyWithoutClientAdminInput
    studentTests?: StudentTestCreateNestedManyWithoutClientAdminInput
    courseCompletions?: CourseCompletionCreateNestedManyWithoutClientAdminInput
    certificates?: CertificateCreateNestedManyWithoutClientAdminInput
    financialRecords?: FinancialRecordCreateNestedManyWithoutClientAdminInput
    enquiries?: EnquiryCreateNestedManyWithoutClientAdminInput
    notifications?: NotificationCreateNestedManyWithoutClientAdminInput
    courseFeeStructures?: CourseFeeStructureCreateNestedManyWithoutClientAdminInput
  }

  export type ClientAdminUncheckedCreateWithoutCoursesInput = {
    id?: string
    name: string
    email: string
    password: string
    instituteName: string
    slug: string
    fullAddress: string
    logo?: string | null
    certificateName?: string | null
    stamp?: string | null
    sign?: string | null
    contact: string
    position: string
    country: string
    state: string
    city: string
    zipCode: string
    createdAt?: Date | string
    role?: $Enums.UserRole
    currentSessionToken?: string | null
    lastLoginAt?: Date | string | null
    roleUsers?: RoleUserUncheckedCreateNestedManyWithoutClientAdminInput
    faculties?: FacultyUncheckedCreateNestedManyWithoutClientAdminInput
    batches?: BatchUncheckedCreateNestedManyWithoutClientAdminInput
    enquiryCourse?: EnquiryCourseUncheckedCreateNestedManyWithoutClientAdminInput
    labs?: LabUncheckedCreateNestedManyWithoutClientAdminInput
    labTimeSlots?: LabTimeSlotUncheckedCreateNestedManyWithoutClientAdminInput
    labAllocations?: LabAllocationUncheckedCreateNestedManyWithoutClientAdminInput
    students?: StudentUncheckedCreateNestedManyWithoutClientAdminInput
    activities?: ActivityLogUncheckedCreateNestedManyWithoutClientAdminInput
    studentCourses?: StudentCourseUncheckedCreateNestedManyWithoutClientAdminInput
    feeStructures?: FeeStructureUncheckedCreateNestedManyWithoutClientAdminInput
    studentFees?: StudentFeeUncheckedCreateNestedManyWithoutClientAdminInput
    stationeryIssues?: StationeryIssueUncheckedCreateNestedManyWithoutClientAdminInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutClientAdminInput
    studentTasks?: StudentTaskUncheckedCreateNestedManyWithoutClientAdminInput
    studentTests?: StudentTestUncheckedCreateNestedManyWithoutClientAdminInput
    courseCompletions?: CourseCompletionUncheckedCreateNestedManyWithoutClientAdminInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutClientAdminInput
    financialRecords?: FinancialRecordUncheckedCreateNestedManyWithoutClientAdminInput
    enquiries?: EnquiryUncheckedCreateNestedManyWithoutClientAdminInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutClientAdminInput
    courseFeeStructures?: CourseFeeStructureUncheckedCreateNestedManyWithoutClientAdminInput
  }

  export type ClientAdminCreateOrConnectWithoutCoursesInput = {
    where: ClientAdminWhereUniqueInput
    create: XOR<ClientAdminCreateWithoutCoursesInput, ClientAdminUncheckedCreateWithoutCoursesInput>
  }

  export type CourseFeeStructureUpsertWithoutCourseInput = {
    update: XOR<CourseFeeStructureUpdateWithoutCourseInput, CourseFeeStructureUncheckedUpdateWithoutCourseInput>
    create: XOR<CourseFeeStructureCreateWithoutCourseInput, CourseFeeStructureUncheckedCreateWithoutCourseInput>
    where?: CourseFeeStructureWhereInput
  }

  export type CourseFeeStructureUpdateToOneWithWhereWithoutCourseInput = {
    where?: CourseFeeStructureWhereInput
    data: XOR<CourseFeeStructureUpdateWithoutCourseInput, CourseFeeStructureUncheckedUpdateWithoutCourseInput>
  }

  export type CourseFeeStructureUpdateWithoutCourseInput = {
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paymentType?: CourseFeeStructureUpdatepaymentTypeInput | string[]
    installments?: InstallmentDetailUpdateManyWithoutCourseFeeStructureNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutCourseFeeStructuresNestedInput
  }

  export type CourseFeeStructureUncheckedUpdateWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paymentType?: CourseFeeStructureUpdatepaymentTypeInput | string[]
    clientAdminId?: StringFieldUpdateOperationsInput | string
    installments?: InstallmentDetailUncheckedUpdateManyWithoutCourseFeeStructureNestedInput
  }

  export type StudentCourseUpsertWithWhereUniqueWithoutCourseInput = {
    where: StudentCourseWhereUniqueInput
    update: XOR<StudentCourseUpdateWithoutCourseInput, StudentCourseUncheckedUpdateWithoutCourseInput>
    create: XOR<StudentCourseCreateWithoutCourseInput, StudentCourseUncheckedCreateWithoutCourseInput>
  }

  export type StudentCourseUpdateWithWhereUniqueWithoutCourseInput = {
    where: StudentCourseWhereUniqueInput
    data: XOR<StudentCourseUpdateWithoutCourseInput, StudentCourseUncheckedUpdateWithoutCourseInput>
  }

  export type StudentCourseUpdateManyWithWhereWithoutCourseInput = {
    where: StudentCourseScalarWhereInput
    data: XOR<StudentCourseUpdateManyMutationInput, StudentCourseUncheckedUpdateManyWithoutCourseInput>
  }

  export type EnquiryCourseUpsertWithWhereUniqueWithoutCourseInput = {
    where: EnquiryCourseWhereUniqueInput
    update: XOR<EnquiryCourseUpdateWithoutCourseInput, EnquiryCourseUncheckedUpdateWithoutCourseInput>
    create: XOR<EnquiryCourseCreateWithoutCourseInput, EnquiryCourseUncheckedCreateWithoutCourseInput>
  }

  export type EnquiryCourseUpdateWithWhereUniqueWithoutCourseInput = {
    where: EnquiryCourseWhereUniqueInput
    data: XOR<EnquiryCourseUpdateWithoutCourseInput, EnquiryCourseUncheckedUpdateWithoutCourseInput>
  }

  export type EnquiryCourseUpdateManyWithWhereWithoutCourseInput = {
    where: EnquiryCourseScalarWhereInput
    data: XOR<EnquiryCourseUpdateManyMutationInput, EnquiryCourseUncheckedUpdateManyWithoutCourseInput>
  }

  export type FeeStructureUpsertWithWhereUniqueWithoutCourseInput = {
    where: FeeStructureWhereUniqueInput
    update: XOR<FeeStructureUpdateWithoutCourseInput, FeeStructureUncheckedUpdateWithoutCourseInput>
    create: XOR<FeeStructureCreateWithoutCourseInput, FeeStructureUncheckedCreateWithoutCourseInput>
  }

  export type FeeStructureUpdateWithWhereUniqueWithoutCourseInput = {
    where: FeeStructureWhereUniqueInput
    data: XOR<FeeStructureUpdateWithoutCourseInput, FeeStructureUncheckedUpdateWithoutCourseInput>
  }

  export type FeeStructureUpdateManyWithWhereWithoutCourseInput = {
    where: FeeStructureScalarWhereInput
    data: XOR<FeeStructureUpdateManyMutationInput, FeeStructureUncheckedUpdateManyWithoutCourseInput>
  }

  export type StationeryIssueUpsertWithWhereUniqueWithoutCourseInput = {
    where: StationeryIssueWhereUniqueInput
    update: XOR<StationeryIssueUpdateWithoutCourseInput, StationeryIssueUncheckedUpdateWithoutCourseInput>
    create: XOR<StationeryIssueCreateWithoutCourseInput, StationeryIssueUncheckedCreateWithoutCourseInput>
  }

  export type StationeryIssueUpdateWithWhereUniqueWithoutCourseInput = {
    where: StationeryIssueWhereUniqueInput
    data: XOR<StationeryIssueUpdateWithoutCourseInput, StationeryIssueUncheckedUpdateWithoutCourseInput>
  }

  export type StationeryIssueUpdateManyWithWhereWithoutCourseInput = {
    where: StationeryIssueScalarWhereInput
    data: XOR<StationeryIssueUpdateManyMutationInput, StationeryIssueUncheckedUpdateManyWithoutCourseInput>
  }

  export type StudentFeeUpsertWithWhereUniqueWithoutCourseInput = {
    where: StudentFeeWhereUniqueInput
    update: XOR<StudentFeeUpdateWithoutCourseInput, StudentFeeUncheckedUpdateWithoutCourseInput>
    create: XOR<StudentFeeCreateWithoutCourseInput, StudentFeeUncheckedCreateWithoutCourseInput>
  }

  export type StudentFeeUpdateWithWhereUniqueWithoutCourseInput = {
    where: StudentFeeWhereUniqueInput
    data: XOR<StudentFeeUpdateWithoutCourseInput, StudentFeeUncheckedUpdateWithoutCourseInput>
  }

  export type StudentFeeUpdateManyWithWhereWithoutCourseInput = {
    where: StudentFeeScalarWhereInput
    data: XOR<StudentFeeUpdateManyMutationInput, StudentFeeUncheckedUpdateManyWithoutCourseInput>
  }

  export type AttendanceRecordUpsertWithWhereUniqueWithoutCourseInput = {
    where: AttendanceRecordWhereUniqueInput
    update: XOR<AttendanceRecordUpdateWithoutCourseInput, AttendanceRecordUncheckedUpdateWithoutCourseInput>
    create: XOR<AttendanceRecordCreateWithoutCourseInput, AttendanceRecordUncheckedCreateWithoutCourseInput>
  }

  export type AttendanceRecordUpdateWithWhereUniqueWithoutCourseInput = {
    where: AttendanceRecordWhereUniqueInput
    data: XOR<AttendanceRecordUpdateWithoutCourseInput, AttendanceRecordUncheckedUpdateWithoutCourseInput>
  }

  export type AttendanceRecordUpdateManyWithWhereWithoutCourseInput = {
    where: AttendanceRecordScalarWhereInput
    data: XOR<AttendanceRecordUpdateManyMutationInput, AttendanceRecordUncheckedUpdateManyWithoutCourseInput>
  }

  export type StudentTaskUpsertWithWhereUniqueWithoutCourseInput = {
    where: StudentTaskWhereUniqueInput
    update: XOR<StudentTaskUpdateWithoutCourseInput, StudentTaskUncheckedUpdateWithoutCourseInput>
    create: XOR<StudentTaskCreateWithoutCourseInput, StudentTaskUncheckedCreateWithoutCourseInput>
  }

  export type StudentTaskUpdateWithWhereUniqueWithoutCourseInput = {
    where: StudentTaskWhereUniqueInput
    data: XOR<StudentTaskUpdateWithoutCourseInput, StudentTaskUncheckedUpdateWithoutCourseInput>
  }

  export type StudentTaskUpdateManyWithWhereWithoutCourseInput = {
    where: StudentTaskScalarWhereInput
    data: XOR<StudentTaskUpdateManyMutationInput, StudentTaskUncheckedUpdateManyWithoutCourseInput>
  }

  export type StudentTestUpsertWithWhereUniqueWithoutCourseInput = {
    where: StudentTestWhereUniqueInput
    update: XOR<StudentTestUpdateWithoutCourseInput, StudentTestUncheckedUpdateWithoutCourseInput>
    create: XOR<StudentTestCreateWithoutCourseInput, StudentTestUncheckedCreateWithoutCourseInput>
  }

  export type StudentTestUpdateWithWhereUniqueWithoutCourseInput = {
    where: StudentTestWhereUniqueInput
    data: XOR<StudentTestUpdateWithoutCourseInput, StudentTestUncheckedUpdateWithoutCourseInput>
  }

  export type StudentTestUpdateManyWithWhereWithoutCourseInput = {
    where: StudentTestScalarWhereInput
    data: XOR<StudentTestUpdateManyMutationInput, StudentTestUncheckedUpdateManyWithoutCourseInput>
  }

  export type CertificateUpsertWithWhereUniqueWithoutCourseInput = {
    where: CertificateWhereUniqueInput
    update: XOR<CertificateUpdateWithoutCourseInput, CertificateUncheckedUpdateWithoutCourseInput>
    create: XOR<CertificateCreateWithoutCourseInput, CertificateUncheckedCreateWithoutCourseInput>
  }

  export type CertificateUpdateWithWhereUniqueWithoutCourseInput = {
    where: CertificateWhereUniqueInput
    data: XOR<CertificateUpdateWithoutCourseInput, CertificateUncheckedUpdateWithoutCourseInput>
  }

  export type CertificateUpdateManyWithWhereWithoutCourseInput = {
    where: CertificateScalarWhereInput
    data: XOR<CertificateUpdateManyMutationInput, CertificateUncheckedUpdateManyWithoutCourseInput>
  }

  export type FinancialRecordUpsertWithWhereUniqueWithoutCourseInput = {
    where: FinancialRecordWhereUniqueInput
    update: XOR<FinancialRecordUpdateWithoutCourseInput, FinancialRecordUncheckedUpdateWithoutCourseInput>
    create: XOR<FinancialRecordCreateWithoutCourseInput, FinancialRecordUncheckedCreateWithoutCourseInput>
  }

  export type FinancialRecordUpdateWithWhereUniqueWithoutCourseInput = {
    where: FinancialRecordWhereUniqueInput
    data: XOR<FinancialRecordUpdateWithoutCourseInput, FinancialRecordUncheckedUpdateWithoutCourseInput>
  }

  export type FinancialRecordUpdateManyWithWhereWithoutCourseInput = {
    where: FinancialRecordScalarWhereInput
    data: XOR<FinancialRecordUpdateManyMutationInput, FinancialRecordUncheckedUpdateManyWithoutCourseInput>
  }

  export type BatchCourseUpsertWithWhereUniqueWithoutCourseInput = {
    where: BatchCourseWhereUniqueInput
    update: XOR<BatchCourseUpdateWithoutCourseInput, BatchCourseUncheckedUpdateWithoutCourseInput>
    create: XOR<BatchCourseCreateWithoutCourseInput, BatchCourseUncheckedCreateWithoutCourseInput>
  }

  export type BatchCourseUpdateWithWhereUniqueWithoutCourseInput = {
    where: BatchCourseWhereUniqueInput
    data: XOR<BatchCourseUpdateWithoutCourseInput, BatchCourseUncheckedUpdateWithoutCourseInput>
  }

  export type BatchCourseUpdateManyWithWhereWithoutCourseInput = {
    where: BatchCourseScalarWhereInput
    data: XOR<BatchCourseUpdateManyMutationInput, BatchCourseUncheckedUpdateManyWithoutCourseInput>
  }

  export type BatchCourseScalarWhereInput = {
    AND?: BatchCourseScalarWhereInput | BatchCourseScalarWhereInput[]
    OR?: BatchCourseScalarWhereInput[]
    NOT?: BatchCourseScalarWhereInput | BatchCourseScalarWhereInput[]
    id?: IntFilter<"BatchCourse"> | number
    batchId?: IntFilter<"BatchCourse"> | number
    courseId?: IntFilter<"BatchCourse"> | number
    pcsReserved?: IntNullableFilter<"BatchCourse"> | number | null
  }

  export type ClientAdminUpsertWithoutCoursesInput = {
    update: XOR<ClientAdminUpdateWithoutCoursesInput, ClientAdminUncheckedUpdateWithoutCoursesInput>
    create: XOR<ClientAdminCreateWithoutCoursesInput, ClientAdminUncheckedCreateWithoutCoursesInput>
    where?: ClientAdminWhereInput
  }

  export type ClientAdminUpdateToOneWithWhereWithoutCoursesInput = {
    where?: ClientAdminWhereInput
    data: XOR<ClientAdminUpdateWithoutCoursesInput, ClientAdminUncheckedUpdateWithoutCoursesInput>
  }

  export type ClientAdminUpdateWithoutCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    instituteName?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    fullAddress?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    certificateName?: NullableStringFieldUpdateOperationsInput | string | null
    stamp?: NullableStringFieldUpdateOperationsInput | string | null
    sign?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    currentSessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleUsers?: RoleUserUpdateManyWithoutClientAdminNestedInput
    faculties?: FacultyUpdateManyWithoutClientAdminNestedInput
    batches?: BatchUpdateManyWithoutClientAdminNestedInput
    enquiryCourse?: EnquiryCourseUpdateManyWithoutClientAdminNestedInput
    labs?: LabUpdateManyWithoutClientAdminNestedInput
    labTimeSlots?: LabTimeSlotUpdateManyWithoutClientAdminNestedInput
    labAllocations?: LabAllocationUpdateManyWithoutClientAdminNestedInput
    students?: StudentUpdateManyWithoutClientAdminNestedInput
    activities?: ActivityLogUpdateManyWithoutClientAdminNestedInput
    studentCourses?: StudentCourseUpdateManyWithoutClientAdminNestedInput
    feeStructures?: FeeStructureUpdateManyWithoutClientAdminNestedInput
    studentFees?: StudentFeeUpdateManyWithoutClientAdminNestedInput
    stationeryIssues?: StationeryIssueUpdateManyWithoutClientAdminNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutClientAdminNestedInput
    studentTasks?: StudentTaskUpdateManyWithoutClientAdminNestedInput
    studentTests?: StudentTestUpdateManyWithoutClientAdminNestedInput
    courseCompletions?: CourseCompletionUpdateManyWithoutClientAdminNestedInput
    certificates?: CertificateUpdateManyWithoutClientAdminNestedInput
    financialRecords?: FinancialRecordUpdateManyWithoutClientAdminNestedInput
    enquiries?: EnquiryUpdateManyWithoutClientAdminNestedInput
    notifications?: NotificationUpdateManyWithoutClientAdminNestedInput
    courseFeeStructures?: CourseFeeStructureUpdateManyWithoutClientAdminNestedInput
  }

  export type ClientAdminUncheckedUpdateWithoutCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    instituteName?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    fullAddress?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    certificateName?: NullableStringFieldUpdateOperationsInput | string | null
    stamp?: NullableStringFieldUpdateOperationsInput | string | null
    sign?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    currentSessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleUsers?: RoleUserUncheckedUpdateManyWithoutClientAdminNestedInput
    faculties?: FacultyUncheckedUpdateManyWithoutClientAdminNestedInput
    batches?: BatchUncheckedUpdateManyWithoutClientAdminNestedInput
    enquiryCourse?: EnquiryCourseUncheckedUpdateManyWithoutClientAdminNestedInput
    labs?: LabUncheckedUpdateManyWithoutClientAdminNestedInput
    labTimeSlots?: LabTimeSlotUncheckedUpdateManyWithoutClientAdminNestedInput
    labAllocations?: LabAllocationUncheckedUpdateManyWithoutClientAdminNestedInput
    students?: StudentUncheckedUpdateManyWithoutClientAdminNestedInput
    activities?: ActivityLogUncheckedUpdateManyWithoutClientAdminNestedInput
    studentCourses?: StudentCourseUncheckedUpdateManyWithoutClientAdminNestedInput
    feeStructures?: FeeStructureUncheckedUpdateManyWithoutClientAdminNestedInput
    studentFees?: StudentFeeUncheckedUpdateManyWithoutClientAdminNestedInput
    stationeryIssues?: StationeryIssueUncheckedUpdateManyWithoutClientAdminNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutClientAdminNestedInput
    studentTasks?: StudentTaskUncheckedUpdateManyWithoutClientAdminNestedInput
    studentTests?: StudentTestUncheckedUpdateManyWithoutClientAdminNestedInput
    courseCompletions?: CourseCompletionUncheckedUpdateManyWithoutClientAdminNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutClientAdminNestedInput
    financialRecords?: FinancialRecordUncheckedUpdateManyWithoutClientAdminNestedInput
    enquiries?: EnquiryUncheckedUpdateManyWithoutClientAdminNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutClientAdminNestedInput
    courseFeeStructures?: CourseFeeStructureUncheckedUpdateManyWithoutClientAdminNestedInput
  }

  export type CourseCreateWithoutCourseFeeStructureInput = {
    name: string
    durationWeeks: number
    description?: string | null
    studentCourses?: StudentCourseCreateNestedManyWithoutCourseInput
    enquiryCourse?: EnquiryCourseCreateNestedManyWithoutCourseInput
    feeStructures?: FeeStructureCreateNestedManyWithoutCourseInput
    stationery?: StationeryIssueCreateNestedManyWithoutCourseInput
    studentFees?: StudentFeeCreateNestedManyWithoutCourseInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutCourseInput
    studentTasks?: StudentTaskCreateNestedManyWithoutCourseInput
    studentTests?: StudentTestCreateNestedManyWithoutCourseInput
    certificates?: CertificateCreateNestedManyWithoutCourseInput
    financialRecords?: FinancialRecordCreateNestedManyWithoutCourseInput
    batchCourses?: BatchCourseCreateNestedManyWithoutCourseInput
    clientAdmin: ClientAdminCreateNestedOneWithoutCoursesInput
  }

  export type CourseUncheckedCreateWithoutCourseFeeStructureInput = {
    id?: number
    name: string
    durationWeeks: number
    description?: string | null
    clientAdminId: string
    studentCourses?: StudentCourseUncheckedCreateNestedManyWithoutCourseInput
    enquiryCourse?: EnquiryCourseUncheckedCreateNestedManyWithoutCourseInput
    feeStructures?: FeeStructureUncheckedCreateNestedManyWithoutCourseInput
    stationery?: StationeryIssueUncheckedCreateNestedManyWithoutCourseInput
    studentFees?: StudentFeeUncheckedCreateNestedManyWithoutCourseInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutCourseInput
    studentTasks?: StudentTaskUncheckedCreateNestedManyWithoutCourseInput
    studentTests?: StudentTestUncheckedCreateNestedManyWithoutCourseInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutCourseInput
    financialRecords?: FinancialRecordUncheckedCreateNestedManyWithoutCourseInput
    batchCourses?: BatchCourseUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutCourseFeeStructureInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutCourseFeeStructureInput, CourseUncheckedCreateWithoutCourseFeeStructureInput>
  }

  export type InstallmentDetailCreateWithoutCourseFeeStructureInput = {
    number: number
    amount: number
    feeStructures?: FeeStructureCreateNestedManyWithoutInstallmentInput
  }

  export type InstallmentDetailUncheckedCreateWithoutCourseFeeStructureInput = {
    id?: number
    number: number
    amount: number
    feeStructures?: FeeStructureUncheckedCreateNestedManyWithoutInstallmentInput
  }

  export type InstallmentDetailCreateOrConnectWithoutCourseFeeStructureInput = {
    where: InstallmentDetailWhereUniqueInput
    create: XOR<InstallmentDetailCreateWithoutCourseFeeStructureInput, InstallmentDetailUncheckedCreateWithoutCourseFeeStructureInput>
  }

  export type InstallmentDetailCreateManyCourseFeeStructureInputEnvelope = {
    data: InstallmentDetailCreateManyCourseFeeStructureInput | InstallmentDetailCreateManyCourseFeeStructureInput[]
    skipDuplicates?: boolean
  }

  export type ClientAdminCreateWithoutCourseFeeStructuresInput = {
    id?: string
    name: string
    email: string
    password: string
    instituteName: string
    slug: string
    fullAddress: string
    logo?: string | null
    certificateName?: string | null
    stamp?: string | null
    sign?: string | null
    contact: string
    position: string
    country: string
    state: string
    city: string
    zipCode: string
    createdAt?: Date | string
    role?: $Enums.UserRole
    currentSessionToken?: string | null
    lastLoginAt?: Date | string | null
    roleUsers?: RoleUserCreateNestedManyWithoutClientAdminInput
    faculties?: FacultyCreateNestedManyWithoutClientAdminInput
    batches?: BatchCreateNestedManyWithoutClientAdminInput
    courses?: CourseCreateNestedManyWithoutClientAdminInput
    enquiryCourse?: EnquiryCourseCreateNestedManyWithoutClientAdminInput
    labs?: LabCreateNestedManyWithoutClientAdminInput
    labTimeSlots?: LabTimeSlotCreateNestedManyWithoutClientAdminInput
    labAllocations?: LabAllocationCreateNestedManyWithoutClientAdminInput
    students?: StudentCreateNestedManyWithoutClientAdminInput
    activities?: ActivityLogCreateNestedManyWithoutClientAdminInput
    studentCourses?: StudentCourseCreateNestedManyWithoutClientAdminInput
    feeStructures?: FeeStructureCreateNestedManyWithoutClientAdminInput
    studentFees?: StudentFeeCreateNestedManyWithoutClientAdminInput
    stationeryIssues?: StationeryIssueCreateNestedManyWithoutClientAdminInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutClientAdminInput
    studentTasks?: StudentTaskCreateNestedManyWithoutClientAdminInput
    studentTests?: StudentTestCreateNestedManyWithoutClientAdminInput
    courseCompletions?: CourseCompletionCreateNestedManyWithoutClientAdminInput
    certificates?: CertificateCreateNestedManyWithoutClientAdminInput
    financialRecords?: FinancialRecordCreateNestedManyWithoutClientAdminInput
    enquiries?: EnquiryCreateNestedManyWithoutClientAdminInput
    notifications?: NotificationCreateNestedManyWithoutClientAdminInput
  }

  export type ClientAdminUncheckedCreateWithoutCourseFeeStructuresInput = {
    id?: string
    name: string
    email: string
    password: string
    instituteName: string
    slug: string
    fullAddress: string
    logo?: string | null
    certificateName?: string | null
    stamp?: string | null
    sign?: string | null
    contact: string
    position: string
    country: string
    state: string
    city: string
    zipCode: string
    createdAt?: Date | string
    role?: $Enums.UserRole
    currentSessionToken?: string | null
    lastLoginAt?: Date | string | null
    roleUsers?: RoleUserUncheckedCreateNestedManyWithoutClientAdminInput
    faculties?: FacultyUncheckedCreateNestedManyWithoutClientAdminInput
    batches?: BatchUncheckedCreateNestedManyWithoutClientAdminInput
    courses?: CourseUncheckedCreateNestedManyWithoutClientAdminInput
    enquiryCourse?: EnquiryCourseUncheckedCreateNestedManyWithoutClientAdminInput
    labs?: LabUncheckedCreateNestedManyWithoutClientAdminInput
    labTimeSlots?: LabTimeSlotUncheckedCreateNestedManyWithoutClientAdminInput
    labAllocations?: LabAllocationUncheckedCreateNestedManyWithoutClientAdminInput
    students?: StudentUncheckedCreateNestedManyWithoutClientAdminInput
    activities?: ActivityLogUncheckedCreateNestedManyWithoutClientAdminInput
    studentCourses?: StudentCourseUncheckedCreateNestedManyWithoutClientAdminInput
    feeStructures?: FeeStructureUncheckedCreateNestedManyWithoutClientAdminInput
    studentFees?: StudentFeeUncheckedCreateNestedManyWithoutClientAdminInput
    stationeryIssues?: StationeryIssueUncheckedCreateNestedManyWithoutClientAdminInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutClientAdminInput
    studentTasks?: StudentTaskUncheckedCreateNestedManyWithoutClientAdminInput
    studentTests?: StudentTestUncheckedCreateNestedManyWithoutClientAdminInput
    courseCompletions?: CourseCompletionUncheckedCreateNestedManyWithoutClientAdminInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutClientAdminInput
    financialRecords?: FinancialRecordUncheckedCreateNestedManyWithoutClientAdminInput
    enquiries?: EnquiryUncheckedCreateNestedManyWithoutClientAdminInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutClientAdminInput
  }

  export type ClientAdminCreateOrConnectWithoutCourseFeeStructuresInput = {
    where: ClientAdminWhereUniqueInput
    create: XOR<ClientAdminCreateWithoutCourseFeeStructuresInput, ClientAdminUncheckedCreateWithoutCourseFeeStructuresInput>
  }

  export type CourseUpsertWithoutCourseFeeStructureInput = {
    update: XOR<CourseUpdateWithoutCourseFeeStructureInput, CourseUncheckedUpdateWithoutCourseFeeStructureInput>
    create: XOR<CourseCreateWithoutCourseFeeStructureInput, CourseUncheckedCreateWithoutCourseFeeStructureInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutCourseFeeStructureInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutCourseFeeStructureInput, CourseUncheckedUpdateWithoutCourseFeeStructureInput>
  }

  export type CourseUpdateWithoutCourseFeeStructureInput = {
    name?: StringFieldUpdateOperationsInput | string
    durationWeeks?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    studentCourses?: StudentCourseUpdateManyWithoutCourseNestedInput
    enquiryCourse?: EnquiryCourseUpdateManyWithoutCourseNestedInput
    feeStructures?: FeeStructureUpdateManyWithoutCourseNestedInput
    stationery?: StationeryIssueUpdateManyWithoutCourseNestedInput
    studentFees?: StudentFeeUpdateManyWithoutCourseNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutCourseNestedInput
    studentTasks?: StudentTaskUpdateManyWithoutCourseNestedInput
    studentTests?: StudentTestUpdateManyWithoutCourseNestedInput
    certificates?: CertificateUpdateManyWithoutCourseNestedInput
    financialRecords?: FinancialRecordUpdateManyWithoutCourseNestedInput
    batchCourses?: BatchCourseUpdateManyWithoutCourseNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutCoursesNestedInput
  }

  export type CourseUncheckedUpdateWithoutCourseFeeStructureInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    durationWeeks?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    clientAdminId?: StringFieldUpdateOperationsInput | string
    studentCourses?: StudentCourseUncheckedUpdateManyWithoutCourseNestedInput
    enquiryCourse?: EnquiryCourseUncheckedUpdateManyWithoutCourseNestedInput
    feeStructures?: FeeStructureUncheckedUpdateManyWithoutCourseNestedInput
    stationery?: StationeryIssueUncheckedUpdateManyWithoutCourseNestedInput
    studentFees?: StudentFeeUncheckedUpdateManyWithoutCourseNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutCourseNestedInput
    studentTasks?: StudentTaskUncheckedUpdateManyWithoutCourseNestedInput
    studentTests?: StudentTestUncheckedUpdateManyWithoutCourseNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutCourseNestedInput
    financialRecords?: FinancialRecordUncheckedUpdateManyWithoutCourseNestedInput
    batchCourses?: BatchCourseUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type InstallmentDetailUpsertWithWhereUniqueWithoutCourseFeeStructureInput = {
    where: InstallmentDetailWhereUniqueInput
    update: XOR<InstallmentDetailUpdateWithoutCourseFeeStructureInput, InstallmentDetailUncheckedUpdateWithoutCourseFeeStructureInput>
    create: XOR<InstallmentDetailCreateWithoutCourseFeeStructureInput, InstallmentDetailUncheckedCreateWithoutCourseFeeStructureInput>
  }

  export type InstallmentDetailUpdateWithWhereUniqueWithoutCourseFeeStructureInput = {
    where: InstallmentDetailWhereUniqueInput
    data: XOR<InstallmentDetailUpdateWithoutCourseFeeStructureInput, InstallmentDetailUncheckedUpdateWithoutCourseFeeStructureInput>
  }

  export type InstallmentDetailUpdateManyWithWhereWithoutCourseFeeStructureInput = {
    where: InstallmentDetailScalarWhereInput
    data: XOR<InstallmentDetailUpdateManyMutationInput, InstallmentDetailUncheckedUpdateManyWithoutCourseFeeStructureInput>
  }

  export type InstallmentDetailScalarWhereInput = {
    AND?: InstallmentDetailScalarWhereInput | InstallmentDetailScalarWhereInput[]
    OR?: InstallmentDetailScalarWhereInput[]
    NOT?: InstallmentDetailScalarWhereInput | InstallmentDetailScalarWhereInput[]
    id?: IntFilter<"InstallmentDetail"> | number
    CourseFeeStructureId?: IntFilter<"InstallmentDetail"> | number
    number?: IntFilter<"InstallmentDetail"> | number
    amount?: FloatFilter<"InstallmentDetail"> | number
  }

  export type ClientAdminUpsertWithoutCourseFeeStructuresInput = {
    update: XOR<ClientAdminUpdateWithoutCourseFeeStructuresInput, ClientAdminUncheckedUpdateWithoutCourseFeeStructuresInput>
    create: XOR<ClientAdminCreateWithoutCourseFeeStructuresInput, ClientAdminUncheckedCreateWithoutCourseFeeStructuresInput>
    where?: ClientAdminWhereInput
  }

  export type ClientAdminUpdateToOneWithWhereWithoutCourseFeeStructuresInput = {
    where?: ClientAdminWhereInput
    data: XOR<ClientAdminUpdateWithoutCourseFeeStructuresInput, ClientAdminUncheckedUpdateWithoutCourseFeeStructuresInput>
  }

  export type ClientAdminUpdateWithoutCourseFeeStructuresInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    instituteName?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    fullAddress?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    certificateName?: NullableStringFieldUpdateOperationsInput | string | null
    stamp?: NullableStringFieldUpdateOperationsInput | string | null
    sign?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    currentSessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleUsers?: RoleUserUpdateManyWithoutClientAdminNestedInput
    faculties?: FacultyUpdateManyWithoutClientAdminNestedInput
    batches?: BatchUpdateManyWithoutClientAdminNestedInput
    courses?: CourseUpdateManyWithoutClientAdminNestedInput
    enquiryCourse?: EnquiryCourseUpdateManyWithoutClientAdminNestedInput
    labs?: LabUpdateManyWithoutClientAdminNestedInput
    labTimeSlots?: LabTimeSlotUpdateManyWithoutClientAdminNestedInput
    labAllocations?: LabAllocationUpdateManyWithoutClientAdminNestedInput
    students?: StudentUpdateManyWithoutClientAdminNestedInput
    activities?: ActivityLogUpdateManyWithoutClientAdminNestedInput
    studentCourses?: StudentCourseUpdateManyWithoutClientAdminNestedInput
    feeStructures?: FeeStructureUpdateManyWithoutClientAdminNestedInput
    studentFees?: StudentFeeUpdateManyWithoutClientAdminNestedInput
    stationeryIssues?: StationeryIssueUpdateManyWithoutClientAdminNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutClientAdminNestedInput
    studentTasks?: StudentTaskUpdateManyWithoutClientAdminNestedInput
    studentTests?: StudentTestUpdateManyWithoutClientAdminNestedInput
    courseCompletions?: CourseCompletionUpdateManyWithoutClientAdminNestedInput
    certificates?: CertificateUpdateManyWithoutClientAdminNestedInput
    financialRecords?: FinancialRecordUpdateManyWithoutClientAdminNestedInput
    enquiries?: EnquiryUpdateManyWithoutClientAdminNestedInput
    notifications?: NotificationUpdateManyWithoutClientAdminNestedInput
  }

  export type ClientAdminUncheckedUpdateWithoutCourseFeeStructuresInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    instituteName?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    fullAddress?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    certificateName?: NullableStringFieldUpdateOperationsInput | string | null
    stamp?: NullableStringFieldUpdateOperationsInput | string | null
    sign?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    currentSessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleUsers?: RoleUserUncheckedUpdateManyWithoutClientAdminNestedInput
    faculties?: FacultyUncheckedUpdateManyWithoutClientAdminNestedInput
    batches?: BatchUncheckedUpdateManyWithoutClientAdminNestedInput
    courses?: CourseUncheckedUpdateManyWithoutClientAdminNestedInput
    enquiryCourse?: EnquiryCourseUncheckedUpdateManyWithoutClientAdminNestedInput
    labs?: LabUncheckedUpdateManyWithoutClientAdminNestedInput
    labTimeSlots?: LabTimeSlotUncheckedUpdateManyWithoutClientAdminNestedInput
    labAllocations?: LabAllocationUncheckedUpdateManyWithoutClientAdminNestedInput
    students?: StudentUncheckedUpdateManyWithoutClientAdminNestedInput
    activities?: ActivityLogUncheckedUpdateManyWithoutClientAdminNestedInput
    studentCourses?: StudentCourseUncheckedUpdateManyWithoutClientAdminNestedInput
    feeStructures?: FeeStructureUncheckedUpdateManyWithoutClientAdminNestedInput
    studentFees?: StudentFeeUncheckedUpdateManyWithoutClientAdminNestedInput
    stationeryIssues?: StationeryIssueUncheckedUpdateManyWithoutClientAdminNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutClientAdminNestedInput
    studentTasks?: StudentTaskUncheckedUpdateManyWithoutClientAdminNestedInput
    studentTests?: StudentTestUncheckedUpdateManyWithoutClientAdminNestedInput
    courseCompletions?: CourseCompletionUncheckedUpdateManyWithoutClientAdminNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutClientAdminNestedInput
    financialRecords?: FinancialRecordUncheckedUpdateManyWithoutClientAdminNestedInput
    enquiries?: EnquiryUncheckedUpdateManyWithoutClientAdminNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutClientAdminNestedInput
  }

  export type FacultyCreateWithoutBatchesInput = {
    name: string
    email: string
    password: string
    contact: string
    joiningDate: Date | string
    specialization?: string | null
    role?: $Enums.UserRole
    country: string
    state: string
    city: string
    zipCode: string
    currentSessionToken?: string | null
    lastLoginAt?: Date | string | null
    attendance?: AttendanceRecordCreateNestedManyWithoutMarkedByInput
    tasks?: StudentTaskCreateNestedManyWithoutFacultyInput
    financialRecords?: FinancialRecordCreateNestedManyWithoutFacultyInput
    clientAdmin: ClientAdminCreateNestedOneWithoutFacultiesInput
  }

  export type FacultyUncheckedCreateWithoutBatchesInput = {
    id?: number
    name: string
    email: string
    password: string
    contact: string
    joiningDate: Date | string
    specialization?: string | null
    role?: $Enums.UserRole
    country: string
    state: string
    city: string
    zipCode: string
    currentSessionToken?: string | null
    lastLoginAt?: Date | string | null
    clientAdminId: string
    attendance?: AttendanceRecordUncheckedCreateNestedManyWithoutMarkedByInput
    tasks?: StudentTaskUncheckedCreateNestedManyWithoutFacultyInput
    financialRecords?: FinancialRecordUncheckedCreateNestedManyWithoutFacultyInput
  }

  export type FacultyCreateOrConnectWithoutBatchesInput = {
    where: FacultyWhereUniqueInput
    create: XOR<FacultyCreateWithoutBatchesInput, FacultyUncheckedCreateWithoutBatchesInput>
  }

  export type LabTimeSlotCreateWithoutBatchesInput = {
    startTime: string
    endTime: string
    day: string
    availablePCs: number
    lab: LabCreateNestedOneWithoutTimeSlotsInput
    allocations?: LabAllocationCreateNestedManyWithoutLabTimeSlotInput
    clientAdmin: ClientAdminCreateNestedOneWithoutLabTimeSlotsInput
  }

  export type LabTimeSlotUncheckedCreateWithoutBatchesInput = {
    id?: number
    startTime: string
    endTime: string
    day: string
    labId: number
    availablePCs: number
    clientAdminId: string
    allocations?: LabAllocationUncheckedCreateNestedManyWithoutLabTimeSlotInput
  }

  export type LabTimeSlotCreateOrConnectWithoutBatchesInput = {
    where: LabTimeSlotWhereUniqueInput
    create: XOR<LabTimeSlotCreateWithoutBatchesInput, LabTimeSlotUncheckedCreateWithoutBatchesInput>
  }

  export type StudentCourseCreateWithoutBatchInput = {
    startDate: Date | string
    endDate: Date | string
    studentCode: string
    internalNotes?: string | null
    status: string
    student: StudentCreateNestedOneWithoutStudentCoursesInput
    course: CourseCreateNestedOneWithoutStudentCoursesInput
    certificate?: CertificateCreateNestedOneWithoutStudentCourseInput
    completions?: CourseCompletionCreateNestedManyWithoutStudentCourseInput
    clientAdmin: ClientAdminCreateNestedOneWithoutStudentCoursesInput
  }

  export type StudentCourseUncheckedCreateWithoutBatchInput = {
    id?: number
    studentId: number
    courseId: number
    startDate: Date | string
    endDate: Date | string
    studentCode: string
    internalNotes?: string | null
    status: string
    clientAdminId: string
    certificate?: CertificateUncheckedCreateNestedOneWithoutStudentCourseInput
    completions?: CourseCompletionUncheckedCreateNestedManyWithoutStudentCourseInput
  }

  export type StudentCourseCreateOrConnectWithoutBatchInput = {
    where: StudentCourseWhereUniqueInput
    create: XOR<StudentCourseCreateWithoutBatchInput, StudentCourseUncheckedCreateWithoutBatchInput>
  }

  export type StudentCourseCreateManyBatchInputEnvelope = {
    data: StudentCourseCreateManyBatchInput | StudentCourseCreateManyBatchInput[]
    skipDuplicates?: boolean
  }

  export type BatchCourseCreateWithoutBatchInput = {
    pcsReserved?: number | null
    course: CourseCreateNestedOneWithoutBatchCoursesInput
  }

  export type BatchCourseUncheckedCreateWithoutBatchInput = {
    id?: number
    courseId: number
    pcsReserved?: number | null
  }

  export type BatchCourseCreateOrConnectWithoutBatchInput = {
    where: BatchCourseWhereUniqueInput
    create: XOR<BatchCourseCreateWithoutBatchInput, BatchCourseUncheckedCreateWithoutBatchInput>
  }

  export type BatchCourseCreateManyBatchInputEnvelope = {
    data: BatchCourseCreateManyBatchInput | BatchCourseCreateManyBatchInput[]
    skipDuplicates?: boolean
  }

  export type ClientAdminCreateWithoutBatchesInput = {
    id?: string
    name: string
    email: string
    password: string
    instituteName: string
    slug: string
    fullAddress: string
    logo?: string | null
    certificateName?: string | null
    stamp?: string | null
    sign?: string | null
    contact: string
    position: string
    country: string
    state: string
    city: string
    zipCode: string
    createdAt?: Date | string
    role?: $Enums.UserRole
    currentSessionToken?: string | null
    lastLoginAt?: Date | string | null
    roleUsers?: RoleUserCreateNestedManyWithoutClientAdminInput
    faculties?: FacultyCreateNestedManyWithoutClientAdminInput
    courses?: CourseCreateNestedManyWithoutClientAdminInput
    enquiryCourse?: EnquiryCourseCreateNestedManyWithoutClientAdminInput
    labs?: LabCreateNestedManyWithoutClientAdminInput
    labTimeSlots?: LabTimeSlotCreateNestedManyWithoutClientAdminInput
    labAllocations?: LabAllocationCreateNestedManyWithoutClientAdminInput
    students?: StudentCreateNestedManyWithoutClientAdminInput
    activities?: ActivityLogCreateNestedManyWithoutClientAdminInput
    studentCourses?: StudentCourseCreateNestedManyWithoutClientAdminInput
    feeStructures?: FeeStructureCreateNestedManyWithoutClientAdminInput
    studentFees?: StudentFeeCreateNestedManyWithoutClientAdminInput
    stationeryIssues?: StationeryIssueCreateNestedManyWithoutClientAdminInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutClientAdminInput
    studentTasks?: StudentTaskCreateNestedManyWithoutClientAdminInput
    studentTests?: StudentTestCreateNestedManyWithoutClientAdminInput
    courseCompletions?: CourseCompletionCreateNestedManyWithoutClientAdminInput
    certificates?: CertificateCreateNestedManyWithoutClientAdminInput
    financialRecords?: FinancialRecordCreateNestedManyWithoutClientAdminInput
    enquiries?: EnquiryCreateNestedManyWithoutClientAdminInput
    notifications?: NotificationCreateNestedManyWithoutClientAdminInput
    courseFeeStructures?: CourseFeeStructureCreateNestedManyWithoutClientAdminInput
  }

  export type ClientAdminUncheckedCreateWithoutBatchesInput = {
    id?: string
    name: string
    email: string
    password: string
    instituteName: string
    slug: string
    fullAddress: string
    logo?: string | null
    certificateName?: string | null
    stamp?: string | null
    sign?: string | null
    contact: string
    position: string
    country: string
    state: string
    city: string
    zipCode: string
    createdAt?: Date | string
    role?: $Enums.UserRole
    currentSessionToken?: string | null
    lastLoginAt?: Date | string | null
    roleUsers?: RoleUserUncheckedCreateNestedManyWithoutClientAdminInput
    faculties?: FacultyUncheckedCreateNestedManyWithoutClientAdminInput
    courses?: CourseUncheckedCreateNestedManyWithoutClientAdminInput
    enquiryCourse?: EnquiryCourseUncheckedCreateNestedManyWithoutClientAdminInput
    labs?: LabUncheckedCreateNestedManyWithoutClientAdminInput
    labTimeSlots?: LabTimeSlotUncheckedCreateNestedManyWithoutClientAdminInput
    labAllocations?: LabAllocationUncheckedCreateNestedManyWithoutClientAdminInput
    students?: StudentUncheckedCreateNestedManyWithoutClientAdminInput
    activities?: ActivityLogUncheckedCreateNestedManyWithoutClientAdminInput
    studentCourses?: StudentCourseUncheckedCreateNestedManyWithoutClientAdminInput
    feeStructures?: FeeStructureUncheckedCreateNestedManyWithoutClientAdminInput
    studentFees?: StudentFeeUncheckedCreateNestedManyWithoutClientAdminInput
    stationeryIssues?: StationeryIssueUncheckedCreateNestedManyWithoutClientAdminInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutClientAdminInput
    studentTasks?: StudentTaskUncheckedCreateNestedManyWithoutClientAdminInput
    studentTests?: StudentTestUncheckedCreateNestedManyWithoutClientAdminInput
    courseCompletions?: CourseCompletionUncheckedCreateNestedManyWithoutClientAdminInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutClientAdminInput
    financialRecords?: FinancialRecordUncheckedCreateNestedManyWithoutClientAdminInput
    enquiries?: EnquiryUncheckedCreateNestedManyWithoutClientAdminInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutClientAdminInput
    courseFeeStructures?: CourseFeeStructureUncheckedCreateNestedManyWithoutClientAdminInput
  }

  export type ClientAdminCreateOrConnectWithoutBatchesInput = {
    where: ClientAdminWhereUniqueInput
    create: XOR<ClientAdminCreateWithoutBatchesInput, ClientAdminUncheckedCreateWithoutBatchesInput>
  }

  export type FacultyUpsertWithoutBatchesInput = {
    update: XOR<FacultyUpdateWithoutBatchesInput, FacultyUncheckedUpdateWithoutBatchesInput>
    create: XOR<FacultyCreateWithoutBatchesInput, FacultyUncheckedCreateWithoutBatchesInput>
    where?: FacultyWhereInput
  }

  export type FacultyUpdateToOneWithWhereWithoutBatchesInput = {
    where?: FacultyWhereInput
    data: XOR<FacultyUpdateWithoutBatchesInput, FacultyUncheckedUpdateWithoutBatchesInput>
  }

  export type FacultyUpdateWithoutBatchesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    joiningDate?: DateTimeFieldUpdateOperationsInput | Date | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    currentSessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attendance?: AttendanceRecordUpdateManyWithoutMarkedByNestedInput
    tasks?: StudentTaskUpdateManyWithoutFacultyNestedInput
    financialRecords?: FinancialRecordUpdateManyWithoutFacultyNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutFacultiesNestedInput
  }

  export type FacultyUncheckedUpdateWithoutBatchesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    joiningDate?: DateTimeFieldUpdateOperationsInput | Date | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    currentSessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clientAdminId?: StringFieldUpdateOperationsInput | string
    attendance?: AttendanceRecordUncheckedUpdateManyWithoutMarkedByNestedInput
    tasks?: StudentTaskUncheckedUpdateManyWithoutFacultyNestedInput
    financialRecords?: FinancialRecordUncheckedUpdateManyWithoutFacultyNestedInput
  }

  export type LabTimeSlotUpsertWithoutBatchesInput = {
    update: XOR<LabTimeSlotUpdateWithoutBatchesInput, LabTimeSlotUncheckedUpdateWithoutBatchesInput>
    create: XOR<LabTimeSlotCreateWithoutBatchesInput, LabTimeSlotUncheckedCreateWithoutBatchesInput>
    where?: LabTimeSlotWhereInput
  }

  export type LabTimeSlotUpdateToOneWithWhereWithoutBatchesInput = {
    where?: LabTimeSlotWhereInput
    data: XOR<LabTimeSlotUpdateWithoutBatchesInput, LabTimeSlotUncheckedUpdateWithoutBatchesInput>
  }

  export type LabTimeSlotUpdateWithoutBatchesInput = {
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    day?: StringFieldUpdateOperationsInput | string
    availablePCs?: IntFieldUpdateOperationsInput | number
    lab?: LabUpdateOneRequiredWithoutTimeSlotsNestedInput
    allocations?: LabAllocationUpdateManyWithoutLabTimeSlotNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutLabTimeSlotsNestedInput
  }

  export type LabTimeSlotUncheckedUpdateWithoutBatchesInput = {
    id?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    day?: StringFieldUpdateOperationsInput | string
    labId?: IntFieldUpdateOperationsInput | number
    availablePCs?: IntFieldUpdateOperationsInput | number
    clientAdminId?: StringFieldUpdateOperationsInput | string
    allocations?: LabAllocationUncheckedUpdateManyWithoutLabTimeSlotNestedInput
  }

  export type StudentCourseUpsertWithWhereUniqueWithoutBatchInput = {
    where: StudentCourseWhereUniqueInput
    update: XOR<StudentCourseUpdateWithoutBatchInput, StudentCourseUncheckedUpdateWithoutBatchInput>
    create: XOR<StudentCourseCreateWithoutBatchInput, StudentCourseUncheckedCreateWithoutBatchInput>
  }

  export type StudentCourseUpdateWithWhereUniqueWithoutBatchInput = {
    where: StudentCourseWhereUniqueInput
    data: XOR<StudentCourseUpdateWithoutBatchInput, StudentCourseUncheckedUpdateWithoutBatchInput>
  }

  export type StudentCourseUpdateManyWithWhereWithoutBatchInput = {
    where: StudentCourseScalarWhereInput
    data: XOR<StudentCourseUpdateManyMutationInput, StudentCourseUncheckedUpdateManyWithoutBatchInput>
  }

  export type BatchCourseUpsertWithWhereUniqueWithoutBatchInput = {
    where: BatchCourseWhereUniqueInput
    update: XOR<BatchCourseUpdateWithoutBatchInput, BatchCourseUncheckedUpdateWithoutBatchInput>
    create: XOR<BatchCourseCreateWithoutBatchInput, BatchCourseUncheckedCreateWithoutBatchInput>
  }

  export type BatchCourseUpdateWithWhereUniqueWithoutBatchInput = {
    where: BatchCourseWhereUniqueInput
    data: XOR<BatchCourseUpdateWithoutBatchInput, BatchCourseUncheckedUpdateWithoutBatchInput>
  }

  export type BatchCourseUpdateManyWithWhereWithoutBatchInput = {
    where: BatchCourseScalarWhereInput
    data: XOR<BatchCourseUpdateManyMutationInput, BatchCourseUncheckedUpdateManyWithoutBatchInput>
  }

  export type ClientAdminUpsertWithoutBatchesInput = {
    update: XOR<ClientAdminUpdateWithoutBatchesInput, ClientAdminUncheckedUpdateWithoutBatchesInput>
    create: XOR<ClientAdminCreateWithoutBatchesInput, ClientAdminUncheckedCreateWithoutBatchesInput>
    where?: ClientAdminWhereInput
  }

  export type ClientAdminUpdateToOneWithWhereWithoutBatchesInput = {
    where?: ClientAdminWhereInput
    data: XOR<ClientAdminUpdateWithoutBatchesInput, ClientAdminUncheckedUpdateWithoutBatchesInput>
  }

  export type ClientAdminUpdateWithoutBatchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    instituteName?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    fullAddress?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    certificateName?: NullableStringFieldUpdateOperationsInput | string | null
    stamp?: NullableStringFieldUpdateOperationsInput | string | null
    sign?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    currentSessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleUsers?: RoleUserUpdateManyWithoutClientAdminNestedInput
    faculties?: FacultyUpdateManyWithoutClientAdminNestedInput
    courses?: CourseUpdateManyWithoutClientAdminNestedInput
    enquiryCourse?: EnquiryCourseUpdateManyWithoutClientAdminNestedInput
    labs?: LabUpdateManyWithoutClientAdminNestedInput
    labTimeSlots?: LabTimeSlotUpdateManyWithoutClientAdminNestedInput
    labAllocations?: LabAllocationUpdateManyWithoutClientAdminNestedInput
    students?: StudentUpdateManyWithoutClientAdminNestedInput
    activities?: ActivityLogUpdateManyWithoutClientAdminNestedInput
    studentCourses?: StudentCourseUpdateManyWithoutClientAdminNestedInput
    feeStructures?: FeeStructureUpdateManyWithoutClientAdminNestedInput
    studentFees?: StudentFeeUpdateManyWithoutClientAdminNestedInput
    stationeryIssues?: StationeryIssueUpdateManyWithoutClientAdminNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutClientAdminNestedInput
    studentTasks?: StudentTaskUpdateManyWithoutClientAdminNestedInput
    studentTests?: StudentTestUpdateManyWithoutClientAdminNestedInput
    courseCompletions?: CourseCompletionUpdateManyWithoutClientAdminNestedInput
    certificates?: CertificateUpdateManyWithoutClientAdminNestedInput
    financialRecords?: FinancialRecordUpdateManyWithoutClientAdminNestedInput
    enquiries?: EnquiryUpdateManyWithoutClientAdminNestedInput
    notifications?: NotificationUpdateManyWithoutClientAdminNestedInput
    courseFeeStructures?: CourseFeeStructureUpdateManyWithoutClientAdminNestedInput
  }

  export type ClientAdminUncheckedUpdateWithoutBatchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    instituteName?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    fullAddress?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    certificateName?: NullableStringFieldUpdateOperationsInput | string | null
    stamp?: NullableStringFieldUpdateOperationsInput | string | null
    sign?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    currentSessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleUsers?: RoleUserUncheckedUpdateManyWithoutClientAdminNestedInput
    faculties?: FacultyUncheckedUpdateManyWithoutClientAdminNestedInput
    courses?: CourseUncheckedUpdateManyWithoutClientAdminNestedInput
    enquiryCourse?: EnquiryCourseUncheckedUpdateManyWithoutClientAdminNestedInput
    labs?: LabUncheckedUpdateManyWithoutClientAdminNestedInput
    labTimeSlots?: LabTimeSlotUncheckedUpdateManyWithoutClientAdminNestedInput
    labAllocations?: LabAllocationUncheckedUpdateManyWithoutClientAdminNestedInput
    students?: StudentUncheckedUpdateManyWithoutClientAdminNestedInput
    activities?: ActivityLogUncheckedUpdateManyWithoutClientAdminNestedInput
    studentCourses?: StudentCourseUncheckedUpdateManyWithoutClientAdminNestedInput
    feeStructures?: FeeStructureUncheckedUpdateManyWithoutClientAdminNestedInput
    studentFees?: StudentFeeUncheckedUpdateManyWithoutClientAdminNestedInput
    stationeryIssues?: StationeryIssueUncheckedUpdateManyWithoutClientAdminNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutClientAdminNestedInput
    studentTasks?: StudentTaskUncheckedUpdateManyWithoutClientAdminNestedInput
    studentTests?: StudentTestUncheckedUpdateManyWithoutClientAdminNestedInput
    courseCompletions?: CourseCompletionUncheckedUpdateManyWithoutClientAdminNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutClientAdminNestedInput
    financialRecords?: FinancialRecordUncheckedUpdateManyWithoutClientAdminNestedInput
    enquiries?: EnquiryUncheckedUpdateManyWithoutClientAdminNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutClientAdminNestedInput
    courseFeeStructures?: CourseFeeStructureUncheckedUpdateManyWithoutClientAdminNestedInput
  }

  export type BatchCreateWithoutBatchCoursesInput = {
    name: string
    faculty?: FacultyCreateNestedOneWithoutBatchesInput
    labTimeSlot: LabTimeSlotCreateNestedOneWithoutBatchesInput
    studentCourses?: StudentCourseCreateNestedManyWithoutBatchInput
    clientAdmin: ClientAdminCreateNestedOneWithoutBatchesInput
  }

  export type BatchUncheckedCreateWithoutBatchCoursesInput = {
    id?: number
    name: string
    facultyId?: number | null
    labTimeSlotId: number
    clientAdminId: string
    studentCourses?: StudentCourseUncheckedCreateNestedManyWithoutBatchInput
  }

  export type BatchCreateOrConnectWithoutBatchCoursesInput = {
    where: BatchWhereUniqueInput
    create: XOR<BatchCreateWithoutBatchCoursesInput, BatchUncheckedCreateWithoutBatchCoursesInput>
  }

  export type CourseCreateWithoutBatchCoursesInput = {
    name: string
    durationWeeks: number
    description?: string | null
    courseFeeStructure?: CourseFeeStructureCreateNestedOneWithoutCourseInput
    studentCourses?: StudentCourseCreateNestedManyWithoutCourseInput
    enquiryCourse?: EnquiryCourseCreateNestedManyWithoutCourseInput
    feeStructures?: FeeStructureCreateNestedManyWithoutCourseInput
    stationery?: StationeryIssueCreateNestedManyWithoutCourseInput
    studentFees?: StudentFeeCreateNestedManyWithoutCourseInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutCourseInput
    studentTasks?: StudentTaskCreateNestedManyWithoutCourseInput
    studentTests?: StudentTestCreateNestedManyWithoutCourseInput
    certificates?: CertificateCreateNestedManyWithoutCourseInput
    financialRecords?: FinancialRecordCreateNestedManyWithoutCourseInput
    clientAdmin: ClientAdminCreateNestedOneWithoutCoursesInput
  }

  export type CourseUncheckedCreateWithoutBatchCoursesInput = {
    id?: number
    name: string
    durationWeeks: number
    description?: string | null
    clientAdminId: string
    courseFeeStructure?: CourseFeeStructureUncheckedCreateNestedOneWithoutCourseInput
    studentCourses?: StudentCourseUncheckedCreateNestedManyWithoutCourseInput
    enquiryCourse?: EnquiryCourseUncheckedCreateNestedManyWithoutCourseInput
    feeStructures?: FeeStructureUncheckedCreateNestedManyWithoutCourseInput
    stationery?: StationeryIssueUncheckedCreateNestedManyWithoutCourseInput
    studentFees?: StudentFeeUncheckedCreateNestedManyWithoutCourseInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutCourseInput
    studentTasks?: StudentTaskUncheckedCreateNestedManyWithoutCourseInput
    studentTests?: StudentTestUncheckedCreateNestedManyWithoutCourseInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutCourseInput
    financialRecords?: FinancialRecordUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutBatchCoursesInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutBatchCoursesInput, CourseUncheckedCreateWithoutBatchCoursesInput>
  }

  export type BatchUpsertWithoutBatchCoursesInput = {
    update: XOR<BatchUpdateWithoutBatchCoursesInput, BatchUncheckedUpdateWithoutBatchCoursesInput>
    create: XOR<BatchCreateWithoutBatchCoursesInput, BatchUncheckedCreateWithoutBatchCoursesInput>
    where?: BatchWhereInput
  }

  export type BatchUpdateToOneWithWhereWithoutBatchCoursesInput = {
    where?: BatchWhereInput
    data: XOR<BatchUpdateWithoutBatchCoursesInput, BatchUncheckedUpdateWithoutBatchCoursesInput>
  }

  export type BatchUpdateWithoutBatchCoursesInput = {
    name?: StringFieldUpdateOperationsInput | string
    faculty?: FacultyUpdateOneWithoutBatchesNestedInput
    labTimeSlot?: LabTimeSlotUpdateOneRequiredWithoutBatchesNestedInput
    studentCourses?: StudentCourseUpdateManyWithoutBatchNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutBatchesNestedInput
  }

  export type BatchUncheckedUpdateWithoutBatchCoursesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    facultyId?: NullableIntFieldUpdateOperationsInput | number | null
    labTimeSlotId?: IntFieldUpdateOperationsInput | number
    clientAdminId?: StringFieldUpdateOperationsInput | string
    studentCourses?: StudentCourseUncheckedUpdateManyWithoutBatchNestedInput
  }

  export type CourseUpsertWithoutBatchCoursesInput = {
    update: XOR<CourseUpdateWithoutBatchCoursesInput, CourseUncheckedUpdateWithoutBatchCoursesInput>
    create: XOR<CourseCreateWithoutBatchCoursesInput, CourseUncheckedCreateWithoutBatchCoursesInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutBatchCoursesInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutBatchCoursesInput, CourseUncheckedUpdateWithoutBatchCoursesInput>
  }

  export type CourseUpdateWithoutBatchCoursesInput = {
    name?: StringFieldUpdateOperationsInput | string
    durationWeeks?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    courseFeeStructure?: CourseFeeStructureUpdateOneWithoutCourseNestedInput
    studentCourses?: StudentCourseUpdateManyWithoutCourseNestedInput
    enquiryCourse?: EnquiryCourseUpdateManyWithoutCourseNestedInput
    feeStructures?: FeeStructureUpdateManyWithoutCourseNestedInput
    stationery?: StationeryIssueUpdateManyWithoutCourseNestedInput
    studentFees?: StudentFeeUpdateManyWithoutCourseNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutCourseNestedInput
    studentTasks?: StudentTaskUpdateManyWithoutCourseNestedInput
    studentTests?: StudentTestUpdateManyWithoutCourseNestedInput
    certificates?: CertificateUpdateManyWithoutCourseNestedInput
    financialRecords?: FinancialRecordUpdateManyWithoutCourseNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutCoursesNestedInput
  }

  export type CourseUncheckedUpdateWithoutBatchCoursesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    durationWeeks?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    clientAdminId?: StringFieldUpdateOperationsInput | string
    courseFeeStructure?: CourseFeeStructureUncheckedUpdateOneWithoutCourseNestedInput
    studentCourses?: StudentCourseUncheckedUpdateManyWithoutCourseNestedInput
    enquiryCourse?: EnquiryCourseUncheckedUpdateManyWithoutCourseNestedInput
    feeStructures?: FeeStructureUncheckedUpdateManyWithoutCourseNestedInput
    stationery?: StationeryIssueUncheckedUpdateManyWithoutCourseNestedInput
    studentFees?: StudentFeeUncheckedUpdateManyWithoutCourseNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutCourseNestedInput
    studentTasks?: StudentTaskUncheckedUpdateManyWithoutCourseNestedInput
    studentTests?: StudentTestUncheckedUpdateManyWithoutCourseNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutCourseNestedInput
    financialRecords?: FinancialRecordUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type BatchCreateWithoutFacultyInput = {
    name: string
    labTimeSlot: LabTimeSlotCreateNestedOneWithoutBatchesInput
    studentCourses?: StudentCourseCreateNestedManyWithoutBatchInput
    batchCourses?: BatchCourseCreateNestedManyWithoutBatchInput
    clientAdmin: ClientAdminCreateNestedOneWithoutBatchesInput
  }

  export type BatchUncheckedCreateWithoutFacultyInput = {
    id?: number
    name: string
    labTimeSlotId: number
    clientAdminId: string
    studentCourses?: StudentCourseUncheckedCreateNestedManyWithoutBatchInput
    batchCourses?: BatchCourseUncheckedCreateNestedManyWithoutBatchInput
  }

  export type BatchCreateOrConnectWithoutFacultyInput = {
    where: BatchWhereUniqueInput
    create: XOR<BatchCreateWithoutFacultyInput, BatchUncheckedCreateWithoutFacultyInput>
  }

  export type BatchCreateManyFacultyInputEnvelope = {
    data: BatchCreateManyFacultyInput | BatchCreateManyFacultyInput[]
    skipDuplicates?: boolean
  }

  export type AttendanceRecordCreateWithoutMarkedByInput = {
    date: Date | string
    present: boolean
    batchId?: number | null
    student: StudentCreateNestedOneWithoutAttendanceInput
    course: CourseCreateNestedOneWithoutAttendanceRecordsInput
    clientAdmin: ClientAdminCreateNestedOneWithoutAttendanceRecordsInput
  }

  export type AttendanceRecordUncheckedCreateWithoutMarkedByInput = {
    id?: number
    studentId: number
    courseId: number
    date: Date | string
    present: boolean
    batchId?: number | null
    clientAdminId: string
  }

  export type AttendanceRecordCreateOrConnectWithoutMarkedByInput = {
    where: AttendanceRecordWhereUniqueInput
    create: XOR<AttendanceRecordCreateWithoutMarkedByInput, AttendanceRecordUncheckedCreateWithoutMarkedByInput>
  }

  export type AttendanceRecordCreateManyMarkedByInputEnvelope = {
    data: AttendanceRecordCreateManyMarkedByInput | AttendanceRecordCreateManyMarkedByInput[]
    skipDuplicates?: boolean
  }

  export type StudentTaskCreateWithoutFacultyInput = {
    assignedDate: Date | string
    dueDate: Date | string
    description: string
    status: string
    facultyRemarks?: string | null
    grade?: string | null
    student: StudentCreateNestedOneWithoutTasksInput
    course: CourseCreateNestedOneWithoutStudentTasksInput
    clientAdmin: ClientAdminCreateNestedOneWithoutStudentTasksInput
  }

  export type StudentTaskUncheckedCreateWithoutFacultyInput = {
    id?: number
    studentId: number
    courseId: number
    assignedDate: Date | string
    dueDate: Date | string
    description: string
    status: string
    facultyRemarks?: string | null
    grade?: string | null
    clientAdminId: string
  }

  export type StudentTaskCreateOrConnectWithoutFacultyInput = {
    where: StudentTaskWhereUniqueInput
    create: XOR<StudentTaskCreateWithoutFacultyInput, StudentTaskUncheckedCreateWithoutFacultyInput>
  }

  export type StudentTaskCreateManyFacultyInputEnvelope = {
    data: StudentTaskCreateManyFacultyInput | StudentTaskCreateManyFacultyInput[]
    skipDuplicates?: boolean
  }

  export type FinancialRecordCreateWithoutFacultyInput = {
    id?: string
    recordType: $Enums.RecordType
    amount: number
    description?: string | null
    date?: Date | string
    paymentMode?: $Enums.PaymentMode | null
    student?: StudentCreateNestedOneWithoutFinancialRecordsInput
    course?: CourseCreateNestedOneWithoutFinancialRecordsInput
    lab?: LabCreateNestedOneWithoutFinancialRecordsInput
    clientAdmin: ClientAdminCreateNestedOneWithoutFinancialRecordsInput
  }

  export type FinancialRecordUncheckedCreateWithoutFacultyInput = {
    id?: string
    clientAdminId: string
    recordType: $Enums.RecordType
    amount: number
    description?: string | null
    date?: Date | string
    paymentMode?: $Enums.PaymentMode | null
    studentId?: number | null
    courseId?: number | null
    labId?: number | null
  }

  export type FinancialRecordCreateOrConnectWithoutFacultyInput = {
    where: FinancialRecordWhereUniqueInput
    create: XOR<FinancialRecordCreateWithoutFacultyInput, FinancialRecordUncheckedCreateWithoutFacultyInput>
  }

  export type FinancialRecordCreateManyFacultyInputEnvelope = {
    data: FinancialRecordCreateManyFacultyInput | FinancialRecordCreateManyFacultyInput[]
    skipDuplicates?: boolean
  }

  export type ClientAdminCreateWithoutFacultiesInput = {
    id?: string
    name: string
    email: string
    password: string
    instituteName: string
    slug: string
    fullAddress: string
    logo?: string | null
    certificateName?: string | null
    stamp?: string | null
    sign?: string | null
    contact: string
    position: string
    country: string
    state: string
    city: string
    zipCode: string
    createdAt?: Date | string
    role?: $Enums.UserRole
    currentSessionToken?: string | null
    lastLoginAt?: Date | string | null
    roleUsers?: RoleUserCreateNestedManyWithoutClientAdminInput
    batches?: BatchCreateNestedManyWithoutClientAdminInput
    courses?: CourseCreateNestedManyWithoutClientAdminInput
    enquiryCourse?: EnquiryCourseCreateNestedManyWithoutClientAdminInput
    labs?: LabCreateNestedManyWithoutClientAdminInput
    labTimeSlots?: LabTimeSlotCreateNestedManyWithoutClientAdminInput
    labAllocations?: LabAllocationCreateNestedManyWithoutClientAdminInput
    students?: StudentCreateNestedManyWithoutClientAdminInput
    activities?: ActivityLogCreateNestedManyWithoutClientAdminInput
    studentCourses?: StudentCourseCreateNestedManyWithoutClientAdminInput
    feeStructures?: FeeStructureCreateNestedManyWithoutClientAdminInput
    studentFees?: StudentFeeCreateNestedManyWithoutClientAdminInput
    stationeryIssues?: StationeryIssueCreateNestedManyWithoutClientAdminInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutClientAdminInput
    studentTasks?: StudentTaskCreateNestedManyWithoutClientAdminInput
    studentTests?: StudentTestCreateNestedManyWithoutClientAdminInput
    courseCompletions?: CourseCompletionCreateNestedManyWithoutClientAdminInput
    certificates?: CertificateCreateNestedManyWithoutClientAdminInput
    financialRecords?: FinancialRecordCreateNestedManyWithoutClientAdminInput
    enquiries?: EnquiryCreateNestedManyWithoutClientAdminInput
    notifications?: NotificationCreateNestedManyWithoutClientAdminInput
    courseFeeStructures?: CourseFeeStructureCreateNestedManyWithoutClientAdminInput
  }

  export type ClientAdminUncheckedCreateWithoutFacultiesInput = {
    id?: string
    name: string
    email: string
    password: string
    instituteName: string
    slug: string
    fullAddress: string
    logo?: string | null
    certificateName?: string | null
    stamp?: string | null
    sign?: string | null
    contact: string
    position: string
    country: string
    state: string
    city: string
    zipCode: string
    createdAt?: Date | string
    role?: $Enums.UserRole
    currentSessionToken?: string | null
    lastLoginAt?: Date | string | null
    roleUsers?: RoleUserUncheckedCreateNestedManyWithoutClientAdminInput
    batches?: BatchUncheckedCreateNestedManyWithoutClientAdminInput
    courses?: CourseUncheckedCreateNestedManyWithoutClientAdminInput
    enquiryCourse?: EnquiryCourseUncheckedCreateNestedManyWithoutClientAdminInput
    labs?: LabUncheckedCreateNestedManyWithoutClientAdminInput
    labTimeSlots?: LabTimeSlotUncheckedCreateNestedManyWithoutClientAdminInput
    labAllocations?: LabAllocationUncheckedCreateNestedManyWithoutClientAdminInput
    students?: StudentUncheckedCreateNestedManyWithoutClientAdminInput
    activities?: ActivityLogUncheckedCreateNestedManyWithoutClientAdminInput
    studentCourses?: StudentCourseUncheckedCreateNestedManyWithoutClientAdminInput
    feeStructures?: FeeStructureUncheckedCreateNestedManyWithoutClientAdminInput
    studentFees?: StudentFeeUncheckedCreateNestedManyWithoutClientAdminInput
    stationeryIssues?: StationeryIssueUncheckedCreateNestedManyWithoutClientAdminInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutClientAdminInput
    studentTasks?: StudentTaskUncheckedCreateNestedManyWithoutClientAdminInput
    studentTests?: StudentTestUncheckedCreateNestedManyWithoutClientAdminInput
    courseCompletions?: CourseCompletionUncheckedCreateNestedManyWithoutClientAdminInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutClientAdminInput
    financialRecords?: FinancialRecordUncheckedCreateNestedManyWithoutClientAdminInput
    enquiries?: EnquiryUncheckedCreateNestedManyWithoutClientAdminInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutClientAdminInput
    courseFeeStructures?: CourseFeeStructureUncheckedCreateNestedManyWithoutClientAdminInput
  }

  export type ClientAdminCreateOrConnectWithoutFacultiesInput = {
    where: ClientAdminWhereUniqueInput
    create: XOR<ClientAdminCreateWithoutFacultiesInput, ClientAdminUncheckedCreateWithoutFacultiesInput>
  }

  export type BatchUpsertWithWhereUniqueWithoutFacultyInput = {
    where: BatchWhereUniqueInput
    update: XOR<BatchUpdateWithoutFacultyInput, BatchUncheckedUpdateWithoutFacultyInput>
    create: XOR<BatchCreateWithoutFacultyInput, BatchUncheckedCreateWithoutFacultyInput>
  }

  export type BatchUpdateWithWhereUniqueWithoutFacultyInput = {
    where: BatchWhereUniqueInput
    data: XOR<BatchUpdateWithoutFacultyInput, BatchUncheckedUpdateWithoutFacultyInput>
  }

  export type BatchUpdateManyWithWhereWithoutFacultyInput = {
    where: BatchScalarWhereInput
    data: XOR<BatchUpdateManyMutationInput, BatchUncheckedUpdateManyWithoutFacultyInput>
  }

  export type AttendanceRecordUpsertWithWhereUniqueWithoutMarkedByInput = {
    where: AttendanceRecordWhereUniqueInput
    update: XOR<AttendanceRecordUpdateWithoutMarkedByInput, AttendanceRecordUncheckedUpdateWithoutMarkedByInput>
    create: XOR<AttendanceRecordCreateWithoutMarkedByInput, AttendanceRecordUncheckedCreateWithoutMarkedByInput>
  }

  export type AttendanceRecordUpdateWithWhereUniqueWithoutMarkedByInput = {
    where: AttendanceRecordWhereUniqueInput
    data: XOR<AttendanceRecordUpdateWithoutMarkedByInput, AttendanceRecordUncheckedUpdateWithoutMarkedByInput>
  }

  export type AttendanceRecordUpdateManyWithWhereWithoutMarkedByInput = {
    where: AttendanceRecordScalarWhereInput
    data: XOR<AttendanceRecordUpdateManyMutationInput, AttendanceRecordUncheckedUpdateManyWithoutMarkedByInput>
  }

  export type StudentTaskUpsertWithWhereUniqueWithoutFacultyInput = {
    where: StudentTaskWhereUniqueInput
    update: XOR<StudentTaskUpdateWithoutFacultyInput, StudentTaskUncheckedUpdateWithoutFacultyInput>
    create: XOR<StudentTaskCreateWithoutFacultyInput, StudentTaskUncheckedCreateWithoutFacultyInput>
  }

  export type StudentTaskUpdateWithWhereUniqueWithoutFacultyInput = {
    where: StudentTaskWhereUniqueInput
    data: XOR<StudentTaskUpdateWithoutFacultyInput, StudentTaskUncheckedUpdateWithoutFacultyInput>
  }

  export type StudentTaskUpdateManyWithWhereWithoutFacultyInput = {
    where: StudentTaskScalarWhereInput
    data: XOR<StudentTaskUpdateManyMutationInput, StudentTaskUncheckedUpdateManyWithoutFacultyInput>
  }

  export type FinancialRecordUpsertWithWhereUniqueWithoutFacultyInput = {
    where: FinancialRecordWhereUniqueInput
    update: XOR<FinancialRecordUpdateWithoutFacultyInput, FinancialRecordUncheckedUpdateWithoutFacultyInput>
    create: XOR<FinancialRecordCreateWithoutFacultyInput, FinancialRecordUncheckedCreateWithoutFacultyInput>
  }

  export type FinancialRecordUpdateWithWhereUniqueWithoutFacultyInput = {
    where: FinancialRecordWhereUniqueInput
    data: XOR<FinancialRecordUpdateWithoutFacultyInput, FinancialRecordUncheckedUpdateWithoutFacultyInput>
  }

  export type FinancialRecordUpdateManyWithWhereWithoutFacultyInput = {
    where: FinancialRecordScalarWhereInput
    data: XOR<FinancialRecordUpdateManyMutationInput, FinancialRecordUncheckedUpdateManyWithoutFacultyInput>
  }

  export type ClientAdminUpsertWithoutFacultiesInput = {
    update: XOR<ClientAdminUpdateWithoutFacultiesInput, ClientAdminUncheckedUpdateWithoutFacultiesInput>
    create: XOR<ClientAdminCreateWithoutFacultiesInput, ClientAdminUncheckedCreateWithoutFacultiesInput>
    where?: ClientAdminWhereInput
  }

  export type ClientAdminUpdateToOneWithWhereWithoutFacultiesInput = {
    where?: ClientAdminWhereInput
    data: XOR<ClientAdminUpdateWithoutFacultiesInput, ClientAdminUncheckedUpdateWithoutFacultiesInput>
  }

  export type ClientAdminUpdateWithoutFacultiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    instituteName?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    fullAddress?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    certificateName?: NullableStringFieldUpdateOperationsInput | string | null
    stamp?: NullableStringFieldUpdateOperationsInput | string | null
    sign?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    currentSessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleUsers?: RoleUserUpdateManyWithoutClientAdminNestedInput
    batches?: BatchUpdateManyWithoutClientAdminNestedInput
    courses?: CourseUpdateManyWithoutClientAdminNestedInput
    enquiryCourse?: EnquiryCourseUpdateManyWithoutClientAdminNestedInput
    labs?: LabUpdateManyWithoutClientAdminNestedInput
    labTimeSlots?: LabTimeSlotUpdateManyWithoutClientAdminNestedInput
    labAllocations?: LabAllocationUpdateManyWithoutClientAdminNestedInput
    students?: StudentUpdateManyWithoutClientAdminNestedInput
    activities?: ActivityLogUpdateManyWithoutClientAdminNestedInput
    studentCourses?: StudentCourseUpdateManyWithoutClientAdminNestedInput
    feeStructures?: FeeStructureUpdateManyWithoutClientAdminNestedInput
    studentFees?: StudentFeeUpdateManyWithoutClientAdminNestedInput
    stationeryIssues?: StationeryIssueUpdateManyWithoutClientAdminNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutClientAdminNestedInput
    studentTasks?: StudentTaskUpdateManyWithoutClientAdminNestedInput
    studentTests?: StudentTestUpdateManyWithoutClientAdminNestedInput
    courseCompletions?: CourseCompletionUpdateManyWithoutClientAdminNestedInput
    certificates?: CertificateUpdateManyWithoutClientAdminNestedInput
    financialRecords?: FinancialRecordUpdateManyWithoutClientAdminNestedInput
    enquiries?: EnquiryUpdateManyWithoutClientAdminNestedInput
    notifications?: NotificationUpdateManyWithoutClientAdminNestedInput
    courseFeeStructures?: CourseFeeStructureUpdateManyWithoutClientAdminNestedInput
  }

  export type ClientAdminUncheckedUpdateWithoutFacultiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    instituteName?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    fullAddress?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    certificateName?: NullableStringFieldUpdateOperationsInput | string | null
    stamp?: NullableStringFieldUpdateOperationsInput | string | null
    sign?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    currentSessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleUsers?: RoleUserUncheckedUpdateManyWithoutClientAdminNestedInput
    batches?: BatchUncheckedUpdateManyWithoutClientAdminNestedInput
    courses?: CourseUncheckedUpdateManyWithoutClientAdminNestedInput
    enquiryCourse?: EnquiryCourseUncheckedUpdateManyWithoutClientAdminNestedInput
    labs?: LabUncheckedUpdateManyWithoutClientAdminNestedInput
    labTimeSlots?: LabTimeSlotUncheckedUpdateManyWithoutClientAdminNestedInput
    labAllocations?: LabAllocationUncheckedUpdateManyWithoutClientAdminNestedInput
    students?: StudentUncheckedUpdateManyWithoutClientAdminNestedInput
    activities?: ActivityLogUncheckedUpdateManyWithoutClientAdminNestedInput
    studentCourses?: StudentCourseUncheckedUpdateManyWithoutClientAdminNestedInput
    feeStructures?: FeeStructureUncheckedUpdateManyWithoutClientAdminNestedInput
    studentFees?: StudentFeeUncheckedUpdateManyWithoutClientAdminNestedInput
    stationeryIssues?: StationeryIssueUncheckedUpdateManyWithoutClientAdminNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutClientAdminNestedInput
    studentTasks?: StudentTaskUncheckedUpdateManyWithoutClientAdminNestedInput
    studentTests?: StudentTestUncheckedUpdateManyWithoutClientAdminNestedInput
    courseCompletions?: CourseCompletionUncheckedUpdateManyWithoutClientAdminNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutClientAdminNestedInput
    financialRecords?: FinancialRecordUncheckedUpdateManyWithoutClientAdminNestedInput
    enquiries?: EnquiryUncheckedUpdateManyWithoutClientAdminNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutClientAdminNestedInput
    courseFeeStructures?: CourseFeeStructureUncheckedUpdateManyWithoutClientAdminNestedInput
  }

  export type LabTimeSlotCreateWithoutLabInput = {
    startTime: string
    endTime: string
    day: string
    availablePCs: number
    batches?: BatchCreateNestedManyWithoutLabTimeSlotInput
    allocations?: LabAllocationCreateNestedManyWithoutLabTimeSlotInput
    clientAdmin: ClientAdminCreateNestedOneWithoutLabTimeSlotsInput
  }

  export type LabTimeSlotUncheckedCreateWithoutLabInput = {
    id?: number
    startTime: string
    endTime: string
    day: string
    availablePCs: number
    clientAdminId: string
    batches?: BatchUncheckedCreateNestedManyWithoutLabTimeSlotInput
    allocations?: LabAllocationUncheckedCreateNestedManyWithoutLabTimeSlotInput
  }

  export type LabTimeSlotCreateOrConnectWithoutLabInput = {
    where: LabTimeSlotWhereUniqueInput
    create: XOR<LabTimeSlotCreateWithoutLabInput, LabTimeSlotUncheckedCreateWithoutLabInput>
  }

  export type LabTimeSlotCreateManyLabInputEnvelope = {
    data: LabTimeSlotCreateManyLabInput | LabTimeSlotCreateManyLabInput[]
    skipDuplicates?: boolean
  }

  export type FinancialRecordCreateWithoutLabInput = {
    id?: string
    recordType: $Enums.RecordType
    amount: number
    description?: string | null
    date?: Date | string
    paymentMode?: $Enums.PaymentMode | null
    student?: StudentCreateNestedOneWithoutFinancialRecordsInput
    course?: CourseCreateNestedOneWithoutFinancialRecordsInput
    faculty?: FacultyCreateNestedOneWithoutFinancialRecordsInput
    clientAdmin: ClientAdminCreateNestedOneWithoutFinancialRecordsInput
  }

  export type FinancialRecordUncheckedCreateWithoutLabInput = {
    id?: string
    clientAdminId: string
    recordType: $Enums.RecordType
    amount: number
    description?: string | null
    date?: Date | string
    paymentMode?: $Enums.PaymentMode | null
    studentId?: number | null
    courseId?: number | null
    facultyId?: number | null
  }

  export type FinancialRecordCreateOrConnectWithoutLabInput = {
    where: FinancialRecordWhereUniqueInput
    create: XOR<FinancialRecordCreateWithoutLabInput, FinancialRecordUncheckedCreateWithoutLabInput>
  }

  export type FinancialRecordCreateManyLabInputEnvelope = {
    data: FinancialRecordCreateManyLabInput | FinancialRecordCreateManyLabInput[]
    skipDuplicates?: boolean
  }

  export type ClientAdminCreateWithoutLabsInput = {
    id?: string
    name: string
    email: string
    password: string
    instituteName: string
    slug: string
    fullAddress: string
    logo?: string | null
    certificateName?: string | null
    stamp?: string | null
    sign?: string | null
    contact: string
    position: string
    country: string
    state: string
    city: string
    zipCode: string
    createdAt?: Date | string
    role?: $Enums.UserRole
    currentSessionToken?: string | null
    lastLoginAt?: Date | string | null
    roleUsers?: RoleUserCreateNestedManyWithoutClientAdminInput
    faculties?: FacultyCreateNestedManyWithoutClientAdminInput
    batches?: BatchCreateNestedManyWithoutClientAdminInput
    courses?: CourseCreateNestedManyWithoutClientAdminInput
    enquiryCourse?: EnquiryCourseCreateNestedManyWithoutClientAdminInput
    labTimeSlots?: LabTimeSlotCreateNestedManyWithoutClientAdminInput
    labAllocations?: LabAllocationCreateNestedManyWithoutClientAdminInput
    students?: StudentCreateNestedManyWithoutClientAdminInput
    activities?: ActivityLogCreateNestedManyWithoutClientAdminInput
    studentCourses?: StudentCourseCreateNestedManyWithoutClientAdminInput
    feeStructures?: FeeStructureCreateNestedManyWithoutClientAdminInput
    studentFees?: StudentFeeCreateNestedManyWithoutClientAdminInput
    stationeryIssues?: StationeryIssueCreateNestedManyWithoutClientAdminInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutClientAdminInput
    studentTasks?: StudentTaskCreateNestedManyWithoutClientAdminInput
    studentTests?: StudentTestCreateNestedManyWithoutClientAdminInput
    courseCompletions?: CourseCompletionCreateNestedManyWithoutClientAdminInput
    certificates?: CertificateCreateNestedManyWithoutClientAdminInput
    financialRecords?: FinancialRecordCreateNestedManyWithoutClientAdminInput
    enquiries?: EnquiryCreateNestedManyWithoutClientAdminInput
    notifications?: NotificationCreateNestedManyWithoutClientAdminInput
    courseFeeStructures?: CourseFeeStructureCreateNestedManyWithoutClientAdminInput
  }

  export type ClientAdminUncheckedCreateWithoutLabsInput = {
    id?: string
    name: string
    email: string
    password: string
    instituteName: string
    slug: string
    fullAddress: string
    logo?: string | null
    certificateName?: string | null
    stamp?: string | null
    sign?: string | null
    contact: string
    position: string
    country: string
    state: string
    city: string
    zipCode: string
    createdAt?: Date | string
    role?: $Enums.UserRole
    currentSessionToken?: string | null
    lastLoginAt?: Date | string | null
    roleUsers?: RoleUserUncheckedCreateNestedManyWithoutClientAdminInput
    faculties?: FacultyUncheckedCreateNestedManyWithoutClientAdminInput
    batches?: BatchUncheckedCreateNestedManyWithoutClientAdminInput
    courses?: CourseUncheckedCreateNestedManyWithoutClientAdminInput
    enquiryCourse?: EnquiryCourseUncheckedCreateNestedManyWithoutClientAdminInput
    labTimeSlots?: LabTimeSlotUncheckedCreateNestedManyWithoutClientAdminInput
    labAllocations?: LabAllocationUncheckedCreateNestedManyWithoutClientAdminInput
    students?: StudentUncheckedCreateNestedManyWithoutClientAdminInput
    activities?: ActivityLogUncheckedCreateNestedManyWithoutClientAdminInput
    studentCourses?: StudentCourseUncheckedCreateNestedManyWithoutClientAdminInput
    feeStructures?: FeeStructureUncheckedCreateNestedManyWithoutClientAdminInput
    studentFees?: StudentFeeUncheckedCreateNestedManyWithoutClientAdminInput
    stationeryIssues?: StationeryIssueUncheckedCreateNestedManyWithoutClientAdminInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutClientAdminInput
    studentTasks?: StudentTaskUncheckedCreateNestedManyWithoutClientAdminInput
    studentTests?: StudentTestUncheckedCreateNestedManyWithoutClientAdminInput
    courseCompletions?: CourseCompletionUncheckedCreateNestedManyWithoutClientAdminInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutClientAdminInput
    financialRecords?: FinancialRecordUncheckedCreateNestedManyWithoutClientAdminInput
    enquiries?: EnquiryUncheckedCreateNestedManyWithoutClientAdminInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutClientAdminInput
    courseFeeStructures?: CourseFeeStructureUncheckedCreateNestedManyWithoutClientAdminInput
  }

  export type ClientAdminCreateOrConnectWithoutLabsInput = {
    where: ClientAdminWhereUniqueInput
    create: XOR<ClientAdminCreateWithoutLabsInput, ClientAdminUncheckedCreateWithoutLabsInput>
  }

  export type LabTimeSlotUpsertWithWhereUniqueWithoutLabInput = {
    where: LabTimeSlotWhereUniqueInput
    update: XOR<LabTimeSlotUpdateWithoutLabInput, LabTimeSlotUncheckedUpdateWithoutLabInput>
    create: XOR<LabTimeSlotCreateWithoutLabInput, LabTimeSlotUncheckedCreateWithoutLabInput>
  }

  export type LabTimeSlotUpdateWithWhereUniqueWithoutLabInput = {
    where: LabTimeSlotWhereUniqueInput
    data: XOR<LabTimeSlotUpdateWithoutLabInput, LabTimeSlotUncheckedUpdateWithoutLabInput>
  }

  export type LabTimeSlotUpdateManyWithWhereWithoutLabInput = {
    where: LabTimeSlotScalarWhereInput
    data: XOR<LabTimeSlotUpdateManyMutationInput, LabTimeSlotUncheckedUpdateManyWithoutLabInput>
  }

  export type FinancialRecordUpsertWithWhereUniqueWithoutLabInput = {
    where: FinancialRecordWhereUniqueInput
    update: XOR<FinancialRecordUpdateWithoutLabInput, FinancialRecordUncheckedUpdateWithoutLabInput>
    create: XOR<FinancialRecordCreateWithoutLabInput, FinancialRecordUncheckedCreateWithoutLabInput>
  }

  export type FinancialRecordUpdateWithWhereUniqueWithoutLabInput = {
    where: FinancialRecordWhereUniqueInput
    data: XOR<FinancialRecordUpdateWithoutLabInput, FinancialRecordUncheckedUpdateWithoutLabInput>
  }

  export type FinancialRecordUpdateManyWithWhereWithoutLabInput = {
    where: FinancialRecordScalarWhereInput
    data: XOR<FinancialRecordUpdateManyMutationInput, FinancialRecordUncheckedUpdateManyWithoutLabInput>
  }

  export type ClientAdminUpsertWithoutLabsInput = {
    update: XOR<ClientAdminUpdateWithoutLabsInput, ClientAdminUncheckedUpdateWithoutLabsInput>
    create: XOR<ClientAdminCreateWithoutLabsInput, ClientAdminUncheckedCreateWithoutLabsInput>
    where?: ClientAdminWhereInput
  }

  export type ClientAdminUpdateToOneWithWhereWithoutLabsInput = {
    where?: ClientAdminWhereInput
    data: XOR<ClientAdminUpdateWithoutLabsInput, ClientAdminUncheckedUpdateWithoutLabsInput>
  }

  export type ClientAdminUpdateWithoutLabsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    instituteName?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    fullAddress?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    certificateName?: NullableStringFieldUpdateOperationsInput | string | null
    stamp?: NullableStringFieldUpdateOperationsInput | string | null
    sign?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    currentSessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleUsers?: RoleUserUpdateManyWithoutClientAdminNestedInput
    faculties?: FacultyUpdateManyWithoutClientAdminNestedInput
    batches?: BatchUpdateManyWithoutClientAdminNestedInput
    courses?: CourseUpdateManyWithoutClientAdminNestedInput
    enquiryCourse?: EnquiryCourseUpdateManyWithoutClientAdminNestedInput
    labTimeSlots?: LabTimeSlotUpdateManyWithoutClientAdminNestedInput
    labAllocations?: LabAllocationUpdateManyWithoutClientAdminNestedInput
    students?: StudentUpdateManyWithoutClientAdminNestedInput
    activities?: ActivityLogUpdateManyWithoutClientAdminNestedInput
    studentCourses?: StudentCourseUpdateManyWithoutClientAdminNestedInput
    feeStructures?: FeeStructureUpdateManyWithoutClientAdminNestedInput
    studentFees?: StudentFeeUpdateManyWithoutClientAdminNestedInput
    stationeryIssues?: StationeryIssueUpdateManyWithoutClientAdminNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutClientAdminNestedInput
    studentTasks?: StudentTaskUpdateManyWithoutClientAdminNestedInput
    studentTests?: StudentTestUpdateManyWithoutClientAdminNestedInput
    courseCompletions?: CourseCompletionUpdateManyWithoutClientAdminNestedInput
    certificates?: CertificateUpdateManyWithoutClientAdminNestedInput
    financialRecords?: FinancialRecordUpdateManyWithoutClientAdminNestedInput
    enquiries?: EnquiryUpdateManyWithoutClientAdminNestedInput
    notifications?: NotificationUpdateManyWithoutClientAdminNestedInput
    courseFeeStructures?: CourseFeeStructureUpdateManyWithoutClientAdminNestedInput
  }

  export type ClientAdminUncheckedUpdateWithoutLabsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    instituteName?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    fullAddress?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    certificateName?: NullableStringFieldUpdateOperationsInput | string | null
    stamp?: NullableStringFieldUpdateOperationsInput | string | null
    sign?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    currentSessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleUsers?: RoleUserUncheckedUpdateManyWithoutClientAdminNestedInput
    faculties?: FacultyUncheckedUpdateManyWithoutClientAdminNestedInput
    batches?: BatchUncheckedUpdateManyWithoutClientAdminNestedInput
    courses?: CourseUncheckedUpdateManyWithoutClientAdminNestedInput
    enquiryCourse?: EnquiryCourseUncheckedUpdateManyWithoutClientAdminNestedInput
    labTimeSlots?: LabTimeSlotUncheckedUpdateManyWithoutClientAdminNestedInput
    labAllocations?: LabAllocationUncheckedUpdateManyWithoutClientAdminNestedInput
    students?: StudentUncheckedUpdateManyWithoutClientAdminNestedInput
    activities?: ActivityLogUncheckedUpdateManyWithoutClientAdminNestedInput
    studentCourses?: StudentCourseUncheckedUpdateManyWithoutClientAdminNestedInput
    feeStructures?: FeeStructureUncheckedUpdateManyWithoutClientAdminNestedInput
    studentFees?: StudentFeeUncheckedUpdateManyWithoutClientAdminNestedInput
    stationeryIssues?: StationeryIssueUncheckedUpdateManyWithoutClientAdminNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutClientAdminNestedInput
    studentTasks?: StudentTaskUncheckedUpdateManyWithoutClientAdminNestedInput
    studentTests?: StudentTestUncheckedUpdateManyWithoutClientAdminNestedInput
    courseCompletions?: CourseCompletionUncheckedUpdateManyWithoutClientAdminNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutClientAdminNestedInput
    financialRecords?: FinancialRecordUncheckedUpdateManyWithoutClientAdminNestedInput
    enquiries?: EnquiryUncheckedUpdateManyWithoutClientAdminNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutClientAdminNestedInput
    courseFeeStructures?: CourseFeeStructureUncheckedUpdateManyWithoutClientAdminNestedInput
  }

  export type LabCreateWithoutTimeSlotsInput = {
    name: string
    location?: string | null
    totalPCs: number
    isActive?: boolean
    financialRecords?: FinancialRecordCreateNestedManyWithoutLabInput
    clientAdmin: ClientAdminCreateNestedOneWithoutLabsInput
  }

  export type LabUncheckedCreateWithoutTimeSlotsInput = {
    id?: number
    name: string
    location?: string | null
    totalPCs: number
    isActive?: boolean
    clientAdminId: string
    financialRecords?: FinancialRecordUncheckedCreateNestedManyWithoutLabInput
  }

  export type LabCreateOrConnectWithoutTimeSlotsInput = {
    where: LabWhereUniqueInput
    create: XOR<LabCreateWithoutTimeSlotsInput, LabUncheckedCreateWithoutTimeSlotsInput>
  }

  export type BatchCreateWithoutLabTimeSlotInput = {
    name: string
    faculty?: FacultyCreateNestedOneWithoutBatchesInput
    studentCourses?: StudentCourseCreateNestedManyWithoutBatchInput
    batchCourses?: BatchCourseCreateNestedManyWithoutBatchInput
    clientAdmin: ClientAdminCreateNestedOneWithoutBatchesInput
  }

  export type BatchUncheckedCreateWithoutLabTimeSlotInput = {
    id?: number
    name: string
    facultyId?: number | null
    clientAdminId: string
    studentCourses?: StudentCourseUncheckedCreateNestedManyWithoutBatchInput
    batchCourses?: BatchCourseUncheckedCreateNestedManyWithoutBatchInput
  }

  export type BatchCreateOrConnectWithoutLabTimeSlotInput = {
    where: BatchWhereUniqueInput
    create: XOR<BatchCreateWithoutLabTimeSlotInput, BatchUncheckedCreateWithoutLabTimeSlotInput>
  }

  export type BatchCreateManyLabTimeSlotInputEnvelope = {
    data: BatchCreateManyLabTimeSlotInput | BatchCreateManyLabTimeSlotInput[]
    skipDuplicates?: boolean
  }

  export type LabAllocationCreateWithoutLabTimeSlotInput = {
    pcNumber: number
    assignedAt?: Date | string
    student: StudentCreateNestedOneWithoutLabAllocationsInput
    clientAdmin: ClientAdminCreateNestedOneWithoutLabAllocationsInput
  }

  export type LabAllocationUncheckedCreateWithoutLabTimeSlotInput = {
    id?: number
    studentId: number
    pcNumber: number
    assignedAt?: Date | string
    clientAdminId: string
  }

  export type LabAllocationCreateOrConnectWithoutLabTimeSlotInput = {
    where: LabAllocationWhereUniqueInput
    create: XOR<LabAllocationCreateWithoutLabTimeSlotInput, LabAllocationUncheckedCreateWithoutLabTimeSlotInput>
  }

  export type LabAllocationCreateManyLabTimeSlotInputEnvelope = {
    data: LabAllocationCreateManyLabTimeSlotInput | LabAllocationCreateManyLabTimeSlotInput[]
    skipDuplicates?: boolean
  }

  export type ClientAdminCreateWithoutLabTimeSlotsInput = {
    id?: string
    name: string
    email: string
    password: string
    instituteName: string
    slug: string
    fullAddress: string
    logo?: string | null
    certificateName?: string | null
    stamp?: string | null
    sign?: string | null
    contact: string
    position: string
    country: string
    state: string
    city: string
    zipCode: string
    createdAt?: Date | string
    role?: $Enums.UserRole
    currentSessionToken?: string | null
    lastLoginAt?: Date | string | null
    roleUsers?: RoleUserCreateNestedManyWithoutClientAdminInput
    faculties?: FacultyCreateNestedManyWithoutClientAdminInput
    batches?: BatchCreateNestedManyWithoutClientAdminInput
    courses?: CourseCreateNestedManyWithoutClientAdminInput
    enquiryCourse?: EnquiryCourseCreateNestedManyWithoutClientAdminInput
    labs?: LabCreateNestedManyWithoutClientAdminInput
    labAllocations?: LabAllocationCreateNestedManyWithoutClientAdminInput
    students?: StudentCreateNestedManyWithoutClientAdminInput
    activities?: ActivityLogCreateNestedManyWithoutClientAdminInput
    studentCourses?: StudentCourseCreateNestedManyWithoutClientAdminInput
    feeStructures?: FeeStructureCreateNestedManyWithoutClientAdminInput
    studentFees?: StudentFeeCreateNestedManyWithoutClientAdminInput
    stationeryIssues?: StationeryIssueCreateNestedManyWithoutClientAdminInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutClientAdminInput
    studentTasks?: StudentTaskCreateNestedManyWithoutClientAdminInput
    studentTests?: StudentTestCreateNestedManyWithoutClientAdminInput
    courseCompletions?: CourseCompletionCreateNestedManyWithoutClientAdminInput
    certificates?: CertificateCreateNestedManyWithoutClientAdminInput
    financialRecords?: FinancialRecordCreateNestedManyWithoutClientAdminInput
    enquiries?: EnquiryCreateNestedManyWithoutClientAdminInput
    notifications?: NotificationCreateNestedManyWithoutClientAdminInput
    courseFeeStructures?: CourseFeeStructureCreateNestedManyWithoutClientAdminInput
  }

  export type ClientAdminUncheckedCreateWithoutLabTimeSlotsInput = {
    id?: string
    name: string
    email: string
    password: string
    instituteName: string
    slug: string
    fullAddress: string
    logo?: string | null
    certificateName?: string | null
    stamp?: string | null
    sign?: string | null
    contact: string
    position: string
    country: string
    state: string
    city: string
    zipCode: string
    createdAt?: Date | string
    role?: $Enums.UserRole
    currentSessionToken?: string | null
    lastLoginAt?: Date | string | null
    roleUsers?: RoleUserUncheckedCreateNestedManyWithoutClientAdminInput
    faculties?: FacultyUncheckedCreateNestedManyWithoutClientAdminInput
    batches?: BatchUncheckedCreateNestedManyWithoutClientAdminInput
    courses?: CourseUncheckedCreateNestedManyWithoutClientAdminInput
    enquiryCourse?: EnquiryCourseUncheckedCreateNestedManyWithoutClientAdminInput
    labs?: LabUncheckedCreateNestedManyWithoutClientAdminInput
    labAllocations?: LabAllocationUncheckedCreateNestedManyWithoutClientAdminInput
    students?: StudentUncheckedCreateNestedManyWithoutClientAdminInput
    activities?: ActivityLogUncheckedCreateNestedManyWithoutClientAdminInput
    studentCourses?: StudentCourseUncheckedCreateNestedManyWithoutClientAdminInput
    feeStructures?: FeeStructureUncheckedCreateNestedManyWithoutClientAdminInput
    studentFees?: StudentFeeUncheckedCreateNestedManyWithoutClientAdminInput
    stationeryIssues?: StationeryIssueUncheckedCreateNestedManyWithoutClientAdminInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutClientAdminInput
    studentTasks?: StudentTaskUncheckedCreateNestedManyWithoutClientAdminInput
    studentTests?: StudentTestUncheckedCreateNestedManyWithoutClientAdminInput
    courseCompletions?: CourseCompletionUncheckedCreateNestedManyWithoutClientAdminInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutClientAdminInput
    financialRecords?: FinancialRecordUncheckedCreateNestedManyWithoutClientAdminInput
    enquiries?: EnquiryUncheckedCreateNestedManyWithoutClientAdminInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutClientAdminInput
    courseFeeStructures?: CourseFeeStructureUncheckedCreateNestedManyWithoutClientAdminInput
  }

  export type ClientAdminCreateOrConnectWithoutLabTimeSlotsInput = {
    where: ClientAdminWhereUniqueInput
    create: XOR<ClientAdminCreateWithoutLabTimeSlotsInput, ClientAdminUncheckedCreateWithoutLabTimeSlotsInput>
  }

  export type LabUpsertWithoutTimeSlotsInput = {
    update: XOR<LabUpdateWithoutTimeSlotsInput, LabUncheckedUpdateWithoutTimeSlotsInput>
    create: XOR<LabCreateWithoutTimeSlotsInput, LabUncheckedCreateWithoutTimeSlotsInput>
    where?: LabWhereInput
  }

  export type LabUpdateToOneWithWhereWithoutTimeSlotsInput = {
    where?: LabWhereInput
    data: XOR<LabUpdateWithoutTimeSlotsInput, LabUncheckedUpdateWithoutTimeSlotsInput>
  }

  export type LabUpdateWithoutTimeSlotsInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    totalPCs?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    financialRecords?: FinancialRecordUpdateManyWithoutLabNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutLabsNestedInput
  }

  export type LabUncheckedUpdateWithoutTimeSlotsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    totalPCs?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    clientAdminId?: StringFieldUpdateOperationsInput | string
    financialRecords?: FinancialRecordUncheckedUpdateManyWithoutLabNestedInput
  }

  export type BatchUpsertWithWhereUniqueWithoutLabTimeSlotInput = {
    where: BatchWhereUniqueInput
    update: XOR<BatchUpdateWithoutLabTimeSlotInput, BatchUncheckedUpdateWithoutLabTimeSlotInput>
    create: XOR<BatchCreateWithoutLabTimeSlotInput, BatchUncheckedCreateWithoutLabTimeSlotInput>
  }

  export type BatchUpdateWithWhereUniqueWithoutLabTimeSlotInput = {
    where: BatchWhereUniqueInput
    data: XOR<BatchUpdateWithoutLabTimeSlotInput, BatchUncheckedUpdateWithoutLabTimeSlotInput>
  }

  export type BatchUpdateManyWithWhereWithoutLabTimeSlotInput = {
    where: BatchScalarWhereInput
    data: XOR<BatchUpdateManyMutationInput, BatchUncheckedUpdateManyWithoutLabTimeSlotInput>
  }

  export type LabAllocationUpsertWithWhereUniqueWithoutLabTimeSlotInput = {
    where: LabAllocationWhereUniqueInput
    update: XOR<LabAllocationUpdateWithoutLabTimeSlotInput, LabAllocationUncheckedUpdateWithoutLabTimeSlotInput>
    create: XOR<LabAllocationCreateWithoutLabTimeSlotInput, LabAllocationUncheckedCreateWithoutLabTimeSlotInput>
  }

  export type LabAllocationUpdateWithWhereUniqueWithoutLabTimeSlotInput = {
    where: LabAllocationWhereUniqueInput
    data: XOR<LabAllocationUpdateWithoutLabTimeSlotInput, LabAllocationUncheckedUpdateWithoutLabTimeSlotInput>
  }

  export type LabAllocationUpdateManyWithWhereWithoutLabTimeSlotInput = {
    where: LabAllocationScalarWhereInput
    data: XOR<LabAllocationUpdateManyMutationInput, LabAllocationUncheckedUpdateManyWithoutLabTimeSlotInput>
  }

  export type ClientAdminUpsertWithoutLabTimeSlotsInput = {
    update: XOR<ClientAdminUpdateWithoutLabTimeSlotsInput, ClientAdminUncheckedUpdateWithoutLabTimeSlotsInput>
    create: XOR<ClientAdminCreateWithoutLabTimeSlotsInput, ClientAdminUncheckedCreateWithoutLabTimeSlotsInput>
    where?: ClientAdminWhereInput
  }

  export type ClientAdminUpdateToOneWithWhereWithoutLabTimeSlotsInput = {
    where?: ClientAdminWhereInput
    data: XOR<ClientAdminUpdateWithoutLabTimeSlotsInput, ClientAdminUncheckedUpdateWithoutLabTimeSlotsInput>
  }

  export type ClientAdminUpdateWithoutLabTimeSlotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    instituteName?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    fullAddress?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    certificateName?: NullableStringFieldUpdateOperationsInput | string | null
    stamp?: NullableStringFieldUpdateOperationsInput | string | null
    sign?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    currentSessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleUsers?: RoleUserUpdateManyWithoutClientAdminNestedInput
    faculties?: FacultyUpdateManyWithoutClientAdminNestedInput
    batches?: BatchUpdateManyWithoutClientAdminNestedInput
    courses?: CourseUpdateManyWithoutClientAdminNestedInput
    enquiryCourse?: EnquiryCourseUpdateManyWithoutClientAdminNestedInput
    labs?: LabUpdateManyWithoutClientAdminNestedInput
    labAllocations?: LabAllocationUpdateManyWithoutClientAdminNestedInput
    students?: StudentUpdateManyWithoutClientAdminNestedInput
    activities?: ActivityLogUpdateManyWithoutClientAdminNestedInput
    studentCourses?: StudentCourseUpdateManyWithoutClientAdminNestedInput
    feeStructures?: FeeStructureUpdateManyWithoutClientAdminNestedInput
    studentFees?: StudentFeeUpdateManyWithoutClientAdminNestedInput
    stationeryIssues?: StationeryIssueUpdateManyWithoutClientAdminNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutClientAdminNestedInput
    studentTasks?: StudentTaskUpdateManyWithoutClientAdminNestedInput
    studentTests?: StudentTestUpdateManyWithoutClientAdminNestedInput
    courseCompletions?: CourseCompletionUpdateManyWithoutClientAdminNestedInput
    certificates?: CertificateUpdateManyWithoutClientAdminNestedInput
    financialRecords?: FinancialRecordUpdateManyWithoutClientAdminNestedInput
    enquiries?: EnquiryUpdateManyWithoutClientAdminNestedInput
    notifications?: NotificationUpdateManyWithoutClientAdminNestedInput
    courseFeeStructures?: CourseFeeStructureUpdateManyWithoutClientAdminNestedInput
  }

  export type ClientAdminUncheckedUpdateWithoutLabTimeSlotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    instituteName?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    fullAddress?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    certificateName?: NullableStringFieldUpdateOperationsInput | string | null
    stamp?: NullableStringFieldUpdateOperationsInput | string | null
    sign?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    currentSessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleUsers?: RoleUserUncheckedUpdateManyWithoutClientAdminNestedInput
    faculties?: FacultyUncheckedUpdateManyWithoutClientAdminNestedInput
    batches?: BatchUncheckedUpdateManyWithoutClientAdminNestedInput
    courses?: CourseUncheckedUpdateManyWithoutClientAdminNestedInput
    enquiryCourse?: EnquiryCourseUncheckedUpdateManyWithoutClientAdminNestedInput
    labs?: LabUncheckedUpdateManyWithoutClientAdminNestedInput
    labAllocations?: LabAllocationUncheckedUpdateManyWithoutClientAdminNestedInput
    students?: StudentUncheckedUpdateManyWithoutClientAdminNestedInput
    activities?: ActivityLogUncheckedUpdateManyWithoutClientAdminNestedInput
    studentCourses?: StudentCourseUncheckedUpdateManyWithoutClientAdminNestedInput
    feeStructures?: FeeStructureUncheckedUpdateManyWithoutClientAdminNestedInput
    studentFees?: StudentFeeUncheckedUpdateManyWithoutClientAdminNestedInput
    stationeryIssues?: StationeryIssueUncheckedUpdateManyWithoutClientAdminNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutClientAdminNestedInput
    studentTasks?: StudentTaskUncheckedUpdateManyWithoutClientAdminNestedInput
    studentTests?: StudentTestUncheckedUpdateManyWithoutClientAdminNestedInput
    courseCompletions?: CourseCompletionUncheckedUpdateManyWithoutClientAdminNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutClientAdminNestedInput
    financialRecords?: FinancialRecordUncheckedUpdateManyWithoutClientAdminNestedInput
    enquiries?: EnquiryUncheckedUpdateManyWithoutClientAdminNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutClientAdminNestedInput
    courseFeeStructures?: CourseFeeStructureUncheckedUpdateManyWithoutClientAdminNestedInput
  }

  export type FeeStructureCreateWithoutInstallmentInput = {
    totalAmount: number
    paymentType: $Enums.PaymentType
    installmentCount?: number | null
    student: StudentCreateNestedOneWithoutFeeStructuresInput
    course: CourseCreateNestedOneWithoutFeeStructuresInput
    studentFees?: StudentFeeCreateNestedManyWithoutFeeStructureInput
    clientAdmin: ClientAdminCreateNestedOneWithoutFeeStructuresInput
  }

  export type FeeStructureUncheckedCreateWithoutInstallmentInput = {
    id?: number
    studentId: number
    courseId: number
    totalAmount: number
    paymentType: $Enums.PaymentType
    installmentCount?: number | null
    clientAdminId: string
    studentFees?: StudentFeeUncheckedCreateNestedManyWithoutFeeStructureInput
  }

  export type FeeStructureCreateOrConnectWithoutInstallmentInput = {
    where: FeeStructureWhereUniqueInput
    create: XOR<FeeStructureCreateWithoutInstallmentInput, FeeStructureUncheckedCreateWithoutInstallmentInput>
  }

  export type FeeStructureCreateManyInstallmentInputEnvelope = {
    data: FeeStructureCreateManyInstallmentInput | FeeStructureCreateManyInstallmentInput[]
    skipDuplicates?: boolean
  }

  export type CourseFeeStructureCreateWithoutInstallmentsInput = {
    totalAmount: number
    paymentType?: CourseFeeStructureCreatepaymentTypeInput | string[]
    course: CourseCreateNestedOneWithoutCourseFeeStructureInput
    clientAdmin: ClientAdminCreateNestedOneWithoutCourseFeeStructuresInput
  }

  export type CourseFeeStructureUncheckedCreateWithoutInstallmentsInput = {
    id?: number
    courseId: number
    totalAmount: number
    paymentType?: CourseFeeStructureCreatepaymentTypeInput | string[]
    clientAdminId: string
  }

  export type CourseFeeStructureCreateOrConnectWithoutInstallmentsInput = {
    where: CourseFeeStructureWhereUniqueInput
    create: XOR<CourseFeeStructureCreateWithoutInstallmentsInput, CourseFeeStructureUncheckedCreateWithoutInstallmentsInput>
  }

  export type FeeStructureUpsertWithWhereUniqueWithoutInstallmentInput = {
    where: FeeStructureWhereUniqueInput
    update: XOR<FeeStructureUpdateWithoutInstallmentInput, FeeStructureUncheckedUpdateWithoutInstallmentInput>
    create: XOR<FeeStructureCreateWithoutInstallmentInput, FeeStructureUncheckedCreateWithoutInstallmentInput>
  }

  export type FeeStructureUpdateWithWhereUniqueWithoutInstallmentInput = {
    where: FeeStructureWhereUniqueInput
    data: XOR<FeeStructureUpdateWithoutInstallmentInput, FeeStructureUncheckedUpdateWithoutInstallmentInput>
  }

  export type FeeStructureUpdateManyWithWhereWithoutInstallmentInput = {
    where: FeeStructureScalarWhereInput
    data: XOR<FeeStructureUpdateManyMutationInput, FeeStructureUncheckedUpdateManyWithoutInstallmentInput>
  }

  export type CourseFeeStructureUpsertWithoutInstallmentsInput = {
    update: XOR<CourseFeeStructureUpdateWithoutInstallmentsInput, CourseFeeStructureUncheckedUpdateWithoutInstallmentsInput>
    create: XOR<CourseFeeStructureCreateWithoutInstallmentsInput, CourseFeeStructureUncheckedCreateWithoutInstallmentsInput>
    where?: CourseFeeStructureWhereInput
  }

  export type CourseFeeStructureUpdateToOneWithWhereWithoutInstallmentsInput = {
    where?: CourseFeeStructureWhereInput
    data: XOR<CourseFeeStructureUpdateWithoutInstallmentsInput, CourseFeeStructureUncheckedUpdateWithoutInstallmentsInput>
  }

  export type CourseFeeStructureUpdateWithoutInstallmentsInput = {
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paymentType?: CourseFeeStructureUpdatepaymentTypeInput | string[]
    course?: CourseUpdateOneRequiredWithoutCourseFeeStructureNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutCourseFeeStructuresNestedInput
  }

  export type CourseFeeStructureUncheckedUpdateWithoutInstallmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paymentType?: CourseFeeStructureUpdatepaymentTypeInput | string[]
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type LabTimeSlotCreateWithoutAllocationsInput = {
    startTime: string
    endTime: string
    day: string
    availablePCs: number
    lab: LabCreateNestedOneWithoutTimeSlotsInput
    batches?: BatchCreateNestedManyWithoutLabTimeSlotInput
    clientAdmin: ClientAdminCreateNestedOneWithoutLabTimeSlotsInput
  }

  export type LabTimeSlotUncheckedCreateWithoutAllocationsInput = {
    id?: number
    startTime: string
    endTime: string
    day: string
    labId: number
    availablePCs: number
    clientAdminId: string
    batches?: BatchUncheckedCreateNestedManyWithoutLabTimeSlotInput
  }

  export type LabTimeSlotCreateOrConnectWithoutAllocationsInput = {
    where: LabTimeSlotWhereUniqueInput
    create: XOR<LabTimeSlotCreateWithoutAllocationsInput, LabTimeSlotUncheckedCreateWithoutAllocationsInput>
  }

  export type StudentCreateWithoutLabAllocationsInput = {
    serialNumber: number
    studentCode: string
    fullName: string
    fatherName: string
    motherName: string
    photoUrl?: string | null
    contact: string
    parentsContact: string
    email?: string | null
    residentialAddress?: string | null
    permenantAddress?: string | null
    dob: string
    gender: string
    religion?: string | null
    idProofType?: string | null
    idProofNumber?: string | null
    admissionDate: Date | string
    enquiry?: EnquiryCreateNestedOneWithoutStudentInput
    studentCourses?: StudentCourseCreateNestedManyWithoutStudentInput
    feeStructures?: FeeStructureCreateNestedManyWithoutStudentInput
    feeRecords?: StudentFeeCreateNestedManyWithoutStudentInput
    attendance?: AttendanceRecordCreateNestedManyWithoutStudentInput
    tasks?: StudentTaskCreateNestedManyWithoutStudentInput
    tests?: StudentTestCreateNestedManyWithoutStudentInput
    completions?: CourseCompletionCreateNestedManyWithoutStudentInput
    stationery?: StationeryIssueCreateNestedManyWithoutStudentInput
    certificates?: CertificateCreateNestedManyWithoutStudentInput
    financialRecords?: FinancialRecordCreateNestedManyWithoutStudentInput
    clientAdmin: ClientAdminCreateNestedOneWithoutStudentsInput
  }

  export type StudentUncheckedCreateWithoutLabAllocationsInput = {
    id?: number
    serialNumber: number
    studentCode: string
    fullName: string
    fatherName: string
    motherName: string
    photoUrl?: string | null
    contact: string
    parentsContact: string
    email?: string | null
    residentialAddress?: string | null
    permenantAddress?: string | null
    dob: string
    gender: string
    religion?: string | null
    idProofType?: string | null
    idProofNumber?: string | null
    admissionDate: Date | string
    clientAdminId: string
    enquiry?: EnquiryUncheckedCreateNestedOneWithoutStudentInput
    studentCourses?: StudentCourseUncheckedCreateNestedManyWithoutStudentInput
    feeStructures?: FeeStructureUncheckedCreateNestedManyWithoutStudentInput
    feeRecords?: StudentFeeUncheckedCreateNestedManyWithoutStudentInput
    attendance?: AttendanceRecordUncheckedCreateNestedManyWithoutStudentInput
    tasks?: StudentTaskUncheckedCreateNestedManyWithoutStudentInput
    tests?: StudentTestUncheckedCreateNestedManyWithoutStudentInput
    completions?: CourseCompletionUncheckedCreateNestedManyWithoutStudentInput
    stationery?: StationeryIssueUncheckedCreateNestedManyWithoutStudentInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutStudentInput
    financialRecords?: FinancialRecordUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutLabAllocationsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutLabAllocationsInput, StudentUncheckedCreateWithoutLabAllocationsInput>
  }

  export type ClientAdminCreateWithoutLabAllocationsInput = {
    id?: string
    name: string
    email: string
    password: string
    instituteName: string
    slug: string
    fullAddress: string
    logo?: string | null
    certificateName?: string | null
    stamp?: string | null
    sign?: string | null
    contact: string
    position: string
    country: string
    state: string
    city: string
    zipCode: string
    createdAt?: Date | string
    role?: $Enums.UserRole
    currentSessionToken?: string | null
    lastLoginAt?: Date | string | null
    roleUsers?: RoleUserCreateNestedManyWithoutClientAdminInput
    faculties?: FacultyCreateNestedManyWithoutClientAdminInput
    batches?: BatchCreateNestedManyWithoutClientAdminInput
    courses?: CourseCreateNestedManyWithoutClientAdminInput
    enquiryCourse?: EnquiryCourseCreateNestedManyWithoutClientAdminInput
    labs?: LabCreateNestedManyWithoutClientAdminInput
    labTimeSlots?: LabTimeSlotCreateNestedManyWithoutClientAdminInput
    students?: StudentCreateNestedManyWithoutClientAdminInput
    activities?: ActivityLogCreateNestedManyWithoutClientAdminInput
    studentCourses?: StudentCourseCreateNestedManyWithoutClientAdminInput
    feeStructures?: FeeStructureCreateNestedManyWithoutClientAdminInput
    studentFees?: StudentFeeCreateNestedManyWithoutClientAdminInput
    stationeryIssues?: StationeryIssueCreateNestedManyWithoutClientAdminInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutClientAdminInput
    studentTasks?: StudentTaskCreateNestedManyWithoutClientAdminInput
    studentTests?: StudentTestCreateNestedManyWithoutClientAdminInput
    courseCompletions?: CourseCompletionCreateNestedManyWithoutClientAdminInput
    certificates?: CertificateCreateNestedManyWithoutClientAdminInput
    financialRecords?: FinancialRecordCreateNestedManyWithoutClientAdminInput
    enquiries?: EnquiryCreateNestedManyWithoutClientAdminInput
    notifications?: NotificationCreateNestedManyWithoutClientAdminInput
    courseFeeStructures?: CourseFeeStructureCreateNestedManyWithoutClientAdminInput
  }

  export type ClientAdminUncheckedCreateWithoutLabAllocationsInput = {
    id?: string
    name: string
    email: string
    password: string
    instituteName: string
    slug: string
    fullAddress: string
    logo?: string | null
    certificateName?: string | null
    stamp?: string | null
    sign?: string | null
    contact: string
    position: string
    country: string
    state: string
    city: string
    zipCode: string
    createdAt?: Date | string
    role?: $Enums.UserRole
    currentSessionToken?: string | null
    lastLoginAt?: Date | string | null
    roleUsers?: RoleUserUncheckedCreateNestedManyWithoutClientAdminInput
    faculties?: FacultyUncheckedCreateNestedManyWithoutClientAdminInput
    batches?: BatchUncheckedCreateNestedManyWithoutClientAdminInput
    courses?: CourseUncheckedCreateNestedManyWithoutClientAdminInput
    enquiryCourse?: EnquiryCourseUncheckedCreateNestedManyWithoutClientAdminInput
    labs?: LabUncheckedCreateNestedManyWithoutClientAdminInput
    labTimeSlots?: LabTimeSlotUncheckedCreateNestedManyWithoutClientAdminInput
    students?: StudentUncheckedCreateNestedManyWithoutClientAdminInput
    activities?: ActivityLogUncheckedCreateNestedManyWithoutClientAdminInput
    studentCourses?: StudentCourseUncheckedCreateNestedManyWithoutClientAdminInput
    feeStructures?: FeeStructureUncheckedCreateNestedManyWithoutClientAdminInput
    studentFees?: StudentFeeUncheckedCreateNestedManyWithoutClientAdminInput
    stationeryIssues?: StationeryIssueUncheckedCreateNestedManyWithoutClientAdminInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutClientAdminInput
    studentTasks?: StudentTaskUncheckedCreateNestedManyWithoutClientAdminInput
    studentTests?: StudentTestUncheckedCreateNestedManyWithoutClientAdminInput
    courseCompletions?: CourseCompletionUncheckedCreateNestedManyWithoutClientAdminInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutClientAdminInput
    financialRecords?: FinancialRecordUncheckedCreateNestedManyWithoutClientAdminInput
    enquiries?: EnquiryUncheckedCreateNestedManyWithoutClientAdminInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutClientAdminInput
    courseFeeStructures?: CourseFeeStructureUncheckedCreateNestedManyWithoutClientAdminInput
  }

  export type ClientAdminCreateOrConnectWithoutLabAllocationsInput = {
    where: ClientAdminWhereUniqueInput
    create: XOR<ClientAdminCreateWithoutLabAllocationsInput, ClientAdminUncheckedCreateWithoutLabAllocationsInput>
  }

  export type LabTimeSlotUpsertWithoutAllocationsInput = {
    update: XOR<LabTimeSlotUpdateWithoutAllocationsInput, LabTimeSlotUncheckedUpdateWithoutAllocationsInput>
    create: XOR<LabTimeSlotCreateWithoutAllocationsInput, LabTimeSlotUncheckedCreateWithoutAllocationsInput>
    where?: LabTimeSlotWhereInput
  }

  export type LabTimeSlotUpdateToOneWithWhereWithoutAllocationsInput = {
    where?: LabTimeSlotWhereInput
    data: XOR<LabTimeSlotUpdateWithoutAllocationsInput, LabTimeSlotUncheckedUpdateWithoutAllocationsInput>
  }

  export type LabTimeSlotUpdateWithoutAllocationsInput = {
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    day?: StringFieldUpdateOperationsInput | string
    availablePCs?: IntFieldUpdateOperationsInput | number
    lab?: LabUpdateOneRequiredWithoutTimeSlotsNestedInput
    batches?: BatchUpdateManyWithoutLabTimeSlotNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutLabTimeSlotsNestedInput
  }

  export type LabTimeSlotUncheckedUpdateWithoutAllocationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    day?: StringFieldUpdateOperationsInput | string
    labId?: IntFieldUpdateOperationsInput | number
    availablePCs?: IntFieldUpdateOperationsInput | number
    clientAdminId?: StringFieldUpdateOperationsInput | string
    batches?: BatchUncheckedUpdateManyWithoutLabTimeSlotNestedInput
  }

  export type StudentUpsertWithoutLabAllocationsInput = {
    update: XOR<StudentUpdateWithoutLabAllocationsInput, StudentUncheckedUpdateWithoutLabAllocationsInput>
    create: XOR<StudentCreateWithoutLabAllocationsInput, StudentUncheckedCreateWithoutLabAllocationsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutLabAllocationsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutLabAllocationsInput, StudentUncheckedUpdateWithoutLabAllocationsInput>
  }

  export type StudentUpdateWithoutLabAllocationsInput = {
    serialNumber?: IntFieldUpdateOperationsInput | number
    studentCode?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    fatherName?: StringFieldUpdateOperationsInput | string
    motherName?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: StringFieldUpdateOperationsInput | string
    parentsContact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: NullableStringFieldUpdateOperationsInput | string | null
    permenantAddress?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    idProofType?: NullableStringFieldUpdateOperationsInput | string | null
    idProofNumber?: NullableStringFieldUpdateOperationsInput | string | null
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    enquiry?: EnquiryUpdateOneWithoutStudentNestedInput
    studentCourses?: StudentCourseUpdateManyWithoutStudentNestedInput
    feeStructures?: FeeStructureUpdateManyWithoutStudentNestedInput
    feeRecords?: StudentFeeUpdateManyWithoutStudentNestedInput
    attendance?: AttendanceRecordUpdateManyWithoutStudentNestedInput
    tasks?: StudentTaskUpdateManyWithoutStudentNestedInput
    tests?: StudentTestUpdateManyWithoutStudentNestedInput
    completions?: CourseCompletionUpdateManyWithoutStudentNestedInput
    stationery?: StationeryIssueUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUpdateManyWithoutStudentNestedInput
    financialRecords?: FinancialRecordUpdateManyWithoutStudentNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutStudentsNestedInput
  }

  export type StudentUncheckedUpdateWithoutLabAllocationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    serialNumber?: IntFieldUpdateOperationsInput | number
    studentCode?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    fatherName?: StringFieldUpdateOperationsInput | string
    motherName?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: StringFieldUpdateOperationsInput | string
    parentsContact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: NullableStringFieldUpdateOperationsInput | string | null
    permenantAddress?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    idProofType?: NullableStringFieldUpdateOperationsInput | string | null
    idProofNumber?: NullableStringFieldUpdateOperationsInput | string | null
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    clientAdminId?: StringFieldUpdateOperationsInput | string
    enquiry?: EnquiryUncheckedUpdateOneWithoutStudentNestedInput
    studentCourses?: StudentCourseUncheckedUpdateManyWithoutStudentNestedInput
    feeStructures?: FeeStructureUncheckedUpdateManyWithoutStudentNestedInput
    feeRecords?: StudentFeeUncheckedUpdateManyWithoutStudentNestedInput
    attendance?: AttendanceRecordUncheckedUpdateManyWithoutStudentNestedInput
    tasks?: StudentTaskUncheckedUpdateManyWithoutStudentNestedInput
    tests?: StudentTestUncheckedUpdateManyWithoutStudentNestedInput
    completions?: CourseCompletionUncheckedUpdateManyWithoutStudentNestedInput
    stationery?: StationeryIssueUncheckedUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutStudentNestedInput
    financialRecords?: FinancialRecordUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type ClientAdminUpsertWithoutLabAllocationsInput = {
    update: XOR<ClientAdminUpdateWithoutLabAllocationsInput, ClientAdminUncheckedUpdateWithoutLabAllocationsInput>
    create: XOR<ClientAdminCreateWithoutLabAllocationsInput, ClientAdminUncheckedCreateWithoutLabAllocationsInput>
    where?: ClientAdminWhereInput
  }

  export type ClientAdminUpdateToOneWithWhereWithoutLabAllocationsInput = {
    where?: ClientAdminWhereInput
    data: XOR<ClientAdminUpdateWithoutLabAllocationsInput, ClientAdminUncheckedUpdateWithoutLabAllocationsInput>
  }

  export type ClientAdminUpdateWithoutLabAllocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    instituteName?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    fullAddress?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    certificateName?: NullableStringFieldUpdateOperationsInput | string | null
    stamp?: NullableStringFieldUpdateOperationsInput | string | null
    sign?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    currentSessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleUsers?: RoleUserUpdateManyWithoutClientAdminNestedInput
    faculties?: FacultyUpdateManyWithoutClientAdminNestedInput
    batches?: BatchUpdateManyWithoutClientAdminNestedInput
    courses?: CourseUpdateManyWithoutClientAdminNestedInput
    enquiryCourse?: EnquiryCourseUpdateManyWithoutClientAdminNestedInput
    labs?: LabUpdateManyWithoutClientAdminNestedInput
    labTimeSlots?: LabTimeSlotUpdateManyWithoutClientAdminNestedInput
    students?: StudentUpdateManyWithoutClientAdminNestedInput
    activities?: ActivityLogUpdateManyWithoutClientAdminNestedInput
    studentCourses?: StudentCourseUpdateManyWithoutClientAdminNestedInput
    feeStructures?: FeeStructureUpdateManyWithoutClientAdminNestedInput
    studentFees?: StudentFeeUpdateManyWithoutClientAdminNestedInput
    stationeryIssues?: StationeryIssueUpdateManyWithoutClientAdminNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutClientAdminNestedInput
    studentTasks?: StudentTaskUpdateManyWithoutClientAdminNestedInput
    studentTests?: StudentTestUpdateManyWithoutClientAdminNestedInput
    courseCompletions?: CourseCompletionUpdateManyWithoutClientAdminNestedInput
    certificates?: CertificateUpdateManyWithoutClientAdminNestedInput
    financialRecords?: FinancialRecordUpdateManyWithoutClientAdminNestedInput
    enquiries?: EnquiryUpdateManyWithoutClientAdminNestedInput
    notifications?: NotificationUpdateManyWithoutClientAdminNestedInput
    courseFeeStructures?: CourseFeeStructureUpdateManyWithoutClientAdminNestedInput
  }

  export type ClientAdminUncheckedUpdateWithoutLabAllocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    instituteName?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    fullAddress?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    certificateName?: NullableStringFieldUpdateOperationsInput | string | null
    stamp?: NullableStringFieldUpdateOperationsInput | string | null
    sign?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    currentSessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleUsers?: RoleUserUncheckedUpdateManyWithoutClientAdminNestedInput
    faculties?: FacultyUncheckedUpdateManyWithoutClientAdminNestedInput
    batches?: BatchUncheckedUpdateManyWithoutClientAdminNestedInput
    courses?: CourseUncheckedUpdateManyWithoutClientAdminNestedInput
    enquiryCourse?: EnquiryCourseUncheckedUpdateManyWithoutClientAdminNestedInput
    labs?: LabUncheckedUpdateManyWithoutClientAdminNestedInput
    labTimeSlots?: LabTimeSlotUncheckedUpdateManyWithoutClientAdminNestedInput
    students?: StudentUncheckedUpdateManyWithoutClientAdminNestedInput
    activities?: ActivityLogUncheckedUpdateManyWithoutClientAdminNestedInput
    studentCourses?: StudentCourseUncheckedUpdateManyWithoutClientAdminNestedInput
    feeStructures?: FeeStructureUncheckedUpdateManyWithoutClientAdminNestedInput
    studentFees?: StudentFeeUncheckedUpdateManyWithoutClientAdminNestedInput
    stationeryIssues?: StationeryIssueUncheckedUpdateManyWithoutClientAdminNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutClientAdminNestedInput
    studentTasks?: StudentTaskUncheckedUpdateManyWithoutClientAdminNestedInput
    studentTests?: StudentTestUncheckedUpdateManyWithoutClientAdminNestedInput
    courseCompletions?: CourseCompletionUncheckedUpdateManyWithoutClientAdminNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutClientAdminNestedInput
    financialRecords?: FinancialRecordUncheckedUpdateManyWithoutClientAdminNestedInput
    enquiries?: EnquiryUncheckedUpdateManyWithoutClientAdminNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutClientAdminNestedInput
    courseFeeStructures?: CourseFeeStructureUncheckedUpdateManyWithoutClientAdminNestedInput
  }

  export type StudentCreateWithoutStudentCoursesInput = {
    serialNumber: number
    studentCode: string
    fullName: string
    fatherName: string
    motherName: string
    photoUrl?: string | null
    contact: string
    parentsContact: string
    email?: string | null
    residentialAddress?: string | null
    permenantAddress?: string | null
    dob: string
    gender: string
    religion?: string | null
    idProofType?: string | null
    idProofNumber?: string | null
    admissionDate: Date | string
    enquiry?: EnquiryCreateNestedOneWithoutStudentInput
    labAllocations?: LabAllocationCreateNestedManyWithoutStudentInput
    feeStructures?: FeeStructureCreateNestedManyWithoutStudentInput
    feeRecords?: StudentFeeCreateNestedManyWithoutStudentInput
    attendance?: AttendanceRecordCreateNestedManyWithoutStudentInput
    tasks?: StudentTaskCreateNestedManyWithoutStudentInput
    tests?: StudentTestCreateNestedManyWithoutStudentInput
    completions?: CourseCompletionCreateNestedManyWithoutStudentInput
    stationery?: StationeryIssueCreateNestedManyWithoutStudentInput
    certificates?: CertificateCreateNestedManyWithoutStudentInput
    financialRecords?: FinancialRecordCreateNestedManyWithoutStudentInput
    clientAdmin: ClientAdminCreateNestedOneWithoutStudentsInput
  }

  export type StudentUncheckedCreateWithoutStudentCoursesInput = {
    id?: number
    serialNumber: number
    studentCode: string
    fullName: string
    fatherName: string
    motherName: string
    photoUrl?: string | null
    contact: string
    parentsContact: string
    email?: string | null
    residentialAddress?: string | null
    permenantAddress?: string | null
    dob: string
    gender: string
    religion?: string | null
    idProofType?: string | null
    idProofNumber?: string | null
    admissionDate: Date | string
    clientAdminId: string
    enquiry?: EnquiryUncheckedCreateNestedOneWithoutStudentInput
    labAllocations?: LabAllocationUncheckedCreateNestedManyWithoutStudentInput
    feeStructures?: FeeStructureUncheckedCreateNestedManyWithoutStudentInput
    feeRecords?: StudentFeeUncheckedCreateNestedManyWithoutStudentInput
    attendance?: AttendanceRecordUncheckedCreateNestedManyWithoutStudentInput
    tasks?: StudentTaskUncheckedCreateNestedManyWithoutStudentInput
    tests?: StudentTestUncheckedCreateNestedManyWithoutStudentInput
    completions?: CourseCompletionUncheckedCreateNestedManyWithoutStudentInput
    stationery?: StationeryIssueUncheckedCreateNestedManyWithoutStudentInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutStudentInput
    financialRecords?: FinancialRecordUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutStudentCoursesInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutStudentCoursesInput, StudentUncheckedCreateWithoutStudentCoursesInput>
  }

  export type CourseCreateWithoutStudentCoursesInput = {
    name: string
    durationWeeks: number
    description?: string | null
    courseFeeStructure?: CourseFeeStructureCreateNestedOneWithoutCourseInput
    enquiryCourse?: EnquiryCourseCreateNestedManyWithoutCourseInput
    feeStructures?: FeeStructureCreateNestedManyWithoutCourseInput
    stationery?: StationeryIssueCreateNestedManyWithoutCourseInput
    studentFees?: StudentFeeCreateNestedManyWithoutCourseInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutCourseInput
    studentTasks?: StudentTaskCreateNestedManyWithoutCourseInput
    studentTests?: StudentTestCreateNestedManyWithoutCourseInput
    certificates?: CertificateCreateNestedManyWithoutCourseInput
    financialRecords?: FinancialRecordCreateNestedManyWithoutCourseInput
    batchCourses?: BatchCourseCreateNestedManyWithoutCourseInput
    clientAdmin: ClientAdminCreateNestedOneWithoutCoursesInput
  }

  export type CourseUncheckedCreateWithoutStudentCoursesInput = {
    id?: number
    name: string
    durationWeeks: number
    description?: string | null
    clientAdminId: string
    courseFeeStructure?: CourseFeeStructureUncheckedCreateNestedOneWithoutCourseInput
    enquiryCourse?: EnquiryCourseUncheckedCreateNestedManyWithoutCourseInput
    feeStructures?: FeeStructureUncheckedCreateNestedManyWithoutCourseInput
    stationery?: StationeryIssueUncheckedCreateNestedManyWithoutCourseInput
    studentFees?: StudentFeeUncheckedCreateNestedManyWithoutCourseInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutCourseInput
    studentTasks?: StudentTaskUncheckedCreateNestedManyWithoutCourseInput
    studentTests?: StudentTestUncheckedCreateNestedManyWithoutCourseInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutCourseInput
    financialRecords?: FinancialRecordUncheckedCreateNestedManyWithoutCourseInput
    batchCourses?: BatchCourseUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutStudentCoursesInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutStudentCoursesInput, CourseUncheckedCreateWithoutStudentCoursesInput>
  }

  export type BatchCreateWithoutStudentCoursesInput = {
    name: string
    faculty?: FacultyCreateNestedOneWithoutBatchesInput
    labTimeSlot: LabTimeSlotCreateNestedOneWithoutBatchesInput
    batchCourses?: BatchCourseCreateNestedManyWithoutBatchInput
    clientAdmin: ClientAdminCreateNestedOneWithoutBatchesInput
  }

  export type BatchUncheckedCreateWithoutStudentCoursesInput = {
    id?: number
    name: string
    facultyId?: number | null
    labTimeSlotId: number
    clientAdminId: string
    batchCourses?: BatchCourseUncheckedCreateNestedManyWithoutBatchInput
  }

  export type BatchCreateOrConnectWithoutStudentCoursesInput = {
    where: BatchWhereUniqueInput
    create: XOR<BatchCreateWithoutStudentCoursesInput, BatchUncheckedCreateWithoutStudentCoursesInput>
  }

  export type CertificateCreateWithoutStudentCourseInput = {
    issueDate: Date | string
    certificateUrl: string
    student: StudentCreateNestedOneWithoutCertificatesInput
    course: CourseCreateNestedOneWithoutCertificatesInput
    clientAdmin: ClientAdminCreateNestedOneWithoutCertificatesInput
  }

  export type CertificateUncheckedCreateWithoutStudentCourseInput = {
    id?: number
    studentId: number
    courseId: number
    issueDate: Date | string
    certificateUrl: string
    clientAdminId: string
  }

  export type CertificateCreateOrConnectWithoutStudentCourseInput = {
    where: CertificateWhereUniqueInput
    create: XOR<CertificateCreateWithoutStudentCourseInput, CertificateUncheckedCreateWithoutStudentCourseInput>
  }

  export type CourseCompletionCreateWithoutStudentCourseInput = {
    completionDate: Date | string
    feedback?: string | null
    remarks?: string | null
    student: StudentCreateNestedOneWithoutCompletionsInput
    clientAdmin: ClientAdminCreateNestedOneWithoutCourseCompletionsInput
  }

  export type CourseCompletionUncheckedCreateWithoutStudentCourseInput = {
    id?: number
    studentId: number
    completionDate: Date | string
    feedback?: string | null
    remarks?: string | null
    clientAdminId: string
  }

  export type CourseCompletionCreateOrConnectWithoutStudentCourseInput = {
    where: CourseCompletionWhereUniqueInput
    create: XOR<CourseCompletionCreateWithoutStudentCourseInput, CourseCompletionUncheckedCreateWithoutStudentCourseInput>
  }

  export type CourseCompletionCreateManyStudentCourseInputEnvelope = {
    data: CourseCompletionCreateManyStudentCourseInput | CourseCompletionCreateManyStudentCourseInput[]
    skipDuplicates?: boolean
  }

  export type ClientAdminCreateWithoutStudentCoursesInput = {
    id?: string
    name: string
    email: string
    password: string
    instituteName: string
    slug: string
    fullAddress: string
    logo?: string | null
    certificateName?: string | null
    stamp?: string | null
    sign?: string | null
    contact: string
    position: string
    country: string
    state: string
    city: string
    zipCode: string
    createdAt?: Date | string
    role?: $Enums.UserRole
    currentSessionToken?: string | null
    lastLoginAt?: Date | string | null
    roleUsers?: RoleUserCreateNestedManyWithoutClientAdminInput
    faculties?: FacultyCreateNestedManyWithoutClientAdminInput
    batches?: BatchCreateNestedManyWithoutClientAdminInput
    courses?: CourseCreateNestedManyWithoutClientAdminInput
    enquiryCourse?: EnquiryCourseCreateNestedManyWithoutClientAdminInput
    labs?: LabCreateNestedManyWithoutClientAdminInput
    labTimeSlots?: LabTimeSlotCreateNestedManyWithoutClientAdminInput
    labAllocations?: LabAllocationCreateNestedManyWithoutClientAdminInput
    students?: StudentCreateNestedManyWithoutClientAdminInput
    activities?: ActivityLogCreateNestedManyWithoutClientAdminInput
    feeStructures?: FeeStructureCreateNestedManyWithoutClientAdminInput
    studentFees?: StudentFeeCreateNestedManyWithoutClientAdminInput
    stationeryIssues?: StationeryIssueCreateNestedManyWithoutClientAdminInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutClientAdminInput
    studentTasks?: StudentTaskCreateNestedManyWithoutClientAdminInput
    studentTests?: StudentTestCreateNestedManyWithoutClientAdminInput
    courseCompletions?: CourseCompletionCreateNestedManyWithoutClientAdminInput
    certificates?: CertificateCreateNestedManyWithoutClientAdminInput
    financialRecords?: FinancialRecordCreateNestedManyWithoutClientAdminInput
    enquiries?: EnquiryCreateNestedManyWithoutClientAdminInput
    notifications?: NotificationCreateNestedManyWithoutClientAdminInput
    courseFeeStructures?: CourseFeeStructureCreateNestedManyWithoutClientAdminInput
  }

  export type ClientAdminUncheckedCreateWithoutStudentCoursesInput = {
    id?: string
    name: string
    email: string
    password: string
    instituteName: string
    slug: string
    fullAddress: string
    logo?: string | null
    certificateName?: string | null
    stamp?: string | null
    sign?: string | null
    contact: string
    position: string
    country: string
    state: string
    city: string
    zipCode: string
    createdAt?: Date | string
    role?: $Enums.UserRole
    currentSessionToken?: string | null
    lastLoginAt?: Date | string | null
    roleUsers?: RoleUserUncheckedCreateNestedManyWithoutClientAdminInput
    faculties?: FacultyUncheckedCreateNestedManyWithoutClientAdminInput
    batches?: BatchUncheckedCreateNestedManyWithoutClientAdminInput
    courses?: CourseUncheckedCreateNestedManyWithoutClientAdminInput
    enquiryCourse?: EnquiryCourseUncheckedCreateNestedManyWithoutClientAdminInput
    labs?: LabUncheckedCreateNestedManyWithoutClientAdminInput
    labTimeSlots?: LabTimeSlotUncheckedCreateNestedManyWithoutClientAdminInput
    labAllocations?: LabAllocationUncheckedCreateNestedManyWithoutClientAdminInput
    students?: StudentUncheckedCreateNestedManyWithoutClientAdminInput
    activities?: ActivityLogUncheckedCreateNestedManyWithoutClientAdminInput
    feeStructures?: FeeStructureUncheckedCreateNestedManyWithoutClientAdminInput
    studentFees?: StudentFeeUncheckedCreateNestedManyWithoutClientAdminInput
    stationeryIssues?: StationeryIssueUncheckedCreateNestedManyWithoutClientAdminInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutClientAdminInput
    studentTasks?: StudentTaskUncheckedCreateNestedManyWithoutClientAdminInput
    studentTests?: StudentTestUncheckedCreateNestedManyWithoutClientAdminInput
    courseCompletions?: CourseCompletionUncheckedCreateNestedManyWithoutClientAdminInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutClientAdminInput
    financialRecords?: FinancialRecordUncheckedCreateNestedManyWithoutClientAdminInput
    enquiries?: EnquiryUncheckedCreateNestedManyWithoutClientAdminInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutClientAdminInput
    courseFeeStructures?: CourseFeeStructureUncheckedCreateNestedManyWithoutClientAdminInput
  }

  export type ClientAdminCreateOrConnectWithoutStudentCoursesInput = {
    where: ClientAdminWhereUniqueInput
    create: XOR<ClientAdminCreateWithoutStudentCoursesInput, ClientAdminUncheckedCreateWithoutStudentCoursesInput>
  }

  export type StudentUpsertWithoutStudentCoursesInput = {
    update: XOR<StudentUpdateWithoutStudentCoursesInput, StudentUncheckedUpdateWithoutStudentCoursesInput>
    create: XOR<StudentCreateWithoutStudentCoursesInput, StudentUncheckedCreateWithoutStudentCoursesInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutStudentCoursesInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutStudentCoursesInput, StudentUncheckedUpdateWithoutStudentCoursesInput>
  }

  export type StudentUpdateWithoutStudentCoursesInput = {
    serialNumber?: IntFieldUpdateOperationsInput | number
    studentCode?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    fatherName?: StringFieldUpdateOperationsInput | string
    motherName?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: StringFieldUpdateOperationsInput | string
    parentsContact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: NullableStringFieldUpdateOperationsInput | string | null
    permenantAddress?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    idProofType?: NullableStringFieldUpdateOperationsInput | string | null
    idProofNumber?: NullableStringFieldUpdateOperationsInput | string | null
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    enquiry?: EnquiryUpdateOneWithoutStudentNestedInput
    labAllocations?: LabAllocationUpdateManyWithoutStudentNestedInput
    feeStructures?: FeeStructureUpdateManyWithoutStudentNestedInput
    feeRecords?: StudentFeeUpdateManyWithoutStudentNestedInput
    attendance?: AttendanceRecordUpdateManyWithoutStudentNestedInput
    tasks?: StudentTaskUpdateManyWithoutStudentNestedInput
    tests?: StudentTestUpdateManyWithoutStudentNestedInput
    completions?: CourseCompletionUpdateManyWithoutStudentNestedInput
    stationery?: StationeryIssueUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUpdateManyWithoutStudentNestedInput
    financialRecords?: FinancialRecordUpdateManyWithoutStudentNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutStudentsNestedInput
  }

  export type StudentUncheckedUpdateWithoutStudentCoursesInput = {
    id?: IntFieldUpdateOperationsInput | number
    serialNumber?: IntFieldUpdateOperationsInput | number
    studentCode?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    fatherName?: StringFieldUpdateOperationsInput | string
    motherName?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: StringFieldUpdateOperationsInput | string
    parentsContact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: NullableStringFieldUpdateOperationsInput | string | null
    permenantAddress?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    idProofType?: NullableStringFieldUpdateOperationsInput | string | null
    idProofNumber?: NullableStringFieldUpdateOperationsInput | string | null
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    clientAdminId?: StringFieldUpdateOperationsInput | string
    enquiry?: EnquiryUncheckedUpdateOneWithoutStudentNestedInput
    labAllocations?: LabAllocationUncheckedUpdateManyWithoutStudentNestedInput
    feeStructures?: FeeStructureUncheckedUpdateManyWithoutStudentNestedInput
    feeRecords?: StudentFeeUncheckedUpdateManyWithoutStudentNestedInput
    attendance?: AttendanceRecordUncheckedUpdateManyWithoutStudentNestedInput
    tasks?: StudentTaskUncheckedUpdateManyWithoutStudentNestedInput
    tests?: StudentTestUncheckedUpdateManyWithoutStudentNestedInput
    completions?: CourseCompletionUncheckedUpdateManyWithoutStudentNestedInput
    stationery?: StationeryIssueUncheckedUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutStudentNestedInput
    financialRecords?: FinancialRecordUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type CourseUpsertWithoutStudentCoursesInput = {
    update: XOR<CourseUpdateWithoutStudentCoursesInput, CourseUncheckedUpdateWithoutStudentCoursesInput>
    create: XOR<CourseCreateWithoutStudentCoursesInput, CourseUncheckedCreateWithoutStudentCoursesInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutStudentCoursesInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutStudentCoursesInput, CourseUncheckedUpdateWithoutStudentCoursesInput>
  }

  export type CourseUpdateWithoutStudentCoursesInput = {
    name?: StringFieldUpdateOperationsInput | string
    durationWeeks?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    courseFeeStructure?: CourseFeeStructureUpdateOneWithoutCourseNestedInput
    enquiryCourse?: EnquiryCourseUpdateManyWithoutCourseNestedInput
    feeStructures?: FeeStructureUpdateManyWithoutCourseNestedInput
    stationery?: StationeryIssueUpdateManyWithoutCourseNestedInput
    studentFees?: StudentFeeUpdateManyWithoutCourseNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutCourseNestedInput
    studentTasks?: StudentTaskUpdateManyWithoutCourseNestedInput
    studentTests?: StudentTestUpdateManyWithoutCourseNestedInput
    certificates?: CertificateUpdateManyWithoutCourseNestedInput
    financialRecords?: FinancialRecordUpdateManyWithoutCourseNestedInput
    batchCourses?: BatchCourseUpdateManyWithoutCourseNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutCoursesNestedInput
  }

  export type CourseUncheckedUpdateWithoutStudentCoursesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    durationWeeks?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    clientAdminId?: StringFieldUpdateOperationsInput | string
    courseFeeStructure?: CourseFeeStructureUncheckedUpdateOneWithoutCourseNestedInput
    enquiryCourse?: EnquiryCourseUncheckedUpdateManyWithoutCourseNestedInput
    feeStructures?: FeeStructureUncheckedUpdateManyWithoutCourseNestedInput
    stationery?: StationeryIssueUncheckedUpdateManyWithoutCourseNestedInput
    studentFees?: StudentFeeUncheckedUpdateManyWithoutCourseNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutCourseNestedInput
    studentTasks?: StudentTaskUncheckedUpdateManyWithoutCourseNestedInput
    studentTests?: StudentTestUncheckedUpdateManyWithoutCourseNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutCourseNestedInput
    financialRecords?: FinancialRecordUncheckedUpdateManyWithoutCourseNestedInput
    batchCourses?: BatchCourseUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type BatchUpsertWithoutStudentCoursesInput = {
    update: XOR<BatchUpdateWithoutStudentCoursesInput, BatchUncheckedUpdateWithoutStudentCoursesInput>
    create: XOR<BatchCreateWithoutStudentCoursesInput, BatchUncheckedCreateWithoutStudentCoursesInput>
    where?: BatchWhereInput
  }

  export type BatchUpdateToOneWithWhereWithoutStudentCoursesInput = {
    where?: BatchWhereInput
    data: XOR<BatchUpdateWithoutStudentCoursesInput, BatchUncheckedUpdateWithoutStudentCoursesInput>
  }

  export type BatchUpdateWithoutStudentCoursesInput = {
    name?: StringFieldUpdateOperationsInput | string
    faculty?: FacultyUpdateOneWithoutBatchesNestedInput
    labTimeSlot?: LabTimeSlotUpdateOneRequiredWithoutBatchesNestedInput
    batchCourses?: BatchCourseUpdateManyWithoutBatchNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutBatchesNestedInput
  }

  export type BatchUncheckedUpdateWithoutStudentCoursesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    facultyId?: NullableIntFieldUpdateOperationsInput | number | null
    labTimeSlotId?: IntFieldUpdateOperationsInput | number
    clientAdminId?: StringFieldUpdateOperationsInput | string
    batchCourses?: BatchCourseUncheckedUpdateManyWithoutBatchNestedInput
  }

  export type CertificateUpsertWithoutStudentCourseInput = {
    update: XOR<CertificateUpdateWithoutStudentCourseInput, CertificateUncheckedUpdateWithoutStudentCourseInput>
    create: XOR<CertificateCreateWithoutStudentCourseInput, CertificateUncheckedCreateWithoutStudentCourseInput>
    where?: CertificateWhereInput
  }

  export type CertificateUpdateToOneWithWhereWithoutStudentCourseInput = {
    where?: CertificateWhereInput
    data: XOR<CertificateUpdateWithoutStudentCourseInput, CertificateUncheckedUpdateWithoutStudentCourseInput>
  }

  export type CertificateUpdateWithoutStudentCourseInput = {
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    certificateUrl?: StringFieldUpdateOperationsInput | string
    student?: StudentUpdateOneRequiredWithoutCertificatesNestedInput
    course?: CourseUpdateOneRequiredWithoutCertificatesNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutCertificatesNestedInput
  }

  export type CertificateUncheckedUpdateWithoutStudentCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    certificateUrl?: StringFieldUpdateOperationsInput | string
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type CourseCompletionUpsertWithWhereUniqueWithoutStudentCourseInput = {
    where: CourseCompletionWhereUniqueInput
    update: XOR<CourseCompletionUpdateWithoutStudentCourseInput, CourseCompletionUncheckedUpdateWithoutStudentCourseInput>
    create: XOR<CourseCompletionCreateWithoutStudentCourseInput, CourseCompletionUncheckedCreateWithoutStudentCourseInput>
  }

  export type CourseCompletionUpdateWithWhereUniqueWithoutStudentCourseInput = {
    where: CourseCompletionWhereUniqueInput
    data: XOR<CourseCompletionUpdateWithoutStudentCourseInput, CourseCompletionUncheckedUpdateWithoutStudentCourseInput>
  }

  export type CourseCompletionUpdateManyWithWhereWithoutStudentCourseInput = {
    where: CourseCompletionScalarWhereInput
    data: XOR<CourseCompletionUpdateManyMutationInput, CourseCompletionUncheckedUpdateManyWithoutStudentCourseInput>
  }

  export type ClientAdminUpsertWithoutStudentCoursesInput = {
    update: XOR<ClientAdminUpdateWithoutStudentCoursesInput, ClientAdminUncheckedUpdateWithoutStudentCoursesInput>
    create: XOR<ClientAdminCreateWithoutStudentCoursesInput, ClientAdminUncheckedCreateWithoutStudentCoursesInput>
    where?: ClientAdminWhereInput
  }

  export type ClientAdminUpdateToOneWithWhereWithoutStudentCoursesInput = {
    where?: ClientAdminWhereInput
    data: XOR<ClientAdminUpdateWithoutStudentCoursesInput, ClientAdminUncheckedUpdateWithoutStudentCoursesInput>
  }

  export type ClientAdminUpdateWithoutStudentCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    instituteName?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    fullAddress?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    certificateName?: NullableStringFieldUpdateOperationsInput | string | null
    stamp?: NullableStringFieldUpdateOperationsInput | string | null
    sign?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    currentSessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleUsers?: RoleUserUpdateManyWithoutClientAdminNestedInput
    faculties?: FacultyUpdateManyWithoutClientAdminNestedInput
    batches?: BatchUpdateManyWithoutClientAdminNestedInput
    courses?: CourseUpdateManyWithoutClientAdminNestedInput
    enquiryCourse?: EnquiryCourseUpdateManyWithoutClientAdminNestedInput
    labs?: LabUpdateManyWithoutClientAdminNestedInput
    labTimeSlots?: LabTimeSlotUpdateManyWithoutClientAdminNestedInput
    labAllocations?: LabAllocationUpdateManyWithoutClientAdminNestedInput
    students?: StudentUpdateManyWithoutClientAdminNestedInput
    activities?: ActivityLogUpdateManyWithoutClientAdminNestedInput
    feeStructures?: FeeStructureUpdateManyWithoutClientAdminNestedInput
    studentFees?: StudentFeeUpdateManyWithoutClientAdminNestedInput
    stationeryIssues?: StationeryIssueUpdateManyWithoutClientAdminNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutClientAdminNestedInput
    studentTasks?: StudentTaskUpdateManyWithoutClientAdminNestedInput
    studentTests?: StudentTestUpdateManyWithoutClientAdminNestedInput
    courseCompletions?: CourseCompletionUpdateManyWithoutClientAdminNestedInput
    certificates?: CertificateUpdateManyWithoutClientAdminNestedInput
    financialRecords?: FinancialRecordUpdateManyWithoutClientAdminNestedInput
    enquiries?: EnquiryUpdateManyWithoutClientAdminNestedInput
    notifications?: NotificationUpdateManyWithoutClientAdminNestedInput
    courseFeeStructures?: CourseFeeStructureUpdateManyWithoutClientAdminNestedInput
  }

  export type ClientAdminUncheckedUpdateWithoutStudentCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    instituteName?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    fullAddress?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    certificateName?: NullableStringFieldUpdateOperationsInput | string | null
    stamp?: NullableStringFieldUpdateOperationsInput | string | null
    sign?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    currentSessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleUsers?: RoleUserUncheckedUpdateManyWithoutClientAdminNestedInput
    faculties?: FacultyUncheckedUpdateManyWithoutClientAdminNestedInput
    batches?: BatchUncheckedUpdateManyWithoutClientAdminNestedInput
    courses?: CourseUncheckedUpdateManyWithoutClientAdminNestedInput
    enquiryCourse?: EnquiryCourseUncheckedUpdateManyWithoutClientAdminNestedInput
    labs?: LabUncheckedUpdateManyWithoutClientAdminNestedInput
    labTimeSlots?: LabTimeSlotUncheckedUpdateManyWithoutClientAdminNestedInput
    labAllocations?: LabAllocationUncheckedUpdateManyWithoutClientAdminNestedInput
    students?: StudentUncheckedUpdateManyWithoutClientAdminNestedInput
    activities?: ActivityLogUncheckedUpdateManyWithoutClientAdminNestedInput
    feeStructures?: FeeStructureUncheckedUpdateManyWithoutClientAdminNestedInput
    studentFees?: StudentFeeUncheckedUpdateManyWithoutClientAdminNestedInput
    stationeryIssues?: StationeryIssueUncheckedUpdateManyWithoutClientAdminNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutClientAdminNestedInput
    studentTasks?: StudentTaskUncheckedUpdateManyWithoutClientAdminNestedInput
    studentTests?: StudentTestUncheckedUpdateManyWithoutClientAdminNestedInput
    courseCompletions?: CourseCompletionUncheckedUpdateManyWithoutClientAdminNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutClientAdminNestedInput
    financialRecords?: FinancialRecordUncheckedUpdateManyWithoutClientAdminNestedInput
    enquiries?: EnquiryUncheckedUpdateManyWithoutClientAdminNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutClientAdminNestedInput
    courseFeeStructures?: CourseFeeStructureUncheckedUpdateManyWithoutClientAdminNestedInput
  }

  export type StudentCreateWithoutFeeStructuresInput = {
    serialNumber: number
    studentCode: string
    fullName: string
    fatherName: string
    motherName: string
    photoUrl?: string | null
    contact: string
    parentsContact: string
    email?: string | null
    residentialAddress?: string | null
    permenantAddress?: string | null
    dob: string
    gender: string
    religion?: string | null
    idProofType?: string | null
    idProofNumber?: string | null
    admissionDate: Date | string
    enquiry?: EnquiryCreateNestedOneWithoutStudentInput
    labAllocations?: LabAllocationCreateNestedManyWithoutStudentInput
    studentCourses?: StudentCourseCreateNestedManyWithoutStudentInput
    feeRecords?: StudentFeeCreateNestedManyWithoutStudentInput
    attendance?: AttendanceRecordCreateNestedManyWithoutStudentInput
    tasks?: StudentTaskCreateNestedManyWithoutStudentInput
    tests?: StudentTestCreateNestedManyWithoutStudentInput
    completions?: CourseCompletionCreateNestedManyWithoutStudentInput
    stationery?: StationeryIssueCreateNestedManyWithoutStudentInput
    certificates?: CertificateCreateNestedManyWithoutStudentInput
    financialRecords?: FinancialRecordCreateNestedManyWithoutStudentInput
    clientAdmin: ClientAdminCreateNestedOneWithoutStudentsInput
  }

  export type StudentUncheckedCreateWithoutFeeStructuresInput = {
    id?: number
    serialNumber: number
    studentCode: string
    fullName: string
    fatherName: string
    motherName: string
    photoUrl?: string | null
    contact: string
    parentsContact: string
    email?: string | null
    residentialAddress?: string | null
    permenantAddress?: string | null
    dob: string
    gender: string
    religion?: string | null
    idProofType?: string | null
    idProofNumber?: string | null
    admissionDate: Date | string
    clientAdminId: string
    enquiry?: EnquiryUncheckedCreateNestedOneWithoutStudentInput
    labAllocations?: LabAllocationUncheckedCreateNestedManyWithoutStudentInput
    studentCourses?: StudentCourseUncheckedCreateNestedManyWithoutStudentInput
    feeRecords?: StudentFeeUncheckedCreateNestedManyWithoutStudentInput
    attendance?: AttendanceRecordUncheckedCreateNestedManyWithoutStudentInput
    tasks?: StudentTaskUncheckedCreateNestedManyWithoutStudentInput
    tests?: StudentTestUncheckedCreateNestedManyWithoutStudentInput
    completions?: CourseCompletionUncheckedCreateNestedManyWithoutStudentInput
    stationery?: StationeryIssueUncheckedCreateNestedManyWithoutStudentInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutStudentInput
    financialRecords?: FinancialRecordUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutFeeStructuresInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutFeeStructuresInput, StudentUncheckedCreateWithoutFeeStructuresInput>
  }

  export type CourseCreateWithoutFeeStructuresInput = {
    name: string
    durationWeeks: number
    description?: string | null
    courseFeeStructure?: CourseFeeStructureCreateNestedOneWithoutCourseInput
    studentCourses?: StudentCourseCreateNestedManyWithoutCourseInput
    enquiryCourse?: EnquiryCourseCreateNestedManyWithoutCourseInput
    stationery?: StationeryIssueCreateNestedManyWithoutCourseInput
    studentFees?: StudentFeeCreateNestedManyWithoutCourseInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutCourseInput
    studentTasks?: StudentTaskCreateNestedManyWithoutCourseInput
    studentTests?: StudentTestCreateNestedManyWithoutCourseInput
    certificates?: CertificateCreateNestedManyWithoutCourseInput
    financialRecords?: FinancialRecordCreateNestedManyWithoutCourseInput
    batchCourses?: BatchCourseCreateNestedManyWithoutCourseInput
    clientAdmin: ClientAdminCreateNestedOneWithoutCoursesInput
  }

  export type CourseUncheckedCreateWithoutFeeStructuresInput = {
    id?: number
    name: string
    durationWeeks: number
    description?: string | null
    clientAdminId: string
    courseFeeStructure?: CourseFeeStructureUncheckedCreateNestedOneWithoutCourseInput
    studentCourses?: StudentCourseUncheckedCreateNestedManyWithoutCourseInput
    enquiryCourse?: EnquiryCourseUncheckedCreateNestedManyWithoutCourseInput
    stationery?: StationeryIssueUncheckedCreateNestedManyWithoutCourseInput
    studentFees?: StudentFeeUncheckedCreateNestedManyWithoutCourseInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutCourseInput
    studentTasks?: StudentTaskUncheckedCreateNestedManyWithoutCourseInput
    studentTests?: StudentTestUncheckedCreateNestedManyWithoutCourseInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutCourseInput
    financialRecords?: FinancialRecordUncheckedCreateNestedManyWithoutCourseInput
    batchCourses?: BatchCourseUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutFeeStructuresInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutFeeStructuresInput, CourseUncheckedCreateWithoutFeeStructuresInput>
  }

  export type InstallmentDetailCreateWithoutFeeStructuresInput = {
    number: number
    amount: number
    CourseFeeStructure: CourseFeeStructureCreateNestedOneWithoutInstallmentsInput
  }

  export type InstallmentDetailUncheckedCreateWithoutFeeStructuresInput = {
    id?: number
    CourseFeeStructureId: number
    number: number
    amount: number
  }

  export type InstallmentDetailCreateOrConnectWithoutFeeStructuresInput = {
    where: InstallmentDetailWhereUniqueInput
    create: XOR<InstallmentDetailCreateWithoutFeeStructuresInput, InstallmentDetailUncheckedCreateWithoutFeeStructuresInput>
  }

  export type StudentFeeCreateWithoutFeeStructureInput = {
    dueDate: Date | string
    amountDue: number
    amountPaid: number
    paymentDate?: Date | string | null
    paymentMode: $Enums.PaymentMode
    receiptNo: string
    paymentStatus?: $Enums.PaymentStatus
    student: StudentCreateNestedOneWithoutFeeRecordsInput
    course: CourseCreateNestedOneWithoutStudentFeesInput
    feeLogs?: StudentFeeLogCreateNestedManyWithoutStudentFeeInput
    notification?: NotificationCreateNestedOneWithoutPaymentInput
    clientAdmin: ClientAdminCreateNestedOneWithoutStudentFeesInput
  }

  export type StudentFeeUncheckedCreateWithoutFeeStructureInput = {
    id?: number
    dueDate: Date | string
    amountDue: number
    amountPaid: number
    paymentDate?: Date | string | null
    paymentMode: $Enums.PaymentMode
    receiptNo: string
    paymentStatus?: $Enums.PaymentStatus
    clientAdminId: string
    feeLogs?: StudentFeeLogUncheckedCreateNestedManyWithoutStudentFeeInput
    notification?: NotificationUncheckedCreateNestedOneWithoutPaymentInput
  }

  export type StudentFeeCreateOrConnectWithoutFeeStructureInput = {
    where: StudentFeeWhereUniqueInput
    create: XOR<StudentFeeCreateWithoutFeeStructureInput, StudentFeeUncheckedCreateWithoutFeeStructureInput>
  }

  export type StudentFeeCreateManyFeeStructureInputEnvelope = {
    data: StudentFeeCreateManyFeeStructureInput | StudentFeeCreateManyFeeStructureInput[]
    skipDuplicates?: boolean
  }

  export type ClientAdminCreateWithoutFeeStructuresInput = {
    id?: string
    name: string
    email: string
    password: string
    instituteName: string
    slug: string
    fullAddress: string
    logo?: string | null
    certificateName?: string | null
    stamp?: string | null
    sign?: string | null
    contact: string
    position: string
    country: string
    state: string
    city: string
    zipCode: string
    createdAt?: Date | string
    role?: $Enums.UserRole
    currentSessionToken?: string | null
    lastLoginAt?: Date | string | null
    roleUsers?: RoleUserCreateNestedManyWithoutClientAdminInput
    faculties?: FacultyCreateNestedManyWithoutClientAdminInput
    batches?: BatchCreateNestedManyWithoutClientAdminInput
    courses?: CourseCreateNestedManyWithoutClientAdminInput
    enquiryCourse?: EnquiryCourseCreateNestedManyWithoutClientAdminInput
    labs?: LabCreateNestedManyWithoutClientAdminInput
    labTimeSlots?: LabTimeSlotCreateNestedManyWithoutClientAdminInput
    labAllocations?: LabAllocationCreateNestedManyWithoutClientAdminInput
    students?: StudentCreateNestedManyWithoutClientAdminInput
    activities?: ActivityLogCreateNestedManyWithoutClientAdminInput
    studentCourses?: StudentCourseCreateNestedManyWithoutClientAdminInput
    studentFees?: StudentFeeCreateNestedManyWithoutClientAdminInput
    stationeryIssues?: StationeryIssueCreateNestedManyWithoutClientAdminInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutClientAdminInput
    studentTasks?: StudentTaskCreateNestedManyWithoutClientAdminInput
    studentTests?: StudentTestCreateNestedManyWithoutClientAdminInput
    courseCompletions?: CourseCompletionCreateNestedManyWithoutClientAdminInput
    certificates?: CertificateCreateNestedManyWithoutClientAdminInput
    financialRecords?: FinancialRecordCreateNestedManyWithoutClientAdminInput
    enquiries?: EnquiryCreateNestedManyWithoutClientAdminInput
    notifications?: NotificationCreateNestedManyWithoutClientAdminInput
    courseFeeStructures?: CourseFeeStructureCreateNestedManyWithoutClientAdminInput
  }

  export type ClientAdminUncheckedCreateWithoutFeeStructuresInput = {
    id?: string
    name: string
    email: string
    password: string
    instituteName: string
    slug: string
    fullAddress: string
    logo?: string | null
    certificateName?: string | null
    stamp?: string | null
    sign?: string | null
    contact: string
    position: string
    country: string
    state: string
    city: string
    zipCode: string
    createdAt?: Date | string
    role?: $Enums.UserRole
    currentSessionToken?: string | null
    lastLoginAt?: Date | string | null
    roleUsers?: RoleUserUncheckedCreateNestedManyWithoutClientAdminInput
    faculties?: FacultyUncheckedCreateNestedManyWithoutClientAdminInput
    batches?: BatchUncheckedCreateNestedManyWithoutClientAdminInput
    courses?: CourseUncheckedCreateNestedManyWithoutClientAdminInput
    enquiryCourse?: EnquiryCourseUncheckedCreateNestedManyWithoutClientAdminInput
    labs?: LabUncheckedCreateNestedManyWithoutClientAdminInput
    labTimeSlots?: LabTimeSlotUncheckedCreateNestedManyWithoutClientAdminInput
    labAllocations?: LabAllocationUncheckedCreateNestedManyWithoutClientAdminInput
    students?: StudentUncheckedCreateNestedManyWithoutClientAdminInput
    activities?: ActivityLogUncheckedCreateNestedManyWithoutClientAdminInput
    studentCourses?: StudentCourseUncheckedCreateNestedManyWithoutClientAdminInput
    studentFees?: StudentFeeUncheckedCreateNestedManyWithoutClientAdminInput
    stationeryIssues?: StationeryIssueUncheckedCreateNestedManyWithoutClientAdminInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutClientAdminInput
    studentTasks?: StudentTaskUncheckedCreateNestedManyWithoutClientAdminInput
    studentTests?: StudentTestUncheckedCreateNestedManyWithoutClientAdminInput
    courseCompletions?: CourseCompletionUncheckedCreateNestedManyWithoutClientAdminInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutClientAdminInput
    financialRecords?: FinancialRecordUncheckedCreateNestedManyWithoutClientAdminInput
    enquiries?: EnquiryUncheckedCreateNestedManyWithoutClientAdminInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutClientAdminInput
    courseFeeStructures?: CourseFeeStructureUncheckedCreateNestedManyWithoutClientAdminInput
  }

  export type ClientAdminCreateOrConnectWithoutFeeStructuresInput = {
    where: ClientAdminWhereUniqueInput
    create: XOR<ClientAdminCreateWithoutFeeStructuresInput, ClientAdminUncheckedCreateWithoutFeeStructuresInput>
  }

  export type StudentUpsertWithoutFeeStructuresInput = {
    update: XOR<StudentUpdateWithoutFeeStructuresInput, StudentUncheckedUpdateWithoutFeeStructuresInput>
    create: XOR<StudentCreateWithoutFeeStructuresInput, StudentUncheckedCreateWithoutFeeStructuresInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutFeeStructuresInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutFeeStructuresInput, StudentUncheckedUpdateWithoutFeeStructuresInput>
  }

  export type StudentUpdateWithoutFeeStructuresInput = {
    serialNumber?: IntFieldUpdateOperationsInput | number
    studentCode?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    fatherName?: StringFieldUpdateOperationsInput | string
    motherName?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: StringFieldUpdateOperationsInput | string
    parentsContact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: NullableStringFieldUpdateOperationsInput | string | null
    permenantAddress?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    idProofType?: NullableStringFieldUpdateOperationsInput | string | null
    idProofNumber?: NullableStringFieldUpdateOperationsInput | string | null
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    enquiry?: EnquiryUpdateOneWithoutStudentNestedInput
    labAllocations?: LabAllocationUpdateManyWithoutStudentNestedInput
    studentCourses?: StudentCourseUpdateManyWithoutStudentNestedInput
    feeRecords?: StudentFeeUpdateManyWithoutStudentNestedInput
    attendance?: AttendanceRecordUpdateManyWithoutStudentNestedInput
    tasks?: StudentTaskUpdateManyWithoutStudentNestedInput
    tests?: StudentTestUpdateManyWithoutStudentNestedInput
    completions?: CourseCompletionUpdateManyWithoutStudentNestedInput
    stationery?: StationeryIssueUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUpdateManyWithoutStudentNestedInput
    financialRecords?: FinancialRecordUpdateManyWithoutStudentNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutStudentsNestedInput
  }

  export type StudentUncheckedUpdateWithoutFeeStructuresInput = {
    id?: IntFieldUpdateOperationsInput | number
    serialNumber?: IntFieldUpdateOperationsInput | number
    studentCode?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    fatherName?: StringFieldUpdateOperationsInput | string
    motherName?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: StringFieldUpdateOperationsInput | string
    parentsContact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: NullableStringFieldUpdateOperationsInput | string | null
    permenantAddress?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    idProofType?: NullableStringFieldUpdateOperationsInput | string | null
    idProofNumber?: NullableStringFieldUpdateOperationsInput | string | null
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    clientAdminId?: StringFieldUpdateOperationsInput | string
    enquiry?: EnquiryUncheckedUpdateOneWithoutStudentNestedInput
    labAllocations?: LabAllocationUncheckedUpdateManyWithoutStudentNestedInput
    studentCourses?: StudentCourseUncheckedUpdateManyWithoutStudentNestedInput
    feeRecords?: StudentFeeUncheckedUpdateManyWithoutStudentNestedInput
    attendance?: AttendanceRecordUncheckedUpdateManyWithoutStudentNestedInput
    tasks?: StudentTaskUncheckedUpdateManyWithoutStudentNestedInput
    tests?: StudentTestUncheckedUpdateManyWithoutStudentNestedInput
    completions?: CourseCompletionUncheckedUpdateManyWithoutStudentNestedInput
    stationery?: StationeryIssueUncheckedUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutStudentNestedInput
    financialRecords?: FinancialRecordUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type CourseUpsertWithoutFeeStructuresInput = {
    update: XOR<CourseUpdateWithoutFeeStructuresInput, CourseUncheckedUpdateWithoutFeeStructuresInput>
    create: XOR<CourseCreateWithoutFeeStructuresInput, CourseUncheckedCreateWithoutFeeStructuresInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutFeeStructuresInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutFeeStructuresInput, CourseUncheckedUpdateWithoutFeeStructuresInput>
  }

  export type CourseUpdateWithoutFeeStructuresInput = {
    name?: StringFieldUpdateOperationsInput | string
    durationWeeks?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    courseFeeStructure?: CourseFeeStructureUpdateOneWithoutCourseNestedInput
    studentCourses?: StudentCourseUpdateManyWithoutCourseNestedInput
    enquiryCourse?: EnquiryCourseUpdateManyWithoutCourseNestedInput
    stationery?: StationeryIssueUpdateManyWithoutCourseNestedInput
    studentFees?: StudentFeeUpdateManyWithoutCourseNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutCourseNestedInput
    studentTasks?: StudentTaskUpdateManyWithoutCourseNestedInput
    studentTests?: StudentTestUpdateManyWithoutCourseNestedInput
    certificates?: CertificateUpdateManyWithoutCourseNestedInput
    financialRecords?: FinancialRecordUpdateManyWithoutCourseNestedInput
    batchCourses?: BatchCourseUpdateManyWithoutCourseNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutCoursesNestedInput
  }

  export type CourseUncheckedUpdateWithoutFeeStructuresInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    durationWeeks?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    clientAdminId?: StringFieldUpdateOperationsInput | string
    courseFeeStructure?: CourseFeeStructureUncheckedUpdateOneWithoutCourseNestedInput
    studentCourses?: StudentCourseUncheckedUpdateManyWithoutCourseNestedInput
    enquiryCourse?: EnquiryCourseUncheckedUpdateManyWithoutCourseNestedInput
    stationery?: StationeryIssueUncheckedUpdateManyWithoutCourseNestedInput
    studentFees?: StudentFeeUncheckedUpdateManyWithoutCourseNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutCourseNestedInput
    studentTasks?: StudentTaskUncheckedUpdateManyWithoutCourseNestedInput
    studentTests?: StudentTestUncheckedUpdateManyWithoutCourseNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutCourseNestedInput
    financialRecords?: FinancialRecordUncheckedUpdateManyWithoutCourseNestedInput
    batchCourses?: BatchCourseUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type InstallmentDetailUpsertWithoutFeeStructuresInput = {
    update: XOR<InstallmentDetailUpdateWithoutFeeStructuresInput, InstallmentDetailUncheckedUpdateWithoutFeeStructuresInput>
    create: XOR<InstallmentDetailCreateWithoutFeeStructuresInput, InstallmentDetailUncheckedCreateWithoutFeeStructuresInput>
    where?: InstallmentDetailWhereInput
  }

  export type InstallmentDetailUpdateToOneWithWhereWithoutFeeStructuresInput = {
    where?: InstallmentDetailWhereInput
    data: XOR<InstallmentDetailUpdateWithoutFeeStructuresInput, InstallmentDetailUncheckedUpdateWithoutFeeStructuresInput>
  }

  export type InstallmentDetailUpdateWithoutFeeStructuresInput = {
    number?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    CourseFeeStructure?: CourseFeeStructureUpdateOneRequiredWithoutInstallmentsNestedInput
  }

  export type InstallmentDetailUncheckedUpdateWithoutFeeStructuresInput = {
    id?: IntFieldUpdateOperationsInput | number
    CourseFeeStructureId?: IntFieldUpdateOperationsInput | number
    number?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
  }

  export type StudentFeeUpsertWithWhereUniqueWithoutFeeStructureInput = {
    where: StudentFeeWhereUniqueInput
    update: XOR<StudentFeeUpdateWithoutFeeStructureInput, StudentFeeUncheckedUpdateWithoutFeeStructureInput>
    create: XOR<StudentFeeCreateWithoutFeeStructureInput, StudentFeeUncheckedCreateWithoutFeeStructureInput>
  }

  export type StudentFeeUpdateWithWhereUniqueWithoutFeeStructureInput = {
    where: StudentFeeWhereUniqueInput
    data: XOR<StudentFeeUpdateWithoutFeeStructureInput, StudentFeeUncheckedUpdateWithoutFeeStructureInput>
  }

  export type StudentFeeUpdateManyWithWhereWithoutFeeStructureInput = {
    where: StudentFeeScalarWhereInput
    data: XOR<StudentFeeUpdateManyMutationInput, StudentFeeUncheckedUpdateManyWithoutFeeStructureInput>
  }

  export type ClientAdminUpsertWithoutFeeStructuresInput = {
    update: XOR<ClientAdminUpdateWithoutFeeStructuresInput, ClientAdminUncheckedUpdateWithoutFeeStructuresInput>
    create: XOR<ClientAdminCreateWithoutFeeStructuresInput, ClientAdminUncheckedCreateWithoutFeeStructuresInput>
    where?: ClientAdminWhereInput
  }

  export type ClientAdminUpdateToOneWithWhereWithoutFeeStructuresInput = {
    where?: ClientAdminWhereInput
    data: XOR<ClientAdminUpdateWithoutFeeStructuresInput, ClientAdminUncheckedUpdateWithoutFeeStructuresInput>
  }

  export type ClientAdminUpdateWithoutFeeStructuresInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    instituteName?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    fullAddress?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    certificateName?: NullableStringFieldUpdateOperationsInput | string | null
    stamp?: NullableStringFieldUpdateOperationsInput | string | null
    sign?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    currentSessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleUsers?: RoleUserUpdateManyWithoutClientAdminNestedInput
    faculties?: FacultyUpdateManyWithoutClientAdminNestedInput
    batches?: BatchUpdateManyWithoutClientAdminNestedInput
    courses?: CourseUpdateManyWithoutClientAdminNestedInput
    enquiryCourse?: EnquiryCourseUpdateManyWithoutClientAdminNestedInput
    labs?: LabUpdateManyWithoutClientAdminNestedInput
    labTimeSlots?: LabTimeSlotUpdateManyWithoutClientAdminNestedInput
    labAllocations?: LabAllocationUpdateManyWithoutClientAdminNestedInput
    students?: StudentUpdateManyWithoutClientAdminNestedInput
    activities?: ActivityLogUpdateManyWithoutClientAdminNestedInput
    studentCourses?: StudentCourseUpdateManyWithoutClientAdminNestedInput
    studentFees?: StudentFeeUpdateManyWithoutClientAdminNestedInput
    stationeryIssues?: StationeryIssueUpdateManyWithoutClientAdminNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutClientAdminNestedInput
    studentTasks?: StudentTaskUpdateManyWithoutClientAdminNestedInput
    studentTests?: StudentTestUpdateManyWithoutClientAdminNestedInput
    courseCompletions?: CourseCompletionUpdateManyWithoutClientAdminNestedInput
    certificates?: CertificateUpdateManyWithoutClientAdminNestedInput
    financialRecords?: FinancialRecordUpdateManyWithoutClientAdminNestedInput
    enquiries?: EnquiryUpdateManyWithoutClientAdminNestedInput
    notifications?: NotificationUpdateManyWithoutClientAdminNestedInput
    courseFeeStructures?: CourseFeeStructureUpdateManyWithoutClientAdminNestedInput
  }

  export type ClientAdminUncheckedUpdateWithoutFeeStructuresInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    instituteName?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    fullAddress?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    certificateName?: NullableStringFieldUpdateOperationsInput | string | null
    stamp?: NullableStringFieldUpdateOperationsInput | string | null
    sign?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    currentSessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleUsers?: RoleUserUncheckedUpdateManyWithoutClientAdminNestedInput
    faculties?: FacultyUncheckedUpdateManyWithoutClientAdminNestedInput
    batches?: BatchUncheckedUpdateManyWithoutClientAdminNestedInput
    courses?: CourseUncheckedUpdateManyWithoutClientAdminNestedInput
    enquiryCourse?: EnquiryCourseUncheckedUpdateManyWithoutClientAdminNestedInput
    labs?: LabUncheckedUpdateManyWithoutClientAdminNestedInput
    labTimeSlots?: LabTimeSlotUncheckedUpdateManyWithoutClientAdminNestedInput
    labAllocations?: LabAllocationUncheckedUpdateManyWithoutClientAdminNestedInput
    students?: StudentUncheckedUpdateManyWithoutClientAdminNestedInput
    activities?: ActivityLogUncheckedUpdateManyWithoutClientAdminNestedInput
    studentCourses?: StudentCourseUncheckedUpdateManyWithoutClientAdminNestedInput
    studentFees?: StudentFeeUncheckedUpdateManyWithoutClientAdminNestedInput
    stationeryIssues?: StationeryIssueUncheckedUpdateManyWithoutClientAdminNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutClientAdminNestedInput
    studentTasks?: StudentTaskUncheckedUpdateManyWithoutClientAdminNestedInput
    studentTests?: StudentTestUncheckedUpdateManyWithoutClientAdminNestedInput
    courseCompletions?: CourseCompletionUncheckedUpdateManyWithoutClientAdminNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutClientAdminNestedInput
    financialRecords?: FinancialRecordUncheckedUpdateManyWithoutClientAdminNestedInput
    enquiries?: EnquiryUncheckedUpdateManyWithoutClientAdminNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutClientAdminNestedInput
    courseFeeStructures?: CourseFeeStructureUncheckedUpdateManyWithoutClientAdminNestedInput
  }

  export type StudentFeeCreateWithoutFeeLogsInput = {
    dueDate: Date | string
    amountDue: number
    amountPaid: number
    paymentDate?: Date | string | null
    paymentMode: $Enums.PaymentMode
    receiptNo: string
    paymentStatus?: $Enums.PaymentStatus
    student: StudentCreateNestedOneWithoutFeeRecordsInput
    course: CourseCreateNestedOneWithoutStudentFeesInput
    feeStructure?: FeeStructureCreateNestedOneWithoutStudentFeesInput
    notification?: NotificationCreateNestedOneWithoutPaymentInput
    clientAdmin: ClientAdminCreateNestedOneWithoutStudentFeesInput
  }

  export type StudentFeeUncheckedCreateWithoutFeeLogsInput = {
    id?: number
    studentId: number
    courseId: number
    dueDate: Date | string
    amountDue: number
    amountPaid: number
    paymentDate?: Date | string | null
    paymentMode: $Enums.PaymentMode
    receiptNo: string
    paymentStatus?: $Enums.PaymentStatus
    clientAdminId: string
    notification?: NotificationUncheckedCreateNestedOneWithoutPaymentInput
  }

  export type StudentFeeCreateOrConnectWithoutFeeLogsInput = {
    where: StudentFeeWhereUniqueInput
    create: XOR<StudentFeeCreateWithoutFeeLogsInput, StudentFeeUncheckedCreateWithoutFeeLogsInput>
  }

  export type StudentFeeUpsertWithoutFeeLogsInput = {
    update: XOR<StudentFeeUpdateWithoutFeeLogsInput, StudentFeeUncheckedUpdateWithoutFeeLogsInput>
    create: XOR<StudentFeeCreateWithoutFeeLogsInput, StudentFeeUncheckedCreateWithoutFeeLogsInput>
    where?: StudentFeeWhereInput
  }

  export type StudentFeeUpdateToOneWithWhereWithoutFeeLogsInput = {
    where?: StudentFeeWhereInput
    data: XOR<StudentFeeUpdateWithoutFeeLogsInput, StudentFeeUncheckedUpdateWithoutFeeLogsInput>
  }

  export type StudentFeeUpdateWithoutFeeLogsInput = {
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amountDue?: FloatFieldUpdateOperationsInput | number
    amountPaid?: FloatFieldUpdateOperationsInput | number
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMode?: EnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode
    receiptNo?: StringFieldUpdateOperationsInput | string
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    student?: StudentUpdateOneRequiredWithoutFeeRecordsNestedInput
    course?: CourseUpdateOneRequiredWithoutStudentFeesNestedInput
    feeStructure?: FeeStructureUpdateOneWithoutStudentFeesNestedInput
    notification?: NotificationUpdateOneWithoutPaymentNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutStudentFeesNestedInput
  }

  export type StudentFeeUncheckedUpdateWithoutFeeLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amountDue?: FloatFieldUpdateOperationsInput | number
    amountPaid?: FloatFieldUpdateOperationsInput | number
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMode?: EnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode
    receiptNo?: StringFieldUpdateOperationsInput | string
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    clientAdminId?: StringFieldUpdateOperationsInput | string
    notification?: NotificationUncheckedUpdateOneWithoutPaymentNestedInput
  }

  export type StudentCreateWithoutFeeRecordsInput = {
    serialNumber: number
    studentCode: string
    fullName: string
    fatherName: string
    motherName: string
    photoUrl?: string | null
    contact: string
    parentsContact: string
    email?: string | null
    residentialAddress?: string | null
    permenantAddress?: string | null
    dob: string
    gender: string
    religion?: string | null
    idProofType?: string | null
    idProofNumber?: string | null
    admissionDate: Date | string
    enquiry?: EnquiryCreateNestedOneWithoutStudentInput
    labAllocations?: LabAllocationCreateNestedManyWithoutStudentInput
    studentCourses?: StudentCourseCreateNestedManyWithoutStudentInput
    feeStructures?: FeeStructureCreateNestedManyWithoutStudentInput
    attendance?: AttendanceRecordCreateNestedManyWithoutStudentInput
    tasks?: StudentTaskCreateNestedManyWithoutStudentInput
    tests?: StudentTestCreateNestedManyWithoutStudentInput
    completions?: CourseCompletionCreateNestedManyWithoutStudentInput
    stationery?: StationeryIssueCreateNestedManyWithoutStudentInput
    certificates?: CertificateCreateNestedManyWithoutStudentInput
    financialRecords?: FinancialRecordCreateNestedManyWithoutStudentInput
    clientAdmin: ClientAdminCreateNestedOneWithoutStudentsInput
  }

  export type StudentUncheckedCreateWithoutFeeRecordsInput = {
    id?: number
    serialNumber: number
    studentCode: string
    fullName: string
    fatherName: string
    motherName: string
    photoUrl?: string | null
    contact: string
    parentsContact: string
    email?: string | null
    residentialAddress?: string | null
    permenantAddress?: string | null
    dob: string
    gender: string
    religion?: string | null
    idProofType?: string | null
    idProofNumber?: string | null
    admissionDate: Date | string
    clientAdminId: string
    enquiry?: EnquiryUncheckedCreateNestedOneWithoutStudentInput
    labAllocations?: LabAllocationUncheckedCreateNestedManyWithoutStudentInput
    studentCourses?: StudentCourseUncheckedCreateNestedManyWithoutStudentInput
    feeStructures?: FeeStructureUncheckedCreateNestedManyWithoutStudentInput
    attendance?: AttendanceRecordUncheckedCreateNestedManyWithoutStudentInput
    tasks?: StudentTaskUncheckedCreateNestedManyWithoutStudentInput
    tests?: StudentTestUncheckedCreateNestedManyWithoutStudentInput
    completions?: CourseCompletionUncheckedCreateNestedManyWithoutStudentInput
    stationery?: StationeryIssueUncheckedCreateNestedManyWithoutStudentInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutStudentInput
    financialRecords?: FinancialRecordUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutFeeRecordsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutFeeRecordsInput, StudentUncheckedCreateWithoutFeeRecordsInput>
  }

  export type CourseCreateWithoutStudentFeesInput = {
    name: string
    durationWeeks: number
    description?: string | null
    courseFeeStructure?: CourseFeeStructureCreateNestedOneWithoutCourseInput
    studentCourses?: StudentCourseCreateNestedManyWithoutCourseInput
    enquiryCourse?: EnquiryCourseCreateNestedManyWithoutCourseInput
    feeStructures?: FeeStructureCreateNestedManyWithoutCourseInput
    stationery?: StationeryIssueCreateNestedManyWithoutCourseInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutCourseInput
    studentTasks?: StudentTaskCreateNestedManyWithoutCourseInput
    studentTests?: StudentTestCreateNestedManyWithoutCourseInput
    certificates?: CertificateCreateNestedManyWithoutCourseInput
    financialRecords?: FinancialRecordCreateNestedManyWithoutCourseInput
    batchCourses?: BatchCourseCreateNestedManyWithoutCourseInput
    clientAdmin: ClientAdminCreateNestedOneWithoutCoursesInput
  }

  export type CourseUncheckedCreateWithoutStudentFeesInput = {
    id?: number
    name: string
    durationWeeks: number
    description?: string | null
    clientAdminId: string
    courseFeeStructure?: CourseFeeStructureUncheckedCreateNestedOneWithoutCourseInput
    studentCourses?: StudentCourseUncheckedCreateNestedManyWithoutCourseInput
    enquiryCourse?: EnquiryCourseUncheckedCreateNestedManyWithoutCourseInput
    feeStructures?: FeeStructureUncheckedCreateNestedManyWithoutCourseInput
    stationery?: StationeryIssueUncheckedCreateNestedManyWithoutCourseInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutCourseInput
    studentTasks?: StudentTaskUncheckedCreateNestedManyWithoutCourseInput
    studentTests?: StudentTestUncheckedCreateNestedManyWithoutCourseInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutCourseInput
    financialRecords?: FinancialRecordUncheckedCreateNestedManyWithoutCourseInput
    batchCourses?: BatchCourseUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutStudentFeesInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutStudentFeesInput, CourseUncheckedCreateWithoutStudentFeesInput>
  }

  export type StudentFeeLogCreateWithoutStudentFeeInput = {
    amountPaid: number
    paymentDate: Date | string
    paymentMode: $Enums.PaymentMode
    receiptNo: string
  }

  export type StudentFeeLogUncheckedCreateWithoutStudentFeeInput = {
    id?: number
    amountPaid: number
    paymentDate: Date | string
    paymentMode: $Enums.PaymentMode
    receiptNo: string
  }

  export type StudentFeeLogCreateOrConnectWithoutStudentFeeInput = {
    where: StudentFeeLogWhereUniqueInput
    create: XOR<StudentFeeLogCreateWithoutStudentFeeInput, StudentFeeLogUncheckedCreateWithoutStudentFeeInput>
  }

  export type StudentFeeLogCreateManyStudentFeeInputEnvelope = {
    data: StudentFeeLogCreateManyStudentFeeInput | StudentFeeLogCreateManyStudentFeeInput[]
    skipDuplicates?: boolean
  }

  export type FeeStructureCreateWithoutStudentFeesInput = {
    totalAmount: number
    paymentType: $Enums.PaymentType
    installmentCount?: number | null
    student: StudentCreateNestedOneWithoutFeeStructuresInput
    course: CourseCreateNestedOneWithoutFeeStructuresInput
    installment?: InstallmentDetailCreateNestedOneWithoutFeeStructuresInput
    clientAdmin: ClientAdminCreateNestedOneWithoutFeeStructuresInput
  }

  export type FeeStructureUncheckedCreateWithoutStudentFeesInput = {
    id?: number
    studentId: number
    courseId: number
    totalAmount: number
    paymentType: $Enums.PaymentType
    installmentCount?: number | null
    installmentTypeId?: number | null
    clientAdminId: string
  }

  export type FeeStructureCreateOrConnectWithoutStudentFeesInput = {
    where: FeeStructureWhereUniqueInput
    create: XOR<FeeStructureCreateWithoutStudentFeesInput, FeeStructureUncheckedCreateWithoutStudentFeesInput>
  }

  export type NotificationCreateWithoutPaymentInput = {
    id?: string
    message: string
    seen?: boolean
    createdAt?: Date | string
    followUp?: FollowUpCreateNestedOneWithoutNotificationInput
    enquiry?: EnquiryCreateNestedOneWithoutNotificationInput
    clientAdmin: ClientAdminCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutPaymentInput = {
    id?: string
    message: string
    seen?: boolean
    createdAt?: Date | string
    followUpId?: string | null
    enquiryId?: string | null
    clientAdminId: string
  }

  export type NotificationCreateOrConnectWithoutPaymentInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutPaymentInput, NotificationUncheckedCreateWithoutPaymentInput>
  }

  export type ClientAdminCreateWithoutStudentFeesInput = {
    id?: string
    name: string
    email: string
    password: string
    instituteName: string
    slug: string
    fullAddress: string
    logo?: string | null
    certificateName?: string | null
    stamp?: string | null
    sign?: string | null
    contact: string
    position: string
    country: string
    state: string
    city: string
    zipCode: string
    createdAt?: Date | string
    role?: $Enums.UserRole
    currentSessionToken?: string | null
    lastLoginAt?: Date | string | null
    roleUsers?: RoleUserCreateNestedManyWithoutClientAdminInput
    faculties?: FacultyCreateNestedManyWithoutClientAdminInput
    batches?: BatchCreateNestedManyWithoutClientAdminInput
    courses?: CourseCreateNestedManyWithoutClientAdminInput
    enquiryCourse?: EnquiryCourseCreateNestedManyWithoutClientAdminInput
    labs?: LabCreateNestedManyWithoutClientAdminInput
    labTimeSlots?: LabTimeSlotCreateNestedManyWithoutClientAdminInput
    labAllocations?: LabAllocationCreateNestedManyWithoutClientAdminInput
    students?: StudentCreateNestedManyWithoutClientAdminInput
    activities?: ActivityLogCreateNestedManyWithoutClientAdminInput
    studentCourses?: StudentCourseCreateNestedManyWithoutClientAdminInput
    feeStructures?: FeeStructureCreateNestedManyWithoutClientAdminInput
    stationeryIssues?: StationeryIssueCreateNestedManyWithoutClientAdminInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutClientAdminInput
    studentTasks?: StudentTaskCreateNestedManyWithoutClientAdminInput
    studentTests?: StudentTestCreateNestedManyWithoutClientAdminInput
    courseCompletions?: CourseCompletionCreateNestedManyWithoutClientAdminInput
    certificates?: CertificateCreateNestedManyWithoutClientAdminInput
    financialRecords?: FinancialRecordCreateNestedManyWithoutClientAdminInput
    enquiries?: EnquiryCreateNestedManyWithoutClientAdminInput
    notifications?: NotificationCreateNestedManyWithoutClientAdminInput
    courseFeeStructures?: CourseFeeStructureCreateNestedManyWithoutClientAdminInput
  }

  export type ClientAdminUncheckedCreateWithoutStudentFeesInput = {
    id?: string
    name: string
    email: string
    password: string
    instituteName: string
    slug: string
    fullAddress: string
    logo?: string | null
    certificateName?: string | null
    stamp?: string | null
    sign?: string | null
    contact: string
    position: string
    country: string
    state: string
    city: string
    zipCode: string
    createdAt?: Date | string
    role?: $Enums.UserRole
    currentSessionToken?: string | null
    lastLoginAt?: Date | string | null
    roleUsers?: RoleUserUncheckedCreateNestedManyWithoutClientAdminInput
    faculties?: FacultyUncheckedCreateNestedManyWithoutClientAdminInput
    batches?: BatchUncheckedCreateNestedManyWithoutClientAdminInput
    courses?: CourseUncheckedCreateNestedManyWithoutClientAdminInput
    enquiryCourse?: EnquiryCourseUncheckedCreateNestedManyWithoutClientAdminInput
    labs?: LabUncheckedCreateNestedManyWithoutClientAdminInput
    labTimeSlots?: LabTimeSlotUncheckedCreateNestedManyWithoutClientAdminInput
    labAllocations?: LabAllocationUncheckedCreateNestedManyWithoutClientAdminInput
    students?: StudentUncheckedCreateNestedManyWithoutClientAdminInput
    activities?: ActivityLogUncheckedCreateNestedManyWithoutClientAdminInput
    studentCourses?: StudentCourseUncheckedCreateNestedManyWithoutClientAdminInput
    feeStructures?: FeeStructureUncheckedCreateNestedManyWithoutClientAdminInput
    stationeryIssues?: StationeryIssueUncheckedCreateNestedManyWithoutClientAdminInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutClientAdminInput
    studentTasks?: StudentTaskUncheckedCreateNestedManyWithoutClientAdminInput
    studentTests?: StudentTestUncheckedCreateNestedManyWithoutClientAdminInput
    courseCompletions?: CourseCompletionUncheckedCreateNestedManyWithoutClientAdminInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutClientAdminInput
    financialRecords?: FinancialRecordUncheckedCreateNestedManyWithoutClientAdminInput
    enquiries?: EnquiryUncheckedCreateNestedManyWithoutClientAdminInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutClientAdminInput
    courseFeeStructures?: CourseFeeStructureUncheckedCreateNestedManyWithoutClientAdminInput
  }

  export type ClientAdminCreateOrConnectWithoutStudentFeesInput = {
    where: ClientAdminWhereUniqueInput
    create: XOR<ClientAdminCreateWithoutStudentFeesInput, ClientAdminUncheckedCreateWithoutStudentFeesInput>
  }

  export type StudentUpsertWithoutFeeRecordsInput = {
    update: XOR<StudentUpdateWithoutFeeRecordsInput, StudentUncheckedUpdateWithoutFeeRecordsInput>
    create: XOR<StudentCreateWithoutFeeRecordsInput, StudentUncheckedCreateWithoutFeeRecordsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutFeeRecordsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutFeeRecordsInput, StudentUncheckedUpdateWithoutFeeRecordsInput>
  }

  export type StudentUpdateWithoutFeeRecordsInput = {
    serialNumber?: IntFieldUpdateOperationsInput | number
    studentCode?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    fatherName?: StringFieldUpdateOperationsInput | string
    motherName?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: StringFieldUpdateOperationsInput | string
    parentsContact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: NullableStringFieldUpdateOperationsInput | string | null
    permenantAddress?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    idProofType?: NullableStringFieldUpdateOperationsInput | string | null
    idProofNumber?: NullableStringFieldUpdateOperationsInput | string | null
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    enquiry?: EnquiryUpdateOneWithoutStudentNestedInput
    labAllocations?: LabAllocationUpdateManyWithoutStudentNestedInput
    studentCourses?: StudentCourseUpdateManyWithoutStudentNestedInput
    feeStructures?: FeeStructureUpdateManyWithoutStudentNestedInput
    attendance?: AttendanceRecordUpdateManyWithoutStudentNestedInput
    tasks?: StudentTaskUpdateManyWithoutStudentNestedInput
    tests?: StudentTestUpdateManyWithoutStudentNestedInput
    completions?: CourseCompletionUpdateManyWithoutStudentNestedInput
    stationery?: StationeryIssueUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUpdateManyWithoutStudentNestedInput
    financialRecords?: FinancialRecordUpdateManyWithoutStudentNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutStudentsNestedInput
  }

  export type StudentUncheckedUpdateWithoutFeeRecordsInput = {
    id?: IntFieldUpdateOperationsInput | number
    serialNumber?: IntFieldUpdateOperationsInput | number
    studentCode?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    fatherName?: StringFieldUpdateOperationsInput | string
    motherName?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: StringFieldUpdateOperationsInput | string
    parentsContact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: NullableStringFieldUpdateOperationsInput | string | null
    permenantAddress?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    idProofType?: NullableStringFieldUpdateOperationsInput | string | null
    idProofNumber?: NullableStringFieldUpdateOperationsInput | string | null
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    clientAdminId?: StringFieldUpdateOperationsInput | string
    enquiry?: EnquiryUncheckedUpdateOneWithoutStudentNestedInput
    labAllocations?: LabAllocationUncheckedUpdateManyWithoutStudentNestedInput
    studentCourses?: StudentCourseUncheckedUpdateManyWithoutStudentNestedInput
    feeStructures?: FeeStructureUncheckedUpdateManyWithoutStudentNestedInput
    attendance?: AttendanceRecordUncheckedUpdateManyWithoutStudentNestedInput
    tasks?: StudentTaskUncheckedUpdateManyWithoutStudentNestedInput
    tests?: StudentTestUncheckedUpdateManyWithoutStudentNestedInput
    completions?: CourseCompletionUncheckedUpdateManyWithoutStudentNestedInput
    stationery?: StationeryIssueUncheckedUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutStudentNestedInput
    financialRecords?: FinancialRecordUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type CourseUpsertWithoutStudentFeesInput = {
    update: XOR<CourseUpdateWithoutStudentFeesInput, CourseUncheckedUpdateWithoutStudentFeesInput>
    create: XOR<CourseCreateWithoutStudentFeesInput, CourseUncheckedCreateWithoutStudentFeesInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutStudentFeesInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutStudentFeesInput, CourseUncheckedUpdateWithoutStudentFeesInput>
  }

  export type CourseUpdateWithoutStudentFeesInput = {
    name?: StringFieldUpdateOperationsInput | string
    durationWeeks?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    courseFeeStructure?: CourseFeeStructureUpdateOneWithoutCourseNestedInput
    studentCourses?: StudentCourseUpdateManyWithoutCourseNestedInput
    enquiryCourse?: EnquiryCourseUpdateManyWithoutCourseNestedInput
    feeStructures?: FeeStructureUpdateManyWithoutCourseNestedInput
    stationery?: StationeryIssueUpdateManyWithoutCourseNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutCourseNestedInput
    studentTasks?: StudentTaskUpdateManyWithoutCourseNestedInput
    studentTests?: StudentTestUpdateManyWithoutCourseNestedInput
    certificates?: CertificateUpdateManyWithoutCourseNestedInput
    financialRecords?: FinancialRecordUpdateManyWithoutCourseNestedInput
    batchCourses?: BatchCourseUpdateManyWithoutCourseNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutCoursesNestedInput
  }

  export type CourseUncheckedUpdateWithoutStudentFeesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    durationWeeks?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    clientAdminId?: StringFieldUpdateOperationsInput | string
    courseFeeStructure?: CourseFeeStructureUncheckedUpdateOneWithoutCourseNestedInput
    studentCourses?: StudentCourseUncheckedUpdateManyWithoutCourseNestedInput
    enquiryCourse?: EnquiryCourseUncheckedUpdateManyWithoutCourseNestedInput
    feeStructures?: FeeStructureUncheckedUpdateManyWithoutCourseNestedInput
    stationery?: StationeryIssueUncheckedUpdateManyWithoutCourseNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutCourseNestedInput
    studentTasks?: StudentTaskUncheckedUpdateManyWithoutCourseNestedInput
    studentTests?: StudentTestUncheckedUpdateManyWithoutCourseNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutCourseNestedInput
    financialRecords?: FinancialRecordUncheckedUpdateManyWithoutCourseNestedInput
    batchCourses?: BatchCourseUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type StudentFeeLogUpsertWithWhereUniqueWithoutStudentFeeInput = {
    where: StudentFeeLogWhereUniqueInput
    update: XOR<StudentFeeLogUpdateWithoutStudentFeeInput, StudentFeeLogUncheckedUpdateWithoutStudentFeeInput>
    create: XOR<StudentFeeLogCreateWithoutStudentFeeInput, StudentFeeLogUncheckedCreateWithoutStudentFeeInput>
  }

  export type StudentFeeLogUpdateWithWhereUniqueWithoutStudentFeeInput = {
    where: StudentFeeLogWhereUniqueInput
    data: XOR<StudentFeeLogUpdateWithoutStudentFeeInput, StudentFeeLogUncheckedUpdateWithoutStudentFeeInput>
  }

  export type StudentFeeLogUpdateManyWithWhereWithoutStudentFeeInput = {
    where: StudentFeeLogScalarWhereInput
    data: XOR<StudentFeeLogUpdateManyMutationInput, StudentFeeLogUncheckedUpdateManyWithoutStudentFeeInput>
  }

  export type StudentFeeLogScalarWhereInput = {
    AND?: StudentFeeLogScalarWhereInput | StudentFeeLogScalarWhereInput[]
    OR?: StudentFeeLogScalarWhereInput[]
    NOT?: StudentFeeLogScalarWhereInput | StudentFeeLogScalarWhereInput[]
    id?: IntFilter<"StudentFeeLog"> | number
    studentFeeId?: IntFilter<"StudentFeeLog"> | number
    amountPaid?: FloatFilter<"StudentFeeLog"> | number
    paymentDate?: DateTimeFilter<"StudentFeeLog"> | Date | string
    paymentMode?: EnumPaymentModeFilter<"StudentFeeLog"> | $Enums.PaymentMode
    receiptNo?: StringFilter<"StudentFeeLog"> | string
  }

  export type FeeStructureUpsertWithoutStudentFeesInput = {
    update: XOR<FeeStructureUpdateWithoutStudentFeesInput, FeeStructureUncheckedUpdateWithoutStudentFeesInput>
    create: XOR<FeeStructureCreateWithoutStudentFeesInput, FeeStructureUncheckedCreateWithoutStudentFeesInput>
    where?: FeeStructureWhereInput
  }

  export type FeeStructureUpdateToOneWithWhereWithoutStudentFeesInput = {
    where?: FeeStructureWhereInput
    data: XOR<FeeStructureUpdateWithoutStudentFeesInput, FeeStructureUncheckedUpdateWithoutStudentFeesInput>
  }

  export type FeeStructureUpdateWithoutStudentFeesInput = {
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paymentType?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    installmentCount?: NullableIntFieldUpdateOperationsInput | number | null
    student?: StudentUpdateOneRequiredWithoutFeeStructuresNestedInput
    course?: CourseUpdateOneRequiredWithoutFeeStructuresNestedInput
    installment?: InstallmentDetailUpdateOneWithoutFeeStructuresNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutFeeStructuresNestedInput
  }

  export type FeeStructureUncheckedUpdateWithoutStudentFeesInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paymentType?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    installmentCount?: NullableIntFieldUpdateOperationsInput | number | null
    installmentTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationUpsertWithoutPaymentInput = {
    update: XOR<NotificationUpdateWithoutPaymentInput, NotificationUncheckedUpdateWithoutPaymentInput>
    create: XOR<NotificationCreateWithoutPaymentInput, NotificationUncheckedCreateWithoutPaymentInput>
    where?: NotificationWhereInput
  }

  export type NotificationUpdateToOneWithWhereWithoutPaymentInput = {
    where?: NotificationWhereInput
    data: XOR<NotificationUpdateWithoutPaymentInput, NotificationUncheckedUpdateWithoutPaymentInput>
  }

  export type NotificationUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    seen?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    followUp?: FollowUpUpdateOneWithoutNotificationNestedInput
    enquiry?: EnquiryUpdateOneWithoutNotificationNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    seen?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    followUpId?: NullableStringFieldUpdateOperationsInput | string | null
    enquiryId?: NullableStringFieldUpdateOperationsInput | string | null
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type ClientAdminUpsertWithoutStudentFeesInput = {
    update: XOR<ClientAdminUpdateWithoutStudentFeesInput, ClientAdminUncheckedUpdateWithoutStudentFeesInput>
    create: XOR<ClientAdminCreateWithoutStudentFeesInput, ClientAdminUncheckedCreateWithoutStudentFeesInput>
    where?: ClientAdminWhereInput
  }

  export type ClientAdminUpdateToOneWithWhereWithoutStudentFeesInput = {
    where?: ClientAdminWhereInput
    data: XOR<ClientAdminUpdateWithoutStudentFeesInput, ClientAdminUncheckedUpdateWithoutStudentFeesInput>
  }

  export type ClientAdminUpdateWithoutStudentFeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    instituteName?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    fullAddress?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    certificateName?: NullableStringFieldUpdateOperationsInput | string | null
    stamp?: NullableStringFieldUpdateOperationsInput | string | null
    sign?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    currentSessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleUsers?: RoleUserUpdateManyWithoutClientAdminNestedInput
    faculties?: FacultyUpdateManyWithoutClientAdminNestedInput
    batches?: BatchUpdateManyWithoutClientAdminNestedInput
    courses?: CourseUpdateManyWithoutClientAdminNestedInput
    enquiryCourse?: EnquiryCourseUpdateManyWithoutClientAdminNestedInput
    labs?: LabUpdateManyWithoutClientAdminNestedInput
    labTimeSlots?: LabTimeSlotUpdateManyWithoutClientAdminNestedInput
    labAllocations?: LabAllocationUpdateManyWithoutClientAdminNestedInput
    students?: StudentUpdateManyWithoutClientAdminNestedInput
    activities?: ActivityLogUpdateManyWithoutClientAdminNestedInput
    studentCourses?: StudentCourseUpdateManyWithoutClientAdminNestedInput
    feeStructures?: FeeStructureUpdateManyWithoutClientAdminNestedInput
    stationeryIssues?: StationeryIssueUpdateManyWithoutClientAdminNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutClientAdminNestedInput
    studentTasks?: StudentTaskUpdateManyWithoutClientAdminNestedInput
    studentTests?: StudentTestUpdateManyWithoutClientAdminNestedInput
    courseCompletions?: CourseCompletionUpdateManyWithoutClientAdminNestedInput
    certificates?: CertificateUpdateManyWithoutClientAdminNestedInput
    financialRecords?: FinancialRecordUpdateManyWithoutClientAdminNestedInput
    enquiries?: EnquiryUpdateManyWithoutClientAdminNestedInput
    notifications?: NotificationUpdateManyWithoutClientAdminNestedInput
    courseFeeStructures?: CourseFeeStructureUpdateManyWithoutClientAdminNestedInput
  }

  export type ClientAdminUncheckedUpdateWithoutStudentFeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    instituteName?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    fullAddress?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    certificateName?: NullableStringFieldUpdateOperationsInput | string | null
    stamp?: NullableStringFieldUpdateOperationsInput | string | null
    sign?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    currentSessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleUsers?: RoleUserUncheckedUpdateManyWithoutClientAdminNestedInput
    faculties?: FacultyUncheckedUpdateManyWithoutClientAdminNestedInput
    batches?: BatchUncheckedUpdateManyWithoutClientAdminNestedInput
    courses?: CourseUncheckedUpdateManyWithoutClientAdminNestedInput
    enquiryCourse?: EnquiryCourseUncheckedUpdateManyWithoutClientAdminNestedInput
    labs?: LabUncheckedUpdateManyWithoutClientAdminNestedInput
    labTimeSlots?: LabTimeSlotUncheckedUpdateManyWithoutClientAdminNestedInput
    labAllocations?: LabAllocationUncheckedUpdateManyWithoutClientAdminNestedInput
    students?: StudentUncheckedUpdateManyWithoutClientAdminNestedInput
    activities?: ActivityLogUncheckedUpdateManyWithoutClientAdminNestedInput
    studentCourses?: StudentCourseUncheckedUpdateManyWithoutClientAdminNestedInput
    feeStructures?: FeeStructureUncheckedUpdateManyWithoutClientAdminNestedInput
    stationeryIssues?: StationeryIssueUncheckedUpdateManyWithoutClientAdminNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutClientAdminNestedInput
    studentTasks?: StudentTaskUncheckedUpdateManyWithoutClientAdminNestedInput
    studentTests?: StudentTestUncheckedUpdateManyWithoutClientAdminNestedInput
    courseCompletions?: CourseCompletionUncheckedUpdateManyWithoutClientAdminNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutClientAdminNestedInput
    financialRecords?: FinancialRecordUncheckedUpdateManyWithoutClientAdminNestedInput
    enquiries?: EnquiryUncheckedUpdateManyWithoutClientAdminNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutClientAdminNestedInput
    courseFeeStructures?: CourseFeeStructureUncheckedUpdateManyWithoutClientAdminNestedInput
  }

  export type StationeryIssueCreateWithoutItemInput = {
    issueDate: Date | string
    quantity: number
    remarks?: string | null
    student: StudentCreateNestedOneWithoutStationeryInput
    course: CourseCreateNestedOneWithoutStationeryInput
    clientAdmin: ClientAdminCreateNestedOneWithoutStationeryIssuesInput
  }

  export type StationeryIssueUncheckedCreateWithoutItemInput = {
    id?: number
    studentId: number
    courseId: number
    issueDate: Date | string
    quantity: number
    remarks?: string | null
    clientAdminId: string
  }

  export type StationeryIssueCreateOrConnectWithoutItemInput = {
    where: StationeryIssueWhereUniqueInput
    create: XOR<StationeryIssueCreateWithoutItemInput, StationeryIssueUncheckedCreateWithoutItemInput>
  }

  export type StationeryIssueCreateManyItemInputEnvelope = {
    data: StationeryIssueCreateManyItemInput | StationeryIssueCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type StationeryIssueUpsertWithWhereUniqueWithoutItemInput = {
    where: StationeryIssueWhereUniqueInput
    update: XOR<StationeryIssueUpdateWithoutItemInput, StationeryIssueUncheckedUpdateWithoutItemInput>
    create: XOR<StationeryIssueCreateWithoutItemInput, StationeryIssueUncheckedCreateWithoutItemInput>
  }

  export type StationeryIssueUpdateWithWhereUniqueWithoutItemInput = {
    where: StationeryIssueWhereUniqueInput
    data: XOR<StationeryIssueUpdateWithoutItemInput, StationeryIssueUncheckedUpdateWithoutItemInput>
  }

  export type StationeryIssueUpdateManyWithWhereWithoutItemInput = {
    where: StationeryIssueScalarWhereInput
    data: XOR<StationeryIssueUpdateManyMutationInput, StationeryIssueUncheckedUpdateManyWithoutItemInput>
  }

  export type StudentCreateWithoutStationeryInput = {
    serialNumber: number
    studentCode: string
    fullName: string
    fatherName: string
    motherName: string
    photoUrl?: string | null
    contact: string
    parentsContact: string
    email?: string | null
    residentialAddress?: string | null
    permenantAddress?: string | null
    dob: string
    gender: string
    religion?: string | null
    idProofType?: string | null
    idProofNumber?: string | null
    admissionDate: Date | string
    enquiry?: EnquiryCreateNestedOneWithoutStudentInput
    labAllocations?: LabAllocationCreateNestedManyWithoutStudentInput
    studentCourses?: StudentCourseCreateNestedManyWithoutStudentInput
    feeStructures?: FeeStructureCreateNestedManyWithoutStudentInput
    feeRecords?: StudentFeeCreateNestedManyWithoutStudentInput
    attendance?: AttendanceRecordCreateNestedManyWithoutStudentInput
    tasks?: StudentTaskCreateNestedManyWithoutStudentInput
    tests?: StudentTestCreateNestedManyWithoutStudentInput
    completions?: CourseCompletionCreateNestedManyWithoutStudentInput
    certificates?: CertificateCreateNestedManyWithoutStudentInput
    financialRecords?: FinancialRecordCreateNestedManyWithoutStudentInput
    clientAdmin: ClientAdminCreateNestedOneWithoutStudentsInput
  }

  export type StudentUncheckedCreateWithoutStationeryInput = {
    id?: number
    serialNumber: number
    studentCode: string
    fullName: string
    fatherName: string
    motherName: string
    photoUrl?: string | null
    contact: string
    parentsContact: string
    email?: string | null
    residentialAddress?: string | null
    permenantAddress?: string | null
    dob: string
    gender: string
    religion?: string | null
    idProofType?: string | null
    idProofNumber?: string | null
    admissionDate: Date | string
    clientAdminId: string
    enquiry?: EnquiryUncheckedCreateNestedOneWithoutStudentInput
    labAllocations?: LabAllocationUncheckedCreateNestedManyWithoutStudentInput
    studentCourses?: StudentCourseUncheckedCreateNestedManyWithoutStudentInput
    feeStructures?: FeeStructureUncheckedCreateNestedManyWithoutStudentInput
    feeRecords?: StudentFeeUncheckedCreateNestedManyWithoutStudentInput
    attendance?: AttendanceRecordUncheckedCreateNestedManyWithoutStudentInput
    tasks?: StudentTaskUncheckedCreateNestedManyWithoutStudentInput
    tests?: StudentTestUncheckedCreateNestedManyWithoutStudentInput
    completions?: CourseCompletionUncheckedCreateNestedManyWithoutStudentInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutStudentInput
    financialRecords?: FinancialRecordUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutStationeryInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutStationeryInput, StudentUncheckedCreateWithoutStationeryInput>
  }

  export type CourseCreateWithoutStationeryInput = {
    name: string
    durationWeeks: number
    description?: string | null
    courseFeeStructure?: CourseFeeStructureCreateNestedOneWithoutCourseInput
    studentCourses?: StudentCourseCreateNestedManyWithoutCourseInput
    enquiryCourse?: EnquiryCourseCreateNestedManyWithoutCourseInput
    feeStructures?: FeeStructureCreateNestedManyWithoutCourseInput
    studentFees?: StudentFeeCreateNestedManyWithoutCourseInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutCourseInput
    studentTasks?: StudentTaskCreateNestedManyWithoutCourseInput
    studentTests?: StudentTestCreateNestedManyWithoutCourseInput
    certificates?: CertificateCreateNestedManyWithoutCourseInput
    financialRecords?: FinancialRecordCreateNestedManyWithoutCourseInput
    batchCourses?: BatchCourseCreateNestedManyWithoutCourseInput
    clientAdmin: ClientAdminCreateNestedOneWithoutCoursesInput
  }

  export type CourseUncheckedCreateWithoutStationeryInput = {
    id?: number
    name: string
    durationWeeks: number
    description?: string | null
    clientAdminId: string
    courseFeeStructure?: CourseFeeStructureUncheckedCreateNestedOneWithoutCourseInput
    studentCourses?: StudentCourseUncheckedCreateNestedManyWithoutCourseInput
    enquiryCourse?: EnquiryCourseUncheckedCreateNestedManyWithoutCourseInput
    feeStructures?: FeeStructureUncheckedCreateNestedManyWithoutCourseInput
    studentFees?: StudentFeeUncheckedCreateNestedManyWithoutCourseInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutCourseInput
    studentTasks?: StudentTaskUncheckedCreateNestedManyWithoutCourseInput
    studentTests?: StudentTestUncheckedCreateNestedManyWithoutCourseInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutCourseInput
    financialRecords?: FinancialRecordUncheckedCreateNestedManyWithoutCourseInput
    batchCourses?: BatchCourseUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutStationeryInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutStationeryInput, CourseUncheckedCreateWithoutStationeryInput>
  }

  export type StationeryItemCreateWithoutStationeryIssuesInput = {
    name: string
    quantityAvailable: number
  }

  export type StationeryItemUncheckedCreateWithoutStationeryIssuesInput = {
    id?: number
    name: string
    quantityAvailable: number
  }

  export type StationeryItemCreateOrConnectWithoutStationeryIssuesInput = {
    where: StationeryItemWhereUniqueInput
    create: XOR<StationeryItemCreateWithoutStationeryIssuesInput, StationeryItemUncheckedCreateWithoutStationeryIssuesInput>
  }

  export type ClientAdminCreateWithoutStationeryIssuesInput = {
    id?: string
    name: string
    email: string
    password: string
    instituteName: string
    slug: string
    fullAddress: string
    logo?: string | null
    certificateName?: string | null
    stamp?: string | null
    sign?: string | null
    contact: string
    position: string
    country: string
    state: string
    city: string
    zipCode: string
    createdAt?: Date | string
    role?: $Enums.UserRole
    currentSessionToken?: string | null
    lastLoginAt?: Date | string | null
    roleUsers?: RoleUserCreateNestedManyWithoutClientAdminInput
    faculties?: FacultyCreateNestedManyWithoutClientAdminInput
    batches?: BatchCreateNestedManyWithoutClientAdminInput
    courses?: CourseCreateNestedManyWithoutClientAdminInput
    enquiryCourse?: EnquiryCourseCreateNestedManyWithoutClientAdminInput
    labs?: LabCreateNestedManyWithoutClientAdminInput
    labTimeSlots?: LabTimeSlotCreateNestedManyWithoutClientAdminInput
    labAllocations?: LabAllocationCreateNestedManyWithoutClientAdminInput
    students?: StudentCreateNestedManyWithoutClientAdminInput
    activities?: ActivityLogCreateNestedManyWithoutClientAdminInput
    studentCourses?: StudentCourseCreateNestedManyWithoutClientAdminInput
    feeStructures?: FeeStructureCreateNestedManyWithoutClientAdminInput
    studentFees?: StudentFeeCreateNestedManyWithoutClientAdminInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutClientAdminInput
    studentTasks?: StudentTaskCreateNestedManyWithoutClientAdminInput
    studentTests?: StudentTestCreateNestedManyWithoutClientAdminInput
    courseCompletions?: CourseCompletionCreateNestedManyWithoutClientAdminInput
    certificates?: CertificateCreateNestedManyWithoutClientAdminInput
    financialRecords?: FinancialRecordCreateNestedManyWithoutClientAdminInput
    enquiries?: EnquiryCreateNestedManyWithoutClientAdminInput
    notifications?: NotificationCreateNestedManyWithoutClientAdminInput
    courseFeeStructures?: CourseFeeStructureCreateNestedManyWithoutClientAdminInput
  }

  export type ClientAdminUncheckedCreateWithoutStationeryIssuesInput = {
    id?: string
    name: string
    email: string
    password: string
    instituteName: string
    slug: string
    fullAddress: string
    logo?: string | null
    certificateName?: string | null
    stamp?: string | null
    sign?: string | null
    contact: string
    position: string
    country: string
    state: string
    city: string
    zipCode: string
    createdAt?: Date | string
    role?: $Enums.UserRole
    currentSessionToken?: string | null
    lastLoginAt?: Date | string | null
    roleUsers?: RoleUserUncheckedCreateNestedManyWithoutClientAdminInput
    faculties?: FacultyUncheckedCreateNestedManyWithoutClientAdminInput
    batches?: BatchUncheckedCreateNestedManyWithoutClientAdminInput
    courses?: CourseUncheckedCreateNestedManyWithoutClientAdminInput
    enquiryCourse?: EnquiryCourseUncheckedCreateNestedManyWithoutClientAdminInput
    labs?: LabUncheckedCreateNestedManyWithoutClientAdminInput
    labTimeSlots?: LabTimeSlotUncheckedCreateNestedManyWithoutClientAdminInput
    labAllocations?: LabAllocationUncheckedCreateNestedManyWithoutClientAdminInput
    students?: StudentUncheckedCreateNestedManyWithoutClientAdminInput
    activities?: ActivityLogUncheckedCreateNestedManyWithoutClientAdminInput
    studentCourses?: StudentCourseUncheckedCreateNestedManyWithoutClientAdminInput
    feeStructures?: FeeStructureUncheckedCreateNestedManyWithoutClientAdminInput
    studentFees?: StudentFeeUncheckedCreateNestedManyWithoutClientAdminInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutClientAdminInput
    studentTasks?: StudentTaskUncheckedCreateNestedManyWithoutClientAdminInput
    studentTests?: StudentTestUncheckedCreateNestedManyWithoutClientAdminInput
    courseCompletions?: CourseCompletionUncheckedCreateNestedManyWithoutClientAdminInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutClientAdminInput
    financialRecords?: FinancialRecordUncheckedCreateNestedManyWithoutClientAdminInput
    enquiries?: EnquiryUncheckedCreateNestedManyWithoutClientAdminInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutClientAdminInput
    courseFeeStructures?: CourseFeeStructureUncheckedCreateNestedManyWithoutClientAdminInput
  }

  export type ClientAdminCreateOrConnectWithoutStationeryIssuesInput = {
    where: ClientAdminWhereUniqueInput
    create: XOR<ClientAdminCreateWithoutStationeryIssuesInput, ClientAdminUncheckedCreateWithoutStationeryIssuesInput>
  }

  export type StudentUpsertWithoutStationeryInput = {
    update: XOR<StudentUpdateWithoutStationeryInput, StudentUncheckedUpdateWithoutStationeryInput>
    create: XOR<StudentCreateWithoutStationeryInput, StudentUncheckedCreateWithoutStationeryInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutStationeryInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutStationeryInput, StudentUncheckedUpdateWithoutStationeryInput>
  }

  export type StudentUpdateWithoutStationeryInput = {
    serialNumber?: IntFieldUpdateOperationsInput | number
    studentCode?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    fatherName?: StringFieldUpdateOperationsInput | string
    motherName?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: StringFieldUpdateOperationsInput | string
    parentsContact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: NullableStringFieldUpdateOperationsInput | string | null
    permenantAddress?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    idProofType?: NullableStringFieldUpdateOperationsInput | string | null
    idProofNumber?: NullableStringFieldUpdateOperationsInput | string | null
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    enquiry?: EnquiryUpdateOneWithoutStudentNestedInput
    labAllocations?: LabAllocationUpdateManyWithoutStudentNestedInput
    studentCourses?: StudentCourseUpdateManyWithoutStudentNestedInput
    feeStructures?: FeeStructureUpdateManyWithoutStudentNestedInput
    feeRecords?: StudentFeeUpdateManyWithoutStudentNestedInput
    attendance?: AttendanceRecordUpdateManyWithoutStudentNestedInput
    tasks?: StudentTaskUpdateManyWithoutStudentNestedInput
    tests?: StudentTestUpdateManyWithoutStudentNestedInput
    completions?: CourseCompletionUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUpdateManyWithoutStudentNestedInput
    financialRecords?: FinancialRecordUpdateManyWithoutStudentNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutStudentsNestedInput
  }

  export type StudentUncheckedUpdateWithoutStationeryInput = {
    id?: IntFieldUpdateOperationsInput | number
    serialNumber?: IntFieldUpdateOperationsInput | number
    studentCode?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    fatherName?: StringFieldUpdateOperationsInput | string
    motherName?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: StringFieldUpdateOperationsInput | string
    parentsContact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: NullableStringFieldUpdateOperationsInput | string | null
    permenantAddress?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    idProofType?: NullableStringFieldUpdateOperationsInput | string | null
    idProofNumber?: NullableStringFieldUpdateOperationsInput | string | null
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    clientAdminId?: StringFieldUpdateOperationsInput | string
    enquiry?: EnquiryUncheckedUpdateOneWithoutStudentNestedInput
    labAllocations?: LabAllocationUncheckedUpdateManyWithoutStudentNestedInput
    studentCourses?: StudentCourseUncheckedUpdateManyWithoutStudentNestedInput
    feeStructures?: FeeStructureUncheckedUpdateManyWithoutStudentNestedInput
    feeRecords?: StudentFeeUncheckedUpdateManyWithoutStudentNestedInput
    attendance?: AttendanceRecordUncheckedUpdateManyWithoutStudentNestedInput
    tasks?: StudentTaskUncheckedUpdateManyWithoutStudentNestedInput
    tests?: StudentTestUncheckedUpdateManyWithoutStudentNestedInput
    completions?: CourseCompletionUncheckedUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutStudentNestedInput
    financialRecords?: FinancialRecordUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type CourseUpsertWithoutStationeryInput = {
    update: XOR<CourseUpdateWithoutStationeryInput, CourseUncheckedUpdateWithoutStationeryInput>
    create: XOR<CourseCreateWithoutStationeryInput, CourseUncheckedCreateWithoutStationeryInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutStationeryInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutStationeryInput, CourseUncheckedUpdateWithoutStationeryInput>
  }

  export type CourseUpdateWithoutStationeryInput = {
    name?: StringFieldUpdateOperationsInput | string
    durationWeeks?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    courseFeeStructure?: CourseFeeStructureUpdateOneWithoutCourseNestedInput
    studentCourses?: StudentCourseUpdateManyWithoutCourseNestedInput
    enquiryCourse?: EnquiryCourseUpdateManyWithoutCourseNestedInput
    feeStructures?: FeeStructureUpdateManyWithoutCourseNestedInput
    studentFees?: StudentFeeUpdateManyWithoutCourseNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutCourseNestedInput
    studentTasks?: StudentTaskUpdateManyWithoutCourseNestedInput
    studentTests?: StudentTestUpdateManyWithoutCourseNestedInput
    certificates?: CertificateUpdateManyWithoutCourseNestedInput
    financialRecords?: FinancialRecordUpdateManyWithoutCourseNestedInput
    batchCourses?: BatchCourseUpdateManyWithoutCourseNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutCoursesNestedInput
  }

  export type CourseUncheckedUpdateWithoutStationeryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    durationWeeks?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    clientAdminId?: StringFieldUpdateOperationsInput | string
    courseFeeStructure?: CourseFeeStructureUncheckedUpdateOneWithoutCourseNestedInput
    studentCourses?: StudentCourseUncheckedUpdateManyWithoutCourseNestedInput
    enquiryCourse?: EnquiryCourseUncheckedUpdateManyWithoutCourseNestedInput
    feeStructures?: FeeStructureUncheckedUpdateManyWithoutCourseNestedInput
    studentFees?: StudentFeeUncheckedUpdateManyWithoutCourseNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutCourseNestedInput
    studentTasks?: StudentTaskUncheckedUpdateManyWithoutCourseNestedInput
    studentTests?: StudentTestUncheckedUpdateManyWithoutCourseNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutCourseNestedInput
    financialRecords?: FinancialRecordUncheckedUpdateManyWithoutCourseNestedInput
    batchCourses?: BatchCourseUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type StationeryItemUpsertWithoutStationeryIssuesInput = {
    update: XOR<StationeryItemUpdateWithoutStationeryIssuesInput, StationeryItemUncheckedUpdateWithoutStationeryIssuesInput>
    create: XOR<StationeryItemCreateWithoutStationeryIssuesInput, StationeryItemUncheckedCreateWithoutStationeryIssuesInput>
    where?: StationeryItemWhereInput
  }

  export type StationeryItemUpdateToOneWithWhereWithoutStationeryIssuesInput = {
    where?: StationeryItemWhereInput
    data: XOR<StationeryItemUpdateWithoutStationeryIssuesInput, StationeryItemUncheckedUpdateWithoutStationeryIssuesInput>
  }

  export type StationeryItemUpdateWithoutStationeryIssuesInput = {
    name?: StringFieldUpdateOperationsInput | string
    quantityAvailable?: IntFieldUpdateOperationsInput | number
  }

  export type StationeryItemUncheckedUpdateWithoutStationeryIssuesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    quantityAvailable?: IntFieldUpdateOperationsInput | number
  }

  export type ClientAdminUpsertWithoutStationeryIssuesInput = {
    update: XOR<ClientAdminUpdateWithoutStationeryIssuesInput, ClientAdminUncheckedUpdateWithoutStationeryIssuesInput>
    create: XOR<ClientAdminCreateWithoutStationeryIssuesInput, ClientAdminUncheckedCreateWithoutStationeryIssuesInput>
    where?: ClientAdminWhereInput
  }

  export type ClientAdminUpdateToOneWithWhereWithoutStationeryIssuesInput = {
    where?: ClientAdminWhereInput
    data: XOR<ClientAdminUpdateWithoutStationeryIssuesInput, ClientAdminUncheckedUpdateWithoutStationeryIssuesInput>
  }

  export type ClientAdminUpdateWithoutStationeryIssuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    instituteName?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    fullAddress?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    certificateName?: NullableStringFieldUpdateOperationsInput | string | null
    stamp?: NullableStringFieldUpdateOperationsInput | string | null
    sign?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    currentSessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleUsers?: RoleUserUpdateManyWithoutClientAdminNestedInput
    faculties?: FacultyUpdateManyWithoutClientAdminNestedInput
    batches?: BatchUpdateManyWithoutClientAdminNestedInput
    courses?: CourseUpdateManyWithoutClientAdminNestedInput
    enquiryCourse?: EnquiryCourseUpdateManyWithoutClientAdminNestedInput
    labs?: LabUpdateManyWithoutClientAdminNestedInput
    labTimeSlots?: LabTimeSlotUpdateManyWithoutClientAdminNestedInput
    labAllocations?: LabAllocationUpdateManyWithoutClientAdminNestedInput
    students?: StudentUpdateManyWithoutClientAdminNestedInput
    activities?: ActivityLogUpdateManyWithoutClientAdminNestedInput
    studentCourses?: StudentCourseUpdateManyWithoutClientAdminNestedInput
    feeStructures?: FeeStructureUpdateManyWithoutClientAdminNestedInput
    studentFees?: StudentFeeUpdateManyWithoutClientAdminNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutClientAdminNestedInput
    studentTasks?: StudentTaskUpdateManyWithoutClientAdminNestedInput
    studentTests?: StudentTestUpdateManyWithoutClientAdminNestedInput
    courseCompletions?: CourseCompletionUpdateManyWithoutClientAdminNestedInput
    certificates?: CertificateUpdateManyWithoutClientAdminNestedInput
    financialRecords?: FinancialRecordUpdateManyWithoutClientAdminNestedInput
    enquiries?: EnquiryUpdateManyWithoutClientAdminNestedInput
    notifications?: NotificationUpdateManyWithoutClientAdminNestedInput
    courseFeeStructures?: CourseFeeStructureUpdateManyWithoutClientAdminNestedInput
  }

  export type ClientAdminUncheckedUpdateWithoutStationeryIssuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    instituteName?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    fullAddress?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    certificateName?: NullableStringFieldUpdateOperationsInput | string | null
    stamp?: NullableStringFieldUpdateOperationsInput | string | null
    sign?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    currentSessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleUsers?: RoleUserUncheckedUpdateManyWithoutClientAdminNestedInput
    faculties?: FacultyUncheckedUpdateManyWithoutClientAdminNestedInput
    batches?: BatchUncheckedUpdateManyWithoutClientAdminNestedInput
    courses?: CourseUncheckedUpdateManyWithoutClientAdminNestedInput
    enquiryCourse?: EnquiryCourseUncheckedUpdateManyWithoutClientAdminNestedInput
    labs?: LabUncheckedUpdateManyWithoutClientAdminNestedInput
    labTimeSlots?: LabTimeSlotUncheckedUpdateManyWithoutClientAdminNestedInput
    labAllocations?: LabAllocationUncheckedUpdateManyWithoutClientAdminNestedInput
    students?: StudentUncheckedUpdateManyWithoutClientAdminNestedInput
    activities?: ActivityLogUncheckedUpdateManyWithoutClientAdminNestedInput
    studentCourses?: StudentCourseUncheckedUpdateManyWithoutClientAdminNestedInput
    feeStructures?: FeeStructureUncheckedUpdateManyWithoutClientAdminNestedInput
    studentFees?: StudentFeeUncheckedUpdateManyWithoutClientAdminNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutClientAdminNestedInput
    studentTasks?: StudentTaskUncheckedUpdateManyWithoutClientAdminNestedInput
    studentTests?: StudentTestUncheckedUpdateManyWithoutClientAdminNestedInput
    courseCompletions?: CourseCompletionUncheckedUpdateManyWithoutClientAdminNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutClientAdminNestedInput
    financialRecords?: FinancialRecordUncheckedUpdateManyWithoutClientAdminNestedInput
    enquiries?: EnquiryUncheckedUpdateManyWithoutClientAdminNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutClientAdminNestedInput
    courseFeeStructures?: CourseFeeStructureUncheckedUpdateManyWithoutClientAdminNestedInput
  }

  export type StudentCreateWithoutAttendanceInput = {
    serialNumber: number
    studentCode: string
    fullName: string
    fatherName: string
    motherName: string
    photoUrl?: string | null
    contact: string
    parentsContact: string
    email?: string | null
    residentialAddress?: string | null
    permenantAddress?: string | null
    dob: string
    gender: string
    religion?: string | null
    idProofType?: string | null
    idProofNumber?: string | null
    admissionDate: Date | string
    enquiry?: EnquiryCreateNestedOneWithoutStudentInput
    labAllocations?: LabAllocationCreateNestedManyWithoutStudentInput
    studentCourses?: StudentCourseCreateNestedManyWithoutStudentInput
    feeStructures?: FeeStructureCreateNestedManyWithoutStudentInput
    feeRecords?: StudentFeeCreateNestedManyWithoutStudentInput
    tasks?: StudentTaskCreateNestedManyWithoutStudentInput
    tests?: StudentTestCreateNestedManyWithoutStudentInput
    completions?: CourseCompletionCreateNestedManyWithoutStudentInput
    stationery?: StationeryIssueCreateNestedManyWithoutStudentInput
    certificates?: CertificateCreateNestedManyWithoutStudentInput
    financialRecords?: FinancialRecordCreateNestedManyWithoutStudentInput
    clientAdmin: ClientAdminCreateNestedOneWithoutStudentsInput
  }

  export type StudentUncheckedCreateWithoutAttendanceInput = {
    id?: number
    serialNumber: number
    studentCode: string
    fullName: string
    fatherName: string
    motherName: string
    photoUrl?: string | null
    contact: string
    parentsContact: string
    email?: string | null
    residentialAddress?: string | null
    permenantAddress?: string | null
    dob: string
    gender: string
    religion?: string | null
    idProofType?: string | null
    idProofNumber?: string | null
    admissionDate: Date | string
    clientAdminId: string
    enquiry?: EnquiryUncheckedCreateNestedOneWithoutStudentInput
    labAllocations?: LabAllocationUncheckedCreateNestedManyWithoutStudentInput
    studentCourses?: StudentCourseUncheckedCreateNestedManyWithoutStudentInput
    feeStructures?: FeeStructureUncheckedCreateNestedManyWithoutStudentInput
    feeRecords?: StudentFeeUncheckedCreateNestedManyWithoutStudentInput
    tasks?: StudentTaskUncheckedCreateNestedManyWithoutStudentInput
    tests?: StudentTestUncheckedCreateNestedManyWithoutStudentInput
    completions?: CourseCompletionUncheckedCreateNestedManyWithoutStudentInput
    stationery?: StationeryIssueUncheckedCreateNestedManyWithoutStudentInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutStudentInput
    financialRecords?: FinancialRecordUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutAttendanceInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutAttendanceInput, StudentUncheckedCreateWithoutAttendanceInput>
  }

  export type CourseCreateWithoutAttendanceRecordsInput = {
    name: string
    durationWeeks: number
    description?: string | null
    courseFeeStructure?: CourseFeeStructureCreateNestedOneWithoutCourseInput
    studentCourses?: StudentCourseCreateNestedManyWithoutCourseInput
    enquiryCourse?: EnquiryCourseCreateNestedManyWithoutCourseInput
    feeStructures?: FeeStructureCreateNestedManyWithoutCourseInput
    stationery?: StationeryIssueCreateNestedManyWithoutCourseInput
    studentFees?: StudentFeeCreateNestedManyWithoutCourseInput
    studentTasks?: StudentTaskCreateNestedManyWithoutCourseInput
    studentTests?: StudentTestCreateNestedManyWithoutCourseInput
    certificates?: CertificateCreateNestedManyWithoutCourseInput
    financialRecords?: FinancialRecordCreateNestedManyWithoutCourseInput
    batchCourses?: BatchCourseCreateNestedManyWithoutCourseInput
    clientAdmin: ClientAdminCreateNestedOneWithoutCoursesInput
  }

  export type CourseUncheckedCreateWithoutAttendanceRecordsInput = {
    id?: number
    name: string
    durationWeeks: number
    description?: string | null
    clientAdminId: string
    courseFeeStructure?: CourseFeeStructureUncheckedCreateNestedOneWithoutCourseInput
    studentCourses?: StudentCourseUncheckedCreateNestedManyWithoutCourseInput
    enquiryCourse?: EnquiryCourseUncheckedCreateNestedManyWithoutCourseInput
    feeStructures?: FeeStructureUncheckedCreateNestedManyWithoutCourseInput
    stationery?: StationeryIssueUncheckedCreateNestedManyWithoutCourseInput
    studentFees?: StudentFeeUncheckedCreateNestedManyWithoutCourseInput
    studentTasks?: StudentTaskUncheckedCreateNestedManyWithoutCourseInput
    studentTests?: StudentTestUncheckedCreateNestedManyWithoutCourseInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutCourseInput
    financialRecords?: FinancialRecordUncheckedCreateNestedManyWithoutCourseInput
    batchCourses?: BatchCourseUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutAttendanceRecordsInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutAttendanceRecordsInput, CourseUncheckedCreateWithoutAttendanceRecordsInput>
  }

  export type FacultyCreateWithoutAttendanceInput = {
    name: string
    email: string
    password: string
    contact: string
    joiningDate: Date | string
    specialization?: string | null
    role?: $Enums.UserRole
    country: string
    state: string
    city: string
    zipCode: string
    currentSessionToken?: string | null
    lastLoginAt?: Date | string | null
    batches?: BatchCreateNestedManyWithoutFacultyInput
    tasks?: StudentTaskCreateNestedManyWithoutFacultyInput
    financialRecords?: FinancialRecordCreateNestedManyWithoutFacultyInput
    clientAdmin: ClientAdminCreateNestedOneWithoutFacultiesInput
  }

  export type FacultyUncheckedCreateWithoutAttendanceInput = {
    id?: number
    name: string
    email: string
    password: string
    contact: string
    joiningDate: Date | string
    specialization?: string | null
    role?: $Enums.UserRole
    country: string
    state: string
    city: string
    zipCode: string
    currentSessionToken?: string | null
    lastLoginAt?: Date | string | null
    clientAdminId: string
    batches?: BatchUncheckedCreateNestedManyWithoutFacultyInput
    tasks?: StudentTaskUncheckedCreateNestedManyWithoutFacultyInput
    financialRecords?: FinancialRecordUncheckedCreateNestedManyWithoutFacultyInput
  }

  export type FacultyCreateOrConnectWithoutAttendanceInput = {
    where: FacultyWhereUniqueInput
    create: XOR<FacultyCreateWithoutAttendanceInput, FacultyUncheckedCreateWithoutAttendanceInput>
  }

  export type ClientAdminCreateWithoutAttendanceRecordsInput = {
    id?: string
    name: string
    email: string
    password: string
    instituteName: string
    slug: string
    fullAddress: string
    logo?: string | null
    certificateName?: string | null
    stamp?: string | null
    sign?: string | null
    contact: string
    position: string
    country: string
    state: string
    city: string
    zipCode: string
    createdAt?: Date | string
    role?: $Enums.UserRole
    currentSessionToken?: string | null
    lastLoginAt?: Date | string | null
    roleUsers?: RoleUserCreateNestedManyWithoutClientAdminInput
    faculties?: FacultyCreateNestedManyWithoutClientAdminInput
    batches?: BatchCreateNestedManyWithoutClientAdminInput
    courses?: CourseCreateNestedManyWithoutClientAdminInput
    enquiryCourse?: EnquiryCourseCreateNestedManyWithoutClientAdminInput
    labs?: LabCreateNestedManyWithoutClientAdminInput
    labTimeSlots?: LabTimeSlotCreateNestedManyWithoutClientAdminInput
    labAllocations?: LabAllocationCreateNestedManyWithoutClientAdminInput
    students?: StudentCreateNestedManyWithoutClientAdminInput
    activities?: ActivityLogCreateNestedManyWithoutClientAdminInput
    studentCourses?: StudentCourseCreateNestedManyWithoutClientAdminInput
    feeStructures?: FeeStructureCreateNestedManyWithoutClientAdminInput
    studentFees?: StudentFeeCreateNestedManyWithoutClientAdminInput
    stationeryIssues?: StationeryIssueCreateNestedManyWithoutClientAdminInput
    studentTasks?: StudentTaskCreateNestedManyWithoutClientAdminInput
    studentTests?: StudentTestCreateNestedManyWithoutClientAdminInput
    courseCompletions?: CourseCompletionCreateNestedManyWithoutClientAdminInput
    certificates?: CertificateCreateNestedManyWithoutClientAdminInput
    financialRecords?: FinancialRecordCreateNestedManyWithoutClientAdminInput
    enquiries?: EnquiryCreateNestedManyWithoutClientAdminInput
    notifications?: NotificationCreateNestedManyWithoutClientAdminInput
    courseFeeStructures?: CourseFeeStructureCreateNestedManyWithoutClientAdminInput
  }

  export type ClientAdminUncheckedCreateWithoutAttendanceRecordsInput = {
    id?: string
    name: string
    email: string
    password: string
    instituteName: string
    slug: string
    fullAddress: string
    logo?: string | null
    certificateName?: string | null
    stamp?: string | null
    sign?: string | null
    contact: string
    position: string
    country: string
    state: string
    city: string
    zipCode: string
    createdAt?: Date | string
    role?: $Enums.UserRole
    currentSessionToken?: string | null
    lastLoginAt?: Date | string | null
    roleUsers?: RoleUserUncheckedCreateNestedManyWithoutClientAdminInput
    faculties?: FacultyUncheckedCreateNestedManyWithoutClientAdminInput
    batches?: BatchUncheckedCreateNestedManyWithoutClientAdminInput
    courses?: CourseUncheckedCreateNestedManyWithoutClientAdminInput
    enquiryCourse?: EnquiryCourseUncheckedCreateNestedManyWithoutClientAdminInput
    labs?: LabUncheckedCreateNestedManyWithoutClientAdminInput
    labTimeSlots?: LabTimeSlotUncheckedCreateNestedManyWithoutClientAdminInput
    labAllocations?: LabAllocationUncheckedCreateNestedManyWithoutClientAdminInput
    students?: StudentUncheckedCreateNestedManyWithoutClientAdminInput
    activities?: ActivityLogUncheckedCreateNestedManyWithoutClientAdminInput
    studentCourses?: StudentCourseUncheckedCreateNestedManyWithoutClientAdminInput
    feeStructures?: FeeStructureUncheckedCreateNestedManyWithoutClientAdminInput
    studentFees?: StudentFeeUncheckedCreateNestedManyWithoutClientAdminInput
    stationeryIssues?: StationeryIssueUncheckedCreateNestedManyWithoutClientAdminInput
    studentTasks?: StudentTaskUncheckedCreateNestedManyWithoutClientAdminInput
    studentTests?: StudentTestUncheckedCreateNestedManyWithoutClientAdminInput
    courseCompletions?: CourseCompletionUncheckedCreateNestedManyWithoutClientAdminInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutClientAdminInput
    financialRecords?: FinancialRecordUncheckedCreateNestedManyWithoutClientAdminInput
    enquiries?: EnquiryUncheckedCreateNestedManyWithoutClientAdminInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutClientAdminInput
    courseFeeStructures?: CourseFeeStructureUncheckedCreateNestedManyWithoutClientAdminInput
  }

  export type ClientAdminCreateOrConnectWithoutAttendanceRecordsInput = {
    where: ClientAdminWhereUniqueInput
    create: XOR<ClientAdminCreateWithoutAttendanceRecordsInput, ClientAdminUncheckedCreateWithoutAttendanceRecordsInput>
  }

  export type StudentUpsertWithoutAttendanceInput = {
    update: XOR<StudentUpdateWithoutAttendanceInput, StudentUncheckedUpdateWithoutAttendanceInput>
    create: XOR<StudentCreateWithoutAttendanceInput, StudentUncheckedCreateWithoutAttendanceInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutAttendanceInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutAttendanceInput, StudentUncheckedUpdateWithoutAttendanceInput>
  }

  export type StudentUpdateWithoutAttendanceInput = {
    serialNumber?: IntFieldUpdateOperationsInput | number
    studentCode?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    fatherName?: StringFieldUpdateOperationsInput | string
    motherName?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: StringFieldUpdateOperationsInput | string
    parentsContact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: NullableStringFieldUpdateOperationsInput | string | null
    permenantAddress?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    idProofType?: NullableStringFieldUpdateOperationsInput | string | null
    idProofNumber?: NullableStringFieldUpdateOperationsInput | string | null
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    enquiry?: EnquiryUpdateOneWithoutStudentNestedInput
    labAllocations?: LabAllocationUpdateManyWithoutStudentNestedInput
    studentCourses?: StudentCourseUpdateManyWithoutStudentNestedInput
    feeStructures?: FeeStructureUpdateManyWithoutStudentNestedInput
    feeRecords?: StudentFeeUpdateManyWithoutStudentNestedInput
    tasks?: StudentTaskUpdateManyWithoutStudentNestedInput
    tests?: StudentTestUpdateManyWithoutStudentNestedInput
    completions?: CourseCompletionUpdateManyWithoutStudentNestedInput
    stationery?: StationeryIssueUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUpdateManyWithoutStudentNestedInput
    financialRecords?: FinancialRecordUpdateManyWithoutStudentNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutStudentsNestedInput
  }

  export type StudentUncheckedUpdateWithoutAttendanceInput = {
    id?: IntFieldUpdateOperationsInput | number
    serialNumber?: IntFieldUpdateOperationsInput | number
    studentCode?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    fatherName?: StringFieldUpdateOperationsInput | string
    motherName?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: StringFieldUpdateOperationsInput | string
    parentsContact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: NullableStringFieldUpdateOperationsInput | string | null
    permenantAddress?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    idProofType?: NullableStringFieldUpdateOperationsInput | string | null
    idProofNumber?: NullableStringFieldUpdateOperationsInput | string | null
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    clientAdminId?: StringFieldUpdateOperationsInput | string
    enquiry?: EnquiryUncheckedUpdateOneWithoutStudentNestedInput
    labAllocations?: LabAllocationUncheckedUpdateManyWithoutStudentNestedInput
    studentCourses?: StudentCourseUncheckedUpdateManyWithoutStudentNestedInput
    feeStructures?: FeeStructureUncheckedUpdateManyWithoutStudentNestedInput
    feeRecords?: StudentFeeUncheckedUpdateManyWithoutStudentNestedInput
    tasks?: StudentTaskUncheckedUpdateManyWithoutStudentNestedInput
    tests?: StudentTestUncheckedUpdateManyWithoutStudentNestedInput
    completions?: CourseCompletionUncheckedUpdateManyWithoutStudentNestedInput
    stationery?: StationeryIssueUncheckedUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutStudentNestedInput
    financialRecords?: FinancialRecordUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type CourseUpsertWithoutAttendanceRecordsInput = {
    update: XOR<CourseUpdateWithoutAttendanceRecordsInput, CourseUncheckedUpdateWithoutAttendanceRecordsInput>
    create: XOR<CourseCreateWithoutAttendanceRecordsInput, CourseUncheckedCreateWithoutAttendanceRecordsInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutAttendanceRecordsInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutAttendanceRecordsInput, CourseUncheckedUpdateWithoutAttendanceRecordsInput>
  }

  export type CourseUpdateWithoutAttendanceRecordsInput = {
    name?: StringFieldUpdateOperationsInput | string
    durationWeeks?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    courseFeeStructure?: CourseFeeStructureUpdateOneWithoutCourseNestedInput
    studentCourses?: StudentCourseUpdateManyWithoutCourseNestedInput
    enquiryCourse?: EnquiryCourseUpdateManyWithoutCourseNestedInput
    feeStructures?: FeeStructureUpdateManyWithoutCourseNestedInput
    stationery?: StationeryIssueUpdateManyWithoutCourseNestedInput
    studentFees?: StudentFeeUpdateManyWithoutCourseNestedInput
    studentTasks?: StudentTaskUpdateManyWithoutCourseNestedInput
    studentTests?: StudentTestUpdateManyWithoutCourseNestedInput
    certificates?: CertificateUpdateManyWithoutCourseNestedInput
    financialRecords?: FinancialRecordUpdateManyWithoutCourseNestedInput
    batchCourses?: BatchCourseUpdateManyWithoutCourseNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutCoursesNestedInput
  }

  export type CourseUncheckedUpdateWithoutAttendanceRecordsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    durationWeeks?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    clientAdminId?: StringFieldUpdateOperationsInput | string
    courseFeeStructure?: CourseFeeStructureUncheckedUpdateOneWithoutCourseNestedInput
    studentCourses?: StudentCourseUncheckedUpdateManyWithoutCourseNestedInput
    enquiryCourse?: EnquiryCourseUncheckedUpdateManyWithoutCourseNestedInput
    feeStructures?: FeeStructureUncheckedUpdateManyWithoutCourseNestedInput
    stationery?: StationeryIssueUncheckedUpdateManyWithoutCourseNestedInput
    studentFees?: StudentFeeUncheckedUpdateManyWithoutCourseNestedInput
    studentTasks?: StudentTaskUncheckedUpdateManyWithoutCourseNestedInput
    studentTests?: StudentTestUncheckedUpdateManyWithoutCourseNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutCourseNestedInput
    financialRecords?: FinancialRecordUncheckedUpdateManyWithoutCourseNestedInput
    batchCourses?: BatchCourseUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type FacultyUpsertWithoutAttendanceInput = {
    update: XOR<FacultyUpdateWithoutAttendanceInput, FacultyUncheckedUpdateWithoutAttendanceInput>
    create: XOR<FacultyCreateWithoutAttendanceInput, FacultyUncheckedCreateWithoutAttendanceInput>
    where?: FacultyWhereInput
  }

  export type FacultyUpdateToOneWithWhereWithoutAttendanceInput = {
    where?: FacultyWhereInput
    data: XOR<FacultyUpdateWithoutAttendanceInput, FacultyUncheckedUpdateWithoutAttendanceInput>
  }

  export type FacultyUpdateWithoutAttendanceInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    joiningDate?: DateTimeFieldUpdateOperationsInput | Date | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    currentSessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    batches?: BatchUpdateManyWithoutFacultyNestedInput
    tasks?: StudentTaskUpdateManyWithoutFacultyNestedInput
    financialRecords?: FinancialRecordUpdateManyWithoutFacultyNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutFacultiesNestedInput
  }

  export type FacultyUncheckedUpdateWithoutAttendanceInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    joiningDate?: DateTimeFieldUpdateOperationsInput | Date | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    currentSessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clientAdminId?: StringFieldUpdateOperationsInput | string
    batches?: BatchUncheckedUpdateManyWithoutFacultyNestedInput
    tasks?: StudentTaskUncheckedUpdateManyWithoutFacultyNestedInput
    financialRecords?: FinancialRecordUncheckedUpdateManyWithoutFacultyNestedInput
  }

  export type ClientAdminUpsertWithoutAttendanceRecordsInput = {
    update: XOR<ClientAdminUpdateWithoutAttendanceRecordsInput, ClientAdminUncheckedUpdateWithoutAttendanceRecordsInput>
    create: XOR<ClientAdminCreateWithoutAttendanceRecordsInput, ClientAdminUncheckedCreateWithoutAttendanceRecordsInput>
    where?: ClientAdminWhereInput
  }

  export type ClientAdminUpdateToOneWithWhereWithoutAttendanceRecordsInput = {
    where?: ClientAdminWhereInput
    data: XOR<ClientAdminUpdateWithoutAttendanceRecordsInput, ClientAdminUncheckedUpdateWithoutAttendanceRecordsInput>
  }

  export type ClientAdminUpdateWithoutAttendanceRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    instituteName?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    fullAddress?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    certificateName?: NullableStringFieldUpdateOperationsInput | string | null
    stamp?: NullableStringFieldUpdateOperationsInput | string | null
    sign?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    currentSessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleUsers?: RoleUserUpdateManyWithoutClientAdminNestedInput
    faculties?: FacultyUpdateManyWithoutClientAdminNestedInput
    batches?: BatchUpdateManyWithoutClientAdminNestedInput
    courses?: CourseUpdateManyWithoutClientAdminNestedInput
    enquiryCourse?: EnquiryCourseUpdateManyWithoutClientAdminNestedInput
    labs?: LabUpdateManyWithoutClientAdminNestedInput
    labTimeSlots?: LabTimeSlotUpdateManyWithoutClientAdminNestedInput
    labAllocations?: LabAllocationUpdateManyWithoutClientAdminNestedInput
    students?: StudentUpdateManyWithoutClientAdminNestedInput
    activities?: ActivityLogUpdateManyWithoutClientAdminNestedInput
    studentCourses?: StudentCourseUpdateManyWithoutClientAdminNestedInput
    feeStructures?: FeeStructureUpdateManyWithoutClientAdminNestedInput
    studentFees?: StudentFeeUpdateManyWithoutClientAdminNestedInput
    stationeryIssues?: StationeryIssueUpdateManyWithoutClientAdminNestedInput
    studentTasks?: StudentTaskUpdateManyWithoutClientAdminNestedInput
    studentTests?: StudentTestUpdateManyWithoutClientAdminNestedInput
    courseCompletions?: CourseCompletionUpdateManyWithoutClientAdminNestedInput
    certificates?: CertificateUpdateManyWithoutClientAdminNestedInput
    financialRecords?: FinancialRecordUpdateManyWithoutClientAdminNestedInput
    enquiries?: EnquiryUpdateManyWithoutClientAdminNestedInput
    notifications?: NotificationUpdateManyWithoutClientAdminNestedInput
    courseFeeStructures?: CourseFeeStructureUpdateManyWithoutClientAdminNestedInput
  }

  export type ClientAdminUncheckedUpdateWithoutAttendanceRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    instituteName?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    fullAddress?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    certificateName?: NullableStringFieldUpdateOperationsInput | string | null
    stamp?: NullableStringFieldUpdateOperationsInput | string | null
    sign?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    currentSessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleUsers?: RoleUserUncheckedUpdateManyWithoutClientAdminNestedInput
    faculties?: FacultyUncheckedUpdateManyWithoutClientAdminNestedInput
    batches?: BatchUncheckedUpdateManyWithoutClientAdminNestedInput
    courses?: CourseUncheckedUpdateManyWithoutClientAdminNestedInput
    enquiryCourse?: EnquiryCourseUncheckedUpdateManyWithoutClientAdminNestedInput
    labs?: LabUncheckedUpdateManyWithoutClientAdminNestedInput
    labTimeSlots?: LabTimeSlotUncheckedUpdateManyWithoutClientAdminNestedInput
    labAllocations?: LabAllocationUncheckedUpdateManyWithoutClientAdminNestedInput
    students?: StudentUncheckedUpdateManyWithoutClientAdminNestedInput
    activities?: ActivityLogUncheckedUpdateManyWithoutClientAdminNestedInput
    studentCourses?: StudentCourseUncheckedUpdateManyWithoutClientAdminNestedInput
    feeStructures?: FeeStructureUncheckedUpdateManyWithoutClientAdminNestedInput
    studentFees?: StudentFeeUncheckedUpdateManyWithoutClientAdminNestedInput
    stationeryIssues?: StationeryIssueUncheckedUpdateManyWithoutClientAdminNestedInput
    studentTasks?: StudentTaskUncheckedUpdateManyWithoutClientAdminNestedInput
    studentTests?: StudentTestUncheckedUpdateManyWithoutClientAdminNestedInput
    courseCompletions?: CourseCompletionUncheckedUpdateManyWithoutClientAdminNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutClientAdminNestedInput
    financialRecords?: FinancialRecordUncheckedUpdateManyWithoutClientAdminNestedInput
    enquiries?: EnquiryUncheckedUpdateManyWithoutClientAdminNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutClientAdminNestedInput
    courseFeeStructures?: CourseFeeStructureUncheckedUpdateManyWithoutClientAdminNestedInput
  }

  export type StudentCreateWithoutTasksInput = {
    serialNumber: number
    studentCode: string
    fullName: string
    fatherName: string
    motherName: string
    photoUrl?: string | null
    contact: string
    parentsContact: string
    email?: string | null
    residentialAddress?: string | null
    permenantAddress?: string | null
    dob: string
    gender: string
    religion?: string | null
    idProofType?: string | null
    idProofNumber?: string | null
    admissionDate: Date | string
    enquiry?: EnquiryCreateNestedOneWithoutStudentInput
    labAllocations?: LabAllocationCreateNestedManyWithoutStudentInput
    studentCourses?: StudentCourseCreateNestedManyWithoutStudentInput
    feeStructures?: FeeStructureCreateNestedManyWithoutStudentInput
    feeRecords?: StudentFeeCreateNestedManyWithoutStudentInput
    attendance?: AttendanceRecordCreateNestedManyWithoutStudentInput
    tests?: StudentTestCreateNestedManyWithoutStudentInput
    completions?: CourseCompletionCreateNestedManyWithoutStudentInput
    stationery?: StationeryIssueCreateNestedManyWithoutStudentInput
    certificates?: CertificateCreateNestedManyWithoutStudentInput
    financialRecords?: FinancialRecordCreateNestedManyWithoutStudentInput
    clientAdmin: ClientAdminCreateNestedOneWithoutStudentsInput
  }

  export type StudentUncheckedCreateWithoutTasksInput = {
    id?: number
    serialNumber: number
    studentCode: string
    fullName: string
    fatherName: string
    motherName: string
    photoUrl?: string | null
    contact: string
    parentsContact: string
    email?: string | null
    residentialAddress?: string | null
    permenantAddress?: string | null
    dob: string
    gender: string
    religion?: string | null
    idProofType?: string | null
    idProofNumber?: string | null
    admissionDate: Date | string
    clientAdminId: string
    enquiry?: EnquiryUncheckedCreateNestedOneWithoutStudentInput
    labAllocations?: LabAllocationUncheckedCreateNestedManyWithoutStudentInput
    studentCourses?: StudentCourseUncheckedCreateNestedManyWithoutStudentInput
    feeStructures?: FeeStructureUncheckedCreateNestedManyWithoutStudentInput
    feeRecords?: StudentFeeUncheckedCreateNestedManyWithoutStudentInput
    attendance?: AttendanceRecordUncheckedCreateNestedManyWithoutStudentInput
    tests?: StudentTestUncheckedCreateNestedManyWithoutStudentInput
    completions?: CourseCompletionUncheckedCreateNestedManyWithoutStudentInput
    stationery?: StationeryIssueUncheckedCreateNestedManyWithoutStudentInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutStudentInput
    financialRecords?: FinancialRecordUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutTasksInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutTasksInput, StudentUncheckedCreateWithoutTasksInput>
  }

  export type CourseCreateWithoutStudentTasksInput = {
    name: string
    durationWeeks: number
    description?: string | null
    courseFeeStructure?: CourseFeeStructureCreateNestedOneWithoutCourseInput
    studentCourses?: StudentCourseCreateNestedManyWithoutCourseInput
    enquiryCourse?: EnquiryCourseCreateNestedManyWithoutCourseInput
    feeStructures?: FeeStructureCreateNestedManyWithoutCourseInput
    stationery?: StationeryIssueCreateNestedManyWithoutCourseInput
    studentFees?: StudentFeeCreateNestedManyWithoutCourseInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutCourseInput
    studentTests?: StudentTestCreateNestedManyWithoutCourseInput
    certificates?: CertificateCreateNestedManyWithoutCourseInput
    financialRecords?: FinancialRecordCreateNestedManyWithoutCourseInput
    batchCourses?: BatchCourseCreateNestedManyWithoutCourseInput
    clientAdmin: ClientAdminCreateNestedOneWithoutCoursesInput
  }

  export type CourseUncheckedCreateWithoutStudentTasksInput = {
    id?: number
    name: string
    durationWeeks: number
    description?: string | null
    clientAdminId: string
    courseFeeStructure?: CourseFeeStructureUncheckedCreateNestedOneWithoutCourseInput
    studentCourses?: StudentCourseUncheckedCreateNestedManyWithoutCourseInput
    enquiryCourse?: EnquiryCourseUncheckedCreateNestedManyWithoutCourseInput
    feeStructures?: FeeStructureUncheckedCreateNestedManyWithoutCourseInput
    stationery?: StationeryIssueUncheckedCreateNestedManyWithoutCourseInput
    studentFees?: StudentFeeUncheckedCreateNestedManyWithoutCourseInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutCourseInput
    studentTests?: StudentTestUncheckedCreateNestedManyWithoutCourseInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutCourseInput
    financialRecords?: FinancialRecordUncheckedCreateNestedManyWithoutCourseInput
    batchCourses?: BatchCourseUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutStudentTasksInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutStudentTasksInput, CourseUncheckedCreateWithoutStudentTasksInput>
  }

  export type FacultyCreateWithoutTasksInput = {
    name: string
    email: string
    password: string
    contact: string
    joiningDate: Date | string
    specialization?: string | null
    role?: $Enums.UserRole
    country: string
    state: string
    city: string
    zipCode: string
    currentSessionToken?: string | null
    lastLoginAt?: Date | string | null
    batches?: BatchCreateNestedManyWithoutFacultyInput
    attendance?: AttendanceRecordCreateNestedManyWithoutMarkedByInput
    financialRecords?: FinancialRecordCreateNestedManyWithoutFacultyInput
    clientAdmin: ClientAdminCreateNestedOneWithoutFacultiesInput
  }

  export type FacultyUncheckedCreateWithoutTasksInput = {
    id?: number
    name: string
    email: string
    password: string
    contact: string
    joiningDate: Date | string
    specialization?: string | null
    role?: $Enums.UserRole
    country: string
    state: string
    city: string
    zipCode: string
    currentSessionToken?: string | null
    lastLoginAt?: Date | string | null
    clientAdminId: string
    batches?: BatchUncheckedCreateNestedManyWithoutFacultyInput
    attendance?: AttendanceRecordUncheckedCreateNestedManyWithoutMarkedByInput
    financialRecords?: FinancialRecordUncheckedCreateNestedManyWithoutFacultyInput
  }

  export type FacultyCreateOrConnectWithoutTasksInput = {
    where: FacultyWhereUniqueInput
    create: XOR<FacultyCreateWithoutTasksInput, FacultyUncheckedCreateWithoutTasksInput>
  }

  export type ClientAdminCreateWithoutStudentTasksInput = {
    id?: string
    name: string
    email: string
    password: string
    instituteName: string
    slug: string
    fullAddress: string
    logo?: string | null
    certificateName?: string | null
    stamp?: string | null
    sign?: string | null
    contact: string
    position: string
    country: string
    state: string
    city: string
    zipCode: string
    createdAt?: Date | string
    role?: $Enums.UserRole
    currentSessionToken?: string | null
    lastLoginAt?: Date | string | null
    roleUsers?: RoleUserCreateNestedManyWithoutClientAdminInput
    faculties?: FacultyCreateNestedManyWithoutClientAdminInput
    batches?: BatchCreateNestedManyWithoutClientAdminInput
    courses?: CourseCreateNestedManyWithoutClientAdminInput
    enquiryCourse?: EnquiryCourseCreateNestedManyWithoutClientAdminInput
    labs?: LabCreateNestedManyWithoutClientAdminInput
    labTimeSlots?: LabTimeSlotCreateNestedManyWithoutClientAdminInput
    labAllocations?: LabAllocationCreateNestedManyWithoutClientAdminInput
    students?: StudentCreateNestedManyWithoutClientAdminInput
    activities?: ActivityLogCreateNestedManyWithoutClientAdminInput
    studentCourses?: StudentCourseCreateNestedManyWithoutClientAdminInput
    feeStructures?: FeeStructureCreateNestedManyWithoutClientAdminInput
    studentFees?: StudentFeeCreateNestedManyWithoutClientAdminInput
    stationeryIssues?: StationeryIssueCreateNestedManyWithoutClientAdminInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutClientAdminInput
    studentTests?: StudentTestCreateNestedManyWithoutClientAdminInput
    courseCompletions?: CourseCompletionCreateNestedManyWithoutClientAdminInput
    certificates?: CertificateCreateNestedManyWithoutClientAdminInput
    financialRecords?: FinancialRecordCreateNestedManyWithoutClientAdminInput
    enquiries?: EnquiryCreateNestedManyWithoutClientAdminInput
    notifications?: NotificationCreateNestedManyWithoutClientAdminInput
    courseFeeStructures?: CourseFeeStructureCreateNestedManyWithoutClientAdminInput
  }

  export type ClientAdminUncheckedCreateWithoutStudentTasksInput = {
    id?: string
    name: string
    email: string
    password: string
    instituteName: string
    slug: string
    fullAddress: string
    logo?: string | null
    certificateName?: string | null
    stamp?: string | null
    sign?: string | null
    contact: string
    position: string
    country: string
    state: string
    city: string
    zipCode: string
    createdAt?: Date | string
    role?: $Enums.UserRole
    currentSessionToken?: string | null
    lastLoginAt?: Date | string | null
    roleUsers?: RoleUserUncheckedCreateNestedManyWithoutClientAdminInput
    faculties?: FacultyUncheckedCreateNestedManyWithoutClientAdminInput
    batches?: BatchUncheckedCreateNestedManyWithoutClientAdminInput
    courses?: CourseUncheckedCreateNestedManyWithoutClientAdminInput
    enquiryCourse?: EnquiryCourseUncheckedCreateNestedManyWithoutClientAdminInput
    labs?: LabUncheckedCreateNestedManyWithoutClientAdminInput
    labTimeSlots?: LabTimeSlotUncheckedCreateNestedManyWithoutClientAdminInput
    labAllocations?: LabAllocationUncheckedCreateNestedManyWithoutClientAdminInput
    students?: StudentUncheckedCreateNestedManyWithoutClientAdminInput
    activities?: ActivityLogUncheckedCreateNestedManyWithoutClientAdminInput
    studentCourses?: StudentCourseUncheckedCreateNestedManyWithoutClientAdminInput
    feeStructures?: FeeStructureUncheckedCreateNestedManyWithoutClientAdminInput
    studentFees?: StudentFeeUncheckedCreateNestedManyWithoutClientAdminInput
    stationeryIssues?: StationeryIssueUncheckedCreateNestedManyWithoutClientAdminInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutClientAdminInput
    studentTests?: StudentTestUncheckedCreateNestedManyWithoutClientAdminInput
    courseCompletions?: CourseCompletionUncheckedCreateNestedManyWithoutClientAdminInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutClientAdminInput
    financialRecords?: FinancialRecordUncheckedCreateNestedManyWithoutClientAdminInput
    enquiries?: EnquiryUncheckedCreateNestedManyWithoutClientAdminInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutClientAdminInput
    courseFeeStructures?: CourseFeeStructureUncheckedCreateNestedManyWithoutClientAdminInput
  }

  export type ClientAdminCreateOrConnectWithoutStudentTasksInput = {
    where: ClientAdminWhereUniqueInput
    create: XOR<ClientAdminCreateWithoutStudentTasksInput, ClientAdminUncheckedCreateWithoutStudentTasksInput>
  }

  export type StudentUpsertWithoutTasksInput = {
    update: XOR<StudentUpdateWithoutTasksInput, StudentUncheckedUpdateWithoutTasksInput>
    create: XOR<StudentCreateWithoutTasksInput, StudentUncheckedCreateWithoutTasksInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutTasksInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutTasksInput, StudentUncheckedUpdateWithoutTasksInput>
  }

  export type StudentUpdateWithoutTasksInput = {
    serialNumber?: IntFieldUpdateOperationsInput | number
    studentCode?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    fatherName?: StringFieldUpdateOperationsInput | string
    motherName?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: StringFieldUpdateOperationsInput | string
    parentsContact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: NullableStringFieldUpdateOperationsInput | string | null
    permenantAddress?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    idProofType?: NullableStringFieldUpdateOperationsInput | string | null
    idProofNumber?: NullableStringFieldUpdateOperationsInput | string | null
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    enquiry?: EnquiryUpdateOneWithoutStudentNestedInput
    labAllocations?: LabAllocationUpdateManyWithoutStudentNestedInput
    studentCourses?: StudentCourseUpdateManyWithoutStudentNestedInput
    feeStructures?: FeeStructureUpdateManyWithoutStudentNestedInput
    feeRecords?: StudentFeeUpdateManyWithoutStudentNestedInput
    attendance?: AttendanceRecordUpdateManyWithoutStudentNestedInput
    tests?: StudentTestUpdateManyWithoutStudentNestedInput
    completions?: CourseCompletionUpdateManyWithoutStudentNestedInput
    stationery?: StationeryIssueUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUpdateManyWithoutStudentNestedInput
    financialRecords?: FinancialRecordUpdateManyWithoutStudentNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutStudentsNestedInput
  }

  export type StudentUncheckedUpdateWithoutTasksInput = {
    id?: IntFieldUpdateOperationsInput | number
    serialNumber?: IntFieldUpdateOperationsInput | number
    studentCode?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    fatherName?: StringFieldUpdateOperationsInput | string
    motherName?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: StringFieldUpdateOperationsInput | string
    parentsContact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: NullableStringFieldUpdateOperationsInput | string | null
    permenantAddress?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    idProofType?: NullableStringFieldUpdateOperationsInput | string | null
    idProofNumber?: NullableStringFieldUpdateOperationsInput | string | null
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    clientAdminId?: StringFieldUpdateOperationsInput | string
    enquiry?: EnquiryUncheckedUpdateOneWithoutStudentNestedInput
    labAllocations?: LabAllocationUncheckedUpdateManyWithoutStudentNestedInput
    studentCourses?: StudentCourseUncheckedUpdateManyWithoutStudentNestedInput
    feeStructures?: FeeStructureUncheckedUpdateManyWithoutStudentNestedInput
    feeRecords?: StudentFeeUncheckedUpdateManyWithoutStudentNestedInput
    attendance?: AttendanceRecordUncheckedUpdateManyWithoutStudentNestedInput
    tests?: StudentTestUncheckedUpdateManyWithoutStudentNestedInput
    completions?: CourseCompletionUncheckedUpdateManyWithoutStudentNestedInput
    stationery?: StationeryIssueUncheckedUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutStudentNestedInput
    financialRecords?: FinancialRecordUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type CourseUpsertWithoutStudentTasksInput = {
    update: XOR<CourseUpdateWithoutStudentTasksInput, CourseUncheckedUpdateWithoutStudentTasksInput>
    create: XOR<CourseCreateWithoutStudentTasksInput, CourseUncheckedCreateWithoutStudentTasksInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutStudentTasksInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutStudentTasksInput, CourseUncheckedUpdateWithoutStudentTasksInput>
  }

  export type CourseUpdateWithoutStudentTasksInput = {
    name?: StringFieldUpdateOperationsInput | string
    durationWeeks?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    courseFeeStructure?: CourseFeeStructureUpdateOneWithoutCourseNestedInput
    studentCourses?: StudentCourseUpdateManyWithoutCourseNestedInput
    enquiryCourse?: EnquiryCourseUpdateManyWithoutCourseNestedInput
    feeStructures?: FeeStructureUpdateManyWithoutCourseNestedInput
    stationery?: StationeryIssueUpdateManyWithoutCourseNestedInput
    studentFees?: StudentFeeUpdateManyWithoutCourseNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutCourseNestedInput
    studentTests?: StudentTestUpdateManyWithoutCourseNestedInput
    certificates?: CertificateUpdateManyWithoutCourseNestedInput
    financialRecords?: FinancialRecordUpdateManyWithoutCourseNestedInput
    batchCourses?: BatchCourseUpdateManyWithoutCourseNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutCoursesNestedInput
  }

  export type CourseUncheckedUpdateWithoutStudentTasksInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    durationWeeks?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    clientAdminId?: StringFieldUpdateOperationsInput | string
    courseFeeStructure?: CourseFeeStructureUncheckedUpdateOneWithoutCourseNestedInput
    studentCourses?: StudentCourseUncheckedUpdateManyWithoutCourseNestedInput
    enquiryCourse?: EnquiryCourseUncheckedUpdateManyWithoutCourseNestedInput
    feeStructures?: FeeStructureUncheckedUpdateManyWithoutCourseNestedInput
    stationery?: StationeryIssueUncheckedUpdateManyWithoutCourseNestedInput
    studentFees?: StudentFeeUncheckedUpdateManyWithoutCourseNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutCourseNestedInput
    studentTests?: StudentTestUncheckedUpdateManyWithoutCourseNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutCourseNestedInput
    financialRecords?: FinancialRecordUncheckedUpdateManyWithoutCourseNestedInput
    batchCourses?: BatchCourseUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type FacultyUpsertWithoutTasksInput = {
    update: XOR<FacultyUpdateWithoutTasksInput, FacultyUncheckedUpdateWithoutTasksInput>
    create: XOR<FacultyCreateWithoutTasksInput, FacultyUncheckedCreateWithoutTasksInput>
    where?: FacultyWhereInput
  }

  export type FacultyUpdateToOneWithWhereWithoutTasksInput = {
    where?: FacultyWhereInput
    data: XOR<FacultyUpdateWithoutTasksInput, FacultyUncheckedUpdateWithoutTasksInput>
  }

  export type FacultyUpdateWithoutTasksInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    joiningDate?: DateTimeFieldUpdateOperationsInput | Date | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    currentSessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    batches?: BatchUpdateManyWithoutFacultyNestedInput
    attendance?: AttendanceRecordUpdateManyWithoutMarkedByNestedInput
    financialRecords?: FinancialRecordUpdateManyWithoutFacultyNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutFacultiesNestedInput
  }

  export type FacultyUncheckedUpdateWithoutTasksInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    joiningDate?: DateTimeFieldUpdateOperationsInput | Date | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    currentSessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clientAdminId?: StringFieldUpdateOperationsInput | string
    batches?: BatchUncheckedUpdateManyWithoutFacultyNestedInput
    attendance?: AttendanceRecordUncheckedUpdateManyWithoutMarkedByNestedInput
    financialRecords?: FinancialRecordUncheckedUpdateManyWithoutFacultyNestedInput
  }

  export type ClientAdminUpsertWithoutStudentTasksInput = {
    update: XOR<ClientAdminUpdateWithoutStudentTasksInput, ClientAdminUncheckedUpdateWithoutStudentTasksInput>
    create: XOR<ClientAdminCreateWithoutStudentTasksInput, ClientAdminUncheckedCreateWithoutStudentTasksInput>
    where?: ClientAdminWhereInput
  }

  export type ClientAdminUpdateToOneWithWhereWithoutStudentTasksInput = {
    where?: ClientAdminWhereInput
    data: XOR<ClientAdminUpdateWithoutStudentTasksInput, ClientAdminUncheckedUpdateWithoutStudentTasksInput>
  }

  export type ClientAdminUpdateWithoutStudentTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    instituteName?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    fullAddress?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    certificateName?: NullableStringFieldUpdateOperationsInput | string | null
    stamp?: NullableStringFieldUpdateOperationsInput | string | null
    sign?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    currentSessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleUsers?: RoleUserUpdateManyWithoutClientAdminNestedInput
    faculties?: FacultyUpdateManyWithoutClientAdminNestedInput
    batches?: BatchUpdateManyWithoutClientAdminNestedInput
    courses?: CourseUpdateManyWithoutClientAdminNestedInput
    enquiryCourse?: EnquiryCourseUpdateManyWithoutClientAdminNestedInput
    labs?: LabUpdateManyWithoutClientAdminNestedInput
    labTimeSlots?: LabTimeSlotUpdateManyWithoutClientAdminNestedInput
    labAllocations?: LabAllocationUpdateManyWithoutClientAdminNestedInput
    students?: StudentUpdateManyWithoutClientAdminNestedInput
    activities?: ActivityLogUpdateManyWithoutClientAdminNestedInput
    studentCourses?: StudentCourseUpdateManyWithoutClientAdminNestedInput
    feeStructures?: FeeStructureUpdateManyWithoutClientAdminNestedInput
    studentFees?: StudentFeeUpdateManyWithoutClientAdminNestedInput
    stationeryIssues?: StationeryIssueUpdateManyWithoutClientAdminNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutClientAdminNestedInput
    studentTests?: StudentTestUpdateManyWithoutClientAdminNestedInput
    courseCompletions?: CourseCompletionUpdateManyWithoutClientAdminNestedInput
    certificates?: CertificateUpdateManyWithoutClientAdminNestedInput
    financialRecords?: FinancialRecordUpdateManyWithoutClientAdminNestedInput
    enquiries?: EnquiryUpdateManyWithoutClientAdminNestedInput
    notifications?: NotificationUpdateManyWithoutClientAdminNestedInput
    courseFeeStructures?: CourseFeeStructureUpdateManyWithoutClientAdminNestedInput
  }

  export type ClientAdminUncheckedUpdateWithoutStudentTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    instituteName?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    fullAddress?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    certificateName?: NullableStringFieldUpdateOperationsInput | string | null
    stamp?: NullableStringFieldUpdateOperationsInput | string | null
    sign?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    currentSessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleUsers?: RoleUserUncheckedUpdateManyWithoutClientAdminNestedInput
    faculties?: FacultyUncheckedUpdateManyWithoutClientAdminNestedInput
    batches?: BatchUncheckedUpdateManyWithoutClientAdminNestedInput
    courses?: CourseUncheckedUpdateManyWithoutClientAdminNestedInput
    enquiryCourse?: EnquiryCourseUncheckedUpdateManyWithoutClientAdminNestedInput
    labs?: LabUncheckedUpdateManyWithoutClientAdminNestedInput
    labTimeSlots?: LabTimeSlotUncheckedUpdateManyWithoutClientAdminNestedInput
    labAllocations?: LabAllocationUncheckedUpdateManyWithoutClientAdminNestedInput
    students?: StudentUncheckedUpdateManyWithoutClientAdminNestedInput
    activities?: ActivityLogUncheckedUpdateManyWithoutClientAdminNestedInput
    studentCourses?: StudentCourseUncheckedUpdateManyWithoutClientAdminNestedInput
    feeStructures?: FeeStructureUncheckedUpdateManyWithoutClientAdminNestedInput
    studentFees?: StudentFeeUncheckedUpdateManyWithoutClientAdminNestedInput
    stationeryIssues?: StationeryIssueUncheckedUpdateManyWithoutClientAdminNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutClientAdminNestedInput
    studentTests?: StudentTestUncheckedUpdateManyWithoutClientAdminNestedInput
    courseCompletions?: CourseCompletionUncheckedUpdateManyWithoutClientAdminNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutClientAdminNestedInput
    financialRecords?: FinancialRecordUncheckedUpdateManyWithoutClientAdminNestedInput
    enquiries?: EnquiryUncheckedUpdateManyWithoutClientAdminNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutClientAdminNestedInput
    courseFeeStructures?: CourseFeeStructureUncheckedUpdateManyWithoutClientAdminNestedInput
  }

  export type StudentCreateWithoutTestsInput = {
    serialNumber: number
    studentCode: string
    fullName: string
    fatherName: string
    motherName: string
    photoUrl?: string | null
    contact: string
    parentsContact: string
    email?: string | null
    residentialAddress?: string | null
    permenantAddress?: string | null
    dob: string
    gender: string
    religion?: string | null
    idProofType?: string | null
    idProofNumber?: string | null
    admissionDate: Date | string
    enquiry?: EnquiryCreateNestedOneWithoutStudentInput
    labAllocations?: LabAllocationCreateNestedManyWithoutStudentInput
    studentCourses?: StudentCourseCreateNestedManyWithoutStudentInput
    feeStructures?: FeeStructureCreateNestedManyWithoutStudentInput
    feeRecords?: StudentFeeCreateNestedManyWithoutStudentInput
    attendance?: AttendanceRecordCreateNestedManyWithoutStudentInput
    tasks?: StudentTaskCreateNestedManyWithoutStudentInput
    completions?: CourseCompletionCreateNestedManyWithoutStudentInput
    stationery?: StationeryIssueCreateNestedManyWithoutStudentInput
    certificates?: CertificateCreateNestedManyWithoutStudentInput
    financialRecords?: FinancialRecordCreateNestedManyWithoutStudentInput
    clientAdmin: ClientAdminCreateNestedOneWithoutStudentsInput
  }

  export type StudentUncheckedCreateWithoutTestsInput = {
    id?: number
    serialNumber: number
    studentCode: string
    fullName: string
    fatherName: string
    motherName: string
    photoUrl?: string | null
    contact: string
    parentsContact: string
    email?: string | null
    residentialAddress?: string | null
    permenantAddress?: string | null
    dob: string
    gender: string
    religion?: string | null
    idProofType?: string | null
    idProofNumber?: string | null
    admissionDate: Date | string
    clientAdminId: string
    enquiry?: EnquiryUncheckedCreateNestedOneWithoutStudentInput
    labAllocations?: LabAllocationUncheckedCreateNestedManyWithoutStudentInput
    studentCourses?: StudentCourseUncheckedCreateNestedManyWithoutStudentInput
    feeStructures?: FeeStructureUncheckedCreateNestedManyWithoutStudentInput
    feeRecords?: StudentFeeUncheckedCreateNestedManyWithoutStudentInput
    attendance?: AttendanceRecordUncheckedCreateNestedManyWithoutStudentInput
    tasks?: StudentTaskUncheckedCreateNestedManyWithoutStudentInput
    completions?: CourseCompletionUncheckedCreateNestedManyWithoutStudentInput
    stationery?: StationeryIssueUncheckedCreateNestedManyWithoutStudentInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutStudentInput
    financialRecords?: FinancialRecordUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutTestsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutTestsInput, StudentUncheckedCreateWithoutTestsInput>
  }

  export type CourseCreateWithoutStudentTestsInput = {
    name: string
    durationWeeks: number
    description?: string | null
    courseFeeStructure?: CourseFeeStructureCreateNestedOneWithoutCourseInput
    studentCourses?: StudentCourseCreateNestedManyWithoutCourseInput
    enquiryCourse?: EnquiryCourseCreateNestedManyWithoutCourseInput
    feeStructures?: FeeStructureCreateNestedManyWithoutCourseInput
    stationery?: StationeryIssueCreateNestedManyWithoutCourseInput
    studentFees?: StudentFeeCreateNestedManyWithoutCourseInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutCourseInput
    studentTasks?: StudentTaskCreateNestedManyWithoutCourseInput
    certificates?: CertificateCreateNestedManyWithoutCourseInput
    financialRecords?: FinancialRecordCreateNestedManyWithoutCourseInput
    batchCourses?: BatchCourseCreateNestedManyWithoutCourseInput
    clientAdmin: ClientAdminCreateNestedOneWithoutCoursesInput
  }

  export type CourseUncheckedCreateWithoutStudentTestsInput = {
    id?: number
    name: string
    durationWeeks: number
    description?: string | null
    clientAdminId: string
    courseFeeStructure?: CourseFeeStructureUncheckedCreateNestedOneWithoutCourseInput
    studentCourses?: StudentCourseUncheckedCreateNestedManyWithoutCourseInput
    enquiryCourse?: EnquiryCourseUncheckedCreateNestedManyWithoutCourseInput
    feeStructures?: FeeStructureUncheckedCreateNestedManyWithoutCourseInput
    stationery?: StationeryIssueUncheckedCreateNestedManyWithoutCourseInput
    studentFees?: StudentFeeUncheckedCreateNestedManyWithoutCourseInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutCourseInput
    studentTasks?: StudentTaskUncheckedCreateNestedManyWithoutCourseInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutCourseInput
    financialRecords?: FinancialRecordUncheckedCreateNestedManyWithoutCourseInput
    batchCourses?: BatchCourseUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutStudentTestsInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutStudentTestsInput, CourseUncheckedCreateWithoutStudentTestsInput>
  }

  export type ClientAdminCreateWithoutStudentTestsInput = {
    id?: string
    name: string
    email: string
    password: string
    instituteName: string
    slug: string
    fullAddress: string
    logo?: string | null
    certificateName?: string | null
    stamp?: string | null
    sign?: string | null
    contact: string
    position: string
    country: string
    state: string
    city: string
    zipCode: string
    createdAt?: Date | string
    role?: $Enums.UserRole
    currentSessionToken?: string | null
    lastLoginAt?: Date | string | null
    roleUsers?: RoleUserCreateNestedManyWithoutClientAdminInput
    faculties?: FacultyCreateNestedManyWithoutClientAdminInput
    batches?: BatchCreateNestedManyWithoutClientAdminInput
    courses?: CourseCreateNestedManyWithoutClientAdminInput
    enquiryCourse?: EnquiryCourseCreateNestedManyWithoutClientAdminInput
    labs?: LabCreateNestedManyWithoutClientAdminInput
    labTimeSlots?: LabTimeSlotCreateNestedManyWithoutClientAdminInput
    labAllocations?: LabAllocationCreateNestedManyWithoutClientAdminInput
    students?: StudentCreateNestedManyWithoutClientAdminInput
    activities?: ActivityLogCreateNestedManyWithoutClientAdminInput
    studentCourses?: StudentCourseCreateNestedManyWithoutClientAdminInput
    feeStructures?: FeeStructureCreateNestedManyWithoutClientAdminInput
    studentFees?: StudentFeeCreateNestedManyWithoutClientAdminInput
    stationeryIssues?: StationeryIssueCreateNestedManyWithoutClientAdminInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutClientAdminInput
    studentTasks?: StudentTaskCreateNestedManyWithoutClientAdminInput
    courseCompletions?: CourseCompletionCreateNestedManyWithoutClientAdminInput
    certificates?: CertificateCreateNestedManyWithoutClientAdminInput
    financialRecords?: FinancialRecordCreateNestedManyWithoutClientAdminInput
    enquiries?: EnquiryCreateNestedManyWithoutClientAdminInput
    notifications?: NotificationCreateNestedManyWithoutClientAdminInput
    courseFeeStructures?: CourseFeeStructureCreateNestedManyWithoutClientAdminInput
  }

  export type ClientAdminUncheckedCreateWithoutStudentTestsInput = {
    id?: string
    name: string
    email: string
    password: string
    instituteName: string
    slug: string
    fullAddress: string
    logo?: string | null
    certificateName?: string | null
    stamp?: string | null
    sign?: string | null
    contact: string
    position: string
    country: string
    state: string
    city: string
    zipCode: string
    createdAt?: Date | string
    role?: $Enums.UserRole
    currentSessionToken?: string | null
    lastLoginAt?: Date | string | null
    roleUsers?: RoleUserUncheckedCreateNestedManyWithoutClientAdminInput
    faculties?: FacultyUncheckedCreateNestedManyWithoutClientAdminInput
    batches?: BatchUncheckedCreateNestedManyWithoutClientAdminInput
    courses?: CourseUncheckedCreateNestedManyWithoutClientAdminInput
    enquiryCourse?: EnquiryCourseUncheckedCreateNestedManyWithoutClientAdminInput
    labs?: LabUncheckedCreateNestedManyWithoutClientAdminInput
    labTimeSlots?: LabTimeSlotUncheckedCreateNestedManyWithoutClientAdminInput
    labAllocations?: LabAllocationUncheckedCreateNestedManyWithoutClientAdminInput
    students?: StudentUncheckedCreateNestedManyWithoutClientAdminInput
    activities?: ActivityLogUncheckedCreateNestedManyWithoutClientAdminInput
    studentCourses?: StudentCourseUncheckedCreateNestedManyWithoutClientAdminInput
    feeStructures?: FeeStructureUncheckedCreateNestedManyWithoutClientAdminInput
    studentFees?: StudentFeeUncheckedCreateNestedManyWithoutClientAdminInput
    stationeryIssues?: StationeryIssueUncheckedCreateNestedManyWithoutClientAdminInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutClientAdminInput
    studentTasks?: StudentTaskUncheckedCreateNestedManyWithoutClientAdminInput
    courseCompletions?: CourseCompletionUncheckedCreateNestedManyWithoutClientAdminInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutClientAdminInput
    financialRecords?: FinancialRecordUncheckedCreateNestedManyWithoutClientAdminInput
    enquiries?: EnquiryUncheckedCreateNestedManyWithoutClientAdminInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutClientAdminInput
    courseFeeStructures?: CourseFeeStructureUncheckedCreateNestedManyWithoutClientAdminInput
  }

  export type ClientAdminCreateOrConnectWithoutStudentTestsInput = {
    where: ClientAdminWhereUniqueInput
    create: XOR<ClientAdminCreateWithoutStudentTestsInput, ClientAdminUncheckedCreateWithoutStudentTestsInput>
  }

  export type StudentUpsertWithoutTestsInput = {
    update: XOR<StudentUpdateWithoutTestsInput, StudentUncheckedUpdateWithoutTestsInput>
    create: XOR<StudentCreateWithoutTestsInput, StudentUncheckedCreateWithoutTestsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutTestsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutTestsInput, StudentUncheckedUpdateWithoutTestsInput>
  }

  export type StudentUpdateWithoutTestsInput = {
    serialNumber?: IntFieldUpdateOperationsInput | number
    studentCode?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    fatherName?: StringFieldUpdateOperationsInput | string
    motherName?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: StringFieldUpdateOperationsInput | string
    parentsContact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: NullableStringFieldUpdateOperationsInput | string | null
    permenantAddress?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    idProofType?: NullableStringFieldUpdateOperationsInput | string | null
    idProofNumber?: NullableStringFieldUpdateOperationsInput | string | null
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    enquiry?: EnquiryUpdateOneWithoutStudentNestedInput
    labAllocations?: LabAllocationUpdateManyWithoutStudentNestedInput
    studentCourses?: StudentCourseUpdateManyWithoutStudentNestedInput
    feeStructures?: FeeStructureUpdateManyWithoutStudentNestedInput
    feeRecords?: StudentFeeUpdateManyWithoutStudentNestedInput
    attendance?: AttendanceRecordUpdateManyWithoutStudentNestedInput
    tasks?: StudentTaskUpdateManyWithoutStudentNestedInput
    completions?: CourseCompletionUpdateManyWithoutStudentNestedInput
    stationery?: StationeryIssueUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUpdateManyWithoutStudentNestedInput
    financialRecords?: FinancialRecordUpdateManyWithoutStudentNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutStudentsNestedInput
  }

  export type StudentUncheckedUpdateWithoutTestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    serialNumber?: IntFieldUpdateOperationsInput | number
    studentCode?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    fatherName?: StringFieldUpdateOperationsInput | string
    motherName?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: StringFieldUpdateOperationsInput | string
    parentsContact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: NullableStringFieldUpdateOperationsInput | string | null
    permenantAddress?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    idProofType?: NullableStringFieldUpdateOperationsInput | string | null
    idProofNumber?: NullableStringFieldUpdateOperationsInput | string | null
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    clientAdminId?: StringFieldUpdateOperationsInput | string
    enquiry?: EnquiryUncheckedUpdateOneWithoutStudentNestedInput
    labAllocations?: LabAllocationUncheckedUpdateManyWithoutStudentNestedInput
    studentCourses?: StudentCourseUncheckedUpdateManyWithoutStudentNestedInput
    feeStructures?: FeeStructureUncheckedUpdateManyWithoutStudentNestedInput
    feeRecords?: StudentFeeUncheckedUpdateManyWithoutStudentNestedInput
    attendance?: AttendanceRecordUncheckedUpdateManyWithoutStudentNestedInput
    tasks?: StudentTaskUncheckedUpdateManyWithoutStudentNestedInput
    completions?: CourseCompletionUncheckedUpdateManyWithoutStudentNestedInput
    stationery?: StationeryIssueUncheckedUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutStudentNestedInput
    financialRecords?: FinancialRecordUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type CourseUpsertWithoutStudentTestsInput = {
    update: XOR<CourseUpdateWithoutStudentTestsInput, CourseUncheckedUpdateWithoutStudentTestsInput>
    create: XOR<CourseCreateWithoutStudentTestsInput, CourseUncheckedCreateWithoutStudentTestsInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutStudentTestsInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutStudentTestsInput, CourseUncheckedUpdateWithoutStudentTestsInput>
  }

  export type CourseUpdateWithoutStudentTestsInput = {
    name?: StringFieldUpdateOperationsInput | string
    durationWeeks?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    courseFeeStructure?: CourseFeeStructureUpdateOneWithoutCourseNestedInput
    studentCourses?: StudentCourseUpdateManyWithoutCourseNestedInput
    enquiryCourse?: EnquiryCourseUpdateManyWithoutCourseNestedInput
    feeStructures?: FeeStructureUpdateManyWithoutCourseNestedInput
    stationery?: StationeryIssueUpdateManyWithoutCourseNestedInput
    studentFees?: StudentFeeUpdateManyWithoutCourseNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutCourseNestedInput
    studentTasks?: StudentTaskUpdateManyWithoutCourseNestedInput
    certificates?: CertificateUpdateManyWithoutCourseNestedInput
    financialRecords?: FinancialRecordUpdateManyWithoutCourseNestedInput
    batchCourses?: BatchCourseUpdateManyWithoutCourseNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutCoursesNestedInput
  }

  export type CourseUncheckedUpdateWithoutStudentTestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    durationWeeks?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    clientAdminId?: StringFieldUpdateOperationsInput | string
    courseFeeStructure?: CourseFeeStructureUncheckedUpdateOneWithoutCourseNestedInput
    studentCourses?: StudentCourseUncheckedUpdateManyWithoutCourseNestedInput
    enquiryCourse?: EnquiryCourseUncheckedUpdateManyWithoutCourseNestedInput
    feeStructures?: FeeStructureUncheckedUpdateManyWithoutCourseNestedInput
    stationery?: StationeryIssueUncheckedUpdateManyWithoutCourseNestedInput
    studentFees?: StudentFeeUncheckedUpdateManyWithoutCourseNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutCourseNestedInput
    studentTasks?: StudentTaskUncheckedUpdateManyWithoutCourseNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutCourseNestedInput
    financialRecords?: FinancialRecordUncheckedUpdateManyWithoutCourseNestedInput
    batchCourses?: BatchCourseUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type ClientAdminUpsertWithoutStudentTestsInput = {
    update: XOR<ClientAdminUpdateWithoutStudentTestsInput, ClientAdminUncheckedUpdateWithoutStudentTestsInput>
    create: XOR<ClientAdminCreateWithoutStudentTestsInput, ClientAdminUncheckedCreateWithoutStudentTestsInput>
    where?: ClientAdminWhereInput
  }

  export type ClientAdminUpdateToOneWithWhereWithoutStudentTestsInput = {
    where?: ClientAdminWhereInput
    data: XOR<ClientAdminUpdateWithoutStudentTestsInput, ClientAdminUncheckedUpdateWithoutStudentTestsInput>
  }

  export type ClientAdminUpdateWithoutStudentTestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    instituteName?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    fullAddress?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    certificateName?: NullableStringFieldUpdateOperationsInput | string | null
    stamp?: NullableStringFieldUpdateOperationsInput | string | null
    sign?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    currentSessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleUsers?: RoleUserUpdateManyWithoutClientAdminNestedInput
    faculties?: FacultyUpdateManyWithoutClientAdminNestedInput
    batches?: BatchUpdateManyWithoutClientAdminNestedInput
    courses?: CourseUpdateManyWithoutClientAdminNestedInput
    enquiryCourse?: EnquiryCourseUpdateManyWithoutClientAdminNestedInput
    labs?: LabUpdateManyWithoutClientAdminNestedInput
    labTimeSlots?: LabTimeSlotUpdateManyWithoutClientAdminNestedInput
    labAllocations?: LabAllocationUpdateManyWithoutClientAdminNestedInput
    students?: StudentUpdateManyWithoutClientAdminNestedInput
    activities?: ActivityLogUpdateManyWithoutClientAdminNestedInput
    studentCourses?: StudentCourseUpdateManyWithoutClientAdminNestedInput
    feeStructures?: FeeStructureUpdateManyWithoutClientAdminNestedInput
    studentFees?: StudentFeeUpdateManyWithoutClientAdminNestedInput
    stationeryIssues?: StationeryIssueUpdateManyWithoutClientAdminNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutClientAdminNestedInput
    studentTasks?: StudentTaskUpdateManyWithoutClientAdminNestedInput
    courseCompletions?: CourseCompletionUpdateManyWithoutClientAdminNestedInput
    certificates?: CertificateUpdateManyWithoutClientAdminNestedInput
    financialRecords?: FinancialRecordUpdateManyWithoutClientAdminNestedInput
    enquiries?: EnquiryUpdateManyWithoutClientAdminNestedInput
    notifications?: NotificationUpdateManyWithoutClientAdminNestedInput
    courseFeeStructures?: CourseFeeStructureUpdateManyWithoutClientAdminNestedInput
  }

  export type ClientAdminUncheckedUpdateWithoutStudentTestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    instituteName?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    fullAddress?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    certificateName?: NullableStringFieldUpdateOperationsInput | string | null
    stamp?: NullableStringFieldUpdateOperationsInput | string | null
    sign?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    currentSessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleUsers?: RoleUserUncheckedUpdateManyWithoutClientAdminNestedInput
    faculties?: FacultyUncheckedUpdateManyWithoutClientAdminNestedInput
    batches?: BatchUncheckedUpdateManyWithoutClientAdminNestedInput
    courses?: CourseUncheckedUpdateManyWithoutClientAdminNestedInput
    enquiryCourse?: EnquiryCourseUncheckedUpdateManyWithoutClientAdminNestedInput
    labs?: LabUncheckedUpdateManyWithoutClientAdminNestedInput
    labTimeSlots?: LabTimeSlotUncheckedUpdateManyWithoutClientAdminNestedInput
    labAllocations?: LabAllocationUncheckedUpdateManyWithoutClientAdminNestedInput
    students?: StudentUncheckedUpdateManyWithoutClientAdminNestedInput
    activities?: ActivityLogUncheckedUpdateManyWithoutClientAdminNestedInput
    studentCourses?: StudentCourseUncheckedUpdateManyWithoutClientAdminNestedInput
    feeStructures?: FeeStructureUncheckedUpdateManyWithoutClientAdminNestedInput
    studentFees?: StudentFeeUncheckedUpdateManyWithoutClientAdminNestedInput
    stationeryIssues?: StationeryIssueUncheckedUpdateManyWithoutClientAdminNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutClientAdminNestedInput
    studentTasks?: StudentTaskUncheckedUpdateManyWithoutClientAdminNestedInput
    courseCompletions?: CourseCompletionUncheckedUpdateManyWithoutClientAdminNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutClientAdminNestedInput
    financialRecords?: FinancialRecordUncheckedUpdateManyWithoutClientAdminNestedInput
    enquiries?: EnquiryUncheckedUpdateManyWithoutClientAdminNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutClientAdminNestedInput
    courseFeeStructures?: CourseFeeStructureUncheckedUpdateManyWithoutClientAdminNestedInput
  }

  export type StudentCourseCreateWithoutCompletionsInput = {
    startDate: Date | string
    endDate: Date | string
    studentCode: string
    internalNotes?: string | null
    status: string
    student: StudentCreateNestedOneWithoutStudentCoursesInput
    course: CourseCreateNestedOneWithoutStudentCoursesInput
    batch?: BatchCreateNestedOneWithoutStudentCoursesInput
    certificate?: CertificateCreateNestedOneWithoutStudentCourseInput
    clientAdmin: ClientAdminCreateNestedOneWithoutStudentCoursesInput
  }

  export type StudentCourseUncheckedCreateWithoutCompletionsInput = {
    id?: number
    studentId: number
    courseId: number
    startDate: Date | string
    endDate: Date | string
    studentCode: string
    batchId?: number | null
    internalNotes?: string | null
    status: string
    clientAdminId: string
    certificate?: CertificateUncheckedCreateNestedOneWithoutStudentCourseInput
  }

  export type StudentCourseCreateOrConnectWithoutCompletionsInput = {
    where: StudentCourseWhereUniqueInput
    create: XOR<StudentCourseCreateWithoutCompletionsInput, StudentCourseUncheckedCreateWithoutCompletionsInput>
  }

  export type StudentCreateWithoutCompletionsInput = {
    serialNumber: number
    studentCode: string
    fullName: string
    fatherName: string
    motherName: string
    photoUrl?: string | null
    contact: string
    parentsContact: string
    email?: string | null
    residentialAddress?: string | null
    permenantAddress?: string | null
    dob: string
    gender: string
    religion?: string | null
    idProofType?: string | null
    idProofNumber?: string | null
    admissionDate: Date | string
    enquiry?: EnquiryCreateNestedOneWithoutStudentInput
    labAllocations?: LabAllocationCreateNestedManyWithoutStudentInput
    studentCourses?: StudentCourseCreateNestedManyWithoutStudentInput
    feeStructures?: FeeStructureCreateNestedManyWithoutStudentInput
    feeRecords?: StudentFeeCreateNestedManyWithoutStudentInput
    attendance?: AttendanceRecordCreateNestedManyWithoutStudentInput
    tasks?: StudentTaskCreateNestedManyWithoutStudentInput
    tests?: StudentTestCreateNestedManyWithoutStudentInput
    stationery?: StationeryIssueCreateNestedManyWithoutStudentInput
    certificates?: CertificateCreateNestedManyWithoutStudentInput
    financialRecords?: FinancialRecordCreateNestedManyWithoutStudentInput
    clientAdmin: ClientAdminCreateNestedOneWithoutStudentsInput
  }

  export type StudentUncheckedCreateWithoutCompletionsInput = {
    id?: number
    serialNumber: number
    studentCode: string
    fullName: string
    fatherName: string
    motherName: string
    photoUrl?: string | null
    contact: string
    parentsContact: string
    email?: string | null
    residentialAddress?: string | null
    permenantAddress?: string | null
    dob: string
    gender: string
    religion?: string | null
    idProofType?: string | null
    idProofNumber?: string | null
    admissionDate: Date | string
    clientAdminId: string
    enquiry?: EnquiryUncheckedCreateNestedOneWithoutStudentInput
    labAllocations?: LabAllocationUncheckedCreateNestedManyWithoutStudentInput
    studentCourses?: StudentCourseUncheckedCreateNestedManyWithoutStudentInput
    feeStructures?: FeeStructureUncheckedCreateNestedManyWithoutStudentInput
    feeRecords?: StudentFeeUncheckedCreateNestedManyWithoutStudentInput
    attendance?: AttendanceRecordUncheckedCreateNestedManyWithoutStudentInput
    tasks?: StudentTaskUncheckedCreateNestedManyWithoutStudentInput
    tests?: StudentTestUncheckedCreateNestedManyWithoutStudentInput
    stationery?: StationeryIssueUncheckedCreateNestedManyWithoutStudentInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutStudentInput
    financialRecords?: FinancialRecordUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutCompletionsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutCompletionsInput, StudentUncheckedCreateWithoutCompletionsInput>
  }

  export type ClientAdminCreateWithoutCourseCompletionsInput = {
    id?: string
    name: string
    email: string
    password: string
    instituteName: string
    slug: string
    fullAddress: string
    logo?: string | null
    certificateName?: string | null
    stamp?: string | null
    sign?: string | null
    contact: string
    position: string
    country: string
    state: string
    city: string
    zipCode: string
    createdAt?: Date | string
    role?: $Enums.UserRole
    currentSessionToken?: string | null
    lastLoginAt?: Date | string | null
    roleUsers?: RoleUserCreateNestedManyWithoutClientAdminInput
    faculties?: FacultyCreateNestedManyWithoutClientAdminInput
    batches?: BatchCreateNestedManyWithoutClientAdminInput
    courses?: CourseCreateNestedManyWithoutClientAdminInput
    enquiryCourse?: EnquiryCourseCreateNestedManyWithoutClientAdminInput
    labs?: LabCreateNestedManyWithoutClientAdminInput
    labTimeSlots?: LabTimeSlotCreateNestedManyWithoutClientAdminInput
    labAllocations?: LabAllocationCreateNestedManyWithoutClientAdminInput
    students?: StudentCreateNestedManyWithoutClientAdminInput
    activities?: ActivityLogCreateNestedManyWithoutClientAdminInput
    studentCourses?: StudentCourseCreateNestedManyWithoutClientAdminInput
    feeStructures?: FeeStructureCreateNestedManyWithoutClientAdminInput
    studentFees?: StudentFeeCreateNestedManyWithoutClientAdminInput
    stationeryIssues?: StationeryIssueCreateNestedManyWithoutClientAdminInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutClientAdminInput
    studentTasks?: StudentTaskCreateNestedManyWithoutClientAdminInput
    studentTests?: StudentTestCreateNestedManyWithoutClientAdminInput
    certificates?: CertificateCreateNestedManyWithoutClientAdminInput
    financialRecords?: FinancialRecordCreateNestedManyWithoutClientAdminInput
    enquiries?: EnquiryCreateNestedManyWithoutClientAdminInput
    notifications?: NotificationCreateNestedManyWithoutClientAdminInput
    courseFeeStructures?: CourseFeeStructureCreateNestedManyWithoutClientAdminInput
  }

  export type ClientAdminUncheckedCreateWithoutCourseCompletionsInput = {
    id?: string
    name: string
    email: string
    password: string
    instituteName: string
    slug: string
    fullAddress: string
    logo?: string | null
    certificateName?: string | null
    stamp?: string | null
    sign?: string | null
    contact: string
    position: string
    country: string
    state: string
    city: string
    zipCode: string
    createdAt?: Date | string
    role?: $Enums.UserRole
    currentSessionToken?: string | null
    lastLoginAt?: Date | string | null
    roleUsers?: RoleUserUncheckedCreateNestedManyWithoutClientAdminInput
    faculties?: FacultyUncheckedCreateNestedManyWithoutClientAdminInput
    batches?: BatchUncheckedCreateNestedManyWithoutClientAdminInput
    courses?: CourseUncheckedCreateNestedManyWithoutClientAdminInput
    enquiryCourse?: EnquiryCourseUncheckedCreateNestedManyWithoutClientAdminInput
    labs?: LabUncheckedCreateNestedManyWithoutClientAdminInput
    labTimeSlots?: LabTimeSlotUncheckedCreateNestedManyWithoutClientAdminInput
    labAllocations?: LabAllocationUncheckedCreateNestedManyWithoutClientAdminInput
    students?: StudentUncheckedCreateNestedManyWithoutClientAdminInput
    activities?: ActivityLogUncheckedCreateNestedManyWithoutClientAdminInput
    studentCourses?: StudentCourseUncheckedCreateNestedManyWithoutClientAdminInput
    feeStructures?: FeeStructureUncheckedCreateNestedManyWithoutClientAdminInput
    studentFees?: StudentFeeUncheckedCreateNestedManyWithoutClientAdminInput
    stationeryIssues?: StationeryIssueUncheckedCreateNestedManyWithoutClientAdminInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutClientAdminInput
    studentTasks?: StudentTaskUncheckedCreateNestedManyWithoutClientAdminInput
    studentTests?: StudentTestUncheckedCreateNestedManyWithoutClientAdminInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutClientAdminInput
    financialRecords?: FinancialRecordUncheckedCreateNestedManyWithoutClientAdminInput
    enquiries?: EnquiryUncheckedCreateNestedManyWithoutClientAdminInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutClientAdminInput
    courseFeeStructures?: CourseFeeStructureUncheckedCreateNestedManyWithoutClientAdminInput
  }

  export type ClientAdminCreateOrConnectWithoutCourseCompletionsInput = {
    where: ClientAdminWhereUniqueInput
    create: XOR<ClientAdminCreateWithoutCourseCompletionsInput, ClientAdminUncheckedCreateWithoutCourseCompletionsInput>
  }

  export type StudentCourseUpsertWithoutCompletionsInput = {
    update: XOR<StudentCourseUpdateWithoutCompletionsInput, StudentCourseUncheckedUpdateWithoutCompletionsInput>
    create: XOR<StudentCourseCreateWithoutCompletionsInput, StudentCourseUncheckedCreateWithoutCompletionsInput>
    where?: StudentCourseWhereInput
  }

  export type StudentCourseUpdateToOneWithWhereWithoutCompletionsInput = {
    where?: StudentCourseWhereInput
    data: XOR<StudentCourseUpdateWithoutCompletionsInput, StudentCourseUncheckedUpdateWithoutCompletionsInput>
  }

  export type StudentCourseUpdateWithoutCompletionsInput = {
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    studentCode?: StringFieldUpdateOperationsInput | string
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    student?: StudentUpdateOneRequiredWithoutStudentCoursesNestedInput
    course?: CourseUpdateOneRequiredWithoutStudentCoursesNestedInput
    batch?: BatchUpdateOneWithoutStudentCoursesNestedInput
    certificate?: CertificateUpdateOneWithoutStudentCourseNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutStudentCoursesNestedInput
  }

  export type StudentCourseUncheckedUpdateWithoutCompletionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    studentCode?: StringFieldUpdateOperationsInput | string
    batchId?: NullableIntFieldUpdateOperationsInput | number | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    clientAdminId?: StringFieldUpdateOperationsInput | string
    certificate?: CertificateUncheckedUpdateOneWithoutStudentCourseNestedInput
  }

  export type StudentUpsertWithoutCompletionsInput = {
    update: XOR<StudentUpdateWithoutCompletionsInput, StudentUncheckedUpdateWithoutCompletionsInput>
    create: XOR<StudentCreateWithoutCompletionsInput, StudentUncheckedCreateWithoutCompletionsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutCompletionsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutCompletionsInput, StudentUncheckedUpdateWithoutCompletionsInput>
  }

  export type StudentUpdateWithoutCompletionsInput = {
    serialNumber?: IntFieldUpdateOperationsInput | number
    studentCode?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    fatherName?: StringFieldUpdateOperationsInput | string
    motherName?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: StringFieldUpdateOperationsInput | string
    parentsContact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: NullableStringFieldUpdateOperationsInput | string | null
    permenantAddress?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    idProofType?: NullableStringFieldUpdateOperationsInput | string | null
    idProofNumber?: NullableStringFieldUpdateOperationsInput | string | null
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    enquiry?: EnquiryUpdateOneWithoutStudentNestedInput
    labAllocations?: LabAllocationUpdateManyWithoutStudentNestedInput
    studentCourses?: StudentCourseUpdateManyWithoutStudentNestedInput
    feeStructures?: FeeStructureUpdateManyWithoutStudentNestedInput
    feeRecords?: StudentFeeUpdateManyWithoutStudentNestedInput
    attendance?: AttendanceRecordUpdateManyWithoutStudentNestedInput
    tasks?: StudentTaskUpdateManyWithoutStudentNestedInput
    tests?: StudentTestUpdateManyWithoutStudentNestedInput
    stationery?: StationeryIssueUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUpdateManyWithoutStudentNestedInput
    financialRecords?: FinancialRecordUpdateManyWithoutStudentNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutStudentsNestedInput
  }

  export type StudentUncheckedUpdateWithoutCompletionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    serialNumber?: IntFieldUpdateOperationsInput | number
    studentCode?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    fatherName?: StringFieldUpdateOperationsInput | string
    motherName?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: StringFieldUpdateOperationsInput | string
    parentsContact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: NullableStringFieldUpdateOperationsInput | string | null
    permenantAddress?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    idProofType?: NullableStringFieldUpdateOperationsInput | string | null
    idProofNumber?: NullableStringFieldUpdateOperationsInput | string | null
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    clientAdminId?: StringFieldUpdateOperationsInput | string
    enquiry?: EnquiryUncheckedUpdateOneWithoutStudentNestedInput
    labAllocations?: LabAllocationUncheckedUpdateManyWithoutStudentNestedInput
    studentCourses?: StudentCourseUncheckedUpdateManyWithoutStudentNestedInput
    feeStructures?: FeeStructureUncheckedUpdateManyWithoutStudentNestedInput
    feeRecords?: StudentFeeUncheckedUpdateManyWithoutStudentNestedInput
    attendance?: AttendanceRecordUncheckedUpdateManyWithoutStudentNestedInput
    tasks?: StudentTaskUncheckedUpdateManyWithoutStudentNestedInput
    tests?: StudentTestUncheckedUpdateManyWithoutStudentNestedInput
    stationery?: StationeryIssueUncheckedUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutStudentNestedInput
    financialRecords?: FinancialRecordUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type ClientAdminUpsertWithoutCourseCompletionsInput = {
    update: XOR<ClientAdminUpdateWithoutCourseCompletionsInput, ClientAdminUncheckedUpdateWithoutCourseCompletionsInput>
    create: XOR<ClientAdminCreateWithoutCourseCompletionsInput, ClientAdminUncheckedCreateWithoutCourseCompletionsInput>
    where?: ClientAdminWhereInput
  }

  export type ClientAdminUpdateToOneWithWhereWithoutCourseCompletionsInput = {
    where?: ClientAdminWhereInput
    data: XOR<ClientAdminUpdateWithoutCourseCompletionsInput, ClientAdminUncheckedUpdateWithoutCourseCompletionsInput>
  }

  export type ClientAdminUpdateWithoutCourseCompletionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    instituteName?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    fullAddress?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    certificateName?: NullableStringFieldUpdateOperationsInput | string | null
    stamp?: NullableStringFieldUpdateOperationsInput | string | null
    sign?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    currentSessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleUsers?: RoleUserUpdateManyWithoutClientAdminNestedInput
    faculties?: FacultyUpdateManyWithoutClientAdminNestedInput
    batches?: BatchUpdateManyWithoutClientAdminNestedInput
    courses?: CourseUpdateManyWithoutClientAdminNestedInput
    enquiryCourse?: EnquiryCourseUpdateManyWithoutClientAdminNestedInput
    labs?: LabUpdateManyWithoutClientAdminNestedInput
    labTimeSlots?: LabTimeSlotUpdateManyWithoutClientAdminNestedInput
    labAllocations?: LabAllocationUpdateManyWithoutClientAdminNestedInput
    students?: StudentUpdateManyWithoutClientAdminNestedInput
    activities?: ActivityLogUpdateManyWithoutClientAdminNestedInput
    studentCourses?: StudentCourseUpdateManyWithoutClientAdminNestedInput
    feeStructures?: FeeStructureUpdateManyWithoutClientAdminNestedInput
    studentFees?: StudentFeeUpdateManyWithoutClientAdminNestedInput
    stationeryIssues?: StationeryIssueUpdateManyWithoutClientAdminNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutClientAdminNestedInput
    studentTasks?: StudentTaskUpdateManyWithoutClientAdminNestedInput
    studentTests?: StudentTestUpdateManyWithoutClientAdminNestedInput
    certificates?: CertificateUpdateManyWithoutClientAdminNestedInput
    financialRecords?: FinancialRecordUpdateManyWithoutClientAdminNestedInput
    enquiries?: EnquiryUpdateManyWithoutClientAdminNestedInput
    notifications?: NotificationUpdateManyWithoutClientAdminNestedInput
    courseFeeStructures?: CourseFeeStructureUpdateManyWithoutClientAdminNestedInput
  }

  export type ClientAdminUncheckedUpdateWithoutCourseCompletionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    instituteName?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    fullAddress?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    certificateName?: NullableStringFieldUpdateOperationsInput | string | null
    stamp?: NullableStringFieldUpdateOperationsInput | string | null
    sign?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    currentSessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleUsers?: RoleUserUncheckedUpdateManyWithoutClientAdminNestedInput
    faculties?: FacultyUncheckedUpdateManyWithoutClientAdminNestedInput
    batches?: BatchUncheckedUpdateManyWithoutClientAdminNestedInput
    courses?: CourseUncheckedUpdateManyWithoutClientAdminNestedInput
    enquiryCourse?: EnquiryCourseUncheckedUpdateManyWithoutClientAdminNestedInput
    labs?: LabUncheckedUpdateManyWithoutClientAdminNestedInput
    labTimeSlots?: LabTimeSlotUncheckedUpdateManyWithoutClientAdminNestedInput
    labAllocations?: LabAllocationUncheckedUpdateManyWithoutClientAdminNestedInput
    students?: StudentUncheckedUpdateManyWithoutClientAdminNestedInput
    activities?: ActivityLogUncheckedUpdateManyWithoutClientAdminNestedInput
    studentCourses?: StudentCourseUncheckedUpdateManyWithoutClientAdminNestedInput
    feeStructures?: FeeStructureUncheckedUpdateManyWithoutClientAdminNestedInput
    studentFees?: StudentFeeUncheckedUpdateManyWithoutClientAdminNestedInput
    stationeryIssues?: StationeryIssueUncheckedUpdateManyWithoutClientAdminNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutClientAdminNestedInput
    studentTasks?: StudentTaskUncheckedUpdateManyWithoutClientAdminNestedInput
    studentTests?: StudentTestUncheckedUpdateManyWithoutClientAdminNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutClientAdminNestedInput
    financialRecords?: FinancialRecordUncheckedUpdateManyWithoutClientAdminNestedInput
    enquiries?: EnquiryUncheckedUpdateManyWithoutClientAdminNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutClientAdminNestedInput
    courseFeeStructures?: CourseFeeStructureUncheckedUpdateManyWithoutClientAdminNestedInput
  }

  export type StudentCreateWithoutCertificatesInput = {
    serialNumber: number
    studentCode: string
    fullName: string
    fatherName: string
    motherName: string
    photoUrl?: string | null
    contact: string
    parentsContact: string
    email?: string | null
    residentialAddress?: string | null
    permenantAddress?: string | null
    dob: string
    gender: string
    religion?: string | null
    idProofType?: string | null
    idProofNumber?: string | null
    admissionDate: Date | string
    enquiry?: EnquiryCreateNestedOneWithoutStudentInput
    labAllocations?: LabAllocationCreateNestedManyWithoutStudentInput
    studentCourses?: StudentCourseCreateNestedManyWithoutStudentInput
    feeStructures?: FeeStructureCreateNestedManyWithoutStudentInput
    feeRecords?: StudentFeeCreateNestedManyWithoutStudentInput
    attendance?: AttendanceRecordCreateNestedManyWithoutStudentInput
    tasks?: StudentTaskCreateNestedManyWithoutStudentInput
    tests?: StudentTestCreateNestedManyWithoutStudentInput
    completions?: CourseCompletionCreateNestedManyWithoutStudentInput
    stationery?: StationeryIssueCreateNestedManyWithoutStudentInput
    financialRecords?: FinancialRecordCreateNestedManyWithoutStudentInput
    clientAdmin: ClientAdminCreateNestedOneWithoutStudentsInput
  }

  export type StudentUncheckedCreateWithoutCertificatesInput = {
    id?: number
    serialNumber: number
    studentCode: string
    fullName: string
    fatherName: string
    motherName: string
    photoUrl?: string | null
    contact: string
    parentsContact: string
    email?: string | null
    residentialAddress?: string | null
    permenantAddress?: string | null
    dob: string
    gender: string
    religion?: string | null
    idProofType?: string | null
    idProofNumber?: string | null
    admissionDate: Date | string
    clientAdminId: string
    enquiry?: EnquiryUncheckedCreateNestedOneWithoutStudentInput
    labAllocations?: LabAllocationUncheckedCreateNestedManyWithoutStudentInput
    studentCourses?: StudentCourseUncheckedCreateNestedManyWithoutStudentInput
    feeStructures?: FeeStructureUncheckedCreateNestedManyWithoutStudentInput
    feeRecords?: StudentFeeUncheckedCreateNestedManyWithoutStudentInput
    attendance?: AttendanceRecordUncheckedCreateNestedManyWithoutStudentInput
    tasks?: StudentTaskUncheckedCreateNestedManyWithoutStudentInput
    tests?: StudentTestUncheckedCreateNestedManyWithoutStudentInput
    completions?: CourseCompletionUncheckedCreateNestedManyWithoutStudentInput
    stationery?: StationeryIssueUncheckedCreateNestedManyWithoutStudentInput
    financialRecords?: FinancialRecordUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutCertificatesInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutCertificatesInput, StudentUncheckedCreateWithoutCertificatesInput>
  }

  export type CourseCreateWithoutCertificatesInput = {
    name: string
    durationWeeks: number
    description?: string | null
    courseFeeStructure?: CourseFeeStructureCreateNestedOneWithoutCourseInput
    studentCourses?: StudentCourseCreateNestedManyWithoutCourseInput
    enquiryCourse?: EnquiryCourseCreateNestedManyWithoutCourseInput
    feeStructures?: FeeStructureCreateNestedManyWithoutCourseInput
    stationery?: StationeryIssueCreateNestedManyWithoutCourseInput
    studentFees?: StudentFeeCreateNestedManyWithoutCourseInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutCourseInput
    studentTasks?: StudentTaskCreateNestedManyWithoutCourseInput
    studentTests?: StudentTestCreateNestedManyWithoutCourseInput
    financialRecords?: FinancialRecordCreateNestedManyWithoutCourseInput
    batchCourses?: BatchCourseCreateNestedManyWithoutCourseInput
    clientAdmin: ClientAdminCreateNestedOneWithoutCoursesInput
  }

  export type CourseUncheckedCreateWithoutCertificatesInput = {
    id?: number
    name: string
    durationWeeks: number
    description?: string | null
    clientAdminId: string
    courseFeeStructure?: CourseFeeStructureUncheckedCreateNestedOneWithoutCourseInput
    studentCourses?: StudentCourseUncheckedCreateNestedManyWithoutCourseInput
    enquiryCourse?: EnquiryCourseUncheckedCreateNestedManyWithoutCourseInput
    feeStructures?: FeeStructureUncheckedCreateNestedManyWithoutCourseInput
    stationery?: StationeryIssueUncheckedCreateNestedManyWithoutCourseInput
    studentFees?: StudentFeeUncheckedCreateNestedManyWithoutCourseInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutCourseInput
    studentTasks?: StudentTaskUncheckedCreateNestedManyWithoutCourseInput
    studentTests?: StudentTestUncheckedCreateNestedManyWithoutCourseInput
    financialRecords?: FinancialRecordUncheckedCreateNestedManyWithoutCourseInput
    batchCourses?: BatchCourseUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutCertificatesInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutCertificatesInput, CourseUncheckedCreateWithoutCertificatesInput>
  }

  export type StudentCourseCreateWithoutCertificateInput = {
    startDate: Date | string
    endDate: Date | string
    studentCode: string
    internalNotes?: string | null
    status: string
    student: StudentCreateNestedOneWithoutStudentCoursesInput
    course: CourseCreateNestedOneWithoutStudentCoursesInput
    batch?: BatchCreateNestedOneWithoutStudentCoursesInput
    completions?: CourseCompletionCreateNestedManyWithoutStudentCourseInput
    clientAdmin: ClientAdminCreateNestedOneWithoutStudentCoursesInput
  }

  export type StudentCourseUncheckedCreateWithoutCertificateInput = {
    id?: number
    studentId: number
    courseId: number
    startDate: Date | string
    endDate: Date | string
    studentCode: string
    batchId?: number | null
    internalNotes?: string | null
    status: string
    clientAdminId: string
    completions?: CourseCompletionUncheckedCreateNestedManyWithoutStudentCourseInput
  }

  export type StudentCourseCreateOrConnectWithoutCertificateInput = {
    where: StudentCourseWhereUniqueInput
    create: XOR<StudentCourseCreateWithoutCertificateInput, StudentCourseUncheckedCreateWithoutCertificateInput>
  }

  export type ClientAdminCreateWithoutCertificatesInput = {
    id?: string
    name: string
    email: string
    password: string
    instituteName: string
    slug: string
    fullAddress: string
    logo?: string | null
    certificateName?: string | null
    stamp?: string | null
    sign?: string | null
    contact: string
    position: string
    country: string
    state: string
    city: string
    zipCode: string
    createdAt?: Date | string
    role?: $Enums.UserRole
    currentSessionToken?: string | null
    lastLoginAt?: Date | string | null
    roleUsers?: RoleUserCreateNestedManyWithoutClientAdminInput
    faculties?: FacultyCreateNestedManyWithoutClientAdminInput
    batches?: BatchCreateNestedManyWithoutClientAdminInput
    courses?: CourseCreateNestedManyWithoutClientAdminInput
    enquiryCourse?: EnquiryCourseCreateNestedManyWithoutClientAdminInput
    labs?: LabCreateNestedManyWithoutClientAdminInput
    labTimeSlots?: LabTimeSlotCreateNestedManyWithoutClientAdminInput
    labAllocations?: LabAllocationCreateNestedManyWithoutClientAdminInput
    students?: StudentCreateNestedManyWithoutClientAdminInput
    activities?: ActivityLogCreateNestedManyWithoutClientAdminInput
    studentCourses?: StudentCourseCreateNestedManyWithoutClientAdminInput
    feeStructures?: FeeStructureCreateNestedManyWithoutClientAdminInput
    studentFees?: StudentFeeCreateNestedManyWithoutClientAdminInput
    stationeryIssues?: StationeryIssueCreateNestedManyWithoutClientAdminInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutClientAdminInput
    studentTasks?: StudentTaskCreateNestedManyWithoutClientAdminInput
    studentTests?: StudentTestCreateNestedManyWithoutClientAdminInput
    courseCompletions?: CourseCompletionCreateNestedManyWithoutClientAdminInput
    financialRecords?: FinancialRecordCreateNestedManyWithoutClientAdminInput
    enquiries?: EnquiryCreateNestedManyWithoutClientAdminInput
    notifications?: NotificationCreateNestedManyWithoutClientAdminInput
    courseFeeStructures?: CourseFeeStructureCreateNestedManyWithoutClientAdminInput
  }

  export type ClientAdminUncheckedCreateWithoutCertificatesInput = {
    id?: string
    name: string
    email: string
    password: string
    instituteName: string
    slug: string
    fullAddress: string
    logo?: string | null
    certificateName?: string | null
    stamp?: string | null
    sign?: string | null
    contact: string
    position: string
    country: string
    state: string
    city: string
    zipCode: string
    createdAt?: Date | string
    role?: $Enums.UserRole
    currentSessionToken?: string | null
    lastLoginAt?: Date | string | null
    roleUsers?: RoleUserUncheckedCreateNestedManyWithoutClientAdminInput
    faculties?: FacultyUncheckedCreateNestedManyWithoutClientAdminInput
    batches?: BatchUncheckedCreateNestedManyWithoutClientAdminInput
    courses?: CourseUncheckedCreateNestedManyWithoutClientAdminInput
    enquiryCourse?: EnquiryCourseUncheckedCreateNestedManyWithoutClientAdminInput
    labs?: LabUncheckedCreateNestedManyWithoutClientAdminInput
    labTimeSlots?: LabTimeSlotUncheckedCreateNestedManyWithoutClientAdminInput
    labAllocations?: LabAllocationUncheckedCreateNestedManyWithoutClientAdminInput
    students?: StudentUncheckedCreateNestedManyWithoutClientAdminInput
    activities?: ActivityLogUncheckedCreateNestedManyWithoutClientAdminInput
    studentCourses?: StudentCourseUncheckedCreateNestedManyWithoutClientAdminInput
    feeStructures?: FeeStructureUncheckedCreateNestedManyWithoutClientAdminInput
    studentFees?: StudentFeeUncheckedCreateNestedManyWithoutClientAdminInput
    stationeryIssues?: StationeryIssueUncheckedCreateNestedManyWithoutClientAdminInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutClientAdminInput
    studentTasks?: StudentTaskUncheckedCreateNestedManyWithoutClientAdminInput
    studentTests?: StudentTestUncheckedCreateNestedManyWithoutClientAdminInput
    courseCompletions?: CourseCompletionUncheckedCreateNestedManyWithoutClientAdminInput
    financialRecords?: FinancialRecordUncheckedCreateNestedManyWithoutClientAdminInput
    enquiries?: EnquiryUncheckedCreateNestedManyWithoutClientAdminInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutClientAdminInput
    courseFeeStructures?: CourseFeeStructureUncheckedCreateNestedManyWithoutClientAdminInput
  }

  export type ClientAdminCreateOrConnectWithoutCertificatesInput = {
    where: ClientAdminWhereUniqueInput
    create: XOR<ClientAdminCreateWithoutCertificatesInput, ClientAdminUncheckedCreateWithoutCertificatesInput>
  }

  export type StudentUpsertWithoutCertificatesInput = {
    update: XOR<StudentUpdateWithoutCertificatesInput, StudentUncheckedUpdateWithoutCertificatesInput>
    create: XOR<StudentCreateWithoutCertificatesInput, StudentUncheckedCreateWithoutCertificatesInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutCertificatesInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutCertificatesInput, StudentUncheckedUpdateWithoutCertificatesInput>
  }

  export type StudentUpdateWithoutCertificatesInput = {
    serialNumber?: IntFieldUpdateOperationsInput | number
    studentCode?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    fatherName?: StringFieldUpdateOperationsInput | string
    motherName?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: StringFieldUpdateOperationsInput | string
    parentsContact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: NullableStringFieldUpdateOperationsInput | string | null
    permenantAddress?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    idProofType?: NullableStringFieldUpdateOperationsInput | string | null
    idProofNumber?: NullableStringFieldUpdateOperationsInput | string | null
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    enquiry?: EnquiryUpdateOneWithoutStudentNestedInput
    labAllocations?: LabAllocationUpdateManyWithoutStudentNestedInput
    studentCourses?: StudentCourseUpdateManyWithoutStudentNestedInput
    feeStructures?: FeeStructureUpdateManyWithoutStudentNestedInput
    feeRecords?: StudentFeeUpdateManyWithoutStudentNestedInput
    attendance?: AttendanceRecordUpdateManyWithoutStudentNestedInput
    tasks?: StudentTaskUpdateManyWithoutStudentNestedInput
    tests?: StudentTestUpdateManyWithoutStudentNestedInput
    completions?: CourseCompletionUpdateManyWithoutStudentNestedInput
    stationery?: StationeryIssueUpdateManyWithoutStudentNestedInput
    financialRecords?: FinancialRecordUpdateManyWithoutStudentNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutStudentsNestedInput
  }

  export type StudentUncheckedUpdateWithoutCertificatesInput = {
    id?: IntFieldUpdateOperationsInput | number
    serialNumber?: IntFieldUpdateOperationsInput | number
    studentCode?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    fatherName?: StringFieldUpdateOperationsInput | string
    motherName?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: StringFieldUpdateOperationsInput | string
    parentsContact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: NullableStringFieldUpdateOperationsInput | string | null
    permenantAddress?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    idProofType?: NullableStringFieldUpdateOperationsInput | string | null
    idProofNumber?: NullableStringFieldUpdateOperationsInput | string | null
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    clientAdminId?: StringFieldUpdateOperationsInput | string
    enquiry?: EnquiryUncheckedUpdateOneWithoutStudentNestedInput
    labAllocations?: LabAllocationUncheckedUpdateManyWithoutStudentNestedInput
    studentCourses?: StudentCourseUncheckedUpdateManyWithoutStudentNestedInput
    feeStructures?: FeeStructureUncheckedUpdateManyWithoutStudentNestedInput
    feeRecords?: StudentFeeUncheckedUpdateManyWithoutStudentNestedInput
    attendance?: AttendanceRecordUncheckedUpdateManyWithoutStudentNestedInput
    tasks?: StudentTaskUncheckedUpdateManyWithoutStudentNestedInput
    tests?: StudentTestUncheckedUpdateManyWithoutStudentNestedInput
    completions?: CourseCompletionUncheckedUpdateManyWithoutStudentNestedInput
    stationery?: StationeryIssueUncheckedUpdateManyWithoutStudentNestedInput
    financialRecords?: FinancialRecordUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type CourseUpsertWithoutCertificatesInput = {
    update: XOR<CourseUpdateWithoutCertificatesInput, CourseUncheckedUpdateWithoutCertificatesInput>
    create: XOR<CourseCreateWithoutCertificatesInput, CourseUncheckedCreateWithoutCertificatesInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutCertificatesInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutCertificatesInput, CourseUncheckedUpdateWithoutCertificatesInput>
  }

  export type CourseUpdateWithoutCertificatesInput = {
    name?: StringFieldUpdateOperationsInput | string
    durationWeeks?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    courseFeeStructure?: CourseFeeStructureUpdateOneWithoutCourseNestedInput
    studentCourses?: StudentCourseUpdateManyWithoutCourseNestedInput
    enquiryCourse?: EnquiryCourseUpdateManyWithoutCourseNestedInput
    feeStructures?: FeeStructureUpdateManyWithoutCourseNestedInput
    stationery?: StationeryIssueUpdateManyWithoutCourseNestedInput
    studentFees?: StudentFeeUpdateManyWithoutCourseNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutCourseNestedInput
    studentTasks?: StudentTaskUpdateManyWithoutCourseNestedInput
    studentTests?: StudentTestUpdateManyWithoutCourseNestedInput
    financialRecords?: FinancialRecordUpdateManyWithoutCourseNestedInput
    batchCourses?: BatchCourseUpdateManyWithoutCourseNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutCoursesNestedInput
  }

  export type CourseUncheckedUpdateWithoutCertificatesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    durationWeeks?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    clientAdminId?: StringFieldUpdateOperationsInput | string
    courseFeeStructure?: CourseFeeStructureUncheckedUpdateOneWithoutCourseNestedInput
    studentCourses?: StudentCourseUncheckedUpdateManyWithoutCourseNestedInput
    enquiryCourse?: EnquiryCourseUncheckedUpdateManyWithoutCourseNestedInput
    feeStructures?: FeeStructureUncheckedUpdateManyWithoutCourseNestedInput
    stationery?: StationeryIssueUncheckedUpdateManyWithoutCourseNestedInput
    studentFees?: StudentFeeUncheckedUpdateManyWithoutCourseNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutCourseNestedInput
    studentTasks?: StudentTaskUncheckedUpdateManyWithoutCourseNestedInput
    studentTests?: StudentTestUncheckedUpdateManyWithoutCourseNestedInput
    financialRecords?: FinancialRecordUncheckedUpdateManyWithoutCourseNestedInput
    batchCourses?: BatchCourseUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type StudentCourseUpsertWithoutCertificateInput = {
    update: XOR<StudentCourseUpdateWithoutCertificateInput, StudentCourseUncheckedUpdateWithoutCertificateInput>
    create: XOR<StudentCourseCreateWithoutCertificateInput, StudentCourseUncheckedCreateWithoutCertificateInput>
    where?: StudentCourseWhereInput
  }

  export type StudentCourseUpdateToOneWithWhereWithoutCertificateInput = {
    where?: StudentCourseWhereInput
    data: XOR<StudentCourseUpdateWithoutCertificateInput, StudentCourseUncheckedUpdateWithoutCertificateInput>
  }

  export type StudentCourseUpdateWithoutCertificateInput = {
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    studentCode?: StringFieldUpdateOperationsInput | string
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    student?: StudentUpdateOneRequiredWithoutStudentCoursesNestedInput
    course?: CourseUpdateOneRequiredWithoutStudentCoursesNestedInput
    batch?: BatchUpdateOneWithoutStudentCoursesNestedInput
    completions?: CourseCompletionUpdateManyWithoutStudentCourseNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutStudentCoursesNestedInput
  }

  export type StudentCourseUncheckedUpdateWithoutCertificateInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    studentCode?: StringFieldUpdateOperationsInput | string
    batchId?: NullableIntFieldUpdateOperationsInput | number | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    clientAdminId?: StringFieldUpdateOperationsInput | string
    completions?: CourseCompletionUncheckedUpdateManyWithoutStudentCourseNestedInput
  }

  export type ClientAdminUpsertWithoutCertificatesInput = {
    update: XOR<ClientAdminUpdateWithoutCertificatesInput, ClientAdminUncheckedUpdateWithoutCertificatesInput>
    create: XOR<ClientAdminCreateWithoutCertificatesInput, ClientAdminUncheckedCreateWithoutCertificatesInput>
    where?: ClientAdminWhereInput
  }

  export type ClientAdminUpdateToOneWithWhereWithoutCertificatesInput = {
    where?: ClientAdminWhereInput
    data: XOR<ClientAdminUpdateWithoutCertificatesInput, ClientAdminUncheckedUpdateWithoutCertificatesInput>
  }

  export type ClientAdminUpdateWithoutCertificatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    instituteName?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    fullAddress?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    certificateName?: NullableStringFieldUpdateOperationsInput | string | null
    stamp?: NullableStringFieldUpdateOperationsInput | string | null
    sign?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    currentSessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleUsers?: RoleUserUpdateManyWithoutClientAdminNestedInput
    faculties?: FacultyUpdateManyWithoutClientAdminNestedInput
    batches?: BatchUpdateManyWithoutClientAdminNestedInput
    courses?: CourseUpdateManyWithoutClientAdminNestedInput
    enquiryCourse?: EnquiryCourseUpdateManyWithoutClientAdminNestedInput
    labs?: LabUpdateManyWithoutClientAdminNestedInput
    labTimeSlots?: LabTimeSlotUpdateManyWithoutClientAdminNestedInput
    labAllocations?: LabAllocationUpdateManyWithoutClientAdminNestedInput
    students?: StudentUpdateManyWithoutClientAdminNestedInput
    activities?: ActivityLogUpdateManyWithoutClientAdminNestedInput
    studentCourses?: StudentCourseUpdateManyWithoutClientAdminNestedInput
    feeStructures?: FeeStructureUpdateManyWithoutClientAdminNestedInput
    studentFees?: StudentFeeUpdateManyWithoutClientAdminNestedInput
    stationeryIssues?: StationeryIssueUpdateManyWithoutClientAdminNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutClientAdminNestedInput
    studentTasks?: StudentTaskUpdateManyWithoutClientAdminNestedInput
    studentTests?: StudentTestUpdateManyWithoutClientAdminNestedInput
    courseCompletions?: CourseCompletionUpdateManyWithoutClientAdminNestedInput
    financialRecords?: FinancialRecordUpdateManyWithoutClientAdminNestedInput
    enquiries?: EnquiryUpdateManyWithoutClientAdminNestedInput
    notifications?: NotificationUpdateManyWithoutClientAdminNestedInput
    courseFeeStructures?: CourseFeeStructureUpdateManyWithoutClientAdminNestedInput
  }

  export type ClientAdminUncheckedUpdateWithoutCertificatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    instituteName?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    fullAddress?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    certificateName?: NullableStringFieldUpdateOperationsInput | string | null
    stamp?: NullableStringFieldUpdateOperationsInput | string | null
    sign?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    currentSessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleUsers?: RoleUserUncheckedUpdateManyWithoutClientAdminNestedInput
    faculties?: FacultyUncheckedUpdateManyWithoutClientAdminNestedInput
    batches?: BatchUncheckedUpdateManyWithoutClientAdminNestedInput
    courses?: CourseUncheckedUpdateManyWithoutClientAdminNestedInput
    enquiryCourse?: EnquiryCourseUncheckedUpdateManyWithoutClientAdminNestedInput
    labs?: LabUncheckedUpdateManyWithoutClientAdminNestedInput
    labTimeSlots?: LabTimeSlotUncheckedUpdateManyWithoutClientAdminNestedInput
    labAllocations?: LabAllocationUncheckedUpdateManyWithoutClientAdminNestedInput
    students?: StudentUncheckedUpdateManyWithoutClientAdminNestedInput
    activities?: ActivityLogUncheckedUpdateManyWithoutClientAdminNestedInput
    studentCourses?: StudentCourseUncheckedUpdateManyWithoutClientAdminNestedInput
    feeStructures?: FeeStructureUncheckedUpdateManyWithoutClientAdminNestedInput
    studentFees?: StudentFeeUncheckedUpdateManyWithoutClientAdminNestedInput
    stationeryIssues?: StationeryIssueUncheckedUpdateManyWithoutClientAdminNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutClientAdminNestedInput
    studentTasks?: StudentTaskUncheckedUpdateManyWithoutClientAdminNestedInput
    studentTests?: StudentTestUncheckedUpdateManyWithoutClientAdminNestedInput
    courseCompletions?: CourseCompletionUncheckedUpdateManyWithoutClientAdminNestedInput
    financialRecords?: FinancialRecordUncheckedUpdateManyWithoutClientAdminNestedInput
    enquiries?: EnquiryUncheckedUpdateManyWithoutClientAdminNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutClientAdminNestedInput
    courseFeeStructures?: CourseFeeStructureUncheckedUpdateManyWithoutClientAdminNestedInput
  }

  export type StudentCreateWithoutFinancialRecordsInput = {
    serialNumber: number
    studentCode: string
    fullName: string
    fatherName: string
    motherName: string
    photoUrl?: string | null
    contact: string
    parentsContact: string
    email?: string | null
    residentialAddress?: string | null
    permenantAddress?: string | null
    dob: string
    gender: string
    religion?: string | null
    idProofType?: string | null
    idProofNumber?: string | null
    admissionDate: Date | string
    enquiry?: EnquiryCreateNestedOneWithoutStudentInput
    labAllocations?: LabAllocationCreateNestedManyWithoutStudentInput
    studentCourses?: StudentCourseCreateNestedManyWithoutStudentInput
    feeStructures?: FeeStructureCreateNestedManyWithoutStudentInput
    feeRecords?: StudentFeeCreateNestedManyWithoutStudentInput
    attendance?: AttendanceRecordCreateNestedManyWithoutStudentInput
    tasks?: StudentTaskCreateNestedManyWithoutStudentInput
    tests?: StudentTestCreateNestedManyWithoutStudentInput
    completions?: CourseCompletionCreateNestedManyWithoutStudentInput
    stationery?: StationeryIssueCreateNestedManyWithoutStudentInput
    certificates?: CertificateCreateNestedManyWithoutStudentInput
    clientAdmin: ClientAdminCreateNestedOneWithoutStudentsInput
  }

  export type StudentUncheckedCreateWithoutFinancialRecordsInput = {
    id?: number
    serialNumber: number
    studentCode: string
    fullName: string
    fatherName: string
    motherName: string
    photoUrl?: string | null
    contact: string
    parentsContact: string
    email?: string | null
    residentialAddress?: string | null
    permenantAddress?: string | null
    dob: string
    gender: string
    religion?: string | null
    idProofType?: string | null
    idProofNumber?: string | null
    admissionDate: Date | string
    clientAdminId: string
    enquiry?: EnquiryUncheckedCreateNestedOneWithoutStudentInput
    labAllocations?: LabAllocationUncheckedCreateNestedManyWithoutStudentInput
    studentCourses?: StudentCourseUncheckedCreateNestedManyWithoutStudentInput
    feeStructures?: FeeStructureUncheckedCreateNestedManyWithoutStudentInput
    feeRecords?: StudentFeeUncheckedCreateNestedManyWithoutStudentInput
    attendance?: AttendanceRecordUncheckedCreateNestedManyWithoutStudentInput
    tasks?: StudentTaskUncheckedCreateNestedManyWithoutStudentInput
    tests?: StudentTestUncheckedCreateNestedManyWithoutStudentInput
    completions?: CourseCompletionUncheckedCreateNestedManyWithoutStudentInput
    stationery?: StationeryIssueUncheckedCreateNestedManyWithoutStudentInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutFinancialRecordsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutFinancialRecordsInput, StudentUncheckedCreateWithoutFinancialRecordsInput>
  }

  export type CourseCreateWithoutFinancialRecordsInput = {
    name: string
    durationWeeks: number
    description?: string | null
    courseFeeStructure?: CourseFeeStructureCreateNestedOneWithoutCourseInput
    studentCourses?: StudentCourseCreateNestedManyWithoutCourseInput
    enquiryCourse?: EnquiryCourseCreateNestedManyWithoutCourseInput
    feeStructures?: FeeStructureCreateNestedManyWithoutCourseInput
    stationery?: StationeryIssueCreateNestedManyWithoutCourseInput
    studentFees?: StudentFeeCreateNestedManyWithoutCourseInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutCourseInput
    studentTasks?: StudentTaskCreateNestedManyWithoutCourseInput
    studentTests?: StudentTestCreateNestedManyWithoutCourseInput
    certificates?: CertificateCreateNestedManyWithoutCourseInput
    batchCourses?: BatchCourseCreateNestedManyWithoutCourseInput
    clientAdmin: ClientAdminCreateNestedOneWithoutCoursesInput
  }

  export type CourseUncheckedCreateWithoutFinancialRecordsInput = {
    id?: number
    name: string
    durationWeeks: number
    description?: string | null
    clientAdminId: string
    courseFeeStructure?: CourseFeeStructureUncheckedCreateNestedOneWithoutCourseInput
    studentCourses?: StudentCourseUncheckedCreateNestedManyWithoutCourseInput
    enquiryCourse?: EnquiryCourseUncheckedCreateNestedManyWithoutCourseInput
    feeStructures?: FeeStructureUncheckedCreateNestedManyWithoutCourseInput
    stationery?: StationeryIssueUncheckedCreateNestedManyWithoutCourseInput
    studentFees?: StudentFeeUncheckedCreateNestedManyWithoutCourseInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutCourseInput
    studentTasks?: StudentTaskUncheckedCreateNestedManyWithoutCourseInput
    studentTests?: StudentTestUncheckedCreateNestedManyWithoutCourseInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutCourseInput
    batchCourses?: BatchCourseUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutFinancialRecordsInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutFinancialRecordsInput, CourseUncheckedCreateWithoutFinancialRecordsInput>
  }

  export type FacultyCreateWithoutFinancialRecordsInput = {
    name: string
    email: string
    password: string
    contact: string
    joiningDate: Date | string
    specialization?: string | null
    role?: $Enums.UserRole
    country: string
    state: string
    city: string
    zipCode: string
    currentSessionToken?: string | null
    lastLoginAt?: Date | string | null
    batches?: BatchCreateNestedManyWithoutFacultyInput
    attendance?: AttendanceRecordCreateNestedManyWithoutMarkedByInput
    tasks?: StudentTaskCreateNestedManyWithoutFacultyInput
    clientAdmin: ClientAdminCreateNestedOneWithoutFacultiesInput
  }

  export type FacultyUncheckedCreateWithoutFinancialRecordsInput = {
    id?: number
    name: string
    email: string
    password: string
    contact: string
    joiningDate: Date | string
    specialization?: string | null
    role?: $Enums.UserRole
    country: string
    state: string
    city: string
    zipCode: string
    currentSessionToken?: string | null
    lastLoginAt?: Date | string | null
    clientAdminId: string
    batches?: BatchUncheckedCreateNestedManyWithoutFacultyInput
    attendance?: AttendanceRecordUncheckedCreateNestedManyWithoutMarkedByInput
    tasks?: StudentTaskUncheckedCreateNestedManyWithoutFacultyInput
  }

  export type FacultyCreateOrConnectWithoutFinancialRecordsInput = {
    where: FacultyWhereUniqueInput
    create: XOR<FacultyCreateWithoutFinancialRecordsInput, FacultyUncheckedCreateWithoutFinancialRecordsInput>
  }

  export type LabCreateWithoutFinancialRecordsInput = {
    name: string
    location?: string | null
    totalPCs: number
    isActive?: boolean
    timeSlots?: LabTimeSlotCreateNestedManyWithoutLabInput
    clientAdmin: ClientAdminCreateNestedOneWithoutLabsInput
  }

  export type LabUncheckedCreateWithoutFinancialRecordsInput = {
    id?: number
    name: string
    location?: string | null
    totalPCs: number
    isActive?: boolean
    clientAdminId: string
    timeSlots?: LabTimeSlotUncheckedCreateNestedManyWithoutLabInput
  }

  export type LabCreateOrConnectWithoutFinancialRecordsInput = {
    where: LabWhereUniqueInput
    create: XOR<LabCreateWithoutFinancialRecordsInput, LabUncheckedCreateWithoutFinancialRecordsInput>
  }

  export type ClientAdminCreateWithoutFinancialRecordsInput = {
    id?: string
    name: string
    email: string
    password: string
    instituteName: string
    slug: string
    fullAddress: string
    logo?: string | null
    certificateName?: string | null
    stamp?: string | null
    sign?: string | null
    contact: string
    position: string
    country: string
    state: string
    city: string
    zipCode: string
    createdAt?: Date | string
    role?: $Enums.UserRole
    currentSessionToken?: string | null
    lastLoginAt?: Date | string | null
    roleUsers?: RoleUserCreateNestedManyWithoutClientAdminInput
    faculties?: FacultyCreateNestedManyWithoutClientAdminInput
    batches?: BatchCreateNestedManyWithoutClientAdminInput
    courses?: CourseCreateNestedManyWithoutClientAdminInput
    enquiryCourse?: EnquiryCourseCreateNestedManyWithoutClientAdminInput
    labs?: LabCreateNestedManyWithoutClientAdminInput
    labTimeSlots?: LabTimeSlotCreateNestedManyWithoutClientAdminInput
    labAllocations?: LabAllocationCreateNestedManyWithoutClientAdminInput
    students?: StudentCreateNestedManyWithoutClientAdminInput
    activities?: ActivityLogCreateNestedManyWithoutClientAdminInput
    studentCourses?: StudentCourseCreateNestedManyWithoutClientAdminInput
    feeStructures?: FeeStructureCreateNestedManyWithoutClientAdminInput
    studentFees?: StudentFeeCreateNestedManyWithoutClientAdminInput
    stationeryIssues?: StationeryIssueCreateNestedManyWithoutClientAdminInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutClientAdminInput
    studentTasks?: StudentTaskCreateNestedManyWithoutClientAdminInput
    studentTests?: StudentTestCreateNestedManyWithoutClientAdminInput
    courseCompletions?: CourseCompletionCreateNestedManyWithoutClientAdminInput
    certificates?: CertificateCreateNestedManyWithoutClientAdminInput
    enquiries?: EnquiryCreateNestedManyWithoutClientAdminInput
    notifications?: NotificationCreateNestedManyWithoutClientAdminInput
    courseFeeStructures?: CourseFeeStructureCreateNestedManyWithoutClientAdminInput
  }

  export type ClientAdminUncheckedCreateWithoutFinancialRecordsInput = {
    id?: string
    name: string
    email: string
    password: string
    instituteName: string
    slug: string
    fullAddress: string
    logo?: string | null
    certificateName?: string | null
    stamp?: string | null
    sign?: string | null
    contact: string
    position: string
    country: string
    state: string
    city: string
    zipCode: string
    createdAt?: Date | string
    role?: $Enums.UserRole
    currentSessionToken?: string | null
    lastLoginAt?: Date | string | null
    roleUsers?: RoleUserUncheckedCreateNestedManyWithoutClientAdminInput
    faculties?: FacultyUncheckedCreateNestedManyWithoutClientAdminInput
    batches?: BatchUncheckedCreateNestedManyWithoutClientAdminInput
    courses?: CourseUncheckedCreateNestedManyWithoutClientAdminInput
    enquiryCourse?: EnquiryCourseUncheckedCreateNestedManyWithoutClientAdminInput
    labs?: LabUncheckedCreateNestedManyWithoutClientAdminInput
    labTimeSlots?: LabTimeSlotUncheckedCreateNestedManyWithoutClientAdminInput
    labAllocations?: LabAllocationUncheckedCreateNestedManyWithoutClientAdminInput
    students?: StudentUncheckedCreateNestedManyWithoutClientAdminInput
    activities?: ActivityLogUncheckedCreateNestedManyWithoutClientAdminInput
    studentCourses?: StudentCourseUncheckedCreateNestedManyWithoutClientAdminInput
    feeStructures?: FeeStructureUncheckedCreateNestedManyWithoutClientAdminInput
    studentFees?: StudentFeeUncheckedCreateNestedManyWithoutClientAdminInput
    stationeryIssues?: StationeryIssueUncheckedCreateNestedManyWithoutClientAdminInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutClientAdminInput
    studentTasks?: StudentTaskUncheckedCreateNestedManyWithoutClientAdminInput
    studentTests?: StudentTestUncheckedCreateNestedManyWithoutClientAdminInput
    courseCompletions?: CourseCompletionUncheckedCreateNestedManyWithoutClientAdminInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutClientAdminInput
    enquiries?: EnquiryUncheckedCreateNestedManyWithoutClientAdminInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutClientAdminInput
    courseFeeStructures?: CourseFeeStructureUncheckedCreateNestedManyWithoutClientAdminInput
  }

  export type ClientAdminCreateOrConnectWithoutFinancialRecordsInput = {
    where: ClientAdminWhereUniqueInput
    create: XOR<ClientAdminCreateWithoutFinancialRecordsInput, ClientAdminUncheckedCreateWithoutFinancialRecordsInput>
  }

  export type StudentUpsertWithoutFinancialRecordsInput = {
    update: XOR<StudentUpdateWithoutFinancialRecordsInput, StudentUncheckedUpdateWithoutFinancialRecordsInput>
    create: XOR<StudentCreateWithoutFinancialRecordsInput, StudentUncheckedCreateWithoutFinancialRecordsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutFinancialRecordsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutFinancialRecordsInput, StudentUncheckedUpdateWithoutFinancialRecordsInput>
  }

  export type StudentUpdateWithoutFinancialRecordsInput = {
    serialNumber?: IntFieldUpdateOperationsInput | number
    studentCode?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    fatherName?: StringFieldUpdateOperationsInput | string
    motherName?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: StringFieldUpdateOperationsInput | string
    parentsContact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: NullableStringFieldUpdateOperationsInput | string | null
    permenantAddress?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    idProofType?: NullableStringFieldUpdateOperationsInput | string | null
    idProofNumber?: NullableStringFieldUpdateOperationsInput | string | null
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    enquiry?: EnquiryUpdateOneWithoutStudentNestedInput
    labAllocations?: LabAllocationUpdateManyWithoutStudentNestedInput
    studentCourses?: StudentCourseUpdateManyWithoutStudentNestedInput
    feeStructures?: FeeStructureUpdateManyWithoutStudentNestedInput
    feeRecords?: StudentFeeUpdateManyWithoutStudentNestedInput
    attendance?: AttendanceRecordUpdateManyWithoutStudentNestedInput
    tasks?: StudentTaskUpdateManyWithoutStudentNestedInput
    tests?: StudentTestUpdateManyWithoutStudentNestedInput
    completions?: CourseCompletionUpdateManyWithoutStudentNestedInput
    stationery?: StationeryIssueUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUpdateManyWithoutStudentNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutStudentsNestedInput
  }

  export type StudentUncheckedUpdateWithoutFinancialRecordsInput = {
    id?: IntFieldUpdateOperationsInput | number
    serialNumber?: IntFieldUpdateOperationsInput | number
    studentCode?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    fatherName?: StringFieldUpdateOperationsInput | string
    motherName?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: StringFieldUpdateOperationsInput | string
    parentsContact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: NullableStringFieldUpdateOperationsInput | string | null
    permenantAddress?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    idProofType?: NullableStringFieldUpdateOperationsInput | string | null
    idProofNumber?: NullableStringFieldUpdateOperationsInput | string | null
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    clientAdminId?: StringFieldUpdateOperationsInput | string
    enquiry?: EnquiryUncheckedUpdateOneWithoutStudentNestedInput
    labAllocations?: LabAllocationUncheckedUpdateManyWithoutStudentNestedInput
    studentCourses?: StudentCourseUncheckedUpdateManyWithoutStudentNestedInput
    feeStructures?: FeeStructureUncheckedUpdateManyWithoutStudentNestedInput
    feeRecords?: StudentFeeUncheckedUpdateManyWithoutStudentNestedInput
    attendance?: AttendanceRecordUncheckedUpdateManyWithoutStudentNestedInput
    tasks?: StudentTaskUncheckedUpdateManyWithoutStudentNestedInput
    tests?: StudentTestUncheckedUpdateManyWithoutStudentNestedInput
    completions?: CourseCompletionUncheckedUpdateManyWithoutStudentNestedInput
    stationery?: StationeryIssueUncheckedUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type CourseUpsertWithoutFinancialRecordsInput = {
    update: XOR<CourseUpdateWithoutFinancialRecordsInput, CourseUncheckedUpdateWithoutFinancialRecordsInput>
    create: XOR<CourseCreateWithoutFinancialRecordsInput, CourseUncheckedCreateWithoutFinancialRecordsInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutFinancialRecordsInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutFinancialRecordsInput, CourseUncheckedUpdateWithoutFinancialRecordsInput>
  }

  export type CourseUpdateWithoutFinancialRecordsInput = {
    name?: StringFieldUpdateOperationsInput | string
    durationWeeks?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    courseFeeStructure?: CourseFeeStructureUpdateOneWithoutCourseNestedInput
    studentCourses?: StudentCourseUpdateManyWithoutCourseNestedInput
    enquiryCourse?: EnquiryCourseUpdateManyWithoutCourseNestedInput
    feeStructures?: FeeStructureUpdateManyWithoutCourseNestedInput
    stationery?: StationeryIssueUpdateManyWithoutCourseNestedInput
    studentFees?: StudentFeeUpdateManyWithoutCourseNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutCourseNestedInput
    studentTasks?: StudentTaskUpdateManyWithoutCourseNestedInput
    studentTests?: StudentTestUpdateManyWithoutCourseNestedInput
    certificates?: CertificateUpdateManyWithoutCourseNestedInput
    batchCourses?: BatchCourseUpdateManyWithoutCourseNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutCoursesNestedInput
  }

  export type CourseUncheckedUpdateWithoutFinancialRecordsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    durationWeeks?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    clientAdminId?: StringFieldUpdateOperationsInput | string
    courseFeeStructure?: CourseFeeStructureUncheckedUpdateOneWithoutCourseNestedInput
    studentCourses?: StudentCourseUncheckedUpdateManyWithoutCourseNestedInput
    enquiryCourse?: EnquiryCourseUncheckedUpdateManyWithoutCourseNestedInput
    feeStructures?: FeeStructureUncheckedUpdateManyWithoutCourseNestedInput
    stationery?: StationeryIssueUncheckedUpdateManyWithoutCourseNestedInput
    studentFees?: StudentFeeUncheckedUpdateManyWithoutCourseNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutCourseNestedInput
    studentTasks?: StudentTaskUncheckedUpdateManyWithoutCourseNestedInput
    studentTests?: StudentTestUncheckedUpdateManyWithoutCourseNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutCourseNestedInput
    batchCourses?: BatchCourseUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type FacultyUpsertWithoutFinancialRecordsInput = {
    update: XOR<FacultyUpdateWithoutFinancialRecordsInput, FacultyUncheckedUpdateWithoutFinancialRecordsInput>
    create: XOR<FacultyCreateWithoutFinancialRecordsInput, FacultyUncheckedCreateWithoutFinancialRecordsInput>
    where?: FacultyWhereInput
  }

  export type FacultyUpdateToOneWithWhereWithoutFinancialRecordsInput = {
    where?: FacultyWhereInput
    data: XOR<FacultyUpdateWithoutFinancialRecordsInput, FacultyUncheckedUpdateWithoutFinancialRecordsInput>
  }

  export type FacultyUpdateWithoutFinancialRecordsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    joiningDate?: DateTimeFieldUpdateOperationsInput | Date | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    currentSessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    batches?: BatchUpdateManyWithoutFacultyNestedInput
    attendance?: AttendanceRecordUpdateManyWithoutMarkedByNestedInput
    tasks?: StudentTaskUpdateManyWithoutFacultyNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutFacultiesNestedInput
  }

  export type FacultyUncheckedUpdateWithoutFinancialRecordsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    joiningDate?: DateTimeFieldUpdateOperationsInput | Date | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    currentSessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clientAdminId?: StringFieldUpdateOperationsInput | string
    batches?: BatchUncheckedUpdateManyWithoutFacultyNestedInput
    attendance?: AttendanceRecordUncheckedUpdateManyWithoutMarkedByNestedInput
    tasks?: StudentTaskUncheckedUpdateManyWithoutFacultyNestedInput
  }

  export type LabUpsertWithoutFinancialRecordsInput = {
    update: XOR<LabUpdateWithoutFinancialRecordsInput, LabUncheckedUpdateWithoutFinancialRecordsInput>
    create: XOR<LabCreateWithoutFinancialRecordsInput, LabUncheckedCreateWithoutFinancialRecordsInput>
    where?: LabWhereInput
  }

  export type LabUpdateToOneWithWhereWithoutFinancialRecordsInput = {
    where?: LabWhereInput
    data: XOR<LabUpdateWithoutFinancialRecordsInput, LabUncheckedUpdateWithoutFinancialRecordsInput>
  }

  export type LabUpdateWithoutFinancialRecordsInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    totalPCs?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    timeSlots?: LabTimeSlotUpdateManyWithoutLabNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutLabsNestedInput
  }

  export type LabUncheckedUpdateWithoutFinancialRecordsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    totalPCs?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    clientAdminId?: StringFieldUpdateOperationsInput | string
    timeSlots?: LabTimeSlotUncheckedUpdateManyWithoutLabNestedInput
  }

  export type ClientAdminUpsertWithoutFinancialRecordsInput = {
    update: XOR<ClientAdminUpdateWithoutFinancialRecordsInput, ClientAdminUncheckedUpdateWithoutFinancialRecordsInput>
    create: XOR<ClientAdminCreateWithoutFinancialRecordsInput, ClientAdminUncheckedCreateWithoutFinancialRecordsInput>
    where?: ClientAdminWhereInput
  }

  export type ClientAdminUpdateToOneWithWhereWithoutFinancialRecordsInput = {
    where?: ClientAdminWhereInput
    data: XOR<ClientAdminUpdateWithoutFinancialRecordsInput, ClientAdminUncheckedUpdateWithoutFinancialRecordsInput>
  }

  export type ClientAdminUpdateWithoutFinancialRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    instituteName?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    fullAddress?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    certificateName?: NullableStringFieldUpdateOperationsInput | string | null
    stamp?: NullableStringFieldUpdateOperationsInput | string | null
    sign?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    currentSessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleUsers?: RoleUserUpdateManyWithoutClientAdminNestedInput
    faculties?: FacultyUpdateManyWithoutClientAdminNestedInput
    batches?: BatchUpdateManyWithoutClientAdminNestedInput
    courses?: CourseUpdateManyWithoutClientAdminNestedInput
    enquiryCourse?: EnquiryCourseUpdateManyWithoutClientAdminNestedInput
    labs?: LabUpdateManyWithoutClientAdminNestedInput
    labTimeSlots?: LabTimeSlotUpdateManyWithoutClientAdminNestedInput
    labAllocations?: LabAllocationUpdateManyWithoutClientAdminNestedInput
    students?: StudentUpdateManyWithoutClientAdminNestedInput
    activities?: ActivityLogUpdateManyWithoutClientAdminNestedInput
    studentCourses?: StudentCourseUpdateManyWithoutClientAdminNestedInput
    feeStructures?: FeeStructureUpdateManyWithoutClientAdminNestedInput
    studentFees?: StudentFeeUpdateManyWithoutClientAdminNestedInput
    stationeryIssues?: StationeryIssueUpdateManyWithoutClientAdminNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutClientAdminNestedInput
    studentTasks?: StudentTaskUpdateManyWithoutClientAdminNestedInput
    studentTests?: StudentTestUpdateManyWithoutClientAdminNestedInput
    courseCompletions?: CourseCompletionUpdateManyWithoutClientAdminNestedInput
    certificates?: CertificateUpdateManyWithoutClientAdminNestedInput
    enquiries?: EnquiryUpdateManyWithoutClientAdminNestedInput
    notifications?: NotificationUpdateManyWithoutClientAdminNestedInput
    courseFeeStructures?: CourseFeeStructureUpdateManyWithoutClientAdminNestedInput
  }

  export type ClientAdminUncheckedUpdateWithoutFinancialRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    instituteName?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    fullAddress?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    certificateName?: NullableStringFieldUpdateOperationsInput | string | null
    stamp?: NullableStringFieldUpdateOperationsInput | string | null
    sign?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    currentSessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roleUsers?: RoleUserUncheckedUpdateManyWithoutClientAdminNestedInput
    faculties?: FacultyUncheckedUpdateManyWithoutClientAdminNestedInput
    batches?: BatchUncheckedUpdateManyWithoutClientAdminNestedInput
    courses?: CourseUncheckedUpdateManyWithoutClientAdminNestedInput
    enquiryCourse?: EnquiryCourseUncheckedUpdateManyWithoutClientAdminNestedInput
    labs?: LabUncheckedUpdateManyWithoutClientAdminNestedInput
    labTimeSlots?: LabTimeSlotUncheckedUpdateManyWithoutClientAdminNestedInput
    labAllocations?: LabAllocationUncheckedUpdateManyWithoutClientAdminNestedInput
    students?: StudentUncheckedUpdateManyWithoutClientAdminNestedInput
    activities?: ActivityLogUncheckedUpdateManyWithoutClientAdminNestedInput
    studentCourses?: StudentCourseUncheckedUpdateManyWithoutClientAdminNestedInput
    feeStructures?: FeeStructureUncheckedUpdateManyWithoutClientAdminNestedInput
    studentFees?: StudentFeeUncheckedUpdateManyWithoutClientAdminNestedInput
    stationeryIssues?: StationeryIssueUncheckedUpdateManyWithoutClientAdminNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutClientAdminNestedInput
    studentTasks?: StudentTaskUncheckedUpdateManyWithoutClientAdminNestedInput
    studentTests?: StudentTestUncheckedUpdateManyWithoutClientAdminNestedInput
    courseCompletions?: CourseCompletionUncheckedUpdateManyWithoutClientAdminNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutClientAdminNestedInput
    enquiries?: EnquiryUncheckedUpdateManyWithoutClientAdminNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutClientAdminNestedInput
    courseFeeStructures?: CourseFeeStructureUncheckedUpdateManyWithoutClientAdminNestedInput
  }

  export type RoleUserCreateManyClientAdminInput = {
    id?: string
    name: string
    email: string
    password: string
    role: $Enums.UserRole
    createdAt?: Date | string
    country: string
    state: string
    city: string
    zipCode: string
    currentSessionToken?: string | null
    lastLoginAt?: Date | string | null
  }

  export type FacultyCreateManyClientAdminInput = {
    id?: number
    name: string
    email: string
    password: string
    contact: string
    joiningDate: Date | string
    specialization?: string | null
    role?: $Enums.UserRole
    country: string
    state: string
    city: string
    zipCode: string
    currentSessionToken?: string | null
    lastLoginAt?: Date | string | null
  }

  export type BatchCreateManyClientAdminInput = {
    id?: number
    name: string
    facultyId?: number | null
    labTimeSlotId: number
  }

  export type CourseCreateManyClientAdminInput = {
    id?: number
    name: string
    durationWeeks: number
    description?: string | null
  }

  export type EnquiryCourseCreateManyClientAdminInput = {
    id?: number
    enquiryId: string
    courseId: number
  }

  export type LabCreateManyClientAdminInput = {
    id?: number
    name: string
    location?: string | null
    totalPCs: number
    isActive?: boolean
  }

  export type LabTimeSlotCreateManyClientAdminInput = {
    id?: number
    startTime: string
    endTime: string
    day: string
    labId: number
    availablePCs: number
  }

  export type LabAllocationCreateManyClientAdminInput = {
    id?: number
    labTimeSlotId: number
    studentId: number
    pcNumber: number
    assignedAt?: Date | string
  }

  export type StudentCreateManyClientAdminInput = {
    id?: number
    serialNumber: number
    studentCode: string
    fullName: string
    fatherName: string
    motherName: string
    photoUrl?: string | null
    contact: string
    parentsContact: string
    email?: string | null
    residentialAddress?: string | null
    permenantAddress?: string | null
    dob: string
    gender: string
    religion?: string | null
    idProofType?: string | null
    idProofNumber?: string | null
    admissionDate: Date | string
  }

  export type ActivityLogCreateManyClientAdminInput = {
    id?: string
    entity: string
    entityId: string
    action: string
    message?: string | null
    createdAt?: Date | string
  }

  export type StudentCourseCreateManyClientAdminInput = {
    id?: number
    studentId: number
    courseId: number
    startDate: Date | string
    endDate: Date | string
    studentCode: string
    batchId?: number | null
    internalNotes?: string | null
    status: string
  }

  export type FeeStructureCreateManyClientAdminInput = {
    id?: number
    studentId: number
    courseId: number
    totalAmount: number
    paymentType: $Enums.PaymentType
    installmentCount?: number | null
    installmentTypeId?: number | null
  }

  export type StudentFeeCreateManyClientAdminInput = {
    id?: number
    studentId: number
    courseId: number
    dueDate: Date | string
    amountDue: number
    amountPaid: number
    paymentDate?: Date | string | null
    paymentMode: $Enums.PaymentMode
    receiptNo: string
    paymentStatus?: $Enums.PaymentStatus
  }

  export type StationeryIssueCreateManyClientAdminInput = {
    id?: number
    studentId: number
    courseId: number
    itemId: number
    issueDate: Date | string
    quantity: number
    remarks?: string | null
  }

  export type AttendanceRecordCreateManyClientAdminInput = {
    id?: number
    studentId: number
    courseId: number
    date: Date | string
    present: boolean
    facultyId: number
    batchId?: number | null
  }

  export type StudentTaskCreateManyClientAdminInput = {
    id?: number
    studentId: number
    courseId: number
    assignedDate: Date | string
    dueDate: Date | string
    description: string
    status: string
    facultyRemarks?: string | null
    grade?: string | null
    facultyId?: number | null
  }

  export type StudentTestCreateManyClientAdminInput = {
    id?: number
    studentId: number
    courseId: number
    testName: string
    testDate: Date | string
    totalMarks: number
    marksObtained: number
    grade: string
  }

  export type CourseCompletionCreateManyClientAdminInput = {
    id?: number
    studentCourseId: number
    studentId: number
    completionDate: Date | string
    feedback?: string | null
    remarks?: string | null
  }

  export type CertificateCreateManyClientAdminInput = {
    id?: number
    studentId: number
    courseId: number
    studentCourseId: number
    issueDate: Date | string
    certificateUrl: string
  }

  export type FinancialRecordCreateManyClientAdminInput = {
    id?: string
    recordType: $Enums.RecordType
    amount: number
    description?: string | null
    date?: Date | string
    paymentMode?: $Enums.PaymentMode | null
    studentId?: number | null
    courseId?: number | null
    facultyId?: number | null
    labId?: number | null
  }

  export type EnquiryCreateManyClientAdminInput = {
    id?: string
    name: string
    contact: string
    email?: string | null
    course?: string | null
    source?: string | null
    leadStatus?: $Enums.LeadStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    isConverted?: boolean
    studentId?: number | null
  }

  export type NotificationCreateManyClientAdminInput = {
    id?: string
    message: string
    seen?: boolean
    createdAt?: Date | string
    followUpId?: string | null
    enquiryId?: string | null
    paymentId?: number | null
  }

  export type CourseFeeStructureCreateManyClientAdminInput = {
    id?: number
    courseId: number
    totalAmount: number
    paymentType?: CourseFeeStructureCreatepaymentTypeInput | string[]
  }

  export type RoleUserUpdateWithoutClientAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    currentSessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RoleUserUncheckedUpdateWithoutClientAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    currentSessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RoleUserUncheckedUpdateManyWithoutClientAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    currentSessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FacultyUpdateWithoutClientAdminInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    joiningDate?: DateTimeFieldUpdateOperationsInput | Date | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    currentSessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    batches?: BatchUpdateManyWithoutFacultyNestedInput
    attendance?: AttendanceRecordUpdateManyWithoutMarkedByNestedInput
    tasks?: StudentTaskUpdateManyWithoutFacultyNestedInput
    financialRecords?: FinancialRecordUpdateManyWithoutFacultyNestedInput
  }

  export type FacultyUncheckedUpdateWithoutClientAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    joiningDate?: DateTimeFieldUpdateOperationsInput | Date | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    currentSessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    batches?: BatchUncheckedUpdateManyWithoutFacultyNestedInput
    attendance?: AttendanceRecordUncheckedUpdateManyWithoutMarkedByNestedInput
    tasks?: StudentTaskUncheckedUpdateManyWithoutFacultyNestedInput
    financialRecords?: FinancialRecordUncheckedUpdateManyWithoutFacultyNestedInput
  }

  export type FacultyUncheckedUpdateManyWithoutClientAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    joiningDate?: DateTimeFieldUpdateOperationsInput | Date | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    country?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    currentSessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BatchUpdateWithoutClientAdminInput = {
    name?: StringFieldUpdateOperationsInput | string
    faculty?: FacultyUpdateOneWithoutBatchesNestedInput
    labTimeSlot?: LabTimeSlotUpdateOneRequiredWithoutBatchesNestedInput
    studentCourses?: StudentCourseUpdateManyWithoutBatchNestedInput
    batchCourses?: BatchCourseUpdateManyWithoutBatchNestedInput
  }

  export type BatchUncheckedUpdateWithoutClientAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    facultyId?: NullableIntFieldUpdateOperationsInput | number | null
    labTimeSlotId?: IntFieldUpdateOperationsInput | number
    studentCourses?: StudentCourseUncheckedUpdateManyWithoutBatchNestedInput
    batchCourses?: BatchCourseUncheckedUpdateManyWithoutBatchNestedInput
  }

  export type BatchUncheckedUpdateManyWithoutClientAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    facultyId?: NullableIntFieldUpdateOperationsInput | number | null
    labTimeSlotId?: IntFieldUpdateOperationsInput | number
  }

  export type CourseUpdateWithoutClientAdminInput = {
    name?: StringFieldUpdateOperationsInput | string
    durationWeeks?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    courseFeeStructure?: CourseFeeStructureUpdateOneWithoutCourseNestedInput
    studentCourses?: StudentCourseUpdateManyWithoutCourseNestedInput
    enquiryCourse?: EnquiryCourseUpdateManyWithoutCourseNestedInput
    feeStructures?: FeeStructureUpdateManyWithoutCourseNestedInput
    stationery?: StationeryIssueUpdateManyWithoutCourseNestedInput
    studentFees?: StudentFeeUpdateManyWithoutCourseNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutCourseNestedInput
    studentTasks?: StudentTaskUpdateManyWithoutCourseNestedInput
    studentTests?: StudentTestUpdateManyWithoutCourseNestedInput
    certificates?: CertificateUpdateManyWithoutCourseNestedInput
    financialRecords?: FinancialRecordUpdateManyWithoutCourseNestedInput
    batchCourses?: BatchCourseUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutClientAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    durationWeeks?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    courseFeeStructure?: CourseFeeStructureUncheckedUpdateOneWithoutCourseNestedInput
    studentCourses?: StudentCourseUncheckedUpdateManyWithoutCourseNestedInput
    enquiryCourse?: EnquiryCourseUncheckedUpdateManyWithoutCourseNestedInput
    feeStructures?: FeeStructureUncheckedUpdateManyWithoutCourseNestedInput
    stationery?: StationeryIssueUncheckedUpdateManyWithoutCourseNestedInput
    studentFees?: StudentFeeUncheckedUpdateManyWithoutCourseNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutCourseNestedInput
    studentTasks?: StudentTaskUncheckedUpdateManyWithoutCourseNestedInput
    studentTests?: StudentTestUncheckedUpdateManyWithoutCourseNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutCourseNestedInput
    financialRecords?: FinancialRecordUncheckedUpdateManyWithoutCourseNestedInput
    batchCourses?: BatchCourseUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateManyWithoutClientAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    durationWeeks?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EnquiryCourseUpdateWithoutClientAdminInput = {
    enquiry?: EnquiryUpdateOneRequiredWithoutEnquiryCourseNestedInput
    course?: CourseUpdateOneRequiredWithoutEnquiryCourseNestedInput
  }

  export type EnquiryCourseUncheckedUpdateWithoutClientAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    enquiryId?: StringFieldUpdateOperationsInput | string
    courseId?: IntFieldUpdateOperationsInput | number
  }

  export type EnquiryCourseUncheckedUpdateManyWithoutClientAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    enquiryId?: StringFieldUpdateOperationsInput | string
    courseId?: IntFieldUpdateOperationsInput | number
  }

  export type LabUpdateWithoutClientAdminInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    totalPCs?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    timeSlots?: LabTimeSlotUpdateManyWithoutLabNestedInput
    financialRecords?: FinancialRecordUpdateManyWithoutLabNestedInput
  }

  export type LabUncheckedUpdateWithoutClientAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    totalPCs?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    timeSlots?: LabTimeSlotUncheckedUpdateManyWithoutLabNestedInput
    financialRecords?: FinancialRecordUncheckedUpdateManyWithoutLabNestedInput
  }

  export type LabUncheckedUpdateManyWithoutClientAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    totalPCs?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LabTimeSlotUpdateWithoutClientAdminInput = {
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    day?: StringFieldUpdateOperationsInput | string
    availablePCs?: IntFieldUpdateOperationsInput | number
    lab?: LabUpdateOneRequiredWithoutTimeSlotsNestedInput
    batches?: BatchUpdateManyWithoutLabTimeSlotNestedInput
    allocations?: LabAllocationUpdateManyWithoutLabTimeSlotNestedInput
  }

  export type LabTimeSlotUncheckedUpdateWithoutClientAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    day?: StringFieldUpdateOperationsInput | string
    labId?: IntFieldUpdateOperationsInput | number
    availablePCs?: IntFieldUpdateOperationsInput | number
    batches?: BatchUncheckedUpdateManyWithoutLabTimeSlotNestedInput
    allocations?: LabAllocationUncheckedUpdateManyWithoutLabTimeSlotNestedInput
  }

  export type LabTimeSlotUncheckedUpdateManyWithoutClientAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    day?: StringFieldUpdateOperationsInput | string
    labId?: IntFieldUpdateOperationsInput | number
    availablePCs?: IntFieldUpdateOperationsInput | number
  }

  export type LabAllocationUpdateWithoutClientAdminInput = {
    pcNumber?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    labTimeSlot?: LabTimeSlotUpdateOneRequiredWithoutAllocationsNestedInput
    student?: StudentUpdateOneRequiredWithoutLabAllocationsNestedInput
  }

  export type LabAllocationUncheckedUpdateWithoutClientAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    labTimeSlotId?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    pcNumber?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabAllocationUncheckedUpdateManyWithoutClientAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    labTimeSlotId?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    pcNumber?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentUpdateWithoutClientAdminInput = {
    serialNumber?: IntFieldUpdateOperationsInput | number
    studentCode?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    fatherName?: StringFieldUpdateOperationsInput | string
    motherName?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: StringFieldUpdateOperationsInput | string
    parentsContact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: NullableStringFieldUpdateOperationsInput | string | null
    permenantAddress?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    idProofType?: NullableStringFieldUpdateOperationsInput | string | null
    idProofNumber?: NullableStringFieldUpdateOperationsInput | string | null
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    enquiry?: EnquiryUpdateOneWithoutStudentNestedInput
    labAllocations?: LabAllocationUpdateManyWithoutStudentNestedInput
    studentCourses?: StudentCourseUpdateManyWithoutStudentNestedInput
    feeStructures?: FeeStructureUpdateManyWithoutStudentNestedInput
    feeRecords?: StudentFeeUpdateManyWithoutStudentNestedInput
    attendance?: AttendanceRecordUpdateManyWithoutStudentNestedInput
    tasks?: StudentTaskUpdateManyWithoutStudentNestedInput
    tests?: StudentTestUpdateManyWithoutStudentNestedInput
    completions?: CourseCompletionUpdateManyWithoutStudentNestedInput
    stationery?: StationeryIssueUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUpdateManyWithoutStudentNestedInput
    financialRecords?: FinancialRecordUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutClientAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    serialNumber?: IntFieldUpdateOperationsInput | number
    studentCode?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    fatherName?: StringFieldUpdateOperationsInput | string
    motherName?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: StringFieldUpdateOperationsInput | string
    parentsContact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: NullableStringFieldUpdateOperationsInput | string | null
    permenantAddress?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    idProofType?: NullableStringFieldUpdateOperationsInput | string | null
    idProofNumber?: NullableStringFieldUpdateOperationsInput | string | null
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    enquiry?: EnquiryUncheckedUpdateOneWithoutStudentNestedInput
    labAllocations?: LabAllocationUncheckedUpdateManyWithoutStudentNestedInput
    studentCourses?: StudentCourseUncheckedUpdateManyWithoutStudentNestedInput
    feeStructures?: FeeStructureUncheckedUpdateManyWithoutStudentNestedInput
    feeRecords?: StudentFeeUncheckedUpdateManyWithoutStudentNestedInput
    attendance?: AttendanceRecordUncheckedUpdateManyWithoutStudentNestedInput
    tasks?: StudentTaskUncheckedUpdateManyWithoutStudentNestedInput
    tests?: StudentTestUncheckedUpdateManyWithoutStudentNestedInput
    completions?: CourseCompletionUncheckedUpdateManyWithoutStudentNestedInput
    stationery?: StationeryIssueUncheckedUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutStudentNestedInput
    financialRecords?: FinancialRecordUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateManyWithoutClientAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    serialNumber?: IntFieldUpdateOperationsInput | number
    studentCode?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    fatherName?: StringFieldUpdateOperationsInput | string
    motherName?: StringFieldUpdateOperationsInput | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: StringFieldUpdateOperationsInput | string
    parentsContact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    residentialAddress?: NullableStringFieldUpdateOperationsInput | string | null
    permenantAddress?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    idProofType?: NullableStringFieldUpdateOperationsInput | string | null
    idProofNumber?: NullableStringFieldUpdateOperationsInput | string | null
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogUpdateWithoutClientAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogUncheckedUpdateWithoutClientAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogUncheckedUpdateManyWithoutClientAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentCourseUpdateWithoutClientAdminInput = {
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    studentCode?: StringFieldUpdateOperationsInput | string
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    student?: StudentUpdateOneRequiredWithoutStudentCoursesNestedInput
    course?: CourseUpdateOneRequiredWithoutStudentCoursesNestedInput
    batch?: BatchUpdateOneWithoutStudentCoursesNestedInput
    certificate?: CertificateUpdateOneWithoutStudentCourseNestedInput
    completions?: CourseCompletionUpdateManyWithoutStudentCourseNestedInput
  }

  export type StudentCourseUncheckedUpdateWithoutClientAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    studentCode?: StringFieldUpdateOperationsInput | string
    batchId?: NullableIntFieldUpdateOperationsInput | number | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    certificate?: CertificateUncheckedUpdateOneWithoutStudentCourseNestedInput
    completions?: CourseCompletionUncheckedUpdateManyWithoutStudentCourseNestedInput
  }

  export type StudentCourseUncheckedUpdateManyWithoutClientAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    studentCode?: StringFieldUpdateOperationsInput | string
    batchId?: NullableIntFieldUpdateOperationsInput | number | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type FeeStructureUpdateWithoutClientAdminInput = {
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paymentType?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    installmentCount?: NullableIntFieldUpdateOperationsInput | number | null
    student?: StudentUpdateOneRequiredWithoutFeeStructuresNestedInput
    course?: CourseUpdateOneRequiredWithoutFeeStructuresNestedInput
    installment?: InstallmentDetailUpdateOneWithoutFeeStructuresNestedInput
    studentFees?: StudentFeeUpdateManyWithoutFeeStructureNestedInput
  }

  export type FeeStructureUncheckedUpdateWithoutClientAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paymentType?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    installmentCount?: NullableIntFieldUpdateOperationsInput | number | null
    installmentTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    studentFees?: StudentFeeUncheckedUpdateManyWithoutFeeStructureNestedInput
  }

  export type FeeStructureUncheckedUpdateManyWithoutClientAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paymentType?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    installmentCount?: NullableIntFieldUpdateOperationsInput | number | null
    installmentTypeId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type StudentFeeUpdateWithoutClientAdminInput = {
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amountDue?: FloatFieldUpdateOperationsInput | number
    amountPaid?: FloatFieldUpdateOperationsInput | number
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMode?: EnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode
    receiptNo?: StringFieldUpdateOperationsInput | string
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    student?: StudentUpdateOneRequiredWithoutFeeRecordsNestedInput
    course?: CourseUpdateOneRequiredWithoutStudentFeesNestedInput
    feeLogs?: StudentFeeLogUpdateManyWithoutStudentFeeNestedInput
    feeStructure?: FeeStructureUpdateOneWithoutStudentFeesNestedInput
    notification?: NotificationUpdateOneWithoutPaymentNestedInput
  }

  export type StudentFeeUncheckedUpdateWithoutClientAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amountDue?: FloatFieldUpdateOperationsInput | number
    amountPaid?: FloatFieldUpdateOperationsInput | number
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMode?: EnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode
    receiptNo?: StringFieldUpdateOperationsInput | string
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    feeLogs?: StudentFeeLogUncheckedUpdateManyWithoutStudentFeeNestedInput
    notification?: NotificationUncheckedUpdateOneWithoutPaymentNestedInput
  }

  export type StudentFeeUncheckedUpdateManyWithoutClientAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amountDue?: FloatFieldUpdateOperationsInput | number
    amountPaid?: FloatFieldUpdateOperationsInput | number
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMode?: EnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode
    receiptNo?: StringFieldUpdateOperationsInput | string
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
  }

  export type StationeryIssueUpdateWithoutClientAdminInput = {
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    student?: StudentUpdateOneRequiredWithoutStationeryNestedInput
    course?: CourseUpdateOneRequiredWithoutStationeryNestedInput
    item?: StationeryItemUpdateOneRequiredWithoutStationeryIssuesNestedInput
  }

  export type StationeryIssueUncheckedUpdateWithoutClientAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StationeryIssueUncheckedUpdateManyWithoutClientAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AttendanceRecordUpdateWithoutClientAdminInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    present?: BoolFieldUpdateOperationsInput | boolean
    batchId?: NullableIntFieldUpdateOperationsInput | number | null
    student?: StudentUpdateOneRequiredWithoutAttendanceNestedInput
    course?: CourseUpdateOneRequiredWithoutAttendanceRecordsNestedInput
    markedBy?: FacultyUpdateOneRequiredWithoutAttendanceNestedInput
  }

  export type AttendanceRecordUncheckedUpdateWithoutClientAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    present?: BoolFieldUpdateOperationsInput | boolean
    facultyId?: IntFieldUpdateOperationsInput | number
    batchId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AttendanceRecordUncheckedUpdateManyWithoutClientAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    present?: BoolFieldUpdateOperationsInput | boolean
    facultyId?: IntFieldUpdateOperationsInput | number
    batchId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type StudentTaskUpdateWithoutClientAdminInput = {
    assignedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    facultyRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    student?: StudentUpdateOneRequiredWithoutTasksNestedInput
    course?: CourseUpdateOneRequiredWithoutStudentTasksNestedInput
    faculty?: FacultyUpdateOneWithoutTasksNestedInput
  }

  export type StudentTaskUncheckedUpdateWithoutClientAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    assignedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    facultyRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    facultyId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type StudentTaskUncheckedUpdateManyWithoutClientAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    assignedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    facultyRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    facultyId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type StudentTestUpdateWithoutClientAdminInput = {
    testName?: StringFieldUpdateOperationsInput | string
    testDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalMarks?: IntFieldUpdateOperationsInput | number
    marksObtained?: IntFieldUpdateOperationsInput | number
    grade?: StringFieldUpdateOperationsInput | string
    student?: StudentUpdateOneRequiredWithoutTestsNestedInput
    course?: CourseUpdateOneRequiredWithoutStudentTestsNestedInput
  }

  export type StudentTestUncheckedUpdateWithoutClientAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    testName?: StringFieldUpdateOperationsInput | string
    testDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalMarks?: IntFieldUpdateOperationsInput | number
    marksObtained?: IntFieldUpdateOperationsInput | number
    grade?: StringFieldUpdateOperationsInput | string
  }

  export type StudentTestUncheckedUpdateManyWithoutClientAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    testName?: StringFieldUpdateOperationsInput | string
    testDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalMarks?: IntFieldUpdateOperationsInput | number
    marksObtained?: IntFieldUpdateOperationsInput | number
    grade?: StringFieldUpdateOperationsInput | string
  }

  export type CourseCompletionUpdateWithoutClientAdminInput = {
    completionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    studentCourse?: StudentCourseUpdateOneRequiredWithoutCompletionsNestedInput
    student?: StudentUpdateOneRequiredWithoutCompletionsNestedInput
  }

  export type CourseCompletionUncheckedUpdateWithoutClientAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentCourseId?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    completionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CourseCompletionUncheckedUpdateManyWithoutClientAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentCourseId?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    completionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CertificateUpdateWithoutClientAdminInput = {
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    certificateUrl?: StringFieldUpdateOperationsInput | string
    student?: StudentUpdateOneRequiredWithoutCertificatesNestedInput
    course?: CourseUpdateOneRequiredWithoutCertificatesNestedInput
    studentCourse?: StudentCourseUpdateOneRequiredWithoutCertificateNestedInput
  }

  export type CertificateUncheckedUpdateWithoutClientAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    studentCourseId?: IntFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    certificateUrl?: StringFieldUpdateOperationsInput | string
  }

  export type CertificateUncheckedUpdateManyWithoutClientAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    studentCourseId?: IntFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    certificateUrl?: StringFieldUpdateOperationsInput | string
  }

  export type FinancialRecordUpdateWithoutClientAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordType?: EnumRecordTypeFieldUpdateOperationsInput | $Enums.RecordType
    amount?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMode?: NullableEnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode | null
    student?: StudentUpdateOneWithoutFinancialRecordsNestedInput
    course?: CourseUpdateOneWithoutFinancialRecordsNestedInput
    faculty?: FacultyUpdateOneWithoutFinancialRecordsNestedInput
    lab?: LabUpdateOneWithoutFinancialRecordsNestedInput
  }

  export type FinancialRecordUncheckedUpdateWithoutClientAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordType?: EnumRecordTypeFieldUpdateOperationsInput | $Enums.RecordType
    amount?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMode?: NullableEnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode | null
    studentId?: NullableIntFieldUpdateOperationsInput | number | null
    courseId?: NullableIntFieldUpdateOperationsInput | number | null
    facultyId?: NullableIntFieldUpdateOperationsInput | number | null
    labId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FinancialRecordUncheckedUpdateManyWithoutClientAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordType?: EnumRecordTypeFieldUpdateOperationsInput | $Enums.RecordType
    amount?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMode?: NullableEnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode | null
    studentId?: NullableIntFieldUpdateOperationsInput | number | null
    courseId?: NullableIntFieldUpdateOperationsInput | number | null
    facultyId?: NullableIntFieldUpdateOperationsInput | number | null
    labId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EnquiryUpdateWithoutClientAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    course?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    leadStatus?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isConverted?: BoolFieldUpdateOperationsInput | boolean
    followUps?: FollowUpUpdateManyWithoutEnquiryNestedInput
    student?: StudentUpdateOneWithoutEnquiryNestedInput
    enquiryCourse?: EnquiryCourseUpdateManyWithoutEnquiryNestedInput
    notification?: NotificationUpdateOneWithoutEnquiryNestedInput
  }

  export type EnquiryUncheckedUpdateWithoutClientAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    course?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    leadStatus?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isConverted?: BoolFieldUpdateOperationsInput | boolean
    studentId?: NullableIntFieldUpdateOperationsInput | number | null
    followUps?: FollowUpUncheckedUpdateManyWithoutEnquiryNestedInput
    enquiryCourse?: EnquiryCourseUncheckedUpdateManyWithoutEnquiryNestedInput
    notification?: NotificationUncheckedUpdateOneWithoutEnquiryNestedInput
  }

  export type EnquiryUncheckedUpdateManyWithoutClientAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    course?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    leadStatus?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isConverted?: BoolFieldUpdateOperationsInput | boolean
    studentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type NotificationUpdateWithoutClientAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    seen?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    followUp?: FollowUpUpdateOneWithoutNotificationNestedInput
    enquiry?: EnquiryUpdateOneWithoutNotificationNestedInput
    payment?: StudentFeeUpdateOneWithoutNotificationNestedInput
  }

  export type NotificationUncheckedUpdateWithoutClientAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    seen?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    followUpId?: NullableStringFieldUpdateOperationsInput | string | null
    enquiryId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type NotificationUncheckedUpdateManyWithoutClientAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    seen?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    followUpId?: NullableStringFieldUpdateOperationsInput | string | null
    enquiryId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CourseFeeStructureUpdateWithoutClientAdminInput = {
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paymentType?: CourseFeeStructureUpdatepaymentTypeInput | string[]
    course?: CourseUpdateOneRequiredWithoutCourseFeeStructureNestedInput
    installments?: InstallmentDetailUpdateManyWithoutCourseFeeStructureNestedInput
  }

  export type CourseFeeStructureUncheckedUpdateWithoutClientAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paymentType?: CourseFeeStructureUpdatepaymentTypeInput | string[]
    installments?: InstallmentDetailUncheckedUpdateManyWithoutCourseFeeStructureNestedInput
  }

  export type CourseFeeStructureUncheckedUpdateManyWithoutClientAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paymentType?: CourseFeeStructureUpdatepaymentTypeInput | string[]
  }

  export type FollowUpCreateManyEnquiryInput = {
    id?: string
    scheduledAt?: Date | string | null
    doneAt?: Date | string | null
    remark: string
    createdAt?: Date | string
    followUpStatus?: $Enums.FollowUpStatus
  }

  export type EnquiryCourseCreateManyEnquiryInput = {
    id?: number
    courseId: number
    clientAdminId: string
  }

  export type FollowUpUpdateWithoutEnquiryInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doneAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remark?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    followUpStatus?: EnumFollowUpStatusFieldUpdateOperationsInput | $Enums.FollowUpStatus
    notification?: NotificationUpdateOneWithoutFollowUpNestedInput
  }

  export type FollowUpUncheckedUpdateWithoutEnquiryInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doneAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remark?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    followUpStatus?: EnumFollowUpStatusFieldUpdateOperationsInput | $Enums.FollowUpStatus
    notification?: NotificationUncheckedUpdateOneWithoutFollowUpNestedInput
  }

  export type FollowUpUncheckedUpdateManyWithoutEnquiryInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doneAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remark?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    followUpStatus?: EnumFollowUpStatusFieldUpdateOperationsInput | $Enums.FollowUpStatus
  }

  export type EnquiryCourseUpdateWithoutEnquiryInput = {
    course?: CourseUpdateOneRequiredWithoutEnquiryCourseNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutEnquiryCourseNestedInput
  }

  export type EnquiryCourseUncheckedUpdateWithoutEnquiryInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type EnquiryCourseUncheckedUpdateManyWithoutEnquiryInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type LabAllocationCreateManyStudentInput = {
    id?: number
    labTimeSlotId: number
    pcNumber: number
    assignedAt?: Date | string
    clientAdminId: string
  }

  export type StudentCourseCreateManyStudentInput = {
    id?: number
    courseId: number
    startDate: Date | string
    endDate: Date | string
    studentCode: string
    batchId?: number | null
    internalNotes?: string | null
    status: string
    clientAdminId: string
  }

  export type FeeStructureCreateManyStudentInput = {
    id?: number
    courseId: number
    totalAmount: number
    paymentType: $Enums.PaymentType
    installmentCount?: number | null
    installmentTypeId?: number | null
    clientAdminId: string
  }

  export type StudentFeeCreateManyStudentInput = {
    id?: number
    courseId: number
    dueDate: Date | string
    amountDue: number
    amountPaid: number
    paymentDate?: Date | string | null
    paymentMode: $Enums.PaymentMode
    receiptNo: string
    paymentStatus?: $Enums.PaymentStatus
    clientAdminId: string
  }

  export type AttendanceRecordCreateManyStudentInput = {
    id?: number
    courseId: number
    date: Date | string
    present: boolean
    facultyId: number
    batchId?: number | null
    clientAdminId: string
  }

  export type StudentTaskCreateManyStudentInput = {
    id?: number
    courseId: number
    assignedDate: Date | string
    dueDate: Date | string
    description: string
    status: string
    facultyRemarks?: string | null
    grade?: string | null
    facultyId?: number | null
    clientAdminId: string
  }

  export type StudentTestCreateManyStudentInput = {
    id?: number
    courseId: number
    testName: string
    testDate: Date | string
    totalMarks: number
    marksObtained: number
    grade: string
    clientAdminId: string
  }

  export type CourseCompletionCreateManyStudentInput = {
    id?: number
    studentCourseId: number
    completionDate: Date | string
    feedback?: string | null
    remarks?: string | null
    clientAdminId: string
  }

  export type StationeryIssueCreateManyStudentInput = {
    id?: number
    courseId: number
    itemId: number
    issueDate: Date | string
    quantity: number
    remarks?: string | null
    clientAdminId: string
  }

  export type CertificateCreateManyStudentInput = {
    id?: number
    courseId: number
    studentCourseId: number
    issueDate: Date | string
    certificateUrl: string
    clientAdminId: string
  }

  export type FinancialRecordCreateManyStudentInput = {
    id?: string
    clientAdminId: string
    recordType: $Enums.RecordType
    amount: number
    description?: string | null
    date?: Date | string
    paymentMode?: $Enums.PaymentMode | null
    courseId?: number | null
    facultyId?: number | null
    labId?: number | null
  }

  export type LabAllocationUpdateWithoutStudentInput = {
    pcNumber?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    labTimeSlot?: LabTimeSlotUpdateOneRequiredWithoutAllocationsNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutLabAllocationsNestedInput
  }

  export type LabAllocationUncheckedUpdateWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    labTimeSlotId?: IntFieldUpdateOperationsInput | number
    pcNumber?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type LabAllocationUncheckedUpdateManyWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    labTimeSlotId?: IntFieldUpdateOperationsInput | number
    pcNumber?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentCourseUpdateWithoutStudentInput = {
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    studentCode?: StringFieldUpdateOperationsInput | string
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    course?: CourseUpdateOneRequiredWithoutStudentCoursesNestedInput
    batch?: BatchUpdateOneWithoutStudentCoursesNestedInput
    certificate?: CertificateUpdateOneWithoutStudentCourseNestedInput
    completions?: CourseCompletionUpdateManyWithoutStudentCourseNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutStudentCoursesNestedInput
  }

  export type StudentCourseUncheckedUpdateWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    studentCode?: StringFieldUpdateOperationsInput | string
    batchId?: NullableIntFieldUpdateOperationsInput | number | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    clientAdminId?: StringFieldUpdateOperationsInput | string
    certificate?: CertificateUncheckedUpdateOneWithoutStudentCourseNestedInput
    completions?: CourseCompletionUncheckedUpdateManyWithoutStudentCourseNestedInput
  }

  export type StudentCourseUncheckedUpdateManyWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    studentCode?: StringFieldUpdateOperationsInput | string
    batchId?: NullableIntFieldUpdateOperationsInput | number | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type FeeStructureUpdateWithoutStudentInput = {
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paymentType?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    installmentCount?: NullableIntFieldUpdateOperationsInput | number | null
    course?: CourseUpdateOneRequiredWithoutFeeStructuresNestedInput
    installment?: InstallmentDetailUpdateOneWithoutFeeStructuresNestedInput
    studentFees?: StudentFeeUpdateManyWithoutFeeStructureNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutFeeStructuresNestedInput
  }

  export type FeeStructureUncheckedUpdateWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paymentType?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    installmentCount?: NullableIntFieldUpdateOperationsInput | number | null
    installmentTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    clientAdminId?: StringFieldUpdateOperationsInput | string
    studentFees?: StudentFeeUncheckedUpdateManyWithoutFeeStructureNestedInput
  }

  export type FeeStructureUncheckedUpdateManyWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paymentType?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    installmentCount?: NullableIntFieldUpdateOperationsInput | number | null
    installmentTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentFeeUpdateWithoutStudentInput = {
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amountDue?: FloatFieldUpdateOperationsInput | number
    amountPaid?: FloatFieldUpdateOperationsInput | number
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMode?: EnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode
    receiptNo?: StringFieldUpdateOperationsInput | string
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    course?: CourseUpdateOneRequiredWithoutStudentFeesNestedInput
    feeLogs?: StudentFeeLogUpdateManyWithoutStudentFeeNestedInput
    feeStructure?: FeeStructureUpdateOneWithoutStudentFeesNestedInput
    notification?: NotificationUpdateOneWithoutPaymentNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutStudentFeesNestedInput
  }

  export type StudentFeeUncheckedUpdateWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amountDue?: FloatFieldUpdateOperationsInput | number
    amountPaid?: FloatFieldUpdateOperationsInput | number
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMode?: EnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode
    receiptNo?: StringFieldUpdateOperationsInput | string
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    clientAdminId?: StringFieldUpdateOperationsInput | string
    feeLogs?: StudentFeeLogUncheckedUpdateManyWithoutStudentFeeNestedInput
    notification?: NotificationUncheckedUpdateOneWithoutPaymentNestedInput
  }

  export type StudentFeeUncheckedUpdateManyWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amountDue?: FloatFieldUpdateOperationsInput | number
    amountPaid?: FloatFieldUpdateOperationsInput | number
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMode?: EnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode
    receiptNo?: StringFieldUpdateOperationsInput | string
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type AttendanceRecordUpdateWithoutStudentInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    present?: BoolFieldUpdateOperationsInput | boolean
    batchId?: NullableIntFieldUpdateOperationsInput | number | null
    course?: CourseUpdateOneRequiredWithoutAttendanceRecordsNestedInput
    markedBy?: FacultyUpdateOneRequiredWithoutAttendanceNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutAttendanceRecordsNestedInput
  }

  export type AttendanceRecordUncheckedUpdateWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    present?: BoolFieldUpdateOperationsInput | boolean
    facultyId?: IntFieldUpdateOperationsInput | number
    batchId?: NullableIntFieldUpdateOperationsInput | number | null
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type AttendanceRecordUncheckedUpdateManyWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    present?: BoolFieldUpdateOperationsInput | boolean
    facultyId?: IntFieldUpdateOperationsInput | number
    batchId?: NullableIntFieldUpdateOperationsInput | number | null
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentTaskUpdateWithoutStudentInput = {
    assignedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    facultyRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    course?: CourseUpdateOneRequiredWithoutStudentTasksNestedInput
    faculty?: FacultyUpdateOneWithoutTasksNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutStudentTasksNestedInput
  }

  export type StudentTaskUncheckedUpdateWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    assignedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    facultyRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    facultyId?: NullableIntFieldUpdateOperationsInput | number | null
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentTaskUncheckedUpdateManyWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    assignedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    facultyRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    facultyId?: NullableIntFieldUpdateOperationsInput | number | null
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentTestUpdateWithoutStudentInput = {
    testName?: StringFieldUpdateOperationsInput | string
    testDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalMarks?: IntFieldUpdateOperationsInput | number
    marksObtained?: IntFieldUpdateOperationsInput | number
    grade?: StringFieldUpdateOperationsInput | string
    course?: CourseUpdateOneRequiredWithoutStudentTestsNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutStudentTestsNestedInput
  }

  export type StudentTestUncheckedUpdateWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    testName?: StringFieldUpdateOperationsInput | string
    testDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalMarks?: IntFieldUpdateOperationsInput | number
    marksObtained?: IntFieldUpdateOperationsInput | number
    grade?: StringFieldUpdateOperationsInput | string
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentTestUncheckedUpdateManyWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    testName?: StringFieldUpdateOperationsInput | string
    testDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalMarks?: IntFieldUpdateOperationsInput | number
    marksObtained?: IntFieldUpdateOperationsInput | number
    grade?: StringFieldUpdateOperationsInput | string
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type CourseCompletionUpdateWithoutStudentInput = {
    completionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    studentCourse?: StudentCourseUpdateOneRequiredWithoutCompletionsNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutCourseCompletionsNestedInput
  }

  export type CourseCompletionUncheckedUpdateWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentCourseId?: IntFieldUpdateOperationsInput | number
    completionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type CourseCompletionUncheckedUpdateManyWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentCourseId?: IntFieldUpdateOperationsInput | number
    completionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type StationeryIssueUpdateWithoutStudentInput = {
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    course?: CourseUpdateOneRequiredWithoutStationeryNestedInput
    item?: StationeryItemUpdateOneRequiredWithoutStationeryIssuesNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutStationeryIssuesNestedInput
  }

  export type StationeryIssueUncheckedUpdateWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type StationeryIssueUncheckedUpdateManyWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type CertificateUpdateWithoutStudentInput = {
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    certificateUrl?: StringFieldUpdateOperationsInput | string
    course?: CourseUpdateOneRequiredWithoutCertificatesNestedInput
    studentCourse?: StudentCourseUpdateOneRequiredWithoutCertificateNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutCertificatesNestedInput
  }

  export type CertificateUncheckedUpdateWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    studentCourseId?: IntFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    certificateUrl?: StringFieldUpdateOperationsInput | string
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type CertificateUncheckedUpdateManyWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    studentCourseId?: IntFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    certificateUrl?: StringFieldUpdateOperationsInput | string
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type FinancialRecordUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordType?: EnumRecordTypeFieldUpdateOperationsInput | $Enums.RecordType
    amount?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMode?: NullableEnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode | null
    course?: CourseUpdateOneWithoutFinancialRecordsNestedInput
    faculty?: FacultyUpdateOneWithoutFinancialRecordsNestedInput
    lab?: LabUpdateOneWithoutFinancialRecordsNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutFinancialRecordsNestedInput
  }

  export type FinancialRecordUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientAdminId?: StringFieldUpdateOperationsInput | string
    recordType?: EnumRecordTypeFieldUpdateOperationsInput | $Enums.RecordType
    amount?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMode?: NullableEnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode | null
    courseId?: NullableIntFieldUpdateOperationsInput | number | null
    facultyId?: NullableIntFieldUpdateOperationsInput | number | null
    labId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FinancialRecordUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientAdminId?: StringFieldUpdateOperationsInput | string
    recordType?: EnumRecordTypeFieldUpdateOperationsInput | $Enums.RecordType
    amount?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMode?: NullableEnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode | null
    courseId?: NullableIntFieldUpdateOperationsInput | number | null
    facultyId?: NullableIntFieldUpdateOperationsInput | number | null
    labId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type StudentCourseCreateManyCourseInput = {
    id?: number
    studentId: number
    startDate: Date | string
    endDate: Date | string
    studentCode: string
    batchId?: number | null
    internalNotes?: string | null
    status: string
    clientAdminId: string
  }

  export type EnquiryCourseCreateManyCourseInput = {
    id?: number
    enquiryId: string
    clientAdminId: string
  }

  export type FeeStructureCreateManyCourseInput = {
    id?: number
    studentId: number
    totalAmount: number
    paymentType: $Enums.PaymentType
    installmentCount?: number | null
    installmentTypeId?: number | null
    clientAdminId: string
  }

  export type StationeryIssueCreateManyCourseInput = {
    id?: number
    studentId: number
    itemId: number
    issueDate: Date | string
    quantity: number
    remarks?: string | null
    clientAdminId: string
  }

  export type StudentFeeCreateManyCourseInput = {
    id?: number
    studentId: number
    dueDate: Date | string
    amountDue: number
    amountPaid: number
    paymentDate?: Date | string | null
    paymentMode: $Enums.PaymentMode
    receiptNo: string
    paymentStatus?: $Enums.PaymentStatus
    clientAdminId: string
  }

  export type AttendanceRecordCreateManyCourseInput = {
    id?: number
    studentId: number
    date: Date | string
    present: boolean
    facultyId: number
    batchId?: number | null
    clientAdminId: string
  }

  export type StudentTaskCreateManyCourseInput = {
    id?: number
    studentId: number
    assignedDate: Date | string
    dueDate: Date | string
    description: string
    status: string
    facultyRemarks?: string | null
    grade?: string | null
    facultyId?: number | null
    clientAdminId: string
  }

  export type StudentTestCreateManyCourseInput = {
    id?: number
    studentId: number
    testName: string
    testDate: Date | string
    totalMarks: number
    marksObtained: number
    grade: string
    clientAdminId: string
  }

  export type CertificateCreateManyCourseInput = {
    id?: number
    studentId: number
    studentCourseId: number
    issueDate: Date | string
    certificateUrl: string
    clientAdminId: string
  }

  export type FinancialRecordCreateManyCourseInput = {
    id?: string
    clientAdminId: string
    recordType: $Enums.RecordType
    amount: number
    description?: string | null
    date?: Date | string
    paymentMode?: $Enums.PaymentMode | null
    studentId?: number | null
    facultyId?: number | null
    labId?: number | null
  }

  export type BatchCourseCreateManyCourseInput = {
    id?: number
    batchId: number
    pcsReserved?: number | null
  }

  export type StudentCourseUpdateWithoutCourseInput = {
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    studentCode?: StringFieldUpdateOperationsInput | string
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    student?: StudentUpdateOneRequiredWithoutStudentCoursesNestedInput
    batch?: BatchUpdateOneWithoutStudentCoursesNestedInput
    certificate?: CertificateUpdateOneWithoutStudentCourseNestedInput
    completions?: CourseCompletionUpdateManyWithoutStudentCourseNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutStudentCoursesNestedInput
  }

  export type StudentCourseUncheckedUpdateWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    studentCode?: StringFieldUpdateOperationsInput | string
    batchId?: NullableIntFieldUpdateOperationsInput | number | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    clientAdminId?: StringFieldUpdateOperationsInput | string
    certificate?: CertificateUncheckedUpdateOneWithoutStudentCourseNestedInput
    completions?: CourseCompletionUncheckedUpdateManyWithoutStudentCourseNestedInput
  }

  export type StudentCourseUncheckedUpdateManyWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    studentCode?: StringFieldUpdateOperationsInput | string
    batchId?: NullableIntFieldUpdateOperationsInput | number | null
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type EnquiryCourseUpdateWithoutCourseInput = {
    enquiry?: EnquiryUpdateOneRequiredWithoutEnquiryCourseNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutEnquiryCourseNestedInput
  }

  export type EnquiryCourseUncheckedUpdateWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    enquiryId?: StringFieldUpdateOperationsInput | string
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type EnquiryCourseUncheckedUpdateManyWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    enquiryId?: StringFieldUpdateOperationsInput | string
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type FeeStructureUpdateWithoutCourseInput = {
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paymentType?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    installmentCount?: NullableIntFieldUpdateOperationsInput | number | null
    student?: StudentUpdateOneRequiredWithoutFeeStructuresNestedInput
    installment?: InstallmentDetailUpdateOneWithoutFeeStructuresNestedInput
    studentFees?: StudentFeeUpdateManyWithoutFeeStructureNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutFeeStructuresNestedInput
  }

  export type FeeStructureUncheckedUpdateWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paymentType?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    installmentCount?: NullableIntFieldUpdateOperationsInput | number | null
    installmentTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    clientAdminId?: StringFieldUpdateOperationsInput | string
    studentFees?: StudentFeeUncheckedUpdateManyWithoutFeeStructureNestedInput
  }

  export type FeeStructureUncheckedUpdateManyWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paymentType?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    installmentCount?: NullableIntFieldUpdateOperationsInput | number | null
    installmentTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type StationeryIssueUpdateWithoutCourseInput = {
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    student?: StudentUpdateOneRequiredWithoutStationeryNestedInput
    item?: StationeryItemUpdateOneRequiredWithoutStationeryIssuesNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutStationeryIssuesNestedInput
  }

  export type StationeryIssueUncheckedUpdateWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type StationeryIssueUncheckedUpdateManyWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentFeeUpdateWithoutCourseInput = {
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amountDue?: FloatFieldUpdateOperationsInput | number
    amountPaid?: FloatFieldUpdateOperationsInput | number
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMode?: EnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode
    receiptNo?: StringFieldUpdateOperationsInput | string
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    student?: StudentUpdateOneRequiredWithoutFeeRecordsNestedInput
    feeLogs?: StudentFeeLogUpdateManyWithoutStudentFeeNestedInput
    feeStructure?: FeeStructureUpdateOneWithoutStudentFeesNestedInput
    notification?: NotificationUpdateOneWithoutPaymentNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutStudentFeesNestedInput
  }

  export type StudentFeeUncheckedUpdateWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amountDue?: FloatFieldUpdateOperationsInput | number
    amountPaid?: FloatFieldUpdateOperationsInput | number
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMode?: EnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode
    receiptNo?: StringFieldUpdateOperationsInput | string
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    clientAdminId?: StringFieldUpdateOperationsInput | string
    feeLogs?: StudentFeeLogUncheckedUpdateManyWithoutStudentFeeNestedInput
    notification?: NotificationUncheckedUpdateOneWithoutPaymentNestedInput
  }

  export type StudentFeeUncheckedUpdateManyWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amountDue?: FloatFieldUpdateOperationsInput | number
    amountPaid?: FloatFieldUpdateOperationsInput | number
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMode?: EnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode
    receiptNo?: StringFieldUpdateOperationsInput | string
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type AttendanceRecordUpdateWithoutCourseInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    present?: BoolFieldUpdateOperationsInput | boolean
    batchId?: NullableIntFieldUpdateOperationsInput | number | null
    student?: StudentUpdateOneRequiredWithoutAttendanceNestedInput
    markedBy?: FacultyUpdateOneRequiredWithoutAttendanceNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutAttendanceRecordsNestedInput
  }

  export type AttendanceRecordUncheckedUpdateWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    present?: BoolFieldUpdateOperationsInput | boolean
    facultyId?: IntFieldUpdateOperationsInput | number
    batchId?: NullableIntFieldUpdateOperationsInput | number | null
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type AttendanceRecordUncheckedUpdateManyWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    present?: BoolFieldUpdateOperationsInput | boolean
    facultyId?: IntFieldUpdateOperationsInput | number
    batchId?: NullableIntFieldUpdateOperationsInput | number | null
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentTaskUpdateWithoutCourseInput = {
    assignedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    facultyRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    student?: StudentUpdateOneRequiredWithoutTasksNestedInput
    faculty?: FacultyUpdateOneWithoutTasksNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutStudentTasksNestedInput
  }

  export type StudentTaskUncheckedUpdateWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    assignedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    facultyRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    facultyId?: NullableIntFieldUpdateOperationsInput | number | null
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentTaskUncheckedUpdateManyWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    assignedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    facultyRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    facultyId?: NullableIntFieldUpdateOperationsInput | number | null
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentTestUpdateWithoutCourseInput = {
    testName?: StringFieldUpdateOperationsInput | string
    testDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalMarks?: IntFieldUpdateOperationsInput | number
    marksObtained?: IntFieldUpdateOperationsInput | number
    grade?: StringFieldUpdateOperationsInput | string
    student?: StudentUpdateOneRequiredWithoutTestsNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutStudentTestsNestedInput
  }

  export type StudentTestUncheckedUpdateWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    testName?: StringFieldUpdateOperationsInput | string
    testDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalMarks?: IntFieldUpdateOperationsInput | number
    marksObtained?: IntFieldUpdateOperationsInput | number
    grade?: StringFieldUpdateOperationsInput | string
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentTestUncheckedUpdateManyWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    testName?: StringFieldUpdateOperationsInput | string
    testDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalMarks?: IntFieldUpdateOperationsInput | number
    marksObtained?: IntFieldUpdateOperationsInput | number
    grade?: StringFieldUpdateOperationsInput | string
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type CertificateUpdateWithoutCourseInput = {
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    certificateUrl?: StringFieldUpdateOperationsInput | string
    student?: StudentUpdateOneRequiredWithoutCertificatesNestedInput
    studentCourse?: StudentCourseUpdateOneRequiredWithoutCertificateNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutCertificatesNestedInput
  }

  export type CertificateUncheckedUpdateWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    studentCourseId?: IntFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    certificateUrl?: StringFieldUpdateOperationsInput | string
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type CertificateUncheckedUpdateManyWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    studentCourseId?: IntFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    certificateUrl?: StringFieldUpdateOperationsInput | string
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type FinancialRecordUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordType?: EnumRecordTypeFieldUpdateOperationsInput | $Enums.RecordType
    amount?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMode?: NullableEnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode | null
    student?: StudentUpdateOneWithoutFinancialRecordsNestedInput
    faculty?: FacultyUpdateOneWithoutFinancialRecordsNestedInput
    lab?: LabUpdateOneWithoutFinancialRecordsNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutFinancialRecordsNestedInput
  }

  export type FinancialRecordUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientAdminId?: StringFieldUpdateOperationsInput | string
    recordType?: EnumRecordTypeFieldUpdateOperationsInput | $Enums.RecordType
    amount?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMode?: NullableEnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode | null
    studentId?: NullableIntFieldUpdateOperationsInput | number | null
    facultyId?: NullableIntFieldUpdateOperationsInput | number | null
    labId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FinancialRecordUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientAdminId?: StringFieldUpdateOperationsInput | string
    recordType?: EnumRecordTypeFieldUpdateOperationsInput | $Enums.RecordType
    amount?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMode?: NullableEnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode | null
    studentId?: NullableIntFieldUpdateOperationsInput | number | null
    facultyId?: NullableIntFieldUpdateOperationsInput | number | null
    labId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BatchCourseUpdateWithoutCourseInput = {
    pcsReserved?: NullableIntFieldUpdateOperationsInput | number | null
    batch?: BatchUpdateOneRequiredWithoutBatchCoursesNestedInput
  }

  export type BatchCourseUncheckedUpdateWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    batchId?: IntFieldUpdateOperationsInput | number
    pcsReserved?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BatchCourseUncheckedUpdateManyWithoutCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    batchId?: IntFieldUpdateOperationsInput | number
    pcsReserved?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type InstallmentDetailCreateManyCourseFeeStructureInput = {
    id?: number
    number: number
    amount: number
  }

  export type InstallmentDetailUpdateWithoutCourseFeeStructureInput = {
    number?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    feeStructures?: FeeStructureUpdateManyWithoutInstallmentNestedInput
  }

  export type InstallmentDetailUncheckedUpdateWithoutCourseFeeStructureInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    feeStructures?: FeeStructureUncheckedUpdateManyWithoutInstallmentNestedInput
  }

  export type InstallmentDetailUncheckedUpdateManyWithoutCourseFeeStructureInput = {
    id?: IntFieldUpdateOperationsInput | number
    number?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
  }

  export type StudentCourseCreateManyBatchInput = {
    id?: number
    studentId: number
    courseId: number
    startDate: Date | string
    endDate: Date | string
    studentCode: string
    internalNotes?: string | null
    status: string
    clientAdminId: string
  }

  export type BatchCourseCreateManyBatchInput = {
    id?: number
    courseId: number
    pcsReserved?: number | null
  }

  export type StudentCourseUpdateWithoutBatchInput = {
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    studentCode?: StringFieldUpdateOperationsInput | string
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    student?: StudentUpdateOneRequiredWithoutStudentCoursesNestedInput
    course?: CourseUpdateOneRequiredWithoutStudentCoursesNestedInput
    certificate?: CertificateUpdateOneWithoutStudentCourseNestedInput
    completions?: CourseCompletionUpdateManyWithoutStudentCourseNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutStudentCoursesNestedInput
  }

  export type StudentCourseUncheckedUpdateWithoutBatchInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    studentCode?: StringFieldUpdateOperationsInput | string
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    clientAdminId?: StringFieldUpdateOperationsInput | string
    certificate?: CertificateUncheckedUpdateOneWithoutStudentCourseNestedInput
    completions?: CourseCompletionUncheckedUpdateManyWithoutStudentCourseNestedInput
  }

  export type StudentCourseUncheckedUpdateManyWithoutBatchInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    studentCode?: StringFieldUpdateOperationsInput | string
    internalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type BatchCourseUpdateWithoutBatchInput = {
    pcsReserved?: NullableIntFieldUpdateOperationsInput | number | null
    course?: CourseUpdateOneRequiredWithoutBatchCoursesNestedInput
  }

  export type BatchCourseUncheckedUpdateWithoutBatchInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    pcsReserved?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BatchCourseUncheckedUpdateManyWithoutBatchInput = {
    id?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    pcsReserved?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BatchCreateManyFacultyInput = {
    id?: number
    name: string
    labTimeSlotId: number
    clientAdminId: string
  }

  export type AttendanceRecordCreateManyMarkedByInput = {
    id?: number
    studentId: number
    courseId: number
    date: Date | string
    present: boolean
    batchId?: number | null
    clientAdminId: string
  }

  export type StudentTaskCreateManyFacultyInput = {
    id?: number
    studentId: number
    courseId: number
    assignedDate: Date | string
    dueDate: Date | string
    description: string
    status: string
    facultyRemarks?: string | null
    grade?: string | null
    clientAdminId: string
  }

  export type FinancialRecordCreateManyFacultyInput = {
    id?: string
    clientAdminId: string
    recordType: $Enums.RecordType
    amount: number
    description?: string | null
    date?: Date | string
    paymentMode?: $Enums.PaymentMode | null
    studentId?: number | null
    courseId?: number | null
    labId?: number | null
  }

  export type BatchUpdateWithoutFacultyInput = {
    name?: StringFieldUpdateOperationsInput | string
    labTimeSlot?: LabTimeSlotUpdateOneRequiredWithoutBatchesNestedInput
    studentCourses?: StudentCourseUpdateManyWithoutBatchNestedInput
    batchCourses?: BatchCourseUpdateManyWithoutBatchNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutBatchesNestedInput
  }

  export type BatchUncheckedUpdateWithoutFacultyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    labTimeSlotId?: IntFieldUpdateOperationsInput | number
    clientAdminId?: StringFieldUpdateOperationsInput | string
    studentCourses?: StudentCourseUncheckedUpdateManyWithoutBatchNestedInput
    batchCourses?: BatchCourseUncheckedUpdateManyWithoutBatchNestedInput
  }

  export type BatchUncheckedUpdateManyWithoutFacultyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    labTimeSlotId?: IntFieldUpdateOperationsInput | number
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type AttendanceRecordUpdateWithoutMarkedByInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    present?: BoolFieldUpdateOperationsInput | boolean
    batchId?: NullableIntFieldUpdateOperationsInput | number | null
    student?: StudentUpdateOneRequiredWithoutAttendanceNestedInput
    course?: CourseUpdateOneRequiredWithoutAttendanceRecordsNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutAttendanceRecordsNestedInput
  }

  export type AttendanceRecordUncheckedUpdateWithoutMarkedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    present?: BoolFieldUpdateOperationsInput | boolean
    batchId?: NullableIntFieldUpdateOperationsInput | number | null
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type AttendanceRecordUncheckedUpdateManyWithoutMarkedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    present?: BoolFieldUpdateOperationsInput | boolean
    batchId?: NullableIntFieldUpdateOperationsInput | number | null
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentTaskUpdateWithoutFacultyInput = {
    assignedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    facultyRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    student?: StudentUpdateOneRequiredWithoutTasksNestedInput
    course?: CourseUpdateOneRequiredWithoutStudentTasksNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutStudentTasksNestedInput
  }

  export type StudentTaskUncheckedUpdateWithoutFacultyInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    assignedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    facultyRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentTaskUncheckedUpdateManyWithoutFacultyInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    assignedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    facultyRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type FinancialRecordUpdateWithoutFacultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordType?: EnumRecordTypeFieldUpdateOperationsInput | $Enums.RecordType
    amount?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMode?: NullableEnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode | null
    student?: StudentUpdateOneWithoutFinancialRecordsNestedInput
    course?: CourseUpdateOneWithoutFinancialRecordsNestedInput
    lab?: LabUpdateOneWithoutFinancialRecordsNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutFinancialRecordsNestedInput
  }

  export type FinancialRecordUncheckedUpdateWithoutFacultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientAdminId?: StringFieldUpdateOperationsInput | string
    recordType?: EnumRecordTypeFieldUpdateOperationsInput | $Enums.RecordType
    amount?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMode?: NullableEnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode | null
    studentId?: NullableIntFieldUpdateOperationsInput | number | null
    courseId?: NullableIntFieldUpdateOperationsInput | number | null
    labId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FinancialRecordUncheckedUpdateManyWithoutFacultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientAdminId?: StringFieldUpdateOperationsInput | string
    recordType?: EnumRecordTypeFieldUpdateOperationsInput | $Enums.RecordType
    amount?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMode?: NullableEnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode | null
    studentId?: NullableIntFieldUpdateOperationsInput | number | null
    courseId?: NullableIntFieldUpdateOperationsInput | number | null
    labId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LabTimeSlotCreateManyLabInput = {
    id?: number
    startTime: string
    endTime: string
    day: string
    availablePCs: number
    clientAdminId: string
  }

  export type FinancialRecordCreateManyLabInput = {
    id?: string
    clientAdminId: string
    recordType: $Enums.RecordType
    amount: number
    description?: string | null
    date?: Date | string
    paymentMode?: $Enums.PaymentMode | null
    studentId?: number | null
    courseId?: number | null
    facultyId?: number | null
  }

  export type LabTimeSlotUpdateWithoutLabInput = {
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    day?: StringFieldUpdateOperationsInput | string
    availablePCs?: IntFieldUpdateOperationsInput | number
    batches?: BatchUpdateManyWithoutLabTimeSlotNestedInput
    allocations?: LabAllocationUpdateManyWithoutLabTimeSlotNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutLabTimeSlotsNestedInput
  }

  export type LabTimeSlotUncheckedUpdateWithoutLabInput = {
    id?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    day?: StringFieldUpdateOperationsInput | string
    availablePCs?: IntFieldUpdateOperationsInput | number
    clientAdminId?: StringFieldUpdateOperationsInput | string
    batches?: BatchUncheckedUpdateManyWithoutLabTimeSlotNestedInput
    allocations?: LabAllocationUncheckedUpdateManyWithoutLabTimeSlotNestedInput
  }

  export type LabTimeSlotUncheckedUpdateManyWithoutLabInput = {
    id?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    day?: StringFieldUpdateOperationsInput | string
    availablePCs?: IntFieldUpdateOperationsInput | number
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type FinancialRecordUpdateWithoutLabInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordType?: EnumRecordTypeFieldUpdateOperationsInput | $Enums.RecordType
    amount?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMode?: NullableEnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode | null
    student?: StudentUpdateOneWithoutFinancialRecordsNestedInput
    course?: CourseUpdateOneWithoutFinancialRecordsNestedInput
    faculty?: FacultyUpdateOneWithoutFinancialRecordsNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutFinancialRecordsNestedInput
  }

  export type FinancialRecordUncheckedUpdateWithoutLabInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientAdminId?: StringFieldUpdateOperationsInput | string
    recordType?: EnumRecordTypeFieldUpdateOperationsInput | $Enums.RecordType
    amount?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMode?: NullableEnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode | null
    studentId?: NullableIntFieldUpdateOperationsInput | number | null
    courseId?: NullableIntFieldUpdateOperationsInput | number | null
    facultyId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FinancialRecordUncheckedUpdateManyWithoutLabInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientAdminId?: StringFieldUpdateOperationsInput | string
    recordType?: EnumRecordTypeFieldUpdateOperationsInput | $Enums.RecordType
    amount?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMode?: NullableEnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode | null
    studentId?: NullableIntFieldUpdateOperationsInput | number | null
    courseId?: NullableIntFieldUpdateOperationsInput | number | null
    facultyId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BatchCreateManyLabTimeSlotInput = {
    id?: number
    name: string
    facultyId?: number | null
    clientAdminId: string
  }

  export type LabAllocationCreateManyLabTimeSlotInput = {
    id?: number
    studentId: number
    pcNumber: number
    assignedAt?: Date | string
    clientAdminId: string
  }

  export type BatchUpdateWithoutLabTimeSlotInput = {
    name?: StringFieldUpdateOperationsInput | string
    faculty?: FacultyUpdateOneWithoutBatchesNestedInput
    studentCourses?: StudentCourseUpdateManyWithoutBatchNestedInput
    batchCourses?: BatchCourseUpdateManyWithoutBatchNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutBatchesNestedInput
  }

  export type BatchUncheckedUpdateWithoutLabTimeSlotInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    facultyId?: NullableIntFieldUpdateOperationsInput | number | null
    clientAdminId?: StringFieldUpdateOperationsInput | string
    studentCourses?: StudentCourseUncheckedUpdateManyWithoutBatchNestedInput
    batchCourses?: BatchCourseUncheckedUpdateManyWithoutBatchNestedInput
  }

  export type BatchUncheckedUpdateManyWithoutLabTimeSlotInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    facultyId?: NullableIntFieldUpdateOperationsInput | number | null
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type LabAllocationUpdateWithoutLabTimeSlotInput = {
    pcNumber?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutLabAllocationsNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutLabAllocationsNestedInput
  }

  export type LabAllocationUncheckedUpdateWithoutLabTimeSlotInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    pcNumber?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type LabAllocationUncheckedUpdateManyWithoutLabTimeSlotInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    pcNumber?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type FeeStructureCreateManyInstallmentInput = {
    id?: number
    studentId: number
    courseId: number
    totalAmount: number
    paymentType: $Enums.PaymentType
    installmentCount?: number | null
    clientAdminId: string
  }

  export type FeeStructureUpdateWithoutInstallmentInput = {
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paymentType?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    installmentCount?: NullableIntFieldUpdateOperationsInput | number | null
    student?: StudentUpdateOneRequiredWithoutFeeStructuresNestedInput
    course?: CourseUpdateOneRequiredWithoutFeeStructuresNestedInput
    studentFees?: StudentFeeUpdateManyWithoutFeeStructureNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutFeeStructuresNestedInput
  }

  export type FeeStructureUncheckedUpdateWithoutInstallmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paymentType?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    installmentCount?: NullableIntFieldUpdateOperationsInput | number | null
    clientAdminId?: StringFieldUpdateOperationsInput | string
    studentFees?: StudentFeeUncheckedUpdateManyWithoutFeeStructureNestedInput
  }

  export type FeeStructureUncheckedUpdateManyWithoutInstallmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paymentType?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    installmentCount?: NullableIntFieldUpdateOperationsInput | number | null
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type CourseCompletionCreateManyStudentCourseInput = {
    id?: number
    studentId: number
    completionDate: Date | string
    feedback?: string | null
    remarks?: string | null
    clientAdminId: string
  }

  export type CourseCompletionUpdateWithoutStudentCourseInput = {
    completionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    student?: StudentUpdateOneRequiredWithoutCompletionsNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutCourseCompletionsNestedInput
  }

  export type CourseCompletionUncheckedUpdateWithoutStudentCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    completionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type CourseCompletionUncheckedUpdateManyWithoutStudentCourseInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    completionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentFeeCreateManyFeeStructureInput = {
    id?: number
    dueDate: Date | string
    amountDue: number
    amountPaid: number
    paymentDate?: Date | string | null
    paymentMode: $Enums.PaymentMode
    receiptNo: string
    paymentStatus?: $Enums.PaymentStatus
    clientAdminId: string
  }

  export type StudentFeeUpdateWithoutFeeStructureInput = {
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amountDue?: FloatFieldUpdateOperationsInput | number
    amountPaid?: FloatFieldUpdateOperationsInput | number
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMode?: EnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode
    receiptNo?: StringFieldUpdateOperationsInput | string
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    student?: StudentUpdateOneRequiredWithoutFeeRecordsNestedInput
    course?: CourseUpdateOneRequiredWithoutStudentFeesNestedInput
    feeLogs?: StudentFeeLogUpdateManyWithoutStudentFeeNestedInput
    notification?: NotificationUpdateOneWithoutPaymentNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutStudentFeesNestedInput
  }

  export type StudentFeeUncheckedUpdateWithoutFeeStructureInput = {
    id?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amountDue?: FloatFieldUpdateOperationsInput | number
    amountPaid?: FloatFieldUpdateOperationsInput | number
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMode?: EnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode
    receiptNo?: StringFieldUpdateOperationsInput | string
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    clientAdminId?: StringFieldUpdateOperationsInput | string
    feeLogs?: StudentFeeLogUncheckedUpdateManyWithoutStudentFeeNestedInput
    notification?: NotificationUncheckedUpdateOneWithoutPaymentNestedInput
  }

  export type StudentFeeUncheckedUpdateManyWithoutFeeStructureInput = {
    id?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amountDue?: FloatFieldUpdateOperationsInput | number
    amountPaid?: FloatFieldUpdateOperationsInput | number
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMode?: EnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode
    receiptNo?: StringFieldUpdateOperationsInput | string
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentFeeLogCreateManyStudentFeeInput = {
    id?: number
    amountPaid: number
    paymentDate: Date | string
    paymentMode: $Enums.PaymentMode
    receiptNo: string
  }

  export type StudentFeeLogUpdateWithoutStudentFeeInput = {
    amountPaid?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMode?: EnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode
    receiptNo?: StringFieldUpdateOperationsInput | string
  }

  export type StudentFeeLogUncheckedUpdateWithoutStudentFeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    amountPaid?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMode?: EnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode
    receiptNo?: StringFieldUpdateOperationsInput | string
  }

  export type StudentFeeLogUncheckedUpdateManyWithoutStudentFeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    amountPaid?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMode?: EnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode
    receiptNo?: StringFieldUpdateOperationsInput | string
  }

  export type StationeryIssueCreateManyItemInput = {
    id?: number
    studentId: number
    courseId: number
    issueDate: Date | string
    quantity: number
    remarks?: string | null
    clientAdminId: string
  }

  export type StationeryIssueUpdateWithoutItemInput = {
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    student?: StudentUpdateOneRequiredWithoutStationeryNestedInput
    course?: CourseUpdateOneRequiredWithoutStationeryNestedInput
    clientAdmin?: ClientAdminUpdateOneRequiredWithoutStationeryIssuesNestedInput
  }

  export type StationeryIssueUncheckedUpdateWithoutItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }

  export type StationeryIssueUncheckedUpdateManyWithoutItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    studentId?: IntFieldUpdateOperationsInput | number
    courseId?: IntFieldUpdateOperationsInput | number
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quantity?: IntFieldUpdateOperationsInput | number
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    clientAdminId?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}